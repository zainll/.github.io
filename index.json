[{"content":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF http://gen.lib.rus.ec/ https://libgen.li/ https://libgen.gs/ https://sci-hub.41610.org/library-genesis https://libgen.rs/search.php?\u0026amp;req=KVM\u0026amp;phrase=1\u0026amp;view=simple\u0026amp;column=def\u0026amp;sort=year\u0026amp;sortmode=DESC https://libgen.rs/ zlibrary PDF https://zh.u1lib.org/ https://en.ru1lib.org/ FreeTechBooks 计算机科学类 http://www.freetechbooks.com/ https://www.freetechbooks.com/ 古登宝计划 http://www.gutenberg.org/ Planet eBook 国内可访问 https://www.planetebook.com/ 布克书屋 https://iao.su/3064/comment-page-1 https://www.bukebook.cn yudu https://express.yudu.com/ kindle 社区 书伴 https://bookfere.com/post/4.html calibre 参考链接： http://www.360doc.com/content/20/0219/14/5008209_893150066.shtml http://www.sohu.com/a/215001801_490529\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/ebookwebsite/","summary":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF","title":"电子书网站"},{"content":" 首先是道歉，为我说过的那些冰冷的话道歉，一直思考怎么能获得你的原谅，你的感受是什么样的，和你说过不太懂女生想什么，只能通过你说过的话来思考，想起每一个细节。 过去的感情经历，从少年开始，是不是太小了？中学时代有一个短头发，斜背包，衣服没有褶皱痕迹的女孩，坐在进门第一个座位的我每天看着她走进教室，放学。叫她F。这可能就是年少时对女孩的爱慕，藏在心里，是年少怯弱还是憧憬又幼稚呢？记得那时候埋藏过一个想法，和F一同上大学，她那时学习好。从此埋下了一颗生根但没有发芽的种子。有一件让我很懊悔的事情，当时她被一个人欺负，而那个人是我的发小，我也劝阻，通过各种方式避免，可是始终没有更勇敢的站出来。 不知道什么时候她发现我在注视她的，可能是上课时，我们同排，在我侧视偷看她。直到中学结束，我们去了不同高中，那时还没智能手机，偶尔发发短信，后来聊QQ，还是诺基亚，晚上回宿舍蒙上被子，等着企鹅闪动。有一天她来到了我所在的高中，见了一面，聊了什么已经忘记了，后来不久就知道了她，有了男朋友，是我中学生关系很好的哥们。没有询问，什么都没有说。就默默地关注了，没有在去打扰。上了大学，知道了她分手，又有了新的男朋友，我也认识。 大学之后因为对高中的怀念，还会和很多人聊天，一个高中时相处很好的，叫她H，大一时聊天可以聊到很晚，不知道怎么就算开始了，不在一个城市，只有假期回家见见，后来也不知道怎么慢慢疏远了，就这样，应该算是初恋，但谁都没有想好，懵懂的开始，无理的结束。 继续写和F，突然有一天她来了我的大学，她分手了，她陪我上了两天课，那时候在准备考研了，她也在准备，聊了我们一同考研，彼此鼓励，畅享未来。你是应该是保研的吧，考研不像高考，有人监督有人约束，完全需要自我管理。可能是考研的日子太难熬，她放弃了，那个周末是考研期间唯一一次在宿舍躺了两天。考研结束后我去她的学校，她说她要回家当老师了，还聊了关于中学时她被欺负那段经历，她很阳光，我也释然了一些。那天我坐上一辆公交车做到了终点站，一个人往回走。从少年到青年埋藏了十年结束了。她已经结婚有了一个女儿，生活忙碌又幸福吧。想想也挺好的。 整个大学时光大部分时间花在骑车，看小说，我几乎走遍了保定所有大街小巷，发现了隐藏在小巷里有些破败的古建筑，待拆的筒子楼，夜市烤鸡……。我的大学女生多于男生，各种活动也是女生很多， 还有当时看了很多小说大部分结尾都是一个悲剧，当时太过痴迷了。可能是心里装着一个憧憬所以并没有考虑过太多的情感，想想是不是傻，并不是，这样挺好的，都画上了句号。 下面就是去大连了，我和她是老乡，叫她Z，聊了几个月之后确定的，我们两个学校有20分钟，每周末约一天，平时忙自己的事情。我们走过了星海湾大桥，整个滨海路……，几乎大连所有可以逛的。想了未来，都朝着未来而努力，聊到了过年回谁家，孩子姓什么，我的态度孩子随谁姓都可以。至于回谁家，她也可以回娘家过年，这些都不是问题。除了最后那段时间我们几乎没有吵过架，我们两个性格也相近，所以很合得来。这是我第一次体会到爱情，浓烈也平淡，恰到好处。关于最后那段经历暂且到这里吧，如果我和你还有可能在慢慢告诉你吧。第一次见面我和你说的关于这段感情的那几句话，是花了很长时间才可以轻松的用几句话来描述。有一点可以对比一下，毕业以前我头发是很多的，头发就是从那时候开始掉的。查了一下，说要是有下一段好的感情能长回来，所以为了拯救头发也比较着急了。 写一段又是很自恋的，从中学开始就接到过一些女孩子写的信，等我放学，收到小礼物，可能是因为在小地方学习好(当然和你这种学霸没法比)，既能和学习好的玩到一起，又能和不好好学习的打成一片，那时候应该是充满阳光的，大学之后就变得沉默了。但是不知道那时候为什么是很理智和成熟的，应该是那时候心里装着F，同时也一直有想要走出去的信念。 关于看待过去的态度，不能是遗忘，也不能是活在过去，是过去这些经历塑造了今天。 这是关于过去的就到这了，下一篇是写写现在吧，写写最近遇到的人，和对未来的想法。\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E8%BF%87%E5%8E%BB/","summary":"首先是道歉，为我说过的那些冰冷的话道歉，一直思考怎么能获得你的原谅，你的感受是什么样的，和你说过不太懂女生想什么，只能通过你说过的话来思考，","title":"过去"},{"content":" 每一篇都从道歉开始，因为人是要为自己所说的，所做的承担责任，无论能不能获得你的原谅，这些都是我需要承担的，就像你说过的，世事就这么艰难吧。陌生人，从相识相知很难了，而我又把我们之间增加困难 很想知道你遇到了什么问题，不过你应该不会说的，那么基于我的猜测来说说，应该是极不准确的，因为没有很多信息。要是有什么冒犯和错误请见谅。 第一点，其实我感觉到你最近可能在攒钱，判断依据是你不打算换手机和一些聊天细节。记得10月1号在地坛买酸奶，那时候应该是由你来付的，这样是很合适的。那时我想到了一些事，所以我就抢着付了，但是处理的很尴尬，你也应该感受到了，从那一刻开始我就不太自然了。也越来越不会处理，让你感觉不舒服了。总之是我抱着意图然后不会处理了。 第二点，你遇到的问题是和房贷什么有关系吗？因为你其实提到过两次关于房贷，利率的话题，但我都没继续，关于利率这个在几周之前已经放风出来了，也看到了一些报告和数据，总之不是很乐观，所以我不太想聊，因为对这个是比较悲观的，市场表现数据不是很好，对于个体不确定性增大。还有一点是自卑，就是我现在可能不能独立解决，我不能要求上一代什么，只能自己创造未来，也希望有一个一同奋斗。说回问题，你如果需要，我可以出一份力，我也不是毫无根据的信任，是基于我对你的判断，你至少是有契约精神的，并且独立的债务关系并不影响你对我的评价，即使最终你认为我们不适合也并不影响什么。 第三点，或者你遇到什么突然的变故了吗？我知道你是一个很独立的女孩，有自己的能力处理，可是生活要是有一个可以分担的人很多困难就不会那么无助，即使能够和你分担的人不是我，你也可以尝试一下。一个人去留学，你都能应付的来，现在遇到的问题你也一定能处理好。从你的想法，态度中能够看到你的坚毅。 可能写下这些都毫无意义，可能更多的是给自己一个救赎，原谅一个陌生人是很难的，第一印象很重要，而破坏这个印象之后就很难修复了，并不奢求你再次认可我，退回到不曾相见也是一种句号。当然我需要为自己所做的所说的付出代价，可能也需要一个支点来分担出我自己的错误，在没有得到别人允许的情况下将别人放进心里是不礼貌的，可能在无法获得原谅的时候，只能自己慢慢移出，还好没有很深，这也是一个成长点吧，对未来是有帮助的。 下一篇写写曾经的感情，过去，现在，未来？ Taylor Swift发布了新专辑，里面有一首很喜欢《Maroon》，暂时找不到资源，自己搜一下吧 update，最后提醒一个事情，个人预测，不保证准确，开完会之后如果没有什么事情发生，口罩相关政策会在几个月内放松，不知道你是什么态度，个人态度是尊重科学，所有人都躺平，谁也没办法改变，对于我们个体而言，不要恐慌，可以准备一点抗病毒之类的药物，大部分都是没事，每年都有因为普通流感挺不过去的，现在这个和流感没有太大区别。不折腾是最好的应对措施，于个体而言也一样。个人预测明年3月之后，本以为是12月左右，在十一之前曾经有过一个担忧，就是我出差可能会被困在这里，而你在北京，主要担心是恐慌，会造成医疗资源分配的问题，对于个体而言如何自我保护？你应该能够想到很多，仅作为提醒。\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E5%88%86%E6%8B%85/","summary":"每一篇都从道歉开始，因为人是要为自己所说的，所做的承担责任，无论能不能获得你的原谅，这些都是我需要承担的，就像你说过的，世事就这么艰难吧。陌","title":"分担"},{"content":" 说明：插件基于C/C++ Project Generator，原始项目未更新，联系到作者沟通是否合入\n本项目地址: https://github.com/zhuangll/vscode_c_project_config\n支持gtest\n安装 在vscode中安装C/C++ Project Generator插件 下载代码，将代码替换到C/C++ Project Generator插件所在目录，windows环境vscode插件目录,将功能代码复制替换如下目录中 C:\\Users\\\u0026lt;用户名\u0026gt;\\.vscode\\extensions\\danielpinto8zz6.c-cpp-project-generator-1.2.4 mingw安装，选择如下链接下载一个即可，添加到环境变量path中 各版本gcc mingw clang https://winlibs.com/ https://github.com/brechtsanders/winlibs_mingw MinGW-w64 https://www.mingw-w64.org/changelog/ 使用方法 wingows环境需要安装mingw，并添加到环境变量 linux环境适配中，已经部分适配，存在小bug，暂无适配动力\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vscode_c_project_config/","summary":"说明：插件基于C/C++ Project Generator，原始项目未更新，联系到作者沟通是否合入 本项目地址: https://github.com/zhuangll/vscode_c_project_config 支持gtest 安装 在vscode中安装C/","title":"vscode c/c++一键创建工程插件"},{"content":" 真的为那天晚上所说的话无比后悔，\u0026ldquo;理性上追求克制与平静，感性上被感情所淹没\u0026quot;形成了情感的对立面。你可能把我归类为你同学在大学里遇到的那个男生了，纠缠嫉妒狭隘自私，总之一定是一个不合格的。所以我所写下的每一页都是在阐述我是一个什么样的，还值不值得你原谅，当然最重要都是你的感受来决定的。 首先是关于自私的问题，我一直的处事原则是凡事都可商量，而且是不喜欢做决定的人，但喜欢做计划，你应该是一个喜欢决断的性格，就像国庆出游计划一样，做出不止一个计划可选，同时更希望你有其他的规划。那天晚上就是太希望看到结果了，太希望可以走进你的生活了。当然说和写是没有意义的，而做才是最重要的，如果未来还有可能会让你感受到的，因为曾经就是这样的。另一点面是异性关系，即使是确定关系也可以有异性朋友啊，那天你说到那个男生时我第一个想到的就是这个观点，只有彼此坦诚相待，工作，生活不可能没有异性朋友的，要是狭隘的这种那生活一定很累了，时时刻刻需要担忧与怀疑，还有什么自由可言，谈到自由，爱情应该是自由自在的，如果爱情成了约束那么就没有必要了，我这样理解对吗？ 然后是关于分寸感，这一点也没有把握好，因为你的感受应该是第一位的，关于地铁站的问题是我没有重视，认为是一件很小的事情，但其实不是如果允许我送你了，就是代表了一种信任，更是一种接受，可是你还没有考虑好我是否值得信任是否值得付出。这些都是我那时候没有能够想到的，其实你已经提醒我很明确了，可是我但是陷入到不解与自私中。如果会再有机会，一定是十倍的耐心，让你有足够的安全感，信任感，其实那时候应该是水到渠成的事了，不需要我刻意去做什么。 最后是我所做的给你带来的感受，都是我的表达方式的问题，最想表达的是可以为你做很多很多，但这些不应该是对你造成的一种负担，而应该是一种自热而然的感受即可。 这是关于感情的成长吗？ 知道我为什么会这么快认定你吗？为什么我这么热情？在你身上看到很多东西，内心坚定，生活气息，自在，你内心深处应该还有更多，很多值得学习的，猛然发现这些都是向往和追求的。最令人向往的感情应该是彼此成就，我还在思考我有什么值得你原谅的，要是没有的话，应该没有上面所有的如果了。 你的感受最最重要，我不做预期，不知道那天晚上脑袋抽哪根筋什么预期，简直毫无意义，我现在所做的两点，第一，取得你的原谅，第二，画一个句号，这个句号不是重新开始而是一个心安，至少不要把我归类到那个男生。 更新原则：静默更新，不在通知，也许还会加你，不过不会很频繁，不要有什么压力，也许你从没看过，但这并不影响我独自走过这段经历，也不应该影响你此刻的经历。内在实力和感知力力，而不是表现形式。 最重要一点，如果你需要我随时准备好。 ","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E7%8B%AC%E7%99%BD/","summary":"真的为那天晚上所说的话无比后悔，\u0026ldquo;理性上追求克制与平静，感性上被感情所淹没\u0026quot;形成了情感的对立面。你可能把我归类为你同学","title":"独白"},{"content":"https://cloud.tencent.com/developer/article/1863949\n系统信息 AIDA64 https://www.aida64.com/\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%A0%91%E8%8E%93%E6%B4%BE/","summary":"https://cloud.tencent.com/developer/article/1863949 系统信息 AIDA64 https://www.aida64.com/","title":"树莓派"},{"content":"\r一个午后点燃了一颗心 岁月不会抹去我的记忆里你所给的阳光 却悄悄的使我不同 一个女孩在有心人的心中 永远不会遗忘 想到这些 十分犹豫 生活太脆太薄 甚至不比一株花经得住风雨年华 倾心自然的眼啊 人生 热情的可珍 同一人事上 第二次的凑巧是不会有的 我平生只见过一次天蓝 给自己宽慰 说\n行过很多路 见过多次海 看过许多天空 却只恋一个最好心灵的人。 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;2022.10.03\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E8%87%B4%E5%A8%9C/","summary":"一个午后点燃了一颗心 岁月不会抹去我的记忆里你所给的阳光 却悄悄的使我不同 一个女孩在有心人的心中 永远不会遗忘 想到这些 十分犹豫 生活太脆太薄 甚至不比","title":"致娜"},{"content":" 💓 这个网站是为你准备的礼物，没有计划添加文字，为了获得你的原谅想在每一页写上文字，由于我不是做前端的水平有限，最近发现很多bug，特别是不同屏幕适应问题，在大一点的屏幕显示效果很好，笔记本屏幕比较小的话显示有问题，尝试很多方法暂时没能修复，所以就把文字内容放到我的个人博客，添加一个写给娜的专栏，点击每一页的图片跳到这里对应的文章。另外的网站会添一些好玩的小功能，简单的写几句话。 从为什么加你开始吧，因为襄阳，从小就知道这个城市，而且在小时候内心有一种向往，包含了祖辈的敬仰。你是一年多来第一次主动接触的女孩，因为这一年多我花很大一部分时间用来走出上一段感情，这就是你说的我感情不稳定的原因，关于过去的感情会专门写一篇，其实想更多的了解你的过去。 网站有一个是一个计数器会自动记录我们相识多久了，到10月2号是第10天，10天时间我们居然那么熟悉了，对于一个慢热的人，从未如此快速的走近其他人。我们聊了很多很多了，你说的很多话我都记得了，很多还需要未来来实现。你是一个很有智慧的女生，才10天怎么可能会接受一个人呢，我不知道哪里抽筋了，就在出差之前非要一个结果，那个晚上一个晚上没有睡，终于想明白了，是因为我太想走进你的生活，想得走火入魔一样。此刻想想才10天，未来日子还有很久很久呢，即使出差也就一两个月，放在时间的长河里太短太短了。 看看那个晚上自己说的话，真的应该抽我自己，怎么写出那么自私、自我的话，心中有那么多多情感要表达，却偏偏写了那样伤你心的话。我是你也是会删了，永远不想在见到这个人。但请相信我，我是一个知错能改的，就像我们一开始那样你说需要分享式交流，这是你给我的一个成长启迪。让你相信不是说说就行的，需要看怎么做。就当这是一次对我的惩罚吧，你期待一个成熟稳重的人，我是这样的性格当然还有很多不成熟的地方需要完善，这些都不是我说说，而是应该相处后你来评价的。 每次和你聊完天我都会思考哪里有没有说的不合适的，比如关于随礼那次，十一我遇到了同样的事情，当时我说的和我做的就很不一样，我还是主动随了，因为那是对曾经友谊的纪念。2号晚上你发消息的我看了很多很多遍，读懂你很多顾虑、感受还有给我的的机会，平时在生活中我是很照顾他人的感受的，朋友同事都这样评价过我。 关于信任你做的很对很对，女孩子保护好自己，我为什么想知道你离那个地铁站近，是因为第三个礼物需要送到。你的观点是需要继续观察观察我，这是合情合理的。我需要有耐心去让你观察与评价。耐心，一个长跑型选手是很有耐心的。 我知道你会认为我写的上面的东西全篇都是自我，很多都是回想、思考你所说的话后我想我应该怎么做的。 关于未来计划，不知道能不能再次打动你，获得你的原谅，但我会在一个不让你厌烦的距离来请求你的谅解,10天对应的最少是10个月吧，应该会是更久吧。网站每周周末必更，也可能会一周两更。\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E9%81%93%E6%AD%89/","summary":"💓 这个网站是为你准备的礼物，没有计划添加文字，为了获得你的原谅想在每一页写上文字，由于我不是做前端的水平有限，最近发现很多bug，特别是不同","title":"请求娜的原谅"},{"content":"内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区的互斥 虚拟文件系统 第1章 内核引导和初始化 处理器上电-\u0026gt;执行引导程序-\u0026gt;加载内核到内存-\u0026gt;执行内核-\u0026gt;内核初始化-\u0026gt;启动用户空间第一个进程 ARM64处理器到物理地址0取第一条指令\n1.1 引导程序 1.1.1 入口_start ARM64处理器U-Boot程序执行过程，入口u-boot/arch/arm/cpu/armv8/start.S标识_start\n.globl\t_start _start: #if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER) #include \u0026lt;asm/boot0-linux-kernel-header.h\u0026gt; #elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) #include \u0026lt;asm/arch/boot0.h\u0026gt; #else b\treset #endif 1.1.2 reset reset: /* Allow the board to save important registers */ /* 允许板卡保存重要的寄存器*/ b\tsave_boot_params .globl\tsave_boot_params_ret save_boot_params_ret: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl // 初始化系统控制寄存器 #endif /* * 异常级别可能是3、2或者1，初始状态： * 小端字节序，禁止MMU，禁止指令/数据缓存 */ adr x0, vectors witch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 // 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址 mrs x0, scr_el3 // 设置安全配置寄存器SCR_EL3 orr x0, x0, #0xf /* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */ msr scr_el3, x0 msr cptr_el3, xzr /* 启用浮点和SIMD功能*/ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* 初始化寄存器CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 // 异常级别2 mov x0, #0x33ff msr cptr_el2, x0 /* 启用浮点和SIMD功能 */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u0026lt;\u0026lt; 20 msr cpacr_el1, x0 /* 启用浮点和SIMD功能 */ 0: … /* 应用ARM处理器特定的勘误表*/ bl apply_core_errata /* 处理器特定的初始化*/ bl lowlevel_init // 执行board_init_f()所需最小初始化 #if defined(CONFIG_ARMV8_SPIN_TABLE) \u0026amp;\u0026amp; !defined(CONFIG_SPL_BUILD) branch_if_master x0, x1, master_cpu b spin_table_secondary_jump // arch/arm/cpu/armv8/spin_tabli.c /* 绝对不会返回*/ #elif defined(CONFIG_ARMV8_MULTIENTRY) branch_if_master x0, x1, master_cpu /* * 从处理器 */ slave_cpu: wfe ldr x1, =CPU_RELEASE_ADDR // 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数 ldr x0, [x1] cbz x0, slave_cpu br x0 /* 跳转到指定地址*/ #endif /* CONFIG_ARMV8_MULTIENTRY */ master_cpu: bl _main // 主处理器执行函数 U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序\n1.1.3 函数_main // arch/arm/lib/crt0_64.S ENTRY(_main) /* * 设置初始的C语言运行环境，并且调用board_init_f(0)。 */ #if defined(CONFIG_SPL_BUILD) \u0026amp;\u0026amp; defined(CONFIG_SPL_STACK ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节*/ mov x0, sp bl board_init_f_alloc_reserve // 在栈的顶部为结构体global_data分配空间 mov sp, x0 /* 设置gd */ mov x18, x0 bl board_init_f_init_reserve // 函数board_init_f_init_reserve，初始化结构体global_data mov x0, #0 bl board_init_f // common/board_f.c 执行数组init_sequence_f中的每个函数 #if !defined(CONFIG_SPL_BUILD) /* * 设置中间环境（新的栈指针和gd），然后调用函数 * relocate_code(addr_moni)。 * */ ldr x0, [x18, #GD_START_ADDR_SP] /* 把寄存器x0设置为gd-\u0026gt;start_addr_sp */ bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节 */ ldr x18, [x18, #GD_BD] /* 把寄存器x18设置为gd-\u0026gt;bd */ sub x18, x18, #GD_SIZE /* 新的gd在bd的下面 */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* 把寄存器x9设置为gd-\u0026gt;reloc_off */ add lr, lr, x9 /* 在重定位后新的返回地址 */ ldr x0, [x18, #GD_RELOCADDR] /* 把寄存器x0设置为gd-\u0026gt;relocaddr */ b relocate_code relocation_return: /* * 设置最终的完整环境 */ bl c_runtime_cpu_setup /* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/ #endif /* !CONFIG_SPL_BUILD */ #if defined(CONFIG_SPL_BUILD) bl spl_relocate_stack_gd /* 可能返回空指针 重新定位栈*/ /* * 执行“sp = (x0 != NULL) ? x0 : sp”， * 规避这个约束： * 带条件的mov指令不能把栈指针寄存器作为操作数 */ mov x1, sp cmp x0, #0 csel x0, x0, x1, ne mov sp, x0 #endif /* * 用0初始化未初始化数据段 */ ldr x0, =__bss_start /* 这是自动重定位*/ ldr x1, =__bss_end /* 这是自动重定位*/ clear_loop: str xzr, [x0], #8 cmp x0, x1 b.lo clear_loop /* 调用函数board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ b board_init_r /* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */ /* 不会运行到这里，因为函数board_init_r()不会返回*/ ENDPROC(_main) 1.1.4 函数run_main_loop 数组init_sequence_r最后一个函数run_main_loop，函数执行流程；\nrun_main_loop main_loop bootdely_process # 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量) autoboot_command abortboot # 等待用户按键 run_command_list # 未等待到按键，自动执行环境变量bootcmd bootm命令处理函数do_bootm\ndo_bootm do_bootm_states bootm_start # 初始化全局变量bootm_header_timages bootm_find_os # 把内核镜像从存储设备读到内存 bootm_find_other # ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件 bootm_load_os # 解压病加载内核到正确位置 bootm_os_get_boot_func # 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux do_bootm_linux(flag=BOOTM_STATE_OS_PREP) # 调用boot_prep_linux boot_prep_linux # 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件 boot_selected_os # do_bootm_linux(flag=BOOTM_STATE_OS_GO) boot_jump_linux # 负责跳转到Linux内核 boot_jum_linux do_nonsec_virt_switch smp_kick_all_cpus # CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3 dcache_disable # 禁用处理器的缓存和内存管理单元 # 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el2 switch_to_el1 armv8_switch_to_el1 内核入口 # 在异常级别2执行内核 armv8_switch_to_el2 内核入口 1.2 内核初始化 内核初始化分为汇编语言部分和C语言部分\n1.2.1 汇编语言部分 ARM64架构内核入口_head，直接跳转到标号stext\n// linux-4.14.295/arch/arm64/kernel/head.S _head: #ifdef CONFIG_EFI // 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS add x13, x18, #0x16 b stext #else b stext // 跳转到内核起始位置 .long0 // 保留 #endif stext\n// linux-4.14.295/arch/arm64/kernel/head.S ENTRY(stext) bl preserve_boot_args // 把引导程序传递的4个参数保存在全局数组boot_args中 bl el2_setup // 降级到异常级别1, 寄存器w0存放cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR偏移，默认值是0 bl set_cpu_boot_mode_flag // __boot_cpu_mode[2] 数组 bl __create_page_tables // 创建页表映射 /* * 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” * 了解细节。 * 返回的时候，处理器已经为开启内存管理单元做好准备， * 转换控制寄存器已经设置好。 */ bl __cpu_setup // 初始化处理器 b __primary_switch // 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel ENDPROC(stext) 函数el2_setup a.如果异常级别是1，那么在异常级别1执行内核。 b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。 1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。 \\\n2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核 \\\n基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程 \\\n// 打开KVM字符设备文件。 fd = open(\u0026#34;/dev/kvm\u0026#34;, O_RDWR); // 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。 vmfd = ioctl(fd, KVM_CREATE_VM, 0); // KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符 vcpu_fd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 从QEMU切换到客户操作系统的过程如下。 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。 为了提高切换速度，ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2 \\\n函数__create_page_tables 1）创建恒等映射，虚拟地址=物理地址__enable_mmu开启内存管理单元 2）为内核镜像创建映射 \\\n映射代码节.idmap.text,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址\n函数__primary_switch 1）__enable_mmu开启内存管理单元 2）__primary_switched __enable_mmu执行流程 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址 __primary_switch执行流程 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE) 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体thread_info的地址(init_task.thread_info) 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors) 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中 5）用0初始化内核的未初始化数据段 6）调用C语言函数start_kernel \\\n1.2.2 C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。 （1）创建1号线程，即init线程，线程函数是kernel_init。 （2）创建2号线程，即kthreadd线程，负责创建内核线程。 （3）0号线程最终变成空闲线程。 \\\ninit线程继续初始化，执行的主要操作如下。 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。 （3）smp_init()：初始化SMP系统，启动所有从处理器。 （4）do_initcalls()：执行级别0～7的初始化。 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。 （7）free_initmem()：释放初始化代码和数据占用的内存。 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。 \\\n级别0～7的初始化，是指使用以下宏注册的初始化函数：\n// include/linux/init.h #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 1.2.3 SMP系统的引导 对称多处理器(Symmetirc Multi-Processor SMP) 3种引导从处理器方法 \\\n自旋表 电源状态协调接口 ACPI停车协议 1.3 init进程 init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有sysvinit、busybox init、upstart、systemd和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件/etc/initab\n第2章 进程管理 2.1 进程 Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。 task_struct结构体是进程描述符，主要成员\nvolatile long state; // 进程状态 void *stack; // 指向内核栈 pid_t pid; // 全局进程号 pid_t tgid // 全局的线程组标识符 struct pid_link pid[PIDTYPE_MAX]; // 进程号，进程组标识符和会话标识符 struct task_struct _rcu *real_parent; // real_parent指向真实的父进程 struct task_struct _rcu *parent; // parent指向父进程 struct task_struct *group_leader; // 指向进村组的组长 const struct cred _rcu *real_cred; // real_cred指向主题和真实客体证书 const struct cred _rcu *cred; // cred指向客体证书 char comm[TASK_COMM_LEN]; // 进程名 int prio, static_prio, nornal_prio; // 调度策略 unsigned int rt_priority,prolicy； // 优先级 cpumask_t cpus_allowed; // 允许进程在哪些处理器上运行 struct mm_struct *mm, *active_mm; // 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符 struct file_struct *files; // 打开文件表 struct nsproxy *nsproxy; // 命名空间 struct signal_struct *signal; // 信号处理 struct sigband_struct *sighand; sigset_t blocked, real_blocked; sigset_t saved_sigmask; struct sigpending pending; struct sysv_sem sysvsem; // UNIx系统5信号量和共享内存 struct sysv_shm sysvshm; 2.2 命名空间 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,虚拟机仅仅是通过命名空间隔离？ \\\n命名空间 隔离资源 控制组cgroup 控制组根目录 进程间通信IPC UNIX系统5进程间通信和POSIx消息队列 network 网络协议 挂载mount 挂载点 PID 进程号 user 用户标识符和组标识符 UNIX分时系统(UTS) 主机名和网络信息服务NIS域名 创建新的命名空间方法： 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间 调用unshare创建新的命名空间 进程使用系统调用setns，绑定一个已经存在的命名空间\n进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。\n2.3 进程标识符 标识符 进程标识符 命名空间给进程分配标识符 线程组标识符 线程组中的主进程称为组长，线程组标识符就是组长的进程标识符\n系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组 进程组标识符 进程组标识符是组长的进程标识符。\n进程可以使用系统调用setpgid创建或者加入一个进程组 会话标识符 进程调用系统调用setsid的时候，创建一个新的会话 pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid \\\n进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，\n2.4 进程关系 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。\n2.4 启动程序 ret = fork(); if (ret \u0026gt; 0) { /* 父进程继续执行 */ } else if (ret == 0) { /* 子进程装载程序 */ ret = execve(filename, argv, envp); } else { /* 创建子进程失败 */ } 2.4.1　创建新进程 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的 两个个系统调用创建进程： \\\nfork：子进程是父进程的副本，用写时复制 clone：可控制子进程和父进程共享哪些资源 vfork：创建子进程，子进程用execve装载程序(已废弃) // 数字表示参数个数 SYSCALL_DEFINE0(fork) // 宏展开 asmlinkage表示C语言函数看被汇编代码调用 asmlinkage long sys_fork(void) 创建进程的进程p和被创建进程c三种关系\n新进程是进程p的子进程 clone传入CLONE_PARENT，兄弟关系 clone传入CLONE_THREAD，同属一个线程组 1. _do_fork函数 // kernel/fork.c long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); // tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址 调用copy_process创建新进程 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置 wake_up_new_task唤醒新进程\n2. copy_process函数 （1）标志组合 |||\n| :-: | :-: |CLONE_NEWNS \u0026amp; CLONE_FS|新进程属于新挂载命名空间\n共享文件系统信息| |CLONE_NEWUSER \u0026amp; CLONE_FS|新进程属于新用户命名空间\n共享文件系统信息| |CLONE_THREAD 未设置CLONE_SIGHAND|新进程和当前进程同属一个线程组，但不共享信号处理程序| |CLONE_SIGHAND 未设置CLONE_VM|新进程和当前进程共享信号处理程序，但不共享虚拟内存|\n（2）dup_task_struct函数 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈\n// include/linux/sched.h union thread_union { #ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK struct task_struct task; #endif #ifndef CONFIG_THREAD_INFO_IN_TASK struct thread_info thread_info; #endif unsigned long stack[THREAD_SIZE/sizeof(long)]; }; 内核栈两种布局\nthread_info在内核栈顶部，成员task指向进程描述符 thread_info未占用内核栈 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址 内核栈的长度时THREAD_SIZE，ARM64架构内核栈长度为16KB thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体 // arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long\tflags;\t/* low level flags 底层标志位 */ mm_segment_t\taddr_limit;\t/* address limit 地址限制 */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN u64\tttbr0;\t/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */ #endif u64\tpreempt_count;\t/* 抢占计数器 0 =\u0026gt; preemptible 可抢占, \u0026lt;0 =\u0026gt; bug缺陷 */ }; （3）copy_creds函数 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1\n（4）检查线程数量限制 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS\n（5）sched_fork函数\n为新进程设置调度器相关的参数\n// linux-5.10.102/kernel/sched/core.c 书中为4.x版本 int sched_fork(unsigned long clone_flags, struct task_struct *p) { __sched_fork(clone_flags, p); // 执行基本设置 /* * We mark the process as NEW here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u0026gt;state = TASK_NEW; // 新进程状态设置为TASK_NEW /* * Make sure we do not leak PI boosting priority to the child. */ p-\u0026gt;prio = current-\u0026gt;normal_prio; // 新进程调度优先级设置为当前进程正常优先级 uclamp_fork(p); /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u0026gt;sched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { // 限期进程或实时进程 p-\u0026gt;policy = SCHED_NORMAL; // 调度策略 p-\u0026gt;static_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u0026gt;rt_priority = 0; } else if (PRIO_TO_NICE(p-\u0026gt;static_prio) \u0026lt; 0) // 普通进程 p-\u0026gt;static_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u0026gt;prio = p-\u0026gt;normal_prio = p-\u0026gt;static_prio; set_load_weight(p, false); /* * We don\u0026#39;t need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u0026gt;sched_reset_on_fork = 0; } if (dl_prio(p-\u0026gt;prio)) // 调度优先级是限期调度累的优先级 return -EAGAIN; // 不允许限期进程分叉生成新的限期进程 else if (rt_prio(p-\u0026gt;prio)) // 调度优先级是实时调度类优先级 p-\u0026gt;sched_class = \u0026amp;rt_sched_class; // 调度类设置为实时调度类 else p-\u0026gt;sched_class = \u0026amp;fair_sched_class; // 调度优先级是公平调度类的优先级，调度类设置为公平调度类 init_entity_runnable_average(\u0026amp;p-\u0026gt;se); #ifdef CONFIG_SCHED_INFO if (likely(sched_info_on())) memset(\u0026amp;p-\u0026gt;sched_info, 0, sizeof(p-\u0026gt;sched_info)); #endif #if defined(CONFIG_SMP) p-\u0026gt;on_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026amp;p-\u0026gt;pushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026amp;p-\u0026gt;pushable_dl_tasks); #endif return 0; } （6）复制或共享资源 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数 // linux-4.14.295/ipc/sem.c int copy_semundo(unsigned long clone_flags, struct task_struct *tsk) { struct sem_undo_list *undo_list; int error; if (clone_flags \u0026amp; CLONE_SYSVSEM) { // CLONE_SYSTEM表示UNIX系统5信号量 error = get_undo_list(\u0026amp;undo_list); if (error) return error; refcount_inc(\u0026amp;undo_list-\u0026gt;refcnt); // 5信号量的撤销请求链表，sem_undo_list 计数+1 tsk-\u0026gt;sysvsem.undo_list = undo_list; } else tsk-\u0026gt;sysvsem.undo_list = NULL; // 新进程5信号量撤销请求链表为空 return 0; } 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表\n// linux-5.10.102/kernel/fork.c static int copy_files(unsigned long clone_flags, struct task_struct *tsk) { struct files_struct *oldf, *newf; int error = 0; /* * A background process may not have any files ... */ oldf = current-\u0026gt;files; if (!oldf) goto out; if (clone_flags \u0026amp; CLONE_FILES) { // CLONE_FIELS共享打开文件表 atomic_inc(\u0026amp;oldf-\u0026gt;count); // files_struct 计数加1 goto out; } newf = dup_fd(oldf, NR_OPEN_MAX, \u0026amp;error); // 新进程把当前进程的打开文件表复制一份 if (!newf) goto out; tsk-\u0026gt;files = newf; error = 0; out: return error; } 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息 函数copy_fs复制或共享文件系统信息\n// linux-5.10.102/kernel/fork.c static int copy_fs(unsigned long clone_flags, struct task_struct *tsk) { struct fs_struct *fs = current-\u0026gt;fs; if (clone_flags \u0026amp; CLONE_FS) { // CLONE_FS共享文件系统信息 /* tsk-\u0026gt;fs is already what we want */ spin_lock(\u0026amp;fs-\u0026gt;lock); if (fs-\u0026gt;in_exec) { spin_unlock(\u0026amp;fs-\u0026gt;lock); return -EAGAIN; } fs-\u0026gt;users++; // fs_struct共享文件系统信息结构体 加1 spin_unlock(\u0026amp;fs-\u0026gt;lock); return 0; } tsk-\u0026gt;fs = copy_fs_struct(fs); // 新进程复制当前进程文件系统信息 if (!tsk-\u0026gt;fs) return -ENOMEM; return 0; } 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 函数copy_sighand复制或共享信号处理程序\n// static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk) { struct sighand_struct *sig; if (clone_flags \u0026amp; CLONE_SIGHAND) { // CLONE_SIGHAND 表示共享信号处理程序 refcount_inc(\u0026amp;current-\u0026gt;sighand-\u0026gt;count); // 引用计数加1 return 0; } // 新进程复制当前进程信号处理程序 sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL); RCU_INIT_POINTER(tsk-\u0026gt;sighand, sig); if (!sig) return -ENOMEM; refcount_set(\u0026amp;sig-\u0026gt;count, 1); spin_lock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); memcpy(sig-\u0026gt;action, current-\u0026gt;sighand-\u0026gt;action, sizeof(sig-\u0026gt;action)); spin_unlock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); /* Reset all signal handler not set to SIG_IGN to SIG_DFL. */ if (clone_flags \u0026amp; CLONE_CLEAR_SIGHAND) flush_signal_handlers(tsk, 0); return 0; } 5）信号结构体，同属一个线程组的线程才会共享信号结构体 函数copy_signal复制或共享信号结构体\n// linux-5.10.102/kernel/fork.c static int copy_signal(unsigned long clone_flags, struct task_struct *tsk) { struct signal_struct *sig; if (clone_flags \u0026amp; CLONE_THREAD) // CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct return 0; // 为新进程分配结构体，初始化，继承当前进程资源限制 sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL); tsk-\u0026gt;signal = sig; if (!sig) return -ENOMEM; sig-\u0026gt;nr_threads = 1; atomic_set(\u0026amp;sig-\u0026gt;live, 1); refcount_set(\u0026amp;sig-\u0026gt;sigcnt, 1); /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */ sig-\u0026gt;thread_head = (struct list_head)LIST_HEAD_INIT(tsk-\u0026gt;thread_node); tsk-\u0026gt;thread_node = (struct list_head)LIST_HEAD_INIT(sig-\u0026gt;thread_head); init_waitqueue_head(\u0026amp;sig-\u0026gt;wait_chldexit); sig-\u0026gt;curr_target = tsk; init_sigpending(\u0026amp;sig-\u0026gt;shared_pending); INIT_HLIST_HEAD(\u0026amp;sig-\u0026gt;multiprocess); seqlock_init(\u0026amp;sig-\u0026gt;stats_lock); prev_cputime_init(\u0026amp;sig-\u0026gt;prev_cputime); #ifdef CONFIG_POSIX_TIMERS INIT_LIST_HEAD(\u0026amp;sig-\u0026gt;posix_timers); hrtimer_init(\u0026amp;sig-\u0026gt;real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); sig-\u0026gt;real_timer.function = it_real_fn; #endif task_lock(current-\u0026gt;group_leader); memcpy(sig-\u0026gt;rlim, current-\u0026gt;signal-\u0026gt;rlim, sizeof sig-\u0026gt;rlim); task_unlock(current-\u0026gt;group_leader); posix_cpu_timers_init_group(sig); tty_audit_fork(sig); sched_autogroup_fork(sig); sig-\u0026gt;oom_score_adj = current-\u0026gt;signal-\u0026gt;oom_score_adj; sig-\u0026gt;oom_score_adj_min = current-\u0026gt;signal-\u0026gt;oom_score_adj_min; mutex_init(\u0026amp;sig-\u0026gt;cred_guard_mutex); init_rwsem(\u0026amp;sig-\u0026gt;exec_update_lock); return 0; } 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存 \\ 函数copy_mm复制或共享虚拟内存\n// linux-5.10.102/kernel/freezer.c static int copy_mm(unsigned long clone_flags, struct task_struct *tsk) { struct mm_struct *mm, *oldmm; int retval; tsk-\u0026gt;min_flt = tsk-\u0026gt;maj_flt = 0; tsk-\u0026gt;nvcsw = tsk-\u0026gt;nivcsw = 0; #ifdef CONFIG_DETECT_HUNG_TASK tsk-\u0026gt;last_switch_count = tsk-\u0026gt;nvcsw + tsk-\u0026gt;nivcsw; tsk-\u0026gt;last_switch_time = 0; #endif tsk-\u0026gt;mm = NULL; tsk-\u0026gt;active_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ oldmm = current-\u0026gt;mm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); if (clone_flags \u0026amp; CLONE_VM) { // CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct mmget(oldmm); mm = oldmm; goto good_mm; } retval = -ENOMEM; // 新进程复制当前进程的虚拟内存 mm = dup_mm(tsk, current-\u0026gt;mm); if (!mm) goto fail_nomem; good_mm: tsk-\u0026gt;mm = mm; tsk-\u0026gt;active_mm = mm; return 0; fail_nomem: return retval; } 7）命名空间 函数copy_namespace创建或共享命名空间\n// linux-5.10.102/kernel/nsproxy.c int copy_namespaces(unsigned long flags, struct task_struct *tsk) { struct nsproxy *old_ns = tsk-\u0026gt;nsproxy; struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns); struct nsproxy *new_ns; int ret; // 如果共享除了用户以外的所有其他命名空间，那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1 if (likely(!(flags \u0026amp; (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWCGROUP | CLONE_NEWTIME)))) { if (likely(old_ns-\u0026gt;time_ns_for_children == old_ns-\u0026gt;time_ns)) { get_nsproxy(old_ns); return 0; } } else if (!ns_capable(user_ns, CAP_SYS_ADMIN)) // 进程没有系统管理权限，那么不允许创建新的命名空间 return -EPERM; /* * CLONE_NEWIPC must detach from the undolist: after switching * to a new ipc namespace, the semaphore arrays from the old * namespace are unreachable. In clone parlance, CLONE_SYSVSEM * means share undolist with parent, so we must forbid using * it along with CLONE_NEWIPC. */ // 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的 if ((flags \u0026amp; (CLONE_NEWIPC | CLONE_SYSVSEM)) == (CLONE_NEWIPC | CLONE_SYSVSEM)) return -EINVAL; // 创建新的命名空间代理，然后创建或者共享命名空间 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-\u0026gt;fs); if (IS_ERR(new_ns)) return PTR_ERR(new_ns); ret = timens_on_fork(new_ns, tsk); if (ret) { free_nsproxy(new_ns); return ret; } tsk-\u0026gt;nsproxy = new_ns; return 0; } 8）I/O上下文 函数copy_io创建或共享I/O上下文\n// linux-5.10.102/kernel/fork.c static int copy_io(unsigned long clone_flags, struct task_struct *tsk) { #ifdef CONFIG_BLOCK struct io_context *ioc = current-\u0026gt;io_context; struct io_context *new_ioc; if (!ioc) return 0; /* * Share io context with parent, if CLONE_IO is set */ if (clone_flags \u0026amp; CLONE_IO) { // CLONE_IO 共享I/O上小文 ioc_task_link(ioc); // 计数nr_tasks加1 tsk-\u0026gt;io_context = ioc; // 共享I/O上下文结构体io_context } else if (ioprio_valid(ioc-\u0026gt;ioprio)) { // 创建新的I/O上下文，初始化，继承当前进程的I/O优先级 new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE); if (unlikely(!new_ioc)) return -ENOMEM; new_ioc-\u0026gt;ioprio = ioc-\u0026gt;ioprio; put_io_context(new_ioc); } #endif return 0; } 9）复制寄存器值 函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct\nARM64架构copy_thread_tls-\u0026gt;copy_thread\n// linux-5.10.102/arch/arm64/kernel/process.c int copy_thread(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz, struct task_struct *p, unsigned long tls) { struct pt_regs *childregs = task_pt_regs(p); // 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值 memset(\u0026amp;p-\u0026gt;thread.cpu_context, 0, sizeof(struct cpu_context)); /* * In case p was allocated the same task_struct pointer as some * other recently-exited task, make sure p is disassociated from * any cpu that may have run that now-exited task recently. * Otherwise we could erroneously skip reloading the FPSIMD * registers for p. */ fpsimd_flush_task_state(p); ptrauth_thread_init_kernel(p); if (likely(!(p-\u0026gt;flags \u0026amp; PF_KTHREAD))) { // 用户进程 *childregs = *current_pt_regs(); childregs-\u0026gt;regs[0] = 0; /* * Read the current TLS pointer from tpidr_el0 as it may be * out-of-sync with the saved value. * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址， * 因为它可能和保存的值不一致 */ *task_user_tls(p) = read_sysreg(tpidr_el0); if (stack_start) { if (is_compat_thread(task_thread_info(p))) childregs-\u0026gt;compat_sp = stack_start; else childregs-\u0026gt;sp = stack_start; } /* * If a TLS pointer was passed to clone, use it for the new thread. * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它 */ if (clone_flags \u0026amp; CLONE_SETTLS) p-\u0026gt;thread.uw.tp_value = tls; } else { // 内核线程 memset(childregs, 0, sizeof(struct pt_regs)); childregs-\u0026gt;pstate = PSR_MODE_EL1h; if (IS_ENABLED(CONFIG_ARM64_UAO) \u0026amp;\u0026amp; cpus_have_const_cap(ARM64_HAS_UAO)) childregs-\u0026gt;pstate |= PSR_UAO_BIT; spectre_v4_enable_task_mitigation(p); if (system_uses_irq_prio_masking()) childregs-\u0026gt;pmr_save = GIC_PRIO_IRQON; p-\u0026gt;thread.cpu_context.x19 = stack_start; p-\u0026gt;thread.cpu_context.x20 = stk_sz; } p-\u0026gt;thread.cpu_context.pc = (unsigned long)ret_from_fork; p-\u0026gt;thread.cpu_context.sp = (unsigned long)childregs; ptrace_hw_copy_thread(p); return 0; } （7）设置进程号和进程关系 static __latent_entropy struct task_struct *copy_process( struct pid *pid, int trace, int node, struct kernel_clone_args *args) { // 为新进程分配进程号 // pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号 if (pid != \u0026amp;init_struct_pid) { pid = alloc_pid(p-\u0026gt;nsproxy-\u0026gt;pid_ns_for_children); if (IS_ERR(pid)) { retval = PTR_ERR(pid); goto bad_fork_cleanup_thread; } } … // 设置新进程退出时发送给父进程的信号 p-\u0026gt;pid = pid_nr(pid); if (clone_flags \u0026amp; CLONE_THREAD) { p-\u0026gt;exit_signal = -1; // 新线程退出时不需要发送信号给父进程 p-\u0026gt;group_leader = current-\u0026gt;group_leader; // group_leader指向同一个组长 p-\u0026gt;tgid = current-\u0026gt;tgid; // tgid存放组长的进程号 } else { if (clone_flags \u0026amp; CLONE_PARENT) // CLONE_PARENT 新进程和当前进程是兄弟关系 p-\u0026gt;exit_signal = current-\u0026gt;group_leader-\u0026gt;exit_signal; // 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal else // 父子关系 p-\u0026gt;exit_signal = (clone_flags \u0026amp; CSIGNAL); // 新进程的成员exit_signal是调用者指定的信号 p-\u0026gt;group_leader = p; p-\u0026gt;tgid = p-\u0026gt;pid; } // 控制组的进程数控制器检查是否允许创建新进程：从当前进程所属的控制组一直到控制组层级的根，如果其中一个控制组的进程数量大于或等于限制，那么不允许使用fork和clone创建新进程 cgroup_threadgroup_change_begin(current); retval = cgroup_can_fork(p); if (retval) goto bad_fork_free_pid; write_lock_irq(\u0026amp;tasklist_lock); // 为新进程设置父进程 if (clone_flags \u0026amp; (CLONE_PARENT|CLONE_THREAD)) { p-\u0026gt;real_parent = current-\u0026gt;real_parent; // 新进程和当前进程拥有相同的父进程 p-\u0026gt;parent_exec_id = current-\u0026gt;parent_exec_id; } else { p-\u0026gt;real_parent = current; // 新进程的父进程是当前进程 p-\u0026gt;parent_exec_id = current-\u0026gt;self_exec_id; } … spin_lock(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); … if (likely(p-\u0026gt;pid)) { … init_task_pid(p, PIDTYPE_PID, pid); if (thread_group_leader(p)) { // true 新进程和当前进程属于同一个进程组 init_task_pid(p, PIDTYPE_PGID, task_pgrp(current)); // 指向同一个进程组的组长的进程号结构体 init_task_pid(p, PIDTYPE_SID, task_session(current)); // 指向同一个会话的控制进程的进程号结构体 if (is_child_reaper(pid)) { ns_of_pid(pid)-\u0026gt;child_reaper = p; p-\u0026gt;signal-\u0026gt;flags |= SIGNAL_UNKILLABLE; // 1号进程是不能杀死的 } p-\u0026gt;signal-\u0026gt;leader_pid = pid; p-\u0026gt;signal-\u0026gt;tty = tty_kref_get(current-\u0026gt;signal-\u0026gt;tty); p-\u0026gt;signal-\u0026gt;has_child_subreaper = p-\u0026gt;real_parent-\u0026gt;signal-\u0026gt; has_child_subreaper || p-\u0026gt;real_parent-\u0026gt;signal-\u0026gt;is_child_subreaper; list_add_tail(\u0026amp;p-\u0026gt;sibling, \u0026amp;p-\u0026gt;real_parent-\u0026gt;children); // 新进程添加到父进程的子进程链表 list_add_tail_rcu(\u0026amp;p-\u0026gt;tasks, \u0026amp;init_task.tasks); // 新进程添加到进程链表中，链表节点是成员tasks，头节点是空闲线程的成员tasks（init_task.tasks） attach_pid(p, PIDTYPE_PGID); // 新进程添加到进程组的进程链表 attach_pid(p, PIDTYPE_SID); // 新进程添加到会话的进程链表 __this_cpu_inc(process_counts); } else { // 创建线程 current-\u0026gt;signal-\u0026gt;nr_threads++; // 线程组的线程计数值加1 atomic_inc(\u0026amp;current-\u0026gt;signal-\u0026gt;live); // 原子变量线程组的第2个线程计数值加1 atomic_inc(\u0026amp;current-\u0026gt;signal-\u0026gt;sigcnt); // 信号结构体的引用计数加1 list_add_tail_rcu(\u0026amp;p-\u0026gt;thread_group, \u0026amp;p-\u0026gt;group_leader-\u0026gt;thread_group); // 线程加入线程组的线程链表 list_add_tail_rcu(\u0026amp;p-\u0026gt;thread_node, \u0026amp;p-\u0026gt;signal-\u0026gt;thread_head); // 线程加入线程组的第二条线程链表 } attach_pid(p, PIDTYPE_PID); // 新进程添加到进程号结构体的进程链表 nr_threads++; // 新进程添加到进程号结构体的进程链表 } total_forks++; spin_unlock(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); … write_unlock_irq(\u0026amp;tasklist_lock); proc_fork_connector(p); cgroup_post_fork(p); cgroup_threadgroup_change_end(current); … return p; } 3.唤醒新进程 wake_up_new_task函数唤醒新进程\n// linux-5.10.102/kernel/sched/core.c void wake_up_new_task(struct task_struct *p) { struct rq_flags rf; struct rq *rq; raw_spin_lock_irqsave(\u0026amp;p-\u0026gt;pi_lock, rf.flags); p-\u0026gt;state = TASK_RUNNING; // 切换TASK_RUNNING #ifdef CONFIG_SMP /* * Fork balancing, do it here and not earlier because: * - cpus_ptr can change in the fork path * - any previously selected CPU might disappear through hotplug * * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq, * as we\u0026#39;re not fully set-up yet. */ p-\u0026gt;recent_used_cpu = task_cpu(p); rseq_migrate(p); __set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); // 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器 #endif rq = __task_rq_lock(p, \u0026amp;rf); // 锁住运行队列 update_rq_clock(rq); // 更新运行队列的时钟 post_init_entity_util_avg(p); // 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值 activate_task(rq, p, ENQUEUE_NOCLOCK); // 把新进程插入运行队列 trace_sched_wakeup_new(p); check_preempt_curr(rq, p, WF_FORK); // 检查新进程是否可以抢占当前进程 #ifdef CONFIG_SMP if (p-\u0026gt;sched_class-\u0026gt;task_woken) { // 在SMP系统上，调用调度类的task_woken方法 /* * Nothing relies on rq-\u0026gt;lock after this, so its fine to * drop it. */ rq_unpin_lock(rq, \u0026amp;rf); p-\u0026gt;sched_class-\u0026gt;task_woken(rq, p); rq_repin_lock(rq, \u0026amp;rf); } #endif task_rq_unlock(rq, p, \u0026amp;rf); // 释放运行队列的锁 } 4.新进程第一次运行 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数\n// linux-5.10.102/arch/arm64/kernel/entry.S tsk .req x28 //当前进程的thread_info结构体的地址 SYM_CODE_START(ret_from_fork) bl\tschedule_tail // 为上一个进程执行清理操作 cbz\tx19, 1f // not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1 mov\tx0, x20 // 内核线程：x19存放线程函数的地址，x20存放线程函数的参数 blr\tx19 // 调用线程函数 1:\tget_current_task tsk // 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址 b\tret_to_user // 返回用户模式 SYM_CODE_END(ret_from_fork) NOKPROBE(ret_from_fork) copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0 // linux-5.10.102/kernel/sched/core.c asmlinkage __visible void schedule_tail(struct task_struct *prev) __releases(rq-\u0026gt;lock) { struct rq *rq; /* * New tasks start with FORK_PREEMPT_COUNT, see there and * finish_task_switch() for details. * * finish_task_switch() will drop rq-\u0026gt;lock() and lower preempt_count * and the preempt_enable() will end up enabling preemption (on * PREEMPT_COUNT kernels). */ rq = finish_task_switch(prev); // 为上一个进程执行清理操作2.8.6 balance_callback(rq); // 执行运行队列的所有负载均衡回调函数 preempt_enable(); // 开启内核抢占 if (current-\u0026gt;set_child_tid) // pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置 put_user(task_pid_vnr(current), current-\u0026gt;set_child_tid); calculate_sigpending(); } 2.4.2 装载程序 调度器调度新进程，新进程从函数ret_from_fork开始，从系统调用fork返回用户空间，返回值0。然后新进程使用系统调用execve装载程序。Linux内核练个装载程序系统调用： \\\n// 路径名是相对时execve解释为相对调用进程的当前工作目录 int execve(const char *filename, char *const argv[], char *const envp[]); // 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录 // 路径名时绝对的，execveat忽略参数dirfd int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); 参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值\n两个系统调用最终都调用函数do_execveat_common 函数do_open_execat打开可执行文件。 函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器 函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-\u0026gt;p指向在栈底保留一个字长（指针长度）后的位置 函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？ \\ 依次把文件名称、环境字符串和参数字符串压到用户栈 函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止\n1.二进制格式 Linux二进制格式\n// linux-5.10.102/include/linux/binfmts.h struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump;\t/* minimal dump size */ } __randomize_layout; 二进制格式提供3个函数 (1)load_binary 加载普通程序 (2)load_shlib 加载共享库 (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度 二进制格式使用register_binfmt向内核注册\n2.装载ELF程序 ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式\n目标文件(可重定位文件)，.o，多个模板文件链接生成可执行文件或共享库 可执行文件 共享库 .so 核心转储文件(core dump file) ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","summary":"内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区","title":"Linux内核深度解析"},{"content":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉取更新代码 git pull # 推送 git push # 合并已push的commit git rebase -i HEAD~n # 强制更新覆盖本次 git fetch --all git reset --hard HEAD git pull # 强制推送 git push -u origin br_master --force # 回合代码 git rebase master # 回退已提交commit git reset --soft \u0026lt;commit-ID\u0026gt; # 忽略部分文件提交 git add filename # 放入本地栈 git stash -u -k git commit git push # 弹出本地栈 git stash pop git配置 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@163.com\u0026#34; git config --list user.name=xxx user.email=xxx@163.com # 生成秘钥 ssh-keygen -t rsa -C \u0026#39;xxx@163.com\u0026#39; # cd ~/.ssh 将 id_rsa.pub 添加道GitHub # 测试链接 ssh -T git@github.com # 设置默认编辑为vim git config --global core.editor \u0026#34;vim\u0026#34; 玩转WSL(6)之Git配置\ngit同时配置Gitee和Github\nGit设置换行符为LF\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/git/","summary":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉","title":"git"},{"content":"python logging # logging.yaml： version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #保留50个log文件 encoding: utf8 server_file_handler: class: logging.handlers.RotatingFileHandler level: INFO # 只在文件中记录INFO级别及以上的log formatter: upgrade filename: ./logs/server.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 loggers: server: level: DEBUG #允许打印DEBUG及以上log handlers: [server_file_handler] propagate: true #设为false则禁止将日志消息传递给父级记录器的处理程序中 root: level: DEBUG handlers: [console, all_file_handler] # logger.py # logging.py from fileinput import filename import os import time import yaml import logging.config import logging import datetime #import coloredlogs class Logger(): def __init__(self, log_name=\u0026#34;log.log\u0026#34;, log_path = \u0026#34;./logs\u0026#34;, default_path = \u0026#34;logging.yaml\u0026#34;, default_level = logging.INFO,env_key = \u0026#34;LOG_CFG\u0026#34;): self.log_name = log_name self.log_path = log_path #time_stamp = time. now = time.strftime(\u0026#39;%Y-%m-%d %H_%M_%S_\u0026#39;) # 文件的命令以及打开路径 log_filename = self.log_path + \u0026#34;/\u0026#34; + now + self.log_name with open(file=default_path, mode=\u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;)as file: logging_yaml = yaml.load(stream=file, Loader=yaml.FullLoader) logging_yaml[\u0026#39;handlers\u0026#39;][\u0026#39;all_file_handler\u0026#39;][\u0026#39;filename\u0026#39;] = log_filename print(\u0026#34;logging_yaml \u0026#34;,logging_yaml) handlers = logging_yaml[\u0026#39;handlers\u0026#39;] for key, value in handlers.items(): if \u0026#39;filename\u0026#39; in value: log_path = (os.path.split(value[\u0026#39;filename\u0026#39;])[0]) print(\u0026#34;log_path\u0026#34;) if not os.path.exists(log_path): os.makedirs(log_path) # 配置logging日志：主要从文件中读取handler的配置、formatter（格式化日志样式）、logger记录器的配置 logging.config.dictConfig(config=logging_yaml) ###设置完毕### # 获取根记录器：配置信息从yaml文件中获取 root = logging.getLogger() # 子记录器的名字与配置文件中loggers字段内的保持一致 server = logging.getLogger(\u0026#34;server\u0026#34;) print(\u0026#34;rootlogger:\u0026#34;, root.handlers) print(\u0026#34;serverlogger:\u0026#34;, server.handlers) print(\u0026#34;子记录器与根记录器的handler是否相同：\u0026#34;, root.handlers[0] == server.handlers[0]) if __name__ ==\u0026#39;__main__\u0026#39;: Logger() logging.info(\u0026#34;first log\u0026#34;) 参考链接：\nhttps://blog.csdn.net/weixin_43988680/article/details/123528294 https://zhuanlan.zhihu.com/p/425678081 https://blog.csdn.net/qq_35812205/article/details/126480417 https://blog.csdn.net/TracelessLe/article/details/108887001 c log zlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/logging/","summary":"python logging # logging.yaml： version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #保留50个lo","title":"logging"},{"content":"多年经验总结，写出最惊艳的 Markdown 高级用法\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/markown/","summary":"多年经验总结，写出最惊艳的 Markdown 高级用法","title":"Markown"},{"content":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxcommand/","summary":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown","title":"LinuxCommand"},{"content":"openbenchmark\nopenssl speed openssl speed --multi 1 openssl speed --multi 1 aes-128-cbc # 编译 https://www.jianshu.com/p/499c4603cfd5\nhttps://blog.csdn.net/CHYabc123456hh/article/details/125794350\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/benchmark/","summary":"openbenchmark openssl speed openssl speed --multi 1 openssl speed --multi 1 aes-128-cbc # 编译 https://www.jianshu.com/p/499c4603cfd5 https://blog.csdn.net/CHYabc123456hh/article/details/125794350","title":"benchmark"},{"content":"[toc]\n深入理解计算机系统 第1章 计算机系统 hello world程序分析 hello.c编译\n编译系统：预处理器cpp、编译器ccl、汇编器as和链接器ld\n计算机系统硬件组成：总线，I/O设备，主存，处理器 CPU 在指令的要求下执行操作：加载、存储、操作和跳转\nhello程序加载 从键盘上读取 hello 命令,从磁盘加载可执行文件到主存,将输出字符串从存储器写到显示器\n高速缓存存储器cache：L1 L2 L3(SRAM) 存储设备层次结构 操作系统有两个基本功能：（1)防止硬件被失控的应用程序滥用；（2 )向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备 操作系统通过几个基本的抽象概念：进程、虚拟内存和文件 Posix 标准：Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程\n进程：操作系统对一个正在运行的程序的一种抽象，操作系统实现进程交错执行的机制称为上下文切换\n操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括 PC 和寄存器文件的当前值，以及主存的内容\n系统调用会将控制权传递给操作系统\n从一个进程到另一个进程的转换是由操作系统内核（kernel )管理的。内核是操作系统代码常驻主存的部分\n读写文件，执行一条系统调用（system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序\n内核不是一个独立的进程。是系统管理全部进程所用代码和数据结构的集合\n线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据\n虚拟内存 程序代码和数据，堆，共享库，栈，内核虚拟内存，\n文件 I/O 设备是文件\n系统之间网络通信\nAmdahl定律\n对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度\n并发和并行 三个层次：\n线程级并发 指令级并行 单指令、多数据并行 计算机系统中抽象 程序结构和执行 处理器和存储子系统，基本数据结构，指令操作，编译器翻译\n第2章 信息的表示和处理 2.1 信息表示 十六进制 x是2的非负整数n次幂时，x=2”，我们可以很容易地将 x 写成十六进制形式，只要记住 X 的二进制表示就是1后面跟n个0， 2^9 = 512 0x200\n字节序 低有效字节在最前面的方式，称为小端法 最高有效字节在最前面的方式，称为大端法 x01234567 大端01 23 45 67 小端 67 45 23 01\n位运算与逻辑运算 位运算\u0026amp;与 |或 ~非 异或 逻辑运算：\u0026amp;\u0026amp;与 ||或 !非 无符号，补码，浮点数\n移位运算 算数右移和逻辑右移\n2.2 整数表示 有符号数和无符号数 补码计算公式 C 库中的文件\u0026lt;limits.h\u0026gt;定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。常量 INT_MAX、INT_MIN 和UINT_MAX, stdint.h 中uintl6_t，int32_t定义指定位数类型。\n#define INT_MAX 2147483647 #define INT.MIN (-INT_MAX 1) 2.3 整数运算 计算机执行的 “整数” 运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出\n2.4 浮点数 浮点表示通过将数字编码为: x*2〃的形式来近似地表示实数\n第3章 程序的机器级表示 计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、 读写存储设备上的数据，以及利用网络通信\n3.1 机器码 指令集体系结构或指令集架构(Instruction Set Architecture,ISA)定义机器级程序的格式和行为，定义了处理器状态、指令的格式，已经每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址，内存模型看做一个大字节数组。\n处理器状态：\n程序计数器(PC x86-64中%rip)给出将要执行的下一条指令在内存中的地址 整数寄存器文件包含16个命名的位置,分别存储64位的值. 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息. 一组向量寄存器可存放一个或多个整数或浮点数值. # -S 产生汇编代码 生成 .s 文件 gcc -Og -S mstore.c # -c 编译并汇编 产生 .o 文件 gcc -Og -c mstore.c # 反汇编 objdump -d mstore.o x86-64指令长度从1到15字节不等. 反汇编器基于机器代码文件中的字节序列确定汇编代码 汇编代码中以 以.开头的行都是指导汇编器和链接器工作的伪指令 C语言中嵌入汇编代码:1)独立汇编文件,用汇编器和链接器把它和C语言代码合并.2)使用GCC的内联汇编特性,用asm伪指令在C程序中包含汇编代码 数据传送指令四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)\n3.2 处理器访问 x86-64的中央处理器(CPU)包含一组16个存储64位值的通用目的寄存器。%r开头，%rax-%rbp 栈指针%rsp，用来指明运行时栈的结束位置\n复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0。\n3.2.1 指令操作和类型 指令操作数：指令操作使用的源数据值，以及放置结果的目的位置。操作数三种类型：立即数(immediate)、寄存器(register)和内存引用。\n数据传送指令\nMOV类：movb，movw，movl和movq 源操作数类型：立即数，寄存器值和内存中的值，目的操作数：指定位置，寄存器，内存地址，x86-64中源操作数和目的操作数不能同为内存地址。\nMOVZ类指令把目的中剩余资金填充位0 MOVS类指令通过符号扩展来填充，把源操作数高位进行复制。 cltq指令：总以寄存器%eax作为源，%rax作为符号扩展结果的目的 *指针简介引用，\u0026amp;取址\n3.2.2 压入和弹出栈数据 pushq操作把数据压入栈中，popq指令弹出数据；栈向下增长，栈顶元素在低地址，栈指针%rsp保存栈顶元素地址。 3.3 算术和逻辑操作 加法指令ADD类：addb、addw、addl和addq 四组操作：加载有效地址、一元操作、二元操作和移位 leaq 将有效地址写入到目的操作数。 一元操作：只有一个操作数，即是源又是目的。 二元操作：第二个操作数既是源又是目的。 移位操作：先给出移位量，然后第二项给出的是要移位的数。算术和逻辑右移。移位量是个立即数，或者但自己寄存器%c1中。左移：SAL和SHL；右移：SAR和SHR\n特殊算数操作 3.4 控制指令 两种基本条件行为：测试数据值，然后根据曹氏结果来改变控制流或数据流。\n3.4.1 条件码(condition code)寄存器 CF：进位标志 ZF：零标志 SF：符号标志 OF：溢出标志 两类设置条件码指令：\nCMP指令：根据两个操作数之差来设置条件码 TEST指令：与AND(\u0026amp;)指令一样，但仅设置条件码 访问条件码：1)条件码的某种组合SET指令 2)条件跳转 3)条件传送数据\n跳转指令jump\njmp无条件跳转指令：直接跳转和间接跳转 # 用寄存器%rax中的值作为跳转目标 jmp *%rax # 以%rax中的值作为读地址，从内存中读取跳转目标 jmp *(%rax) 当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令 的地址，而不是跳转指令本身的地址\n为什么基于条件数据传送(条件赋值)的代码会比基于条件控制转移的代码性能要好？\n分支预测是条件表达式50%的正确率，x86-64分支预测错误惩罚19个时钟周期。 无论测试数据是什么，编译出使用条件传送代码所需的时间8个时钟周期。控制流不依赖于数据，处理器更容易保持流水线是满的。 条件传送指令 3.4.2 循环 条件测试和跳转组合实现循环\ndo-while循环 loop: bogy-statement t = text-expr; if (t) goto loop while 循环 goto test; loop: body-statement test: t = text-expr; if (t) goto loop; t = text-expr if (!t) got done; do body-statement while(test-expr); done for循环 init-expr; got test; loop: body-statement update-expr; test: t = test-expr; if (t) goto loop; init-expr; t = test-expr; if (!t) goto done; loop: body-statement update-epxr; t = test-expr; if (t) goto loop; done 3.4.2 switch语句 switch(开关)语句可以根据一个整数索引值进行多重分支（multiway branching)。使用跳转表(jump table)数据结构使得实现更加高效,跳转表是一个数组，表项i是一个代码段的地址。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关 .rodata（只读数据，Read-Only Data)的目标代码文件的 段中\n3.5 过程 过程：函数，方法，子例程，处理函数。 过程切换：传递控制，传递数据，分配和释放内存\n运行时栈 栈向低地址方向增长，栈指针%rsp指向栈顶元素。pushq和popq指令将数据压栈和出栈。运行栈划分成栈帧，被调函数返回地址属于调用函数栈帧。\n转移控制 将程序计数器(PC)设置为转移目的代码起始位置。 call Q调用过程 call指令，指明被调用过程起始的指令地址,直接调用的目标是标号,间接调用的目标是*后面跟一个操作数指示符.call将返回地址压入栈中,并跳转到函数的第一条指令.\n数据传送 大部分数据传送通过寄存器实现,返回值通过%rax寄存器. x86-64中通过寄存器最多传递6个整型参数,超出部分通过栈传递,栈顶数据大小都向8的倍数对齐。ARMv8通过寄存器最多可传递8个参数。 栈上局部存储：超出寄存器数量，局部变量地址\u0026amp;，局部变量数组或结构 寄存器中的局部存储空间：寄存器组，寄存器%rbx、%rbp和%r12-%r15为被调用者保存寄存器。被调用这必须保存这些寄存器值，不改变值或入栈返回前恢复。其他寄存器由调用者保存。 每次函数调用由字节私有的状态信息（保存的返回值位置和被调用这保存寄存器的值）存储空间。 递归过程与普通调用一致\n3.6 数组分配与访问 数组声明：T A[N] x86-64内存引用指令可简化数组访问\n# E[i] E地址在寄存器%rdx中，i值在寄存器%rcx中 x + 4i movl (%rdx, %rcx, 4), %eax 指针运算 单操作符\u0026amp;和*可产生指针和间接引用指针 嵌套数组(多维数组) 定长数组 #define N 1 变长数组 malloc\n3.7 结构struct和联合union struct 指向结构的指针就是结构第一个字节的地址,结构信息每个字段（field)的字节偏移\nunion 联合能够规避c语言的类型系统，允许以多种类型引用一个对象\n数据对齐 x86-64数据类型对齐 # 保证起始地址是8的倍数 .align 8 3.8机器级程序中控制和数据结合 指针 指针类型，指针值，指针创建\u0026amp;，指针间接引用*，数组与指针，指针强制类型转换，函数指针(*f)()\nGDB\ngdb prog 内存越界引用和缓冲区溢出 数组越界访问 字符串长度超过分配的数组空间 防止缓冲区溢出：栈随机化，栈破坏检测，限制可执行代码区域，变长栈帧\n3.9 浮点代码 MMX-SSE-SSE2-AVX-AVX2 AVX浮点体系16个YMM寄存器%ymm0-%ymm15,256bit(32字节) 浮点传送和转换 浮点运算 x86-64 机器代码 控制结构（比如条件、循环和开关语句）生成的基本指令模式 括栈分配、寄存器使用惯例和参数传递 数据结构（如结构、联合和数组）的分配和访问方式 整数和浮点数算术运算的指令 代码安全漏洞（例如缓冲区溢出）\n第4章 处理器体系结构 处理器支持的指令和指令的字节级编码称为指令集体系结构(Instruction-Set Architecture ISA) HCL(Hardware Control Language硬件控制语言)\n4.1 Y86-64指令集 Y86-64 指令\nmovq指令分成4中：irmovq,rrmovq,mrmovq和rmmovq;i立即数，r寄存器，m内存 整数操作指令4个：addq,subq,andq和xorq;可设置条件吗ZF(零)，SF(符号)和OF(溢出) 跳转指令7条：jmp、 jle、 jl、 je、 jne、 jge 和 jg 6个条件传送指令: cmovle、cmovl、cmove、 cmovne、 cmovge 和 cmovg。 call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回 pushq 和 popq 指令实现了人栈和出栈 halt 指令停止指令的执行 CISC(复杂指令集)和RISC(精简指令集) RISC寻址方式简单:机制和便宜了寻址，只能对寄存器操作数进行算数和逻辑运算，内存引用仅有load和store\n状态码Stat，程序执行的总体状态 以.开头的词是汇编器伪指令（assembler directives)，它们告诉汇 编器调整地址，以便在那儿产生代码或查入一些数据。\npush %rsp指令行为：1)压人％rsp 的原始值，2)压人减去 8 的红印的值\n4.2 逻辑设计和硬件控制语言HCL 逻辑门 与 或 非 逻辑门组成组合电路\n存储器和时钟 两类存储设备：时钟寄存器(寄存器)和随记访问存储器(内存) 处理器随机访问存储器来存储程序数据 SEQ(\u0026ldquo;se-quential\u0026rdquo; 顺序的）的处理器\n操作阶段：\n取值fetch:从内存读取指令字节，地址为程序计数器（PC)的值,从指令中取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令功能）。 译码decode: 译码阶段从寄存器文件读人最多两个操作数 执行execute: 执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针 访存memory: 访存阶段可以将数据写人内存，或者从内存读出数据 写回: 最多可以写两个结果到寄存器文件 更新PC: 将 PC 设置成下一条指令的地址。 SEQ引进结构\n控制处理器中活动的时序原则：从不回读，\n取指阶段 译码和写回阶段 执行阶段 访存阶段 更新PC阶段 流水线 吞吐量：每秒千兆条指令（GIPS)\n各个阶段之间放上流水线寄存器（pipeline register) 现代处理器采用了很深的(15 或更多的阶段)流水线\n带反馈流水线系统 指令执行顺序相关：\n数据相关 控制相关 SEQ+ PIPE 预测下一个 PC\n猜测分支方向并根据猜测开始取指的技术称为分支预测，预测 PC 的新值为 valG\n流水线冒险 相关有两种形式：1)数据相关，下一条指令会用到这一条指令计算出的结果；2)控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时 冒险也可以分为两类：数据冒险（data hazard)和控制冒险(control hazard)\n对于Y86-64 来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器\n异常处理 Y86-64 包括三种不同的内部产生的异常：l)halt 指令，2)有非法指令和功能码组合的指令，3)取指或数据读写试图访问一个非法地址 导致异常的指令称为异常指令（excepting instruction)\nPIPE 各阶段的实现 PC 选择和取指阶段 译码和写回阶段 执行阶段 访存阶段\nCPI(Cycles Per Instruction, 每指令周期数）\n第四章流水部分还需要继续阅读 基本的组合和时序逻辑元素 流水线 五阶段处理器流水线\n第5章 优化程序性能 高性能程序：1)数据结构与算法选择 2)编译器能够优化 3)计算分解，并行化\n5.1 优化编译器 GCC 编译选项 -Og -O1 -O2 -O3 两个指针可能指向同一个内存位置的情况称为内存别 名使用（memory aliasing) 包含函数调用的代码可以用一个称为 内联函数替换（inline substitution, 或 者简称\u0026quot;内联（inlining)\u0026quot;）的过程进行优化\n程序性能表示 CPE每元素的周期数（Cycles Per Element, CPE)\n消除循环的低效率:循环条件判断中使用数值，而不是表达式 减少过程调用：将调用移出循环 消除不必要的内存引用：把中间结果存在临时变量中，最后在赋给引用地址\n5.2 现代处理器 指令并行 两种下界描述了程序的最大性能:延迟界限(latency bound)和吞吐量界限(throughpu bound) 超标量：每个时钟周期执行多个操作 乱序：指令的顺序不一定与机器级程序中的顺序一致 处理器设计两个主要部分：指令控制单元(ICU)和执行单元(EU) 分支预测(branch prediction):处理器会猜测是否选择分支，还预测分支的目的地址 投机执行（speculative execution)冒险？ 处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码 Intel Core i7 Haswell 有 8 个功能单元: 0 整数运算、浮点乘、整数和浮点数除法、分支 1 整数运算、浮点加、整数乘、浮点乘 2 加载、地址计算 3 加载、地址计算 4 存储 5 整数运算 6 整数运算、分支 7 存储、地址计算\n任何对程序寄存器的更新都只会在指令退役时才会发生 控制操作数在执行单元间传送的最常见的机制称为寄存器重命名（register renaming)：值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来， 重命名表只包含关于有未进行写操作的寄存器条目。\n运算性能：\n延迟：完成运算所需总时间 发射时间：两个联系同类型运算直接最小时间周期数 容量：能够执行该元素的功能单元的数量 数据流(data-flow)，关键路径(critical path)\n循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。编译器GCC优化等级-O3\n5.3 提高并行性 对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能 浮点乘法和加法不是可结合的\n重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。\n极大化对向量元素加或者乘的函数性能\n制约程序性能的一些限制因素：寄存器溢出，并行度p超过寄存器数量；分支预测和预测错误处罚\n5.4 内存性能 加载的性能：对两个加载单元而言，其每个时钟周期只能启动一条加载操作，所以 CPE 不可能小于 0.50 存储的性能：每个周期开始一条新的存储\n5.5 性能提高技术 1）高级设计：为问题选择适当的算法和数据结构 2）编码原则：消除连续的函数调用；消除不必要的内存引用 3）低级优化：展开循环；使用多个累积变量和重新结合等，提高指令并行；功能性的风格重写条件操作\n基准数据（benchmark data} Unix 系统提供了一个剖析程序 GPROF Linux 系统上 VALGRIND� 循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器 提供的指令级并行 减少程序需要做的工作的变换 指令级并行度的变换 现代乱序处理器是如何工作的\n第6章 存储器层次结构 存储器层次结构 局部性（locality) 存储技术棗 SRAM 存储器、DRAM 存储器、ROM 存储器以及旋转的和固态的硬盘\n6.1 随机访问存储器 随机访问存储器（Random-Access Memory, RAM)分为两类：静态的和动态的。静态AM(SRAM)比动态 RAM(DRAM)更快，SRAM 用来作为高速缓存存储器，可在CPU芯片上，也可在片下。 SRAM每个位存储在一个双稳态的（bistable)存储器单元 DRAM 将每个位存储为对一个电容的充电 行地址i称为 RAS(Row Access Strobe, 行访问选通脉冲）请求。列地址j称为 CAS(Cÿlumn Access Strobe, 列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引脚 双倍数据速率同步 DRAM(Double Data-Rate Synchronous DRAM, DDR SDRAM) SRAM和DRAM都是易失的,ROM非易失的 只读存储器（Read-Only Memory, ROM) 可擦写 可编程 ROM(Erasable Programmable ROM, EPROM) 闪存（flash memory)是一类非易失性存储器，基于 EEPROM\n总线事务(bus transaction)。读事务（read transaction)从主存传送数据到CPU写事务（write transaction)从CPU传送数据到主存。 地址、数据和控制总线\nIO总线：PCI、PCIE、USB\nCPU 使用一种称为内存映射 I/O(memory-mapped I/O)的技术来向 I/O 设备发射命令。内存映射 I/O 的系统中，地址空间中有一块地址是为与 I/O 设备通信保留的。每个这样的地址称为一个 I/O 端口（I/O port)，当一个设备连接到总线时，它与一个或多个端口相关联(或它被映射到一个或多个端口） 直接内存访问(Direct Memory Access DMA)\n固态硬盘 读SSD比写要快\n6.2 局部性 局部性原理（principle of locality)：倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身 时间局部性（temporal locality) 和空间局部性（spatial locality) 时间局部性的程序中，被引用过一次的内存位置很可能在不远 的将来再被多次引用 空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置 数据引用的局部性，取指令的局部性 局部性原则：重复引用相同变量；步长为々的引用模式的程序，步长越小，空间局部性越好；取指令来说，循环有好的时间和空间局部性\n6.3 存储层次结构 存储器层次结构 高速缓存cache 存储器被划分成连续的数据对象组块（chunk), 称为块（block)。 数据总是以块大小为传送单元（transfer unit)在第k层和第;k+1 层之间来回复制的 缓存命中和缓存不命中(cache miss) 替换策略：最近最少被使用（LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块 缓存不命中的种类\n强制性不命中（compulsory miss)或冷不命中（cold miss)：空的缓存有时被称为冷缓存（cold cache) 冲突不命中（conflict miss)：限制性的放置策略会引起一种不命中 容量不命中（capacity miss)：工作集的大小超过缓存的大小 高速缓存被组织成一个有 S=2^s个高速缓存组（cache set)的数组。每个组包含 £个高速缓存行（cache line)， 每个行是由一个 B =2^b 字节的数据块(block)组成的，一个有效位（valid bit)指明这个行是否包含有意义的信息，还有 t=m-(b+s)个标记位（tag bit)(是当前块的内存地址的位的一个子集》s 它们唯一地标识存储在 这个高速缓存行中的块。 高速缓存的结构可以用元组（S,E,B,m)来描述\n高速缓存请求名字，抽取被请求子过程：1)组选择 2)行匹配 3)字抽取\n组相联高速缓存： 1\u0026lt;E\u0026lt;C/B 称为E路组相联高速缓存 组相连替换最不常使用(Least-Frequently-Used,LFU)策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最 少使用(Least-Recently-Used LRU)策略会替换最后一次访问时间最久远的那一行。\n全相联高速缓存： 包含所有高速缓存行的组（即 E=C/B)组成 写的问题：直写，写回，写分配 i-cache和d-cache 高速缓存性能指标：不命中率(miss rate)，命中率(hit rate)，命中时间(hit time)，不命中出发(miss penalty) 块：固定大小，cache与主存之间传送 行：cache的一个存储单元？ 组：一个或者多个含的集合 编写高速缓存友好代码：对局部变量反复引用；步长为1的引用模式\n高速缓存与程序性能一个程序从存储系统中读数据的速率称为读呑吐量(read throughput) 或者有时称为读带宽(read bandwidth) 利用时间局部性，使得频繁使用的字从 L1 中取出，还要利用空.间局部性，使得尽可能多的字从一个L1 高速缓存行中访问到\n存储器层次结构对程序编写指导：\n注意力集中在内循环上 按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大 从存睹器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大 基本存储技术包括随机存储器(RAM)、非易失性存储器（ROM)和磁盘。RAM 有两种基本类型。静态RAM(SRAM)快一些，用做 CPU 芯片上的髙速缓存，也可以用做芯片下的高速缓存；动态 RAM(DRAM)慢一点，用做主存和图形帧缓冲区；在关电的时候,ROM 也能保持它们的信息； 随机存取存储器（RAM)和只读存储器(ROM) 及磁盘和固态硬盘 时间局部性和空间局部性来提高应用程序的性能\n在系统上运行程序 第7章 链接 链接可以执行于编译时,也可以在源代码翻译成机器代码时；也可以执行于加载时(dynamorio中的链接在执行时)，即程序被加载器加载到内存并执行时；也可以执行与运行时。静态链接和加载时的共享库动态链接，运行时共享库动态链接\n# 编译 gcc -Og -o prog main.c sum.c # 预处理 cpp [可选] main.c main.i # 编译 ccl main.i -Og [可选] -o main.s # 汇编 \u0026gt;\u0026gt;可重定位目标文件 as [] -o main.o main.s # 链接 \u0026gt;\u0026gt;可执行目标文件 ld -o prog [] main.o sum.o # 执行 ./prog 7.1 静态链接 链接器生成可执行文件两个过程：\n符号解析 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 目标文件三种形式：\n可重定位目标文件：包含二进制代码和数据 可执行目标文件：包含二进制代码和数据，可直接复制到内存并执行 共享目标文件：特殊可重定位目标文件，可在加载或运行时被动态地加载进内存并链接 Unix a.out格式，windows可移植可执行(PE)格式，linux 可执行可链接格式(ELF) 可重定位目标文件 ELF头(ELF header)以一个16字节的序列开始,描述生成该文件的系统的字的大小和字节顺序;帮助链接器语法分析和解释目标文件的信息，包括ELF头大小、目标文件类型(可重定位、可执行或共享的)、机器类型、节头部表的文件便宜，节头部表中条目的大小和数量。 夹在 ELF 头和节头部表之间的都是节 ELF可重定位目标文件包含的节：\n.text : 编译程序的机器代码 .rodata: 只读数据，格式串和开关语句的跳转表 .data: 已初始化的全局和静态 C 变量 .bss : 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .rel.text: 一个.text 节中位置的列表 .rel.data： 被模块引用或定义的所有全局变量的重定位信息 .debug：调试符号表，其条目是程序中定义的局部变量和类型定义 .line： 调试符号表，其条目是程序中定义的局部变量和类型定义 LINE .strtab: 字符串表 符号表：全局符号，外部符号和局部符号 符号表是由汇编器构造的，使用编译器输出到汇编语言.s 文件中的符号。.symtab节中包含ELF符号表。 有三个特殊的伪节（pseudosection), 它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号；UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配位置的未初始化的数据目标 符号解析：连接器解析符号\n编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，Linux 链接器来处理多重定义的符号名规则 编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library) 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以过在命令行上指定单独的文件名字来使用这些在库中定义的函数\n# 创建静态库 gcc -c addvec.c multvec.c # AR工具 ar rcs libvector.a addvex.op multvec.o # 使用静态库，包含头文件 gcc -c main2.c gcc -static -o prog2c main2.o ./libvector.a # 等价 gcc -c main2.c gcc --static -o prog2c main2.o -L. -lvector 7.2 重定位 重定位由两步组成： 重定位节和符号定义：合并节为聚合节，为聚会节赋运行时内存地址，为符号赋地址 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址 重定位条目 汇编时汇编器不知道外部函数或全局变量的位置，未知目标引用即为重定位条目，代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中 ELF 定义了 32 种不同的重定位类型,两种最基本的 重定货类型：\nR_X86_64_PC32 重定位一个使用32位PC相对地址的引用 R_X86_64_32 重定位一个使用32位绝对地址的引用 重定位PC相对引用 重定位绝对引用\n7.3 可执行目标文件 ELF 头描述文件的总体格式。它还包括程序的入口点（entry point), 也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和.data 节与可重定位目标文件中的节是相似的，init 节定义了一个小函数，叫做_init， 程序的初始化代码会调用它 可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系\n加载可执行目标文件\n./prog shell 认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。linux程序可通过调用execve函数来调用加载器，加载器加可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。\n在 Linux X86-64系统中，代码段总是从地址 0x400加0 处开始，后面是数据段,运行时堆在数据段之后，通过调用 malloc 库往上增长。后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址(2^48 —1)开始，向较小内存地址增长。栈上的区域，从地址 2^48 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分\n加载器运行时在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。加载器跳转到程序的入口点，即_start函数的地址，这个函数是在系统目标文件 Ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核 父进程创建一个fork子进程，子进程通过execve系统调用启动加载器，加载器删除子进程现有的 虚拟内存段，并创建一组新的代码、数 据、堆和栈段。\n7.4 动态链接共享库 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking), 是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在 Linux 系统中通常用 .so后缀来表示,windows中用DLL\n# -fpic 编译器生成与位置无关代码 gcc -shared -fpic -o libvector.so addvec.c multvec.c 动态链接器通过执行重定位完成链接任务 Linux 系统动态链接器接口\n#include\u0026lt;dlfcn.h\u0026gt; void *dlopen(const char *filename, int flag); // dlsym 函数的输人是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字,如果该符号存在，就返回符号的地址，否则返回 NULL void *dlsym(void *handle, char *symbol); int dlclose(void *handle); const char *dlerror(void); 可加载而无需重定位的代码称为位置无关代码(PIC) 数据段与代码段的距离总是保持不变,数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT) 延迟绑定(lazy binding), 将过程地址的绑定推迟到第一次调用该过程时。过程链接表(Procedure Linkage Table, PLT)\nLinux 链接器支持库打桩(library interpositioning), 允许截获对共享库函数的调用，取而代之执行自己的代码。打桩可以发生在编译时、链接时或当程序被加载和执行的运行时\n# 编译时打桩 gcc -DCOMPILETIME -c mymalloc.c gcc -I. -o intc int.c mymalloc.o # 链接时打桩 gcc -DLINKTIME -c mymallo.c gcc -c int.c gcc -Wl, --wrap, malloc -Wl, --wrap, free -o initl int.o mymalloc.o # 运行时打桩 gcc -DRUNTIME -shared -fpic ~o mymalloc.so mymalloc.c -ldl 处理目标文件的工具,GNUbinutils 包\nAR 创建静态库，查人、删除、列出和提取成员 STRINGS 列出一个目标文件中所有可打印的字符串。 STRIP 从目标文件中删除符号表信息 NM 列出目标文件的符号表中定义的符号 SIZE 列出目标文件中节的名字和大小 READELF 显示目标文件的完整结构，ELF头信息 OBJDUMP 所有二进制工具，反汇编 LDD 可执行文件在运行时所需要的共享库 静态和动态链接, 可重定位的、可执行的和共享的 可重定位的和可执行的目标文件、符号解析、重定位、静态库、 共享目标库、 位置无关代码，以及库打桩 链接器的两个主要任务是符号解析和重定位 链接器生成的目标文件是与一些像加载、虚拟内存和内存映射 加载器将可执行文件的内容映射到内存，并运行这个程序\n第8章 异常控制流ECF 8.1 异常 ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制 应用程序与操作系统交换通过陷阱(trap)或系统(system call)的ECF形式 异常处理通过非本地跳转响应错误，C通过setjmp和longjmph函数 状态变化称为事件(event),处理器检测到事件发生，通过异常表(存储异常号)的跳转表，进行间接过程调用，跳转到操作系统子程序(异常处理程序(exception handler))。异常表的起始地地址放在叫做异常表基址寄存器(exception table base register)的特殊CPU寄存器 异常不同于调用：调用返回地址压入栈，异常返回地址位当前指令或下一条指令；额外压入处理器状态到栈；如控制转移到内核，则压入内核栈；异常程序运行在内核模式 异常分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort) 陷阱用在用户程序和内核之间的系统调用，用户程序向内核请求服务，如读文件(read)、创建进程(fork)、加载程序(execve)和终止进程(exit)等，syscall n 指令 故障示例缺页异常 linux/x85-64异常 C程序用 syscall 函数可以直接调用任何系统调用，通常通过包装函数(系统级函数)使用 寄存 %rax 包含系统调用号,寄存器%rdi，%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。 8.2 进程 进程一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文(context)中 PC值的序列叫逻辑控制流，一个逻辑流在时间上与另一个流重叠，称为并发流，并发运行 并发多个流并发执行；多任务进程轮流运行；时间片\n进程私有地址空间\n代码段总是从地址 0x400000 开始,地址空间顶部保留给内核(操作系统常驻内存的部分)\n处理器通常是用某个控制寄存器中的一个模式位(mode bit)来确定用户模式和内核模式 linux系统提供 /proc 文件系统，允许用户模式进程访问内核数据结构的内容\n上下文切换(context swtich):通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构\n内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling), 是由内核中称为调度器(scheduler)的代码处理的\n系统调用错误处理Unix 系统级函数遇到错误时,返回-1，设置全局整数变量errno\n8.3 进程控制 获取进程ID\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; pid_t getpid(void); pit_t getppid(void); 进程三种状态\n运行：在 CPU 上执行；或等待被执行且最终会被内核调度 停止：进程的执行被挂起（suspended), 且不会被调度。收到SIGSTOP、SIGTSTP、SIGYTTIN或SIGTTOU信号，进程停止，直到收到SIGCONT信号，再次运行 终止：进程会因为三种原因终止：1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用 exit 函数 #include \u0026lt;stdlib.h\u0026gt; // 以status退出状态终止进程 void exit(int status) #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 创建进程 调用一次返回两次在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0 pid_t fork(void); 回收子进程；内核将子进程的退出状态传递给父进程;如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父.init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; // waitpid 函数来等待它的子进程终止或者停止 pid_t waitpid(pid_t pid, int *statusp, int options); options 设置为常量 WNOHANG、WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为\n#include\u0026lt;unistd.h\u0026gt; // 进程休眠secs秒 unsigned int sleep(unsigned int secs); // 让调用函数休眠 int pause(void); // 加载并运行一个新程序 和fork的区别 ？ int execve(const char *filename, const char *argv[], const char *envp[]); main函数有3个参数：1）argc argv[]数组中非空指针数量 2)argv 指向argv[]数组第一个条目 3) envp 指向envp[]数组中第一个条目\n#include \u0026lt;stdlib.h\u0026gt; char *getenv(const char *name); int setenv(const char *name, const char *newvalue, int overwrite); void unsetenv(const char *name); 8.4 信号 发送信号 每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp函数返回当前进程的进程组 ID:\n#include\u0026lt;unistd.h\u0026gt; pid_t getpgrp(void); // 改变进程所属进程组 int setpgid(pid_t pid, pid_t pgid); /bin/kill 程序向另外i的进程发送任意信号\n# 15213 进程组 /bin/kill -9 -15213 #include\u0026lt;sys/typed.h\u0026gt; #include\u0026lt;signal.h\u0026gt; //调用 kill 函数发送信号给其他进程 int kill(pid_t pid, int sig); #include\u0026lt;unistd.h\u0026gt; // 调用 alarm 函数向它自己发送 SIGALRM 信号 unsigned int alarm(unsigned int secs); 接收信号\n#include\u0026lt;signale.h\u0026gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); Linux 提供阻塞信号的隐式和显式的机制：\n隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。 显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。\n#include\u0026lt;signal.h\u0026gt; int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signum); int sigdelset(sigset_t *set, int signum); int sigismember(const sigset_t *set, int signum); 信号处理程序中产生输出唯一安全的方法是使用 write 函数, printf和spirintf是不安全的\n8.5 非本地跳转 C 语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump)，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列\n#include\u0026lt;setjmp.h\u0026gt; // setjmp 函数在 env 缓冲区中保存当前调用环境 int setjmp(jmp_buf env); int sigsetjmp(sigjmp_buf env, int savesigs); // longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化的 setjmp 调用的返回 void longjmp(jmp_buf env, int retval); void siglongjmp(sigjmp_buf env, int retval); 操作进程工具：\nstrace 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹 ps 列出当前系统中的进程 top 打印出关于当前进程资源使用的信息 pmap 显示进程的内存映射 /proc 虚拟文件系统，输出大量内核数据结构的内容 如：cat /proc/loadavg 异常控制流 系统所有层次的异常控制流 底层的硬件异常和中断 四种异常：中断、陷阱、故障和终止 在操作系统层，内核用 ECF 提供进程的基本概念。 并发进程的上下文切换 进程的基本概念 通过 Linux 系统调用来使用多个进程\n第9章 虚拟内存 虚拟内存提供了三个重要的能力:1)主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域; 2)为每个进程提供了一致的地址空间; 3)保护了每个进程的地址空间不被其他进程破坏 虚拟内存如何工作;使用和管理虚拟内存\n物理地址(PA)和虚拟地址(VA) MMU内存管理单元：地址翻译\n9.1 虚拟内存作为缓存工具 虚拟页面三个状态：未分配的；缓存的；位缓存的 DRAM缓存 页表(page table)，页表将虚拟页映射到物理页；页表是页表条目(Page Table Entry PTE)的数组\n页命中 缺页 DRAM缓存不命中，缺页异常\n磁盘和内存之间传送也叫做交换或页面调度；按需页面调度策略:直到不命中才换入页面\n分配页面 VP分配过程是在磁盘上创建空间并更新PTE，指向磁盘上新创建的页面 局部性保证了程序趋于较小的活动页面上\n9.2 虚拟内存作为内存管理工具 进程页表独立\n简化链接：进程内存映射采用相同的基本格式，linux64中代码段总是从虚拟地址0x400000开始 简化加载：.text和.data节linux加载器分配虚拟页，标记位无效的，加载不从磁盘复制数据，内存映射(memory mapping)：将一组连续虚拟也映射到任意一个文件中的任意位置表示 linux系统调用mmap，应用程序可做内存映射。 简化共享： 简化内存分配：页表方式可分配不连续物理空间 9.3 虚拟内存作为内存保护工具 PTE三个许可标志位：\nSUP 进程是否必须运行在内核(超级用户)模式下才能访问该页 READ 位和 WRITE 位控制对页面的读和写访问 9.4 地址翻译 TLB加速地址翻译： MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器(Translation Lookaside Buffer, TLB) TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块 多级页表 Core i7内存系统\nLinux 虚拟内存系统 内核为系统中的每个进程维护一个单独的任务结构(源代码中的 task_StrUCt),任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行目标文件的 名字，以及程序计数器) Linux 缺页异常处理 MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序\n9.5 内存映射 Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)\nfork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID, 给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的副本\n删除已存在的用户区域、映射私有区域、映射共享区域、设置程序计数器(PC)\nmmap 函数的用户级内存映射\n#include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/mman.h\u0026gt; // Linux 进程使用 mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); // munmap 函数删除虚拟内存的区域 // munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域 int munmap(void *start, size_t length); 9.6 动态内存分配 mmap 和 munmap 函数来创建和删除虚拟内存的区域，C语言使用动态内存分配器，动态内存分配器维护着一个进程的虚拟内存区 域，称为堆(heap),每个进程，内核维护着一个变量 brk(读break) 它指向堆的顶部。\n显示分配器：c语言malloc free；C++中new和delete 隐式分配器：垃圾收集器GC，Java #include\u0026lt;stdio.h\u0026gt; // malloc 函数从堆中分配块 void *malloc(size_t size); void free(void *ptr); // malloc 可通过使用 mmap 和 munmap 函数，显式地分配和释放堆内存，或者还可以使用 sbrk 函数 #include\u0026lt;unistd.h\u0026gt; void *sbrk(intptr_t incr); 动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小\n管理和操纵虚拟内存 存储分配操作，标准库的 malloc 和 free 操作 存储泄漏和非法指针引用等内存引用错误\n程序间的交互和通信 第10章 系统级 1/() 10.1 输入/输出(I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程 Unix I/O和标准I/O Unix I/O：打开文件、改变单位文件位置、读写文件和关闭文件。 Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准输出(描述符为 1)和标准错误(描述符为 2) Linux 文件: 普通文件、目录、套接字\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/sttat.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; // flags O_RDONYL 只读 O_WRONLY 只写 O_RDWR 可读可写 int open(char *filename, int flags, mode_t mode); #include \u0026lt;unistd.h\u0026gt; // 关闭文件 int close(int fd) #include\u0026lt;unistd.h\u0026gt; // 读写文件 ssize_t read(int fd, void *buf, size_t n); ssize_t write(int fd, const void *buf, size_t n); RIO健壮读写包 https://blog.csdn.net/df12138/article/details/122272107\n读取文件元数据\n#include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/stat.h\u0026gt; int stat(const char *filename, struct stat *buf); int fstat(int fd, struct stat *buf); 读取目录内容\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;dirent.h\u0026gt; DIR *opendir(const char *name); struct dirent *readdir(DIR *dirp); int closedir(DIR *dirp); 共享文件\n描述符表：每个进程有独立描述符表 文件表：所有进程共享 v-node表：所有进程共享 10.2 I/O 重定向 linux\u0026gt; ls \u0026gt; foo.txt #include\u0026lt;unistd.h\u0026gt; int dup2(int oldfd, int newfd); 10.3 标准I/O C语言libc库提供了打开和关闭文件的函数(fopen 和 fclose)、读和写字节的函数(fread 和 fwrite)、读和写字符串的函数(fgets 和 fputs)以及复杂的格式化的 I/O 函数(scanf 和 printf) 标准 I/O 库将一个打开的文件模型化为一个流,一个流就是一个指向 FILE 类型的结构的指针,有三个打开的流 stdin、stdout和 stderr分别对应于标准输人、标准输出和标准错误\nUnix VO 的基本概念 文件和描述符 共享文件，1/O重定向 访问文件的元数据 C 的标准 I/O 库 Linux 内核使用三个相关的数据结构来表示打开的文件 描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项，每个进程都有它自己单独的描述符表，而所有的进程共享同一个打开文件表和 v-node 表 第11章 网络编程 11.1 客户端-服务器 客户端-服务器(CS)模型中的基本操作是事务(transaction) 网络是一种I/O设备， 局域网(LAN)、以太网 IP地址是32位无符号整数\n// IP address struct struc in_addr { uint32_t s_addr; } // 网络字节序是大端字节序 #include\u0026lt;arpa/int.h\u0026gt; uint32_t htonl(unit32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint_16_t netshort); 11.2 因特网 域名 DNS域名集合和 IP 地址集合之间的映射\nnslookup localhost hostname nslookup cs.mit.edu 因特网客户端和服务器通过在连接上发送和接收字节流来通信,客户端套接字地址中的端口是由内核自动分配的 文件/etc/services 包含机器提供的知名名字和知名端口之间的映射 套接字对(socket pair) :—个连接是由它两端的套接字地址唯一确定\n(cliaddr:cliport, servaddr:servport) 11.3 套接字接口 套接字接口(socket interface)是一组函数，和 Unix I/O 函数结合起来，用以创建网络应用 套接字地址结构\nstruct sockaddr_int { uint16_t sin_family; // Protocol family (always AF_INET) uint16_t sin_port; // Port number in network byte order struct in_addr sin_addr; // IP address in network byte order unsigned char sin_zero[8]；// Pad to sizeof(struct sockaddr) } struct sockaddr { uint16_t sa_famliy; // Protocol family char sa_data[14]; // Address data } #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; int socket(int domain, int type, int protocol); int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen); int bind(int sockfd const struct sockaddr *addr, socklen_t addrlen); int listen(int sockfd, int backlog); int accept(int listenfd, struct sockaddr *addr, int *addrlen); getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构 getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串\n11.3 Web服务器 HTTP、HTML\nTINY Web 服务器\n网络是 I/O 设备 客户端-服务器模型 第12章 并发编程 逻辑控制流在时间上重叠称为并发。使用应用级并发的应用程序称为并发程序(concurrent program)。现代操作系统提供 了三种基本的构造并发程序：\n进程：每个逻辑控制流都是一个进程，由内核来调度和维护。进 程有独立的虚拟地址空间。进程间通信(interprocess communication IPC) I/O 多路复用:逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态 线程：线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度 12.1 基于进程的并发编程 创建进程fork、exec和waitpid。并发服务器的法，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。 进程模型：共享文件表，不共享用户地址空间。独立的地址空间使得显式的 IPC(进程间通信)机制。Unix IPC同一台主机上其他进程进行通信的技术，包括管道、先进先出(FIFO)、系统 V 共享内存，以及系统 V 信号量(semaphore)\n12.2 基于I/O多路复用的并发编程 I/O 多路复用(I/O multiplexing)技术,基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序\n#include \u0026lt;sys/select,h\u0026gt; int select(int n, fd_set *fdset, NULL, NULL, NULL); FD_ZERO(fd_set *fdset); /* Clear all bits in fdset */ FD_CLR(int fd, fd.set *fdset); /* Clear bit fd in fdset */ FD_SET(int fd, fd_set *fdset); /* Turn on bit fd in fdset */ FD_ISSET(int fd, fd_set *fdset); /* Is bit fd in fdset on? */ I/O 多路复用可以用做并发事件驱动(event-driven)程序的基础，在事件驱动程序中，某些事件会导致流向前推进。将逻辑流模型化为状态机。一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移是将状态和输人事件映射到状态。每个转移是将一个（输人状态，输人事件）对映 射到一个输出状态。\n12.3 基于线程的并发编程 第一种方法中，为每个流使用单独的进程。内核会自动调度每个进程，而每个进程有它自己的私有地址空间，使得流共享数据很困难。第二种方法中，创建自己的逻辑流，并利用 I/O 多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间 第三种方法：线程(thread)就是运行在进程上下文中的逻辑流.一个进程里同时运行多个线程的程序。线程由内核自动调度。每个线程都有它自己的线程上下文(thread context), 包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。\n每个进程开始生命周期时都是单一线程，这个线程称为主线程(main thread)在某一时刻，主线程创建一个对等线程(peer thread)。线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止\nPosix 线程(Pthreads)是在 C 程序中处理线程的一个标准接口。\n#include\u0026lt;pthread.h\u0026gt; // 创建线程 typedef void *(func)(void*) int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg); // 获线程 ID pthread_t pthread_self(void); // 终止线程 void pthread_exit(void *thread_return); // 终止当前线程 int pthread_cancel(pthread_t tid); // 回收终止线程资源 int pthread_join(pthread_t tid, void **thread_return); // 分离线程 int pthread_detach(pthread_t tid); // 初始化线程 pthread_once_t once_control = PTHREAD_ONCE_INIT; int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); 12.4 多线程程序中的共享变量 线程共享相同的程序变量。一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。寄存器是从不共享的，而虚拟内存总是共享的。 多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：全局变量、本地自动变量、本地静态变量。 用信号量同步线程:信号量 s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V:\n12.5 并发问题 线程安全：函数被称为线程安全的(thread-safe), 当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果\n三种编写并发程序的基本机制（进程、 1/()多路复用和线程） 用 P、 V 信号量操作来实现同步、线程安全和可重人、竞争条件以及死锁等的基本原则\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e[toc]\u003c/p\u003e\n\u003ch1 id=\"深入理解计算机系统\"\u003e深入理解计算机系统\u003c/h1\u003e\n\u003ch2 id=\"第1章-计算机系统\"\u003e第1章 计算机系统\u003c/h2\u003e","title":"深入理解计算机系统"},{"content":"1.cmake简述 CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\nCMake工程简单例子\ncmake_minimum_required(VERSION 3.12) project(myproj) find_package(Poco REQUIRED COMPONENTS Net Util) add_executable(MyExe) target_source(MyExe PRIVATE \u0026#34;main.cpp\u0026#34;) target_link_library(MyExe PRIVATE Poco::Net PocoUtil) target_complie_definition(MyExe PRIVATE std_cxx_14) 2.Target 和围绕 Target 的配置 C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为target，创建命令分别是add_library()和add_executable()。其中链接库的类型又分为很多种，最常用的就是SHARED以及STATIC，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。 指定target的源文件：\ntarget_source(MyLib PRVIATE \u0026#34;main.cpp\u0026#34; \u0026#34;func.cpp\u0026#34;) PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值\n较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) 命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：\ntarget_source(MyLib PRIVATE ${SRCS}) 配置target时通常还需要指定头文件目录：\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/) 编译时需要的语言特性：\ntarget_compile_features(MyLib PRIVATE std_cxx_14) 编译时的宏定义：\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3) 参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra) 3.Build Specification 和 Usage Requirement C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库 CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。\n一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：\ntarget_compile_features(MyLib PRIVATE cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：\ntarget_compile_features(MyLib PUBLIC cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) 当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可\narget_compile_features(MyLib INTERFACE cxx_std_14) Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，\n4.寻找和使用链接库 C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。 在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。\n4.1 通过 Config file 找到依赖 Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement\nCMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。\n4.2 通过 Find file 找到依赖 对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。\nCMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。 库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake) ${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。 通过 CMake 的find_library和find_path两个命令就可以完成任务：\nfind_library(MPI_LIBRARY NAMES mpi HINTS \u0026#34;${CMAKE_PREFIX_PATH}/lib\u0026#34; ${MPI_LIB_PATH} # 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值 ) find_path(MPI_INCLUDE_DIR NAMES mpi.h PATHS \u0026#34;${CMAKE_PREFIX_PATH}/include\u0026#34; ${MPI_INCLUDE_PATH} # 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值 ) 4.3.find_package 的处理 find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：\n# 要求大版本号为2的SFML库的graphic模块 find_package(SFML 2 COMPONENTS graphics REQUIRED) # SFML提供的target名字为sfml-graphics target_link_libraries(MyEXE PRIVATE sfml-graphics) 5.使用 CMake 来编译 CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：\ncmake --build . 使用\u0026ndash;buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。 对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：\ncmake --build . --config Release 参考链接: cmake https://ukabuer.me/blog/more-modern-cmake/ Makefile ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/cmake/","summary":"\u003ch2 id=\"1cmake简述\"\u003e1.cmake简述\u003c/h2\u003e\n\u003cp\u003e CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\u003c/p\u003e","title":"cmake"},{"content":"一.简单句子分析 英语句子= 主干+修饰成分 分析句子结构: 一个中心 + 两个要点 一个中心: 动词. 句子必须右动词 两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者. 句子的核心是主谓结构\nn个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。\n英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.\n{% pullquote mindmap mindmap-md %}\n英文句子 简单句 主 + 谓 主 + 谓 + 宾 主 + 谓 + 宾 + 宾补 主 + 谓 + 间宾 + 直宾 主 + 系 + 表 复合句 名词性从句 主语从句 宾语从句 同位语从句 表语从句 定语从句 状语从句 时间状语从句 地点状语从句 条件状语从句 结果状语从句 让步状语从句 目的状语从句 特殊句式 强调句 虚拟语气 倒装句 类型 陈述句 祈使句 感叹句 疑问句 {% endpullquote %}\n英语语法从整体上来讲是通过五部分来组成 1、简单句 2、并列句、复合句 3、三大从句 4、特殊句式 5、类型\n补语 补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。 修饰成分 介词短语 从句 非谓语动词 时间状语 论主语的补语，而后将宾语的补语作为一种变形来讨论\n1.1 S + V （主+谓） 句子不可或缺的两部分. 名词/代词/不定式/动名词 + 动词 谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.\n1.2 S + V + C （主+系+表） 主语 +系动词 +表语\n表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。\n系动词包括：\na. be 动词，am, is, are, was, were;\nb. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);\nc. 表变化：become(成为), grow, turn(转变为), go, get, fall;\nd. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).\nappear 显得像是 prove 证实为 become 成为 make 作为\n1.3 S + V + O （主+谓+宾） 主语+谓语+宾语\n谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。\n1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)） 谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。 e.g.,\ngive sb sth = give sth to sb\ntell sb sth = tell sth to sb\n1.5 S + V + O + C（主+谓+宾+宾补） 此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。 主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。\nThere be 句型\nThere be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分\n1.主语：句子所陈述的对象。 2.谓语：主语发出的动作。一般是有动作意义的动词。 3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。 4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。 5. 表语：紧跟系动词后面的成分。 6. 定语：修饰名词或代词的成分。 7. 状语： 修饰形容词、副词、动词或句子的成分。 8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。\n参考链接: https://liam.page/2014/06/21/basic-sentence-and-the-complement/ https://www.zhihu.com/question/30030877/answer/768501967\n参考数据 《语法俱乐部》\n复杂句:从简单句演化而来\n简单句没有什么句序的调整，所以翻译起来基本没有什么难度。\n英语中的修饰成分，分定语和状语两种情况。 英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)\n二、并列句、复合句 简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：\n并列句：简单句+并列词+简单句\n并列词一般有：and / or / but / so /while / yet / for / however\n1）：表示并列：and, not only\u0026hellip;but also\u0026hellip; , neither\u0026hellip;nor\u0026hellip;\nHer father is a doctor and her mother is a teacher .\n2）：表示选择：or, or else, otherwise, either\u0026hellip;or\u0026hellip;\nHurry or you won\u0026rsquo;t make the train.\n3）：表示对比、转折: but, while , yet , however , never ,\nI like tea while she likes coffee .\n4）：表示原因：for\nI am thirsty , for it is hot .\n复合句：简单句+从属连词+简单句\n从属连词有：that / wether/ if\n复合句其实就是我们常说的三大从句，\n三.三大从句 1、名词性从句\n当名词性从句作为句子的不同成分时，又被称呼为不同的名字。\n当作为主语时，称为主语从句。\n当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：\n主语从句 What she said is wrong .\n宾语从句 I said that she was wrong.\n表语从句 The fact is that he doesn’t really try.\n同位语从句 The news that he will come back is ture.\n记住一点，不管什么从句，你把它当成一个”长一点的名词”。\n那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。\n同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。\n2、定语从句\n修饰限定名词，汉语中“的”前面的内容。\n关系代词引导的定语从句\n1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.\n2. whom指人，在定语从句中充当宾语，常可省略。\nMr. Ling is just the boy whom I want to see\n3. which指物，在定语从句中做主语或者宾语，做宾语时可省略\nThis is the pen (which) he bought yesterday.\n4. that指人时，相当于who 或者whom；指物时，相当于which。\n5. whose通常指人，也可指物，在定语从句中做定语。\n指的是谁的。Do you like the book whose cover is yellow?\n关系副词引导的定语从句\nwhen where why\n3、状语从句\n修饰动作的发生的时间、地点、原因、方式\n九大状语从句\n1、时间状语从句\n常用引导词：when, as, while, as soon as, before, after, since , till, until\n特殊引导词：the minute, the moment, the second, every time, the day，the instant,\nI was fat when I was a child.\n2、地点状语从句\n常用引导词：where\n特殊引导词：wherever, anywhere, everywhere\nKeep it where you can see it.\n3、原因状语从句\n常用引导词：because, since, as, for\n特殊引导词：seeing that, now that, in that, considering that, given that.\nMy friends dislike me because I’m beautiful .\n4、目的状语从句\n常用引导词：so that, in order that\n特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that\nstudy hard so that you can pass the exam.\n5、结果状语从句\n常用引导词：so … that, so… that, such … that,\n特殊引导词：such that, to the degree that, to the extent that, to such a degree that,\nHe got up so early that he caught the first bus.\n6、条件状语从句\n常用引导词：if, unless,\n特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that\nIf you ask him, he will help you.\n7、方式状语从句\n常用引导词：as, as if, how\n特殊引导词：the way\nThink as i think\n8、比较状语从句\n常用引导词：as(同级比较), than(不同程度的比较)\n特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B\nThe house is three times as big as ours.\n9、让步状语从句\n常用引导词：though, although, even if, even though\n特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\nThough I believe it, yet I must consider.\n四.特殊句式 1、强调句\nIt is （名词 / 介宾）指的是被强调的内容that （\u0026hellip;\u0026hellip;..）\nIt was she whom we are talking about.\n2、倒装句\n正常句序 ：主谓宾\n倒装句序 ：谓主宾\nwe can win only through hard work .\nonly through hard work can we win .\n3、虚拟语气，假设不可能发生的事情\n1、对过去情况的虚拟\n从句用 had done\n主句用 would could might should have done\n2、对现在情况的虚拟\n从句用 did , was变成were\n主句用 would could might should do\n3、对将来情况虚拟\n从句用 did ，was 变成 were，should do,were to do\n主句用 would could might should do\n五.类型 陈述句\ni like English very much . 我非常喜欢英语。\n疑问句\nis this your key ? 这是你的钥匙吗？\n祈使句\n一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。\nmind you head 小心碰头！\n第二种祈使句以let开头\nLet\u0026rsquo;s have another try\n感叹句\nwhat a brave girl ! 真是个勇敢的女孩子\nhttps://zhuanlan.zhihu.com/p/400448345\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%B8%80/","summary":"\u003ch2 id=\"一简单句子分析\"\u003e一.简单句子分析\u003c/h2\u003e\n\u003cp\u003e \u003cstrong\u003e英语句子= 主干+修饰成分\u003c/strong\u003e\n 分析句子结构:\n  一个中心 + 两个要点\n  一个中心: 动词. 句子必须右动词\n  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.\n  \u003cstrong\u003e句子的核心是主谓结构\u003c/strong\u003e\u003c/p\u003e","title":"英语语法一"},{"content":"hugo运行 hugo -F --cleanDestinationDir # 本地预览 hugo server 参考链接：\nhttps://www.sulvblog.cn/\nhttps://www.jianshu.com/p/fa95c0c1fdab\nhttps://lishensuo.github.io/\nhttps://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612\nhttps://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38\nhttps://blog.csdn.net/qq_45975757/article/details/108923612\nmongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.6.7\u0026#34;} 托管 为了提高访问速度托管在gitee上，迁移完成后将会同时托管到github中。 通过不同分支保存源码和静态网页内容，用br_hugo管理源码，master分支管理public\nhexo # 清理缓存 hexo clean # 生成网页 hexo g # 启动本地服务端口 hexo s # 发布到github hexo d # 强制推送备份源码分支 git push -f origin backup GitHub Pages + Hexo使用及配置 github上创建一个 username.github.io 的工程，username 必须为github的用户名\n参考链接 https://www.jianshu.com/p/f82c76b90336\nhttps://www.jianshu.com/p/5d0b31032d55\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\nhttps://theme-next.org/\nhttps://hexo.io/zh-cn/docs/\nhttps://www.jianshu.com/p/3a05351a37dc\nhttps://www.zhyong.cn/posts/ca02/\nhttp://theme-next.iissnan.com/\nhttps://liam.page/\nhttps://liam.page/en/\n装饰 Hexo博客添加helper-live2d动态模型插件 https://blog.csdn.net/qq_30930805/article/details/\nemojiall 图标可嵌入博客中 https://www.emojiall.com/zh-hans/sub-categories/A15\n图床 vscode + PicGo + github\n# 快捷方式 # 上传剪贴板中的图片到服务器。 ctrl + alt + u # 打开文件浏览器选择图片上传。 ctrl + alt + e 参考链接： https://blog.csdn.net/qq_44314954/article/details/122951033 https://blog.csdn.net/qq_44314954/article/details/122951033 https://www.jianshu.com/p/868b3a2028f8 https://zhuanlan.zhihu.com/p/131584831\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/blog/","summary":"hugo运行 hugo -F --cleanDestinationDir # 本地预览 hugo server 参考链接： https://www.sulvblog.cn/ https://www.jianshu.com/p/fa95c0c1fdab https://lishensuo.github.io/ https://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612 https://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38 https://blog.csdn.net/qq_45975757/article/details/108923612 mongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#3","title":"hexo-\u003ehugo迁移"},{"content":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接： ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334\n安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239\n性能显示 bpytop 装X神器\nsudo apt-get install bpytop sudo snap install bpyto https://blog.csdn.net/ll837448792/article/details/123103212\nubuntu 显示 https://ubuntuqa.com/article/8837.html\nhttps://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html\nUbunut 22.04 LTS 版本 GNU/Linux核心\nGCC 11.2.0 binutils 2.38 glibc 2.35 编译工具链\nPython 3.10.4 Perl 5.34.0 LLVM 14 golang 1.18 rustc 1.58 OpenJDK Ruby 3.0 systemd 249.11 OpenSSL 3.0 虚拟化\nqemu 6.2.0 libvirt 8.0.0 virt-manager 4.0.0 Linux包管理 snap flameshot截图工具 # 快捷方式 # 个人习惯设置为 alt + AQ # -c 保存到粘贴板， -p 保存到路径 flameshot gui -c -p \u0026lt;path\u0026gt; https://www.cnblogs.com/kendoziyu/p/how_to_screenshot_in_ubuntu2004.html free get -O clash.gz https://github.com/Dreamacro/clash/releases/download/v1.11.8/clash-linux-amd64-v1.11.8.gz gzip -f clash.gz -d sudo chmod +x clash ./clash wget -U \u0026#34;Mozilla/6.0\u0026#34; -O ~/.config/clash/config.yaml https://to.runba.cyou/link/HR6FLUV7z8k7lNyx?clash=1 ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxtool/","summary":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接： ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334 安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239 性能显示 bpytop 装X神器 sudo apt-get install bpytop sudo snap install bpyto","title":"linuxTool"},{"content":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # shift + : 低行模式 wq # 保存退出 w! # 保存 !q # 放弃退出 gg # 回到文件首部 GG # 到文件尾部 / # 查找 p # 粘贴 x # 删除光标所在字符 nx # 删除光标所在处后n个字符 d # 删除一行 D # 删除光标到行尾 dG # 删除光标到文件尾 u # 撤销 yy # 复制当前行 dd # 剪切当前行 %s/old/new # 替换old字符为new 史上最全的vim快捷键 Vim使用笔记 Windows使用Vim 在Windows系统中，安装git后已经存在vim，找到vim.exe所在目录，添加到环境变量path中即可。 Windows下载 Vim安装 参考博客：在Windows下安装和使用vim PowerVim PowerVim快捷键 ;n # 打开文件目录树显示在屏幕左侧 ;m # 打开当前函数和变量目录树显示在屏幕右侧 ;w # 保存文件 ;u # 向上翻半屏 ;d # 向下翻半屏 ;1 # 光标快速移动到行首 ;2 # 光标快速移动到行末 ;a # 快速切换.h和cpp文件，写C++的时候很方便 ;e # 打开一个新文件 ;z # 切回shell交互命令，输入fg在切回vim，非常实用 ;s # 水平分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;v # 竖直分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;fw # 查找项目内关键字 ;ff # 查找项目内文件名 ;gt # 跳转到变量或者函数定义的地方，前提是安装ctags，并且在在PowerVim输入 ;tg命令 Jump to the definition of the keyword where the cursor is located, but make sure you have make ctags ;gr # 跳回，对应着;gt ;tg # 对当前目录打ctag ;y # 保存当前选中的目录到系统剪切板，前提是vim支持系统剪切板的寄存器 dsfa;w ;h/l/k/j # 光标向左右上下窗口移动，特别是打开多个窗口。使用这个快捷键组合非常实用 ;gg # 按顺序光标跳转各个窗口 # Shortcuts without ; e # 快速删除光标所在的词 tabc # 关闭当前tab，可以用:tabnew来打开一个新的tab Close tab, of course you should :tabnew a file first. F1 # 编译C++代码，自己写的C++例子的时候一键编译。前提手动在当前目录建一个bin文件夹，这是用来存放编译产生的执行文件 gc # 快速注释选中的块（是visual模式下选中的块） gcc # 快速当前行 { # 光标向上移动一个代码块s } # 光标向下移动一个代码块 PowerVim安装及配置 【VIM】PowerVim安装及使用\nPowerVim - 使Vim更加强大易用\n安装PowerVim 问题解决过程记录\nctags ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vim/","summary":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # shift + : 低行模式 wq # 保存退出 w! # 保存 !q # 放弃退出 gg # 回到文件首部 GG #","title":"vim"},{"content":"CMD命令 # 查询本机IP ipconfig # 向对方电脑发送消息 msg /server 192.168.1.100 * 消息 # 查看本机用户信息 net user # 查看共享资源 net share # 查看网站IP nsloopup www.baidu.com # 查看WiFi配置文件 netsh wlan show # 管道符，输出到文件 | 1.txt # windows 工具软件 Snipaste 截图软件 支持自定义设置快捷键 Download\nZoomIt 屏幕缩放、标记、录制 展示小工具 whois 居然可以在Windows使用 Download\nSysinternals 工具集 Download\neveryting 快速查找文件 Download\n7zip 开源压缩软件 Download\nWiztree 磁盘文件占用 Download\nWindows Terminal 取代传统cmd显示，可集成PowerShell， 登录wsl， 未来Windows将设置为默认终端 微软商店\ncmder 同事推荐，值得探索，Windows命令行工具 \\ Download github 配置\nPowerShell 一款shell，支持Windows、linux、mac，推荐Windows结合 Windows Terminal使用, 使Windows像Linux终端一样爽 Download\nwinget search Microsoft.PowerShell winget install Microsoft.PowerShell 参考链接：\nWindows Powershell和Windows Terminal的区别\n安装和设置 Windows 终端\nQ-Dir 多窗口资源管理器 Download\nFileZilla 多协议文件传送，支持FTP、SFTP，包含Client和Server，支持Windows、Linux、mac Download\n终端连接程序 secureCRT 需要破解 https://blog.csdn.net/qq_39052513/article/details/104692026\ngeek windows卸载工具，清理注册表，删除缓存文件，开箱即用 Download\nWindows包管理 Scoop Scoop 是 Windows 的命令行安装程序，是一个强大的包管理工具\n项目地址\n使用教程\nChocolatey choro Windows软件管理工具Chocolatey的安装和使用\nwinget 官方推出 谁用Windows 终端安装程序？ 我！\n# 使用 WinGet 安装一遍 winget install postman winget search postman # 卸载，再用 Scoop 安装一遍 scoop install postman vcpkg C/C++ 库管理工具，跨平台 Get started with vcpkg\ncget https://cget.readthedocs.io/en/latest/#\n开源库集成器Vcpkg全教程\nWSL 安装ubuntu20.04 安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe\n卸载wsl wslconfig /l # 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令 wslconfig /u Ubuntu 参考链接：WSL系列操作：安装，卸载\n设置wsl # 更改默认root用户登录 ubuntu1804.exe config --default-user root # 更改默认登陆目录 # list 中 Ubuntu-20.04 条目中添加 \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu-20.04\u0026#34; # 以管理员权限运行cmd # 停止 net stop LxssManager # 启动 net start LxssManager l rustdesk 远程开源软件，跨平台 https://github.com/rustdesk/rustdesk\nditto 粘贴板工具 https://ditto-cp.sourceforge.io/ https://github.com/sabrogden/Ditto\nbleachbit https://github.com/bleachbit/bleachbit https://www.bleachbit.org/\nqbittorrent https://github.com/qbittorrent/qBittorrent\nimagine gui 跨平台PNG和JPEG优化GUI工具 https://github.com/meowtec/Imagine\ncreentogif 动图捕获软件 录制屏幕上的指定区域 https://www.screentogif.com/\ngrammarly https://www.grammarly.com/\npotplayer https://iptv-org.github.io/iptv/index.m3u\nmaya 三维建模软件 Online 线上思维导图 https://gitmind.cn/app/template\n在线文档转换 https://www.aconvert.com/cn/\n开源软件下载网站 https://www.fosshub.com/#\n、\n剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键\nchrome插件 油猴\nwindows输入英文中间有间隙 进入了全角模式，选择半角即可\nReact Router http://react-guide.github.io/react-router-cn/index.html\nyoutube 下载 https://www.ganbey.com/youtube-download-3774\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/windowssoftware/","summary":"CMD命令 # 查询本机IP ipconfig # 向对方电脑发送消息 msg /server 192.168.1.100 * 消息 # 查看本机用户信息 net user # 查看共享资源 net share # 查看网站IP nsloopup www.baidu.com # 查看WiFi配置文件 netsh","title":"WindowsSoftware"},{"content":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04\nWindows\n镜像烧录工具 软碟通UltraISO 写入镜像，树莓派刷镜像\nVentoy 官方网站 Ventoy支持多个ISO镜像，开源，支持Linux和Windows ventoy详细使用教程 制作完启动盘，将ISO复制到U盘即可\nWinPE 支持多镜像 支持多镜像\n安装系统 小米 F2设置boot密码，重启F12安装Ubuntu\nThinkpad 1.关闭bitlocker 2.f1进入bios关闭security boot 3.f12进入boot，选择启动U盘\nQ\u0026amp;A 什么功能Windows上有，在Linux没有又没有替代方法 ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","summary":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04 Windows 镜像烧录工具 软碟通UltraISO 写入镜像，树莓派刷镜像 Ventoy 官方网站 Ventoy支持多个ISO镜像，开源，支持","title":"系统安装"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/movie/movie/","summary":"","title":"Movie"},{"content":" QMD 《如愿》-王菲 天后依然\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/music/music/","summary":"QMD 《如愿》-王菲 天后依然","title":"Music"},{"content":"软件故事 1946年 ENIAC\n批处理系统 硬件发展-》 分时系统 机器语言\u0026ndash;纸带 汇编语言\u0026ndash; 指令 操作 Fortran语言 - 第一种高级计算机语言 COBOL 语言 BASIC\n卡耐基 \u0026ndash; 人工智能\nIBM 701 704(Fortran商用) IBM OS/360\n存储时计算机\nUnix c 语言\n欧洲计算机技术： linux 芬兰 万维网 瑞典\nAPPLE II Macish\n微软 收购DOS\nwindows BASIC\n鼠标、 显示器\nC++\nJava Java与互联网\n阿帕奇 IBM linux\n硅谷百年 硅谷 斯坦福、伯克利、圣何塞大学\n特曼\n真空管、晶体管、集成电路 仙童半导体 - 八叛徒 英特尔、AMD、英伟达\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/computerbook/","summary":"\u003ch2 id=\"软件故事\"\u003e软件故事\u003c/h2\u003e\n\u003cp\u003e1946年 ENIAC\u003c/p\u003e\n\u003cp\u003e批处理系统\n硬件发展-》 分时系统\n机器语言\u0026ndash;纸带\n汇编语言\u0026ndash; 指令 操作\nFortran语言 - 第一种高级计算机语言\nCOBOL 语言\nBASIC\u003c/p\u003e","title":"computerbook"},{"content":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使\n《局外人》 加缪 个人主义，无知是最大的邪恶 《culture evolution》 文化的演进 ronald inglehart教授 什么原因猝发个人主义\n《结构性思维》\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/readingplan/","summary":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使 《局外人》 加缪 个人主义，无知是最大的邪恶 《cultur","title":"Reading Plan"},{"content":"豆豆三部曲 《背叛》 《遥远的救世主》 《天幕红尘》\n在细雨中呼唤 余华 普通农村少年以旁观者角度叙述自己的童年少年成长，世间人都处于一辆时光列车中，其中遇到的人和事，不管他们是好的还是坏的，未来的未知都无可逃避，唯一能做好的就是：好好活着，珍惜眼前的一切，做最好的自己。\n死亡不是失去生命，只是走出了时间\n通往奴役之路 如果我们仅仅只是一部无人性的机器中的一个齿轮，这也许不是好事情；但如果我们再也无法脱离它，被束缚在为我们选定的那些上级的身边，那么情况就不知道要糟糕多少倍。当每个人意识到他的命运的不满，就会同他的这种意识一起成长。\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/read/","summary":"豆豆三部曲 《背叛》 《遥远的救世主》 《天幕红尘》 在细雨中呼唤 余华 普通农村少年以旁观者角度叙述自己的童年少年成长，世间人都处于一辆时光列车中，其","title":"读书"},{"content":"第一个信号-中原-可防可治疗 2022.11.01\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/","summary":"第一个信号-中原-可防可治疗 2022.11.01","title":"闲言碎语"},{"content":"编译 注意wsl中需要root用户编译 https://dynamorio.org/page_building.html cmake \\ -DCMAKE_TOOLCHAIN_FILE=/mnt/e/code/dynamorio/make/toolchain-android=arm64.cmake \\ -DANDROID_TOOLCHAIN=/android_toolchain_using \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio cmake \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio 学习链接 DynamoRIO进阶指南 https://blog.csdn.net/oShuangYue12/article/details/109780166 ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/dynamorio/","summary":"\u003ch2 id=\"编译\"\u003e编译\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e注意wsl中需要root用户编译\n\u003ca href=\"https://dynamorio.org/page_building.html\"\u003ehttps://dynamorio.org/page_building.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_TOOLCHAIN_FILE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/mnt/e/code/dynamorio/make/toolchain-android\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003earm64.cmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DANDROID_TOOLCHAIN\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/android_toolchain_using \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"DynamoRIO"},{"content":"总结 leetcode基础题目 经典题目： 3.无重复字符的最长子串 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476. 617. 701. 938. 1089. 1207.\n1.两数之和 思路：两层遍历\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) { int i, j; int *ret = (int *)malloc(sizeof(int) * 2); for (i = 0; i \u0026lt; numsSize; i++) { int key = target - nums[i]; for (j = i + 1; j \u0026lt; numsSize; j++) { if (nums[j] == key) { ret[0] = i; ret[1] = j; } } } *returnSize = 2; return ret; } 2.两数相加 思路：两个链表，判断链表是否为空or，求和不为空链表节点值，第一次添加头节点，之后添加到尾节点，注意处理进位\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) { struct ListNode *head = NULL, *tail = NULL; int carry = 0; while (l1 || l2) { int n1 = l1 ? l1-\u0026gt;val : 0; int n2 = l2 ? l2-\u0026gt;val : 0; int sum = n1 + n2 + carry; if (!head) { head = tail = malloc(sizeof(struct ListNode)); tail-\u0026gt;val = sum % 10; tail-\u0026gt;next = NULL; } else { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = sum % 10; tail = tail-\u0026gt;next; tail-\u0026gt;next = NULL; } carry = sum / 10; if (l1) { l1 = l1-\u0026gt;next; } if (l2) { l2 = l2-\u0026gt;next; } } if (carry \u0026gt; 0) { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = carry; tail-\u0026gt;next-\u0026gt;next = NULL; } return head; } 3.无重复字符的最长子串 思路：双指针，前后快慢指针，table表标记字符是否出现过，right标记，left去除标记，求right-left最大值\nint lengthOfLongestSubstring(char * s){ int len = strlen(s); printf(\u0026#34;len = %d\\n\u0026#34;, len); int left = 0; int right = 0; char table[256] = {0}; int maxLen = 0; while (right \u0026lt; len) { printf(\u0026#34;%d \\t\u0026#34;, right); if (table[s[right]] == 0) { table[s[right]] = 1; right++; //} else if (table[s[right]] == 1) { } else { table[s[left]] = 0; left++; } maxLen = fmax(maxLen, right - left); } return maxLen; } 4.寻找两个正序数组的中位数 思路：每个数组各自索引，判断大小移动索引，最后判断是奇数还是偶数\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){ int sum = nums1Size + nums2Size; int *nums = (int *)malloc(sizeof(int) * sum); int i = 0, j = 0, k = 0; int half = sum / 2 + 1; while (k \u0026lt; half) { int n; if (i \u0026lt; nums1Size \u0026amp;\u0026amp; j \u0026lt; nums2Size) { n = (nums1[i] \u0026lt; nums2[j]) ? nums1[i++] : nums2[j++]; } else if (i \u0026lt; nums1Size) { n = nums1[i++]; } else if (j \u0026lt; nums2Size) { n = nums2[j++]; } nums[k++] = n; } if (sum % 2 == 0) { return (nums[k-1] + nums[k-2]) / 2.0; } else { return nums[k-1]; } } 6.Z 字形变换 思路：计算位置？\nchar * convert(char * s, int numRows){ uint16_t len = strlen(s); if (len \u0026lt; numRows) { numRows = len; } char* out = calloc(len + 1, sizeof(char)); if (numRows \u0026lt; 2) { memcpy(out, s, len + 1); return out; } uint16_t max = numRows - 1; uint16_t rr = 2 * max; uint16_t i = 0; uint16_t o = 0; uint16_t delta = 0; // first row while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } // middle rows for (uint16_t l = 1; l \u0026lt; max; l++) { i = l; delta = 2 * l; while (i \u0026lt; len) { out[o++] = s[i]; delta = rr - delta; i += delta; } } // last row i = max; while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } return out; } 7.整数反转 思路：(取余数)* 10，注意越界，INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7\nint reverse(int x){ int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev \u0026gt; INT_MAX / 10 || (rev == INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7)) return 0; if (rev \u0026lt; INT_MIN / 10 || (rev == INT_MIN / 10 \u0026amp;\u0026amp; pop \u0026lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } 8.字符串转换整数 (atoi) 思路：\nint myAtoi(char * s){ long flag = 1; long num = 0; //int singleRes=0; while(*s == \u0026#39; \u0026#39;) { s++; } if(*s==\u0026#39;-\u0026#39;) { flag=-1; s++; } else if (*s==\u0026#39;+\u0026#39;) { s++; flag=1; } while(*s!=\u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; (*s\u0026lt;=\u0026#39;9\u0026#39; \u0026amp;\u0026amp; *s\u0026gt;=\u0026#39;0\u0026#39;)) { if(num\u0026gt;INT_MAX/10 || (num==INT_MAX/10 \u0026amp;\u0026amp; *s\u0026gt;\u0026#39;7\u0026#39;)){//因为是从正数转化为负数，所以要都按正数溢出标准 if(flag==1) { return INT_MAX; } else { return INT_MIN; } } else { num=num*10+(*s-\u0026#39;0\u0026#39;); s++; } } if(flag==1) { return num; } else { return -num; } } int myAtoi(char * s){ int minusFlag = 0; int length = strlen(s); long int result = 0; char numberBuffer[11]; int counter = 0; while (s[counter] == \u0026#39; \u0026#39;) { counter++; } s = \u0026amp;s[counter]; counter = 0; for (int i = 0; i \u0026lt; length; i++) { if (i == 0) { if (s[0] == \u0026#39;-\u0026#39;) { minusFlag = 1; i++; } else if (s[0] == \u0026#39;+\u0026#39;) { i++; } } if (counter \u0026gt; 10) { if (minusFlag) { return __INT_MAX__ * -1 - 1; } else { return __INT_MAX__; } } if (s[i] \u0026lt; \u0026#39;0\u0026#39; || s[i] \u0026gt; \u0026#39;9\u0026#39;) { break; } if (counter == 0 \u0026amp;\u0026amp; s[i] == \u0026#39;0\u0026#39;) { continue; } numberBuffer[counter] = s[i]; counter++; } int i = 0; while (counter \u0026gt; 0) { if (minusFlag) { result -= (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } else { result += (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } i++; counter--; } if (result \u0026gt; __INT_MAX__) { return __INT_MAX__; } else if (result \u0026lt; __INT_MAX__ * -1 - 1) { return __INT_MAX__ * -1 - 1; } return result; } 9.回文数 思路：将每一位按序装入数组，遍历数组首尾是否相等 ; 递归\nbool isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int table[20] = {0}; int count = 0; while (x) { table[count++] = x % 10; x = x / 10; printf(\u0026#34;x = %d\\n\u0026#34;, x); } for (int i = 0; i \u0026lt; count / 2; i++) { if (table[i] != table[count - i - 1]) { return false; } } return true; } bool isPalindrome(int x){ if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } 11.盛最多水的容器 思路：双指针，头尾向中间\nint maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int maxNum = 0; while (left \u0026lt; right) { int hMax = fmin(height[left], height[right]); int tmp = hMax * (right - left); maxNum = fmax(maxNum, tmp); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return maxNum; } int maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int mArea = 0; while (left \u0026lt; right) { int h = fmin(height[left], height[right]); int m = h * (right - left); mArea = fmax(mArea, m); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return mArea; } int maxArea(int* height, int heightSize){ // Start with maximum container width int start = 0; int end = heightSize - 1; int res = 0; while (start \u0026lt; end) { // Calculate current area by taking minimum of two heights int currArea = (end - start) * fmin(height[start], height[end]); if (currArea \u0026gt; res) res = currArea; if (height[start] \u0026lt; height[end]) { start = start + 1; } else { end = end - 1; } } return res; } 12.整数转罗马数字 思路：\nconst int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; const char* symbols[] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; char* intToRoman(int num) { char* roman = malloc(sizeof(char) * 16); roman[0] = \u0026#39;\\0\u0026#39;; for (int i = 0; i \u0026lt; 13; i++) { while (num \u0026gt;= values[i]) { num -= values[i]; strcpy(roman + strlen(roman), symbols[i]); } if (num == 0) { break; } } return roman; } char *getOne(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;IX\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;VIII\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;VII\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;VI\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;V\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;IV\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;III\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;II\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;I\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getTen(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;XC\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;LXXX\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;LXX\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;LX\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;L\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;XL\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;XXX\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;XX\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;X\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getHundred(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;CM\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;DCCC\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;DCC\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;DC\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;D\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;CD\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;CCC\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;CC\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;C\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getThousand(char c) { switch (c) { case \u0026#39;3\u0026#39;: return \u0026#34;MMM\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;MM\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;M\u0026#34;; default: return NULL; } } char * intToRoman(int num){ int length; char number[5]; char *s = malloc(16 * sizeof(char)); sprintf(number, \u0026#34;%i\u0026#34;, num); length = strlen(number); switch (length) { case 4: sprintf(s, \u0026#34;%s%s%s%s\u0026#34;, getThousand(number[0]), getHundred(number[1]), getTen(number[2]), getOne(number[3])); break; case 3: sprintf(s, \u0026#34;%s%s%s\u0026#34;, getHundred(number[0]), getTen(number[1]), getOne(number[2])); break; case 2: sprintf(s, \u0026#34;%s%s\u0026#34;, getTen(number[0]), getOne(number[1])); break; case 1: s = getOne(number[0]); break; default: break; } return s; } 13.罗马数字转整数 思路：\nint romanToInt(char * s){ int romanToInt = 0; for (int i = 0; i \u0026lt; strlen(s); i++) { switch (s[i]) { case \u0026#39;I\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;V\u0026#39; || s[i + 1] == \u0026#39;X\u0026#39;) { romanToInt -= 1; break; } } romanToInt += 1; break; case \u0026#39;V\u0026#39;: romanToInt += 5; break; case \u0026#39;X\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;L\u0026#39; || s[i + 1] == \u0026#39;C\u0026#39;) { romanToInt -= 10; break; } } romanToInt += 10; break; case \u0026#39;L\u0026#39;: romanToInt += 50; break; case \u0026#39;C\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;D\u0026#39; || s[i + 1] == \u0026#39;M\u0026#39;) { romanToInt -= 100; break; } } romanToInt += 100; break; case \u0026#39;D\u0026#39;: romanToInt += 500; break; case \u0026#39;M\u0026#39;: romanToInt += 1000; break; default: break; } } return romanToInt; } 20.有效的括号 思路：配对判断\nbool isValid(char * s) { int i, k = 0, len = strlen(s); char *store = calloc(len, sizeof(char)); for (i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { switch (s[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;{\u0026#39;: case \u0026#39;[\u0026#39;: store[k++] = s[i]; break; case \u0026#39;)\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;(\u0026#39;) goto out; break; case \u0026#39;}\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;{\u0026#39;) goto out; break; case \u0026#39;]\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;[\u0026#39;) goto out; break; } } out: free(store); return s[i] == \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; k == 0; } 21.合并两个有序链表 思路：先添加头，然后判断 l1 != NULL \u0026amp;\u0026amp; l2 != NULL 添加谁\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode* head = NULL; struct ListNode* tmp = NULL; if (l1 == NULL) { return l2; } if (l2 == NULL) { return l1; } if (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { head = tmp = l1; l1 = l1-\u0026gt;next; } else { head = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) { tmp-\u0026gt;next = l1; } if (l2) { tmp-\u0026gt;next = l2; } return head; } return NULL; } struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode *list = NULL; struct ListNode *tmp = NULL; if (!l1) return l2; if (!l2) return l1; if (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { list = tmp = l1; l1 = l1-\u0026gt;next; } else { list = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) tmp-\u0026gt;next = l1; if (l2) tmp-\u0026gt;next = l2; return list; } return NULL; } /* if (!list1) return list2; if (!list2) return list1; if (list1-\u0026gt;val \u0026lt; list2-\u0026gt;val) { list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next, list2); return list1; } else { list2-\u0026gt;next = mergeTwoLists(list1, list2-\u0026gt;next); return list2; } */ 24.两两交换链表中的节点 思路：递归；借助节点\nstruct ListNode* swapPairs(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* first = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); first-\u0026gt;next = head; head = head-\u0026gt;next; return first; } struct ListNode* swapPairs(struct ListNode* head) { if (!head || !head-\u0026gt;next) return head; struct ListNode *tmp = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); tmp-\u0026gt;next = head; return tmp; } 26.删除有序数组中的重复项 思路：++\nint removeDuplicates(int* nums, int numsSize) { if(numsSize == 0) { return 0; } int fast = 1, low = 0; while (fast \u0026lt; numsSize) { if (nums[fast] != nums[low]) { nums[low + 1] = nums[fast]; low++; } fast++; } return low + 1; } int removeDuplicates(int* nums, int numsSize) { int count = 0, i; for (i = 1; i \u0026lt; numsSize; i++) { if (nums[i] == nums[i - 1]) count++; else nums[i - count] = nums[i]; } return numsSize - count; } 27.移除元素 思路：nums[start++] = nums[i];\nint removeElement(int* nums, int numsSize, int val){ int i, start = 0; for (i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != val) { nums[start++] = nums[i]; } } return start; } 28.实现 strStr() 思路：\nint strStr(char * haystack, char * needle){ int i = 0; int j = 0; int k = 0; int hlen = 0; int nlen = 0; if (needle == NULL || *needle == 0) return 0; if (haystack == NULL || *haystack == 0) return -1; hlen = strlen(haystack); nlen = strlen(needle); if (hlen \u0026lt; nlen) return -1; for (i = 0; i \u0026lt;= hlen - nlen; i++) { j = 0; if (haystack[i] != needle[j++]) continue; k = i + 1; for (; j \u0026lt; nlen; j++) { if (haystack[k] != needle[j]) { break; } else { k++; } } if (j == nlen) return i; } return -1; } 29.两数相除 思路：\nint divide(int dividend, int divisor) { int cnt = 0; int sign = 1; if ((dividend ^ divisor) \u0026lt; 0) { // 两数任意一个为负数 sign = -1; } if (divisor == INT_MIN) { // 除数边界值特殊处理 if (dividend == INT_MIN) { return 1; } else { return 0; } } if (dividend == INT_MIN) { // 被除数边界值特殊处理 if (divisor == -1) { return INT_MAX; } else if (divisor == 1) { return INT_MIN; } dividend += abs(divisor); // 先执行一次加操作，避免abs转换溢出 cnt++; } int a = abs(dividend); int b = abs(divisor); while (a \u0026gt;= b) { int c = 1; int s = b; // 需指数级快速逼近，以避免执行超时 while (s \u0026lt; (a \u0026gt;\u0026gt; 1)) { // 逼近至一半，同时避免溢出 s += s; c += c; } cnt += c; a -= s; } return (sign == -1) ? -cnt : cnt; } int divide(int dividend, int divisor){ int sign = 1; long int output = 0; if (dividend \u0026lt; 0) { sign *= -1; } else { dividend *= -1; } if (divisor \u0026lt; 0) { sign *= -1; } else { divisor *= -1; } while (dividend \u0026lt;= divisor) { long int tmp = 0; long int div = divisor; while (dividend \u0026lt;= div) { tmp += (tmp + 1); dividend -= div; div += div; } if (output \u0026gt;= INT_MAX) { if (sign == -1) { return INT_MIN; } else { return INT_MAX; } } output += tmp; } return output * sign; } 35.搜索插入位置 思路：\nint searchInsert(int* nums, int numsSize, int target) { int left = 0; int right = numsSize - 1; int mid; while (left \u0026lt;= right) { // mid = (right + left) / 2; mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return left; } int searchInsert(int* nums, int numsSize, int target) { int idx = numsSize - 1; if (numsSize \u0026gt; 0) { if (target \u0026gt; nums[idx]) { return numsSize; } return searchInsert(nums, numsSize - 1, target); } return 0; } 38.外观数列 思路：\nchar * countAndSay(int n) { char *p = (char *)malloc(5000); char *p1 = (char *)malloc(5000); p[0] = \u0026#39;1\u0026#39;; p[1] = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt; n; ++i) { int x = 0; for(int j = 0; p[j]; ++j) { int y = 1; //计数器 while (p[j+1] \u0026amp;\u0026amp; p[j] == p[j+1]) { ++y; ++j; } p1[x++] = y+48; p1[x++] = p[j]; } strcpy(p, p1); p[x] = \u0026#39;\\0\u0026#39;; } return p; } char * countAndSay(int n) { // Calculating the length of array double result = 1.0; for (int i = 0; i \u0026lt; n - 1; i++) { result *= 1.4; } int k, j, count, convert = (int)result; // Creating array with the length calculated above char *arr = malloc(convert + 4); arr[0] = \u0026#39;1\u0026#39;; arr[1] = \u0026#39;\\0\u0026#39;; for (int i = 2, length; i \u0026lt;= n; i++) { length = strlen(arr); char newArr[length * 2]; strcpy(newArr, arr); k = 0; j = 0; count = 1; while (newArr[j] != \u0026#39;\\0\u0026#39;) { if (newArr[j] == newArr[j + 1]) { count++; j++; } else { arr[k] = (48 + count); arr[k + 1] = newArr[j]; arr[k + 2] = \u0026#39;\\0\u0026#39;; j++; k += 2; count = 1; } } } return arr; } 53.最大子数组和 思路：累加，动态规划\nint maxcmp(int a, int b) { return a \u0026gt;= b ? a : b; } int maxSubArray(int* nums, int numsSize) { int maxSoFar = nums[0]; int maxEndingHere = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]); maxSoFar = maxcmp(maxSoFar, maxEndingHere); } return maxSoFar; } 66.加一 思路：判断是否发生进位，最后判断最高位是否进位\n// The returned array must be malloced, assume caller calls free(). int *plusOne(int *digits, int digitsSize, int *returnSize) { for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { if (digits[i] \u0026lt; 9) { digits[i]++; *returnSize = digitsSize; return digits; } else { digits[i] = 0; } } int* newdigit = (int *)malloc(sizeof(int) * (digitsSize + 1)); newdigit[0] = 1; for (int i = 1; i \u0026lt; (digitsSize + 1); i++) { newdigit[i] = digits[i-1]; } *returnSize = digitsSize + 1; return newdigit; } int* plusOne(int* digits, int digitsSize, int* returnSize) { *returnSize = digitsSize; digits[digitsSize - 1] += 1; int carry = digits[digitsSize - 1] / 10; for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { digits[i] = (carry + digits[i]) % 10; int t = carry; carry = (carry + digits[i]) / 10; printf(\u0026#34;carry = %d\\n\u0026#34;, carry); } if (carry == 1) { *returnSize = digitsSize + 1; int *res = malloc(sizeof(int) * (*returnSize)); res[0] = 1; for (int i = 0; i \u0026lt; digitsSize; i++) { res[i+1] = digits[i]; } return res; } return digits; } 82.删除排序链表中的重复元素 II 思路：递归，判断是否和下一个链表值相等\nstruct ListNode* deleteDuplicates(struct ListNode* head) { /* if (head == NULL) { return NULL; } if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; */ if (head == NULL) return NULL; if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { /* Remove all duplicate numbers */ while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; } 83.删除排序链表中的重复元素 思路：判断相等，next = next-\u0026gt;next\n/* struct ListNode* deleteDuplicates(struct ListNode* head){ if (head == NULL) { return NULL; } int table[201] = {0}; struct ListNode* cur = head; table[cur-\u0026gt;val + 100] = 1; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next) { if (table[cur-\u0026gt;next-\u0026gt;val + 100] == 1) { if (cur-\u0026gt;next-\u0026gt;next != NULL) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; continue; } else { cur-\u0026gt;next = NULL; break; } } else { table[cur-\u0026gt;next-\u0026gt;val + 100] = 1; } cur = cur-\u0026gt;next; } return head; } */ struct ListNode* deleteDuplicates(struct ListNode* head) { struct ListNode* cur = head; while (cur \u0026amp;\u0026amp; cur-\u0026gt;next) { if (cur-\u0026gt;val == cur-\u0026gt;next-\u0026gt;val) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; } else { cur = cur-\u0026gt;next; } } return head; } /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* deleteDuplicates(struct ListNode* head) { if (head == NULL) { return NULL; } else { struct ListNode* s = head; struct ListNode* t = head-\u0026gt;next; while (t != NULL) { if (s-\u0026gt;val == t-\u0026gt;val) { struct ListNode* y; y=s-\u0026gt;next; s-\u0026gt;next=t-\u0026gt;next; t=y-\u0026gt;next; free(y); } else { s=s-\u0026gt;next; t=t-\u0026gt;next; } } } return head; } 84.柱状图中最大的矩形 思路：单调栈？\nint largestRectangleArea(int* heights, int heightsSize){ /* int *data = (int*)malloc(sizeof(int) * (heightsSize + 2)); int *stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); //给heights前后+0，成新数组data data[0] = 0; for (int i = 1; i \u0026lt;= heightsSize; i++) { data[i] = heights[i - 1]; } data[heightsSize + 1] = 0; int j = 0, area = 0; stack[j] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; data[stack[j]] \u0026gt;= data[i]) { int sidx = stack[j - 1]; int h = data[stack[j]]; //area = fmax(area, data[stack[top]] * (i - stack[top - 1] - 1)); area = fmax(area, h * (i - sidx - 1)); j--; } stack[++j] = i; } return area; */ int* stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); int* nheights = (int*)malloc(sizeof(int) * (heightsSize + 2)); for (int i = 0; i \u0026lt; heightsSize; i++) { nheights[i+1] = heights[i]; } nheights[0] = 0; nheights[heightsSize + 1] = 0; int maxArea = 0; int top = 0; stack[top] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (top \u0026gt; 0 \u0026amp;\u0026amp; nheights[stack[top]] \u0026gt;= nheights[i]) { int h = nheights[stack[top]]; int s = stack[top - 1]; int area = nheights[stack[top]] * (i - s -1); maxArea = fmax(maxArea, area); top--; } top++; stack[top] = i; } return maxArea; } void showIntArr(const char *brief, int *arr, uint32_t nums) { printf(\u0026#34;%s:\u0026#34;, brief); for (uint32_t i = 0; i \u0026lt; nums; i++) { printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); return; } int largestRectangleArea(int* heights, int heightsSize){ int *stack = (int *)malloc(sizeof(int) * (heightsSize + 1)); uint32_t stackIdx = 0; int maxAns = 0; int tmpAns = 0; int high = 0; int wide = 0; stack[stackIdx++] = -1; for (uint32_t i = 0; i \u0026lt; heightsSize; i++) { //showIntArr(\u0026#34;stack\u0026#34;, stack, stackIdx); if (stackIdx == 1) { /* 单调栈为空 */ stack[stackIdx++] = i; continue; } // printf(\u0026#34;stackIdx - 1 [%d]\\n\u0026#34;, stackIdx - 1); if (heights[i] \u0026gt;= heights[stack[stackIdx - 1]]) { stack[stackIdx++] = i; continue; } while ((stackIdx \u0026gt; 1) \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stack[stackIdx - 1]]) { /* 遍历到的元素小于栈顶元素 */ high = heights[stack[stackIdx - 1]]; stackIdx--; wide = i - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;i[%u] high[%d] wide[%d]\\n\u0026#34;, i, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } stack[stackIdx++] = i; } while (stackIdx \u0026gt; 1) { high = heights[stack[stackIdx - 1]]; stackIdx--; wide = heightsSize - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;ele[%d] high[%d] wide[%d]\\n\u0026#34;, heightsSize, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } return maxAns; } 94.二叉树的中序遍历 思路：递归，中序，注意封装递归函数\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void processTraversal(struct TreeNode* root, int* res, int* size) { if (!root) { return; } processTraversal(root-\u0026gt;left, res, size); res[*size] = root-\u0026gt;val; *size += 1; processTraversal(root-\u0026gt;right, res, size); } int* inorderTraversal(struct TreeNode* root, int* returnSize){ int* res = malloc(sizeof(int) * 256); *returnSize = 0; processTraversal(root, res, returnSize); return res; } 101.对称二叉树 思路：递归判断，注意递归出口判断条件\nbool checkSymmetric(struct TreeNode *left, struct TreeNode *right) { if (!left || !right) return left == right; if (left-\u0026gt;val != right-\u0026gt;val) return 0; return checkSymmetric(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; checkSymmetric(left-\u0026gt;right, right-\u0026gt;left); } bool isSymmetric(struct TreeNode *root) { return root == NULL || checkSymmetric(root-\u0026gt;left, root-\u0026gt;right); } 104.二叉树的最大深度 思路：求树深度递归 return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxval(int a, int b) { return a \u0026gt; b ? a : b; } int maxDepth(struct TreeNode *root) { if (root == NULL) { return 0; } return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 1; } return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } int maxDepth(struct TreeNode* root) { if (root == NULL) { return 0; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return fmax(left, right); } 108.将有序数组转换为二叉搜索树 思路：递归处理从中间分左右两部分，先添加当前节点在递归。\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* convertBST(int* nums, int left, int right) { if (left \u0026gt; right) { return NULL; } else { int mid = (right + left) / 2; struct TreeNode* new_val = malloc(sizeof(struct TreeNode)); new_val-\u0026gt;val = nums[mid]; new_val-\u0026gt;left = convertBST(nums, left, mid - 1); new_val-\u0026gt;right = convertBST(nums, mid + 1, right); return new_val; } } struct TreeNode* sortedArrayToBST(int* nums, int numsSize){ if (numsSize == 0) { return NULL; } return convertBST(nums, 0, numsSize - 1); } 109.有序链表转换二叉搜索树 思路：先找到中间节点和尾节点，将中间节点添加到树上，递归处理中间节点前部和后部两部分，递归出口为找不着新节点\n/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* buildBST(struct ListNode* head, struct ListNode* tail) { if (head == tail) { return NULL; } struct ListNode* slow = head; struct ListNode* fast = head; while (fast != tail \u0026amp;\u0026amp; fast-\u0026gt;next != tail) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } //struct TreeNode* node = (struct TreeNode)malloc(sizeof(struct TreeNode)); struct TreeNode *node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = slow-\u0026gt;val; node-\u0026gt;left = buildBST(head, slow); node-\u0026gt;right = buildBST(slow-\u0026gt;next, tail); return node; } struct TreeNode* sortedListToBST(struct ListNode* head){ if (!head) { return NULL; } return buildBST(head, NULL); } 110.平衡二叉树 思路：分别求左右子树的深度height，比较左右深度差值。递归判断左右子树是否为平衡二叉树\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 0; } else { return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } } bool isBalanced(struct TreeNode* root){ if (root == NULL) { return 1; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return abs(left - right) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } 112. 路径总和 思路：递归：左右子树 递归出口； 注意书判空\nbool hasPathSum(struct TreeNode* root, int targetSum){ if (root == NULL) { return false; } if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL \u0026amp;\u0026amp; root-\u0026gt;val == targetSum) { return true; } return hasPathSum(root-\u0026gt;left, targetSum - root-\u0026gt;val) || hasPathSum(root-\u0026gt;right, targetSum - root-\u0026gt;val); } 121.买卖股票的最佳时机 思路：动态规划，股票是连续收益的 maxcmp(0, maxCur + prices[i] - prices[i - 1])，收益累计\nint maxcmp(int a, int b) { return (a \u0026gt;= b) ? a : b; } int maxProfit(int* prices, int pricesSize){ int maxCur = 0, maxSoFar = 0; for (int i = 1; i \u0026lt; pricesSize; i++) { maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]); maxSoFar = maxcmp(maxSoFar, maxCur); printf(\u0026#34;i = %d\\t maxCur = %d \\t maxSoFar = %d\\n\u0026#34;, i, maxCur, maxSoFar); } return maxSoFar; } 125.验证回文串 思路：判断是否是字母和数字，库函数 isalnum; 注意库函数 isalpha 为判断是否为字母。头尾双指针，逼近中间，注意非数字字母忽略\nbool isPalindrome(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt;= right) { //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[left])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left])) { left++; } //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[right])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right])) { right--; } printf(\u0026#34;left = %d\\t right = %d\\n\u0026#34;, left, right); if (tolower(s[left]) != tolower(s[right])) { return false; } left++; right--; } return true; } 136.只出现一次的数字 思路：n ^ n = 0 一个数与自己异或为 0\nint singleNumber(int* nums, int numsSize){ int res = 0; for (int i = 0; i \u0026lt; numsSize; i++) { res = res ^ nums[i]; } return res; } 141.环形链表 思路：快慢双指针，fast一次走两步，slow一次走一步，判断是否能相遇\nbool hasCycle(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; while (slow \u0026amp;\u0026amp; fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { return true; } } return false; } 142.环形链表 II 思路：快慢双指针，判断出环向后，从链表入口开始，和slow指针相同速度遍历，直到相遇\nstruct ListNode *detectCycle(struct ListNode *head) { struct ListNode* slow = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* fast = (struct ListNode*)malloc(sizeof(struct ListNode)); slow = head; fast = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { struct ListNode* entry = head; while (slow != entry) { slow = slow-\u0026gt;next; entry = entry-\u0026gt;next; } return entry; } } return NULL; } 153.寻找旋转排序数组中的最小值 思路：二分查找\nint findMin(int* nums, int numsSize){ int low = 0; int high = numsSize - 1; while (low \u0026lt; high) { int mid = low + (high - low) / 2; if (nums[mid] \u0026lt; nums[high]) { high = mid; } else { low = mid + 1; } } return nums[low]; } int findMin(int* nums, int numsSize){ int i; for (i = 0; i \u0026lt; numsSize - 1; i++) { if (nums[i] \u0026gt; nums[(i+1)]) { return nums[i+1]; } } return nums[0]; } 160.相交链表 思路： 一、 二、先统计两个链表结点个数，然后长链表先走个数差位\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *cur1 = headA; struct ListNode *cur2 = headB; if (cur1 == NULL || cur2 == NULL) return NULL; while (cur1 \u0026amp;\u0026amp; cur2 \u0026amp;\u0026amp; cur1 != cur2) { cur1 = cur1-\u0026gt;next; cur2 = cur2-\u0026gt;next; if (cur1 == cur2) { return cur1; } if (!cur1) { cur1 = headB; } if (!cur2) { cur2 = headA; } } return cur1; } 169.多数元素 思路：选定一个主元素，计数器\nint majorityElement(int* nums, int numsSize){ int count = 1; int majorNum = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { if (count == 0) { majorNum = nums[i]; count++; } else if (majorNum == nums[i]) { count++; } else { count--; } } return majorNum; } 173.二叉搜索树迭代器 思路：\ntypedef struct { int* res; int size; int idx; } BSTIterator; int getTreeSize(struct TreeNode* root) { if (root == NULL) { return 0; } return 1 + getTreeSize(root-\u0026gt;left) + getTreeSize(root-\u0026gt;right); } void inorder(int* ret, int* retSize, struct TreeNode* root) { if (root == NULL) { return; } inorder(ret, retSize, root-\u0026gt;left); ret[(*retSize)++] = root-\u0026gt;val; inorder(ret, retSize, root-\u0026gt;right); } int* inorderTraversal(int* retSize, struct TreeNode* root) { *retSize = 0; int* ret = malloc(sizeof(int) * getTreeSize(root)); inorder(ret, retSize, root); return ret; } BSTIterator* bSTIteratorCreate(struct TreeNode* root) { BSTIterator* ret = malloc(sizeof(BSTIterator)); ret-\u0026gt;res = inorderTraversal(\u0026amp;(ret-\u0026gt;size), root); ret-\u0026gt;idx = 0; return ret; } int bSTIteratorNext(BSTIterator* obj) { return obj-\u0026gt;res[(obj-\u0026gt;idx)++]; } bool bSTIteratorHasNext(BSTIterator* obj) { return (obj-\u0026gt;idx \u0026lt; obj-\u0026gt;size); } void bSTIteratorFree(BSTIterator* obj) { free(obj-\u0026gt;res); free(obj); } 189.轮转数组 思路： 一、每次移动一个数 二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个\nvoid moveOne(int* nums, int numsSize) { int tmp = nums[numsSize - 1]; for (int i = numsSize - 1; i \u0026gt; 0; i--) { nums[i] = nums[i-1]; } nums[0] = tmp; } void rotate(int* nums, int numsSize, int k) { for (int i = 0; i \u0026lt; k; i++) { moveOne(nums, numsSize); } } /* */ void swap(int* a, int* b) { int t = *a; *a = *b; *b = t; } void reverse(int* nums, int start, int end) { while (start \u0026lt; end) { swap(\u0026amp;nums[start], \u0026amp;nums[end]); start += 1; end -= 1; } } void rotate(int* nums, int numsSize, int k) { k %= numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, k - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, k, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); } /* void rotate(int* nums, int numsSize, int k){ for (int i = 0; i \u0026lt; k; i++) { int lastElement = nums[numsSize - 1]; for (int j = numsSize - 1; j \u0026gt; 0; j--) { nums[j] = nums[j - 1]; } nums[0] = lastElement; } }*/ /* void rotate(int* nums, int numsSize, int k){ if (k == numsSize / 2 \u0026amp;\u0026amp; numsSize % 2 != 1) { for (int i = 0; i \u0026lt; k; i++) { int tmp = nums[i]; nums[i] = nums[k+i]; nums[k+i] = tmp; } return; } int i = 0; int tmp = nums[0]; int p = 0; int count = 0; do { p = (i + k) % numsSize; printf(\u0026#34;p = %d\\n\u0026#34;,p); int t = nums[p]; nums[p] = tmp; tmp = t; i = p; } while (i != 0); } */ 190.颠倒二进制位 思路：32位，\nuint32_t reverseBits(uint32_t n) { uint32_t m = 0; int cnt = 32; while (cnt) { m \u0026lt;\u0026lt;= 1; m += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;= 1; cnt--; } return m; } 191.位1的个数 思路：n \u0026amp; 0x1\nint hammingWeight(uint32_t n) { int cnt = 0; while (n) { if (n \u0026amp; 0x1) { cnt++; } n \u0026gt;\u0026gt;= 1; } return cnt; } 201.数字范围按位与 思路：n \u0026amp; (n - 1) 去除n最高位的1\nint rangeBitwiseAnd(int left, int right){ while (left \u0026lt; right) { right \u0026amp;= right - 1; } return right; } 203.移除链表元素 思路：递归\nstruct ListNode *removeElements(struct ListNode *head, int val) { if (head == NULL) { return NULL; } if (head-\u0026gt;val == val) { return removeElements(head-\u0026gt;next, val); } else { head-\u0026gt;next = removeElements(head-\u0026gt;next, val); } return head; } 206.反转链表 思路：\nstruct ListNode* reverseList(struct ListNode* head){ struct ListNode* res = NULL; while (head) { struct ListNode* pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } 209.长度最小的子数组 思路：双指针：累加sum，判断sum，大于target，计算长度，减sum，移动left\nint minSubArrayLen(int target, int* nums, int numsSize){ int i = 0; int sum = 0; int len = INT_MAX; for (int j = 0; j \u0026lt; numsSize; j++) { sum += nums[j]; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,j-i+1); sum -= nums[i]; i++; } } } if (len==INT_MAX) { len=0; } return len; } int minSubArrayLen(int target, int* nums, int numsSize){ int left = 0; int right = 0; int sum = 0; int len = INT_MAX; while (right \u0026lt; numsSize) { sum += nums[right]; right++; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,right-left); sum -= nums[left]; left++; } } } if (len == INT_MAX) { len = 0; } return len; } 215.数组中的第K个最大元素 思路：排序，第k个最大\nint Cmp(const void* a, const void* b) { return *(int *)b - *(int *)a; } int findKthLargest(int* nums, int numsSize, int k){ qsort(nums, numsSize, sizeof(int), Cmp); return nums[k-1]; } 217.存在重复元素 思路： 一、排序，比较前一个数和当前数是否相等 二、uthash\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } bool containsDuplicate(int* nums, int numsSize){ if (numsSize \u0026lt;= 1) { return true; } qsort(nums, numsSize, sizeof(int), Cmp); for (int i = 1; i \u0026lt; numsSize; i++) { if (nums[i-1] == nums[i]) { return true; } } return false; } struct my_struct { int id; UT_hash_handle hh; }; struct my_struct *users = NULL; bool containsDuplicate(int* nums, int numsSize){ struct my_struct *s; HASH_FIND_INT(users, nums[i], s); if (s == NULL) { s = (struct my_struct*)malloc(sizeof(struct my_struct)); s-\u0026gt;id = nums[i]; HASH_ADD_INT(users, id, s); } else { return true; } return false; } 226.翻转二叉树 思路：判空，交换左右子树，递归调用\nstruct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode* tmp = root-\u0026gt;left; root-\u0026gt;left = root-\u0026gt;right; root-\u0026gt;right = tmp; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); return root; } struct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode *left = (struct TreeNode *)malloc(sizeof(struct TreeNode)); struct TreeNode *right = (struct TreeNode *)malloc(sizeof(struct TreeNode)); left = invertTree(root-\u0026gt;left); right = invertTree(root-\u0026gt;right); root-\u0026gt;left = right; root-\u0026gt;right = left; return root; } 231.2的幂 思路：一：累计除2，判断最后是否为1，即整除 二、递归，判断对2取余\nbool isPowerOfTwo(int n) { if (!n) { return false; } while (n % 2 == 0) { n /= 2; } return n == 1; } bool isPowerOfTwo(int n){ if (n == 0) { return false; } if (n == 1) { return true; } bool res = false; if (n % 2 != 0) { return false; }else { res = isPowerOfTwo(n/2); } return res; } bool isPowerOfTwo(int n){ //用位运算来判断有几个1，要是只有一个1那就是2的幂。 if (n \u0026gt;= 2147483647 || n \u0026lt;= -2147483648) { return false; } int nu m =0; while (n\u0026gt;0 \u0026amp;\u0026amp; n!=0) { n \u0026amp;= (n-1); num++; } if (num!=1) { return false; } return true; } 234.回文链表 思路； 一、通过一个数组记录链表中的元素值，在判断数组是否是回文。 二、翻转链表后半部分\n#define MAXSIZE 100000 bool isPalindrome(struct ListNode* head){ int size = 0; int nums[MAXSIZE] = {0}; struct ListNode* p = head; // 判断条件 while (p) { nums[size++] = p-\u0026gt;val; p = p-\u0026gt;next; } printf(\u0026#34;size = %d\\n\u0026#34;, size); int left = 0; int right = size - 1; while (left \u0026lt;= right) { if (nums[left] != nums[right]) { return false; } left++; right--; } return true; } struct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } bool isPalindrome(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; struct ListNode *last; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; faast = fast-\u0026gt;next-\u0026gt;next; } if (fast != NULL) { slow = slow-\u0026gt;next; } last = reverse(slow); while (last) { if (head-\u0026gt;val != last-\u0026gt;val) { return 0; } head = head-\u0026gt;next; last = last-\u0026gt;next; } return 1; } 242.有效的字母异位词 思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录\u0026ndash;，最后，判断表格中所有值是否为零\n#define NUMSIZE 256 bool isAnagram(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); if (sLen != tLen) { return false; } int table[256] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; tLen; i++) { table[t[i]]--; } for (int i = 0; i \u0026lt; NUMSIZE; i++) { if (table[i] != 0) { return false; } } return true; } 268.丢失的数字 思路：边求和，边减去数组中的数字\nint missingNumber(int* nums, int numsSize){ int mNum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { mNum += (i + 1); mNum -= nums[i]; } return mNum; } 278.第一个错误的版本 思路：二分查找\nint firstBadVersion(int n) { int left = 1; int right = n; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (isBadVersion(mid) \u0026amp;\u0026amp; !isBadVersion(mid-1)) { return mid; } else if (isBadVersion(mid) \u0026amp;\u0026amp; isBadVersion(mid-1)) { right = mid - 1; } else { left = mid + 1; } } return -1; } int firstBadVersion(int n) { int low = 1, high = n; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (isBadVersion(mid)) { high = mid - 1; } else { low = mid + 1; } } return low; } 283.移动零 思路：不等于零时向数组中添加，等于零时跳过，最后填充0 nums[start++] = nums[i]\nvoid moveZeroes(int* nums, int numsSize){ int start = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != 0) { nums[start++] = nums[i]; } } for (; start \u0026lt; numsSize; start++) { nums[start] = 0; } } 287.寻找重复整数 思路：循环遍历，标记，判断是否标记过，return\n#define MAXSIZE 100001 int findDuplicate(int* nums, int numsSize){ int table[MAXSIZE] = {0}; for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] != 0) { return nums[i]; } else { table[nums[i]]++; } } return -1; } 344.反转字符串 思路：双指针，交换\nvoid reverseString(char* s, int sSize){ int left =0; int right = sSize - 1; while (left \u0026lt; right) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; } } 367.有效的完全平方数 思路：for 循环，条件 i * i \u0026lt;= num\nbool isPerfectSquare(int num) { for (long i = 0; i * i \u0026lt;= num; i++) { if (i * i == num) { return true; } } return false; } 387.字符串中的第一个唯一字符 思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。\n#define NUMSIZE 256 int firstUniqChar(char * s){ int sLen = strlen(s); int table[NUMSIZE] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; sLen; i++) { if (table[s[i]] == 1) { return i; } } return -1; } 389.找不同 思路：字符可以转化为数字，为了防止溢出通过 - \u0026lsquo;a\u0026rsquo;，求两个字符串的差值，在加上\u0026rsquo;a\u0026rsquo;\nchar findTheDifference(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); int nS = 0; int nT = 0; for (int i = 0; i \u0026lt; sLen; i++) { nS += s[i] - \u0026#39;a\u0026#39;; } for (int i = 0; i \u0026lt; tLen; i++) { nT += t[i] - \u0026#39;a\u0026#39;; } return (char)(nT - nS + \u0026#39;a\u0026#39;); } 404.左叶子之和 思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树\nint sumOfLeftLeaves(struct TreeNode* root){ if (root == NULL) { return 0; } int sum = 0; if (root-\u0026gt;left) { if (root-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;left-\u0026gt;right == NULL) { sum += root-\u0026gt;left-\u0026gt;val; } } return sum + sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } int isleaf(struct TreeNode* root) { return root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL; } int sumOfLeftLeaves(struct TreeNode* root) { if(root == NULL) { return 0; } if (root-\u0026gt;left) { if(isleaf(root-\u0026gt;left)) { // 此处直接递归，少一层调用 return root-\u0026gt;left-\u0026gt;val + sumOfLeftLeaves(root-\u0026gt;right); } } return sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } 442.数组中重复的数据 思路： 一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。 二、\n#define MAXSIZE 100000 int* findDuplicates(int* nums, int numsSize, int* returnSize){ int table[MAXSIZE] = {0}; *returnSize = 0; int *res = (int *)malloc(sizeof(int) * MAXSIZE); for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] == 1) { res[*returnSize] = nums[i]; (*returnSize)++; } else { table[nums[i]]++; } } return res; } int* findDuplicates(int* nums, int numsSize, int* returnSize) { int table[100000] = {0}; int *res = (int *)malloc(sizeof(int) * 100000); int j = 0; for (int i = 0; i \u0026lt; numsSize; i++) { table[nums[i]]++; if (table[nums[i]] == 2) { res[j++] = nums[i]; } } *returnSize = j; return res; } 461.汉明距离 思路： 一、求 x ^ y 中 1 的个数 二、比较x，y的每一位 和 1与\nint hammingDistance(int x, int y) { int n = x ^ y; int res = 0; while (n) { int p = n \u0026amp; 1; if (p) { res++; } n \u0026gt;\u0026gt;= 1; } return res; } int hammingDistance(int x, int y){ int count = 0; while (x || y) { int nX = x \u0026amp; 0x1; int nY = y \u0026amp; 0x1; if (nX != nY) { count++; } x \u0026gt;\u0026gt;= 1; y \u0026gt;\u0026gt;= 1; } return count; } 476.数字的补数 思路： 一、按位与1求与，再取反(!)，然后移位， 二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^\nint findComplement(int num){ int res = 0; int count = 0; while (num) { int t = !(num \u0026amp; 0x1); t \u0026lt;\u0026lt;= count; printf(\u0026#34;t = %d\\n\u0026#34;, t); res += t; count++; num\u0026gt;\u0026gt;=1; } return res; } int findComplement(int num){ int totalBits = 0; int tmp = num; while (tmp) { totalBits++; tmp \u0026gt;\u0026gt;= 1; } int flipNumber = 1; for (int i = 1; i \u0026lt; totalBits; i++) { flipNumber += UINT32_C(1) \u0026lt;\u0026lt; i; } num = num ^ flipNumber; return num; } 509.斐波那契数列 思路：一、递归 二、迭代\n递归 int fib(int n){ if (n \u0026lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); } 迭代 int fib(int n){ if (n \u0026lt;= 1) { return n; } int* nums = (int *)malloc(sizeof(int) * (n + 1)); nums[0] = 0; nums[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { nums[i] = nums[i - 1] + nums[i - 2]; } return nums[n]; } 520.检测大写字母 思路： 一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。 二、\nbool detectCapitalUse(char * word){ int len = strlen(word); if (len \u0026lt;= 1) { return true; } int i = 1; if (isupper(word[i])) { i = 0; while (word[i] != \u0026#39;\\0\u0026#39;) { if (!isupper(word[i])) { return false; } i++; } } else { while (word[i] != \u0026#39;\\0\u0026#39;) { if (isupper(word[i])) { return false; } i++; } } return true; } bool detectCapitalUse(char * word){ int len = strlen(word); if (len == 1) { return true; } for (int i = 1; i \u0026lt; len; i++) { // word[0] 每次都需要判断，一个复杂度。 if (isupper(word[0]) \u0026amp;\u0026amp; isupper(word[1])) { if (!isupper(word[i])) { return false; } } else { if (isupper(word[i])) { return false; } } } return true; } 561.拆分数组I 思路：排序，取偶数位求和。\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int arrayPairSum(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), Cmp); int minSum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (i % 2 == 0) { minSum += nums[i]; } } return minSum; } 617.合并二叉树 思路：递归，判空，\nstruct TreeNode* newNode(int val) { struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = val; node-\u0026gt;left = NULL; node-\u0026gt;right = NULL; return node; } struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){ /* if (root1 == NULL \u0026amp;\u0026amp; root2 == NULL) { return NULL; } */ if (root1 == NULL) { return root2; } if (root2 == NULL) { return root1; } /* struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val += root1 == NULL ? 0 : root1-\u0026gt;val; root-\u0026gt;val += root2 == NULL ? 0 : root2-\u0026gt;val; root-\u0026gt;left = NULL; root-\u0026gt;right = NULL; */ int val = (root1 == NULL ? 0 : root1-\u0026gt;val) + (root2 == NULL ? 0 : root2-\u0026gt;val); struct TreeNode* root = newNode(val); root-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return root; } 647.回文子串 思路：左侧判断去重，左右判断相等。\nint countSubstrings(char * s) { int len = strlen(s); int res = len; // 每个字符都是回文 for (int i = 0; i \u0026lt; len; i++) { int p = i - 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; s[p] == s[i]) { // 左侧去重 res++; p--; } int q = i + 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; q \u0026lt; len \u0026amp;\u0026amp; s[p] == s[q]) { // 判断左右相等 res++; p--; q++; } } return res; } int countSubstrings(char * s){ int len = strlen(s); int count = 0; for (int i = 0; i \u0026lt; len; i++) { count += countPalin(s, i, i, len); if (i != len - 1) { count += countPalin(s, i, i+1, len); } } return count; } int countPalin(char *s, int head, int tail, int len) { int ret = (s[head] == s[tail]) ? 1 : 0; if (ret \u0026amp;\u0026amp; head - 1 \u0026gt;= 0 \u0026amp;\u0026amp; tail + 1 \u0026lt; len) { ret += countPalin(s, head - 1, tail + 1, len); } return ret; } 674.最长连续递增序列 思路：双循环判断，\nint findLengthOfLCIS(int* nums, int numsSize){ if (numsSize == 1) { return 1; } int p2 = 0; int res = 0; for (int i = 1; i \u0026lt; numsSize; i++) { while (i \u0026lt; numsSize \u0026amp;\u0026amp; nums[i-1] \u0026lt; nums[i]) { i++; } res = res \u0026gt; i - p2 ? res : i - p2; p2 = i; } return res; } int findLengthOfLCIS(int* nums, int numsSize){ int maxLen = 0; int i = 0; while (i \u0026lt; numsSize) { int start = i; while (start + 1 \u0026lt; numsSize \u0026amp;\u0026amp; nums[start] \u0026lt; nums[start + 1]) { start++; } maxLen = maxLen \u0026gt; (start - i + 1) ? maxLen : (start - i + 1); start++; i = start; } return maxLen; } 700.二叉搜索树中的搜索 思路：递归，注意 判空 root == NULL\nstruct TreeNode* searchBST(struct TreeNode* root, int val){ if (root == NULL) { return NULL; } if (root-\u0026gt;val == val) { return root; } else if (root-\u0026gt;val \u0026gt; val) { return searchBST(root-\u0026gt;left, val); } else { return searchBST(root-\u0026gt;right, val); } return NULL; } 701.二叉搜索树中的插入操作 思路：递归，递归出口，root == NULL, 新建树结点 malloc\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){ if (root == NULL) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode-\u0026gt;val = val; newNode-\u0026gt;left = NULL; newNode-\u0026gt;right = NULL; return newNode; } if (root-\u0026gt;val \u0026lt; val) { root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); } if (root-\u0026gt;val \u0026gt; val) { root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); } return root; } 704.二分查找 思路：二分查找，注意 left \u0026lt;= right ，包含等于\nint search(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 709.转换成小写字母 思路；库函数 isupper, tolower\nchar * toLowerCase(char * s){ int len = strlen(s); for (int i = 0; i \u0026lt; len; i++) { if (isupper(s[i])) { s[i] = tolower(s[i]); } } return s; } 771.宝石和石头 思路：表记录stones中每个字符个数，求和jewels字符表中的值\nint numJewelsInStones(char * jewels, char * stones){ int table[256] = {0}; int sLen = strlen(stones); for (int i = 0; i \u0026lt; sLen; i++) { table[stones[i]]++; } int jLen = strlen(jewels); int sum = 0; for (int i = 0; i \u0026lt; jLen; i++) { sum += table[jewels[i]]; } return sum; } 852.山脉数组的峰顶索引 思路：判断条件，完全\nint peakIndexInMountainArray(int* arr, int arrSize){ int low = 1, high = arrSize; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026gt; arr[mid + 1]) return mid; else if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026lt; arr[mid + 1]) low = mid + 1; else high = mid - 1; } return -1; } 876.链表的中间结点 思路：快慢指针，第二个指针通过 偶数判断 for循环\nstruct ListNode* middleNode(struct ListNode* head){ struct ListNode* pos1 = head; struct ListNode* pos2 = head; for (int i = 0; pos1-\u0026gt;next != NULL; pos1 = pos1-\u0026gt;next, i++) { if (i % 2 == 0) { pos2 = pos2-\u0026gt;next; } } return pos2; } 905.按奇偶排序数组 思路: 一、双指针，同917 二、判断，前后索引移动，双指针\n解法一： int* sortArrayByParity(int* nums, int numsSize, int* returnSize) { *returnSize = numsSize; int start = 0; int end = numsSize - 1; while (start \u0026lt; end) { while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 == 0) { start++; } while (end \u0026gt; start \u0026amp;\u0026amp; nums[end] % 2 == 1) { end--; } while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 != 0 \u0026amp;\u0026amp; nums[end] % 2 != 1) { int tmp = nums[start]; nums[start] = nums[end]; nums[end] = tmp; start++; end--; } } return nums; } int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int left = 0; int right = numsSize - 1; while (left \u0026lt; right) { if (nums[left] % 2 == 0) { left++; continue; } if (nums[right] % 2 == 1) { right--; continue; } int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; left++; right--; } return nums; } 解法二； int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ int *res = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int j = 0; int p = numsSize - 1; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] % 2 == 0) { res[j] = nums[i]; j++; } else { res[p] = nums[i]; p--; } } return res; } 917.仅仅反转字母 思路：双指针，库函数 isalpha， continue\nchar * reverseOnlyLetters(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt; right) { if (!isalpha(s[left])) { left++; continue; } if (!isalpha(s[right])) { right--; continue; } //if (isalpha(s[left]) \u0026amp;\u0026amp; isalpha(s[right])) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; //} } return s; } 938.二叉搜索树的范围和 int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } if (low \u0026gt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;right, low, high); } if (high \u0026lt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;left, low, high); } return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } else if (root-\u0026gt;val \u0026gt;= low \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= high) { return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } else { return rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } } 965.单值二叉树 思路：递归，递归出口：root == NULL\nbool isUnivalTree(struct TreeNode* root){ // root不判空会报错： // member access within null pointer of type \u0026#39;struct TreeNode\u0026#39; if (root == NULL) { return true; } // 多余 /* if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return true; } */ if (root-\u0026gt;left != NULL) { if (root-\u0026gt;left-\u0026gt;val != root-\u0026gt;val) { return false; } } if (root-\u0026gt;right != NULL) { if (root-\u0026gt;right-\u0026gt;val != root-\u0026gt;val) { return false; } } return isUnivalTree(root-\u0026gt;left) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;right); } 977.有序数组的平方 思路: 一、先平方，再排序 二、双指针，左右指针比较绝对值大小，从后向前填充结果数组\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { //squareNum[i] = nums[i] * nums[i]; squareNum[i] = pow(nums[i], 2); } qsort(squareNum, numsSize, sizeof(int), Cmp); return squareNum; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int left = 0; int right = numsSize - 1; int i = numsSize - 1; while (left \u0026lt; right) { if (fabs(nums[left]) \u0026gt; nums[right]) { squareNum[i--] = nums[left] * nums[left]; left++; } else { squareNum[i--] = nums[right] * nums[right]; right--; } } squareNum[i] = nums[left] * nums[left]; return squareNum; } 1089.复写零 思路：将原数组复制一份，根据复制数组，修改原数组值\nvoid duplicateZeros(int* arr, int arrSize) { int b[arrSize]; // = {0}; memcpy(b, arr, sizeof(int) * arrSize); for (int i = 0, j = 0; i \u0026lt; arrSize \u0026amp;\u0026amp; j \u0026lt; arrSize; i++) { arr[j++] = b[i]; if (j \u0026lt; arrSize \u0026amp;\u0026amp; b[i] == 0) { arr[j++] = 0; } }W } void duplicateZeros(int* arr, int arrSize){ int * nums = (int *)malloc(sizeof(int) * arrSize); for (int i = 0; i \u0026lt; arrSize; i++) { nums[i] = arr[i]; } int j = 0; for (int i = 0; i \u0026lt; arrSize; i++, j++) { arr[i] = nums[j]; if (i + 1 \u0026lt; arrSize \u0026amp;\u0026amp; nums[j] == 0) { arr[++i] = 0; } } } 1184.公交站间的距离 思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){ if (start \u0026gt; destination) { int tmp = start; start = destination; destination = tmp; } int min = 0; int sum = 0; for (int i = 0; i \u0026lt; distanceSize; i++) { sum += distance[i]; if (i \u0026gt;= start \u0026amp;\u0026amp; i \u0026lt; destination) { min += distance[i]; } } min = min \u0026lt; (sum - min) ? min : sum - min; return min; } 1189. “气球” 的最大数量 思路：统计字符次数，注意 字符串指针 取值 *p 或者 字符数组 test[i]\nint maxNumberOfBalloons(char * text){ int len = strlen(text); int table[5] = {0}; char* p = text; while (*p != \u0026#39;\\0\u0026#39;) { if (*p == \u0026#39;b\u0026#39;) { table[0]++; } if (*p == \u0026#39;a\u0026#39;) { table[1]++; } if (*p == \u0026#39;l\u0026#39;) { table[2]++; } if (*p == \u0026#39;o\u0026#39;) { table[3]++; } if (*p == \u0026#39;n\u0026#39;) { table[4]++; } p++; } table[2] /= 2; table[3] /= 2; int min = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { min = min \u0026lt; table[i] ? min : table[i]; } return min; } /* int maxNumberOfBalloons(char * text){ int len = strlen(text); int testNum[5] = {0}; for (int i = 0; i \u0026lt; len; i++) { if (text[i] == \u0026#39;b\u0026#39;) { testNum[0]++; } if (text[i] == \u0026#39;a\u0026#39;) { testNum[1]++; } if (text[i] == \u0026#39;l\u0026#39;) { testNum[2]++; } if (text[i] == \u0026#39;o\u0026#39;) { testNum[3]++; } if (text[i] == \u0026#39;n\u0026#39;) { testNum[4]++; } } testNum[2] /= 2; testNum[3] /= 2; int res = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { res = res \u0026lt; testNum[i] ? res : testNum[i]; } return res; } */ 1207.独一无二的出现次数 解法一\n通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true\nuniqueOccurrences bool uniqueOccurrences(int* arr, int arrSize){ int table[2001] = {0}; for (int i = 0; i \u0026lt; arrSize; i++) { table[arr[i] + 1000]++; printf(\u0026#34;table[arr[%d] + 1000] = %d\\n\u0026#34;, i, table[arr[i] + 1000]); } int table1[2001] = {0}; for (int i = 0; i \u0026lt; 2001; i++) { table1[i] = 0; if (table[i] != 0) { if (table1[table[i]] != 0) { printf(\u0026#34;table1[table[%d]] = %d\\n\u0026#34;, i, table1[table[i]]); return false; } else { table1[table[i]]++; } } } return true; } 解法二：\n同解法一\n/* */ bool uniqueOccurrences(int* arr, int arrSize){ int hashTable[2001]={0};//初始化一张表，下标对应元素值，存储对应元素出现的次数 for(int i=0;i\u0026lt;arrSize;i++) { hashTable[arr[i]+1000]++; } bool visited[1001]={false}; for(int i=0;i\u0026lt;2001;i++) { if(hashTable[i]) { //如果i在数组中 if(visited[hashTable[i]]) { //如果之前出现过与i相同的重复次数 return false; } else { visited[hashTable[i]]=true;//说明与i相同的重复次数还未出现，设置为已访问过 } } } return true; } 参考博客： https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/leetcode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/","summary":"总结 leetcode基础题目 经典题目： 3.无重复字符的最长子串 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476.","title":"leetcode基础题目"},{"content":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？\nLinux内核代码下载 Linux kernel官网 https://www.kernel.org/\n解压 linux-5.19.10.tar.xz\ntar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035\nlinux内核线上阅读 linux、u-boot、qemu、glibc、llvm、grub https://elixir.bootlin.com/ U-boot # 下载源代码 git clone https://source.denx.de/u-boot/u-boot.git # 或 git clone https://github.com/u-boot/u-boot # 切换分支 git checkout v2020.10 官网 https://www.denx.de/wiki/U-Boot/ 代码网站 https://source.denx.de/u-boot 什么是U-Boot以及如何下载U-Boot源码 https://blog.csdn.net/zhuguanlin121/article/details/119008893 gdb 《100个gdb小技巧》 https://leetcode-cn.com/circle/article/7mxorv\nkbuild Kbuild: the Linux Kernel Build System Kernel Build System¶ https://www.zhihu.com/question/47039391/answer/2287806626\nELF 开源库 lief\n参考链接： https://blog.csdn.net/GrayOnDream/article/details/124564129\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linuxreadtool/","summary":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？ Linux内核代码下载 Linux kernel官网 https://www.kernel.org/ 解压 linux-5.19.10.tar.xz tar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035 linux内核线上阅读 li","title":"Linux Read Tool"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/tech/tech/","summary":"","title":"Tech"},{"content":"\rZain\u0026#39;s Blog\r一个记录技术、阅文、生活的博客\r👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego\n","permalink":"https://liuz0123.gitee.io/zain/links/","summary":"Zain\u0026#39;s Blog 一个记录技术、阅文、生活的博客 👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego","title":"🤝闲言俗语"},{"content":"\n英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 思考、觉悟、成长、沉静，时而逗比，时而安静，明心见性 👉Hugo博客交流群\r787018782\n","permalink":"https://liuz0123.gitee.io/zain/about/","summary":"英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 思考、觉悟、成长、沉静，时","title":"🙋🏻‍♂️关于"}]