[{"content":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF http://gen.lib.rus.ec/ https://libgen.li/ https://libgen.gs/ https://sci-hub.41610.org/library-genesis https://libgen.rs/search.php?\u0026amp;req=KVM\u0026amp;phrase=1\u0026amp;view=simple\u0026amp;column=def\u0026amp;sort=year\u0026amp;sortmode=DESC https://libgen.rs/ zlibrary PDF https://zh.u1lib.org/ https://en.ru1lib.org/ FreeTechBooks 计算机科学类 http://www.freetechbooks.com/ https://www.freetechbooks.com/ 古登宝计划 http://www.gutenberg.org/ Planet eBook 国内可访问 https://www.planetebook.com/ 布克书屋 https://iao.su/3064/comment-page-1 https://www.bukebook.cn yudu https://express.yudu.com/ kindle 社区 书伴 https://bookfere.com/post/4.html 参考链接： http://www.360doc.com/content/20/0219/14/5008209_893150066.shtml http://www.sohu.com/a/215001801_490529\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/ebookwebsite/","summary":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF","title":"电子书网站"},{"content":" 每一篇都从道歉开始，因为人是要为自己所说的，所做的承担责任，无论能不能获得你的原谅，这些都是我需要承担的，就像你说过的，世事就这么艰难吧。陌生人，从相识相知很难了，而我又把我们之间增加困难 很想知道你遇到了什么问题，不过你应该不会说的，那么基于我的猜测来说说，应该是极不准确的，因为没有很多信息。要是有什么冒犯和错误请见谅。 第一点，其实我感觉到你最近可能在攒钱，判断依据是你不打算换手机和一些聊天细节。记得10月1号在地坛买酸奶，那时候应该是由你来付的，这样是很合适的。那时我想到了一些事，所以我就抢着付了，但是处理的很尴尬，你也应该感受到了，从那一刻开始我就不太自然了。也越来越不会处理，让你感觉不舒服了。总之是我抱着意图然后不会处理了。 第二点，你遇到的问题是和房贷什么有关系吗？因为你其实提到过两次关于房贷，利率的话题，但我都没继续，关于利率这个在几周之前已经放风出来了，也看到了一些报告和数据，总之不是很乐观，所以我不太想聊，因为对这个是比较悲观的，市场表现数据不是很好，对于个体不确定性增大。还有一点是自卑，就是我现在可能不能独立解决，我不能要求上一代什么，只能自己创造未来，也希望有一个一同奋斗。说回问题，你如果需要，我可以出一份力，我也不是毫无根据的信任，是基于我对你的判断，你至少是有契约精神的，并且独立的债务关系并不影响你对我的评价，即使最终你认为我们不适合也并不影响什么。 第三点，或者你遇到什么突然的变故了吗？我知道你是一个很独立的女孩，有自己的能力处理，可是生活要是有一个可以分担的人很多困难就不会那么无助，即使能够和你分担的人不是我，你也可以尝试一下。一个人去留学，你都能应付的来，现在遇到的问题你也一定能处理好。从你的想法，态度中能够看到你的坚毅。 可能写下这些都毫无意义，可能更多的是给自己一个救赎，原谅一个陌生人是很难的，第一印象很重要，而破坏这个印象之后就很难修复了，并不奢求你再次认可我，退回到不曾相见也是一种句号。当然我需要为自己所做的所说的付出代价，可能也需要一个支点来分担出我自己的错误，在没有得到别人允许的情况下将别人放进心里是不礼貌的，可能在无法获得原谅的时候，只能自己慢慢移出，还好没有很深，这也是一个成长点吧，对未来是有帮助的。 下一篇写写曾经的感情，过去，现在，未来？ Taylor Swift发布了新专辑，里面有一首很喜欢《Maroon》，暂时找不到资源，自己搜一下吧 update，最后提醒一个事情，个人预测，不保证准确，开完会之后如果没有什么事情发生，口罩相关政策会在几个月内放松，不知道你是什么态度，个人态度是尊重科学，所有人都躺平，谁也没办法改变，对于我们个体而言，不要恐慌，可以准备一点抗病毒之类的药物，大部分都是没事，每年都有因为普通流感挺不过去的，现在这个和流感没有太大区别。不折腾是最好的应对措施，于个体而言也一样。如果你比较支持，那就当啰嗦了，请忽略。 ","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E5%88%86%E6%8B%85/","summary":"每一篇都从道歉开始，因为人是要为自己所说的，所做的承担责任，无论能不能获得你的原谅，这些都是我需要承担的，就像你说过的，世事就这么艰难吧。陌","title":"分担"},{"content":" 说明：插件基于C/C++ Project Generator，原始项目未更新，联系到作者沟通是否合入\n本项目地址: https://github.com/zhuangll/vscode_c_project_config\n安装 在vscode中安装C/C++ Project Generator插件 下载代码，将代码替换到C/C++ Project Generator插件所在目录，windows环境vscode插件目录,将功能代码复制替换如下目录中 C:\\Users\\\u0026lt;用户名\u0026gt;\\.vscode\\extensions\\danielpinto8zz6.c-cpp-project-generator-1.2.4 mingw安装，选择如下链接下载一个即可，添加到环境变量path中 各版本gcc mingw clang https://winlibs.com/ https://github.com/brechtsanders/winlibs_mingw MinGW-w64 https://www.mingw-w64.org/changelog/ 使用方法 wingows环境需要安装mingw，并添加到环境变量 linux环境适配中\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vscode_c_project_config/","summary":"说明：插件基于C/C++ Project Generator，原始项目未更新，联系到作者沟通是否合入 本项目地址: https://github.com/zhuangll/vscode_c_project_config 安装 在vscode中安装C/C++ Project Gen","title":"vscode c/c++一键创建工程插件"},{"content":" 真的为那天晚上所说的话无比后悔，\u0026ldquo;理性上追求克制与平静，感性上被感情所淹没\u0026quot;形成了情感的对立面。你可能把我归类为你同学在大学里遇到的那个男生了，纠缠嫉妒狭隘自私，总之一定是一个不合格的。所以我所写下的每一页都是在阐述我是一个什么样的，还值不值得你原谅，当然最重要都是你的感受来决定的。 首先是关于自私的问题，我一直的处事原则是凡事都可商量，而且是不喜欢做决定的人，但喜欢做计划，你应该是一个喜欢决断的性格，就像国庆出游计划一样，做出不止一个计划可选，同时更希望你有其他的规划。那天晚上就是太希望看到结果了，太希望可以走进你的生活了。当然说和写是没有意义的，而做才是最重要的，如果未来还有可能会让你感受到的，因为曾经就是这样的。另一点面是异性关系，即使是确定关系也可以有异性朋友啊，那天你说到那个男生时我第一个想到的就是这个观点，只有彼此坦诚相待，工作，生活不可能没有异性朋友的，要是狭隘的这种那生活一定很累了，时时刻刻需要担忧与怀疑，还有什么自由可言，谈到自由，爱情应该是自由自在的，如果爱情成了约束那么就没有必要了，我这样理解对吗？ 然后是关于分寸感，这一点也没有把握好，因为你的感受应该是第一位的，关于地铁站的问题是我没有重视，认为是一件很小的事情，但其实不是如果允许我送你了，就是代表了一种信任，更是一种接受，可是你还没有考虑好我是否值得信任是否值得付出。这些都是我那时候没有能够想到的，其实你已经提醒我很明确了，可是我但是陷入到不解与自私中。如果会再有机会，一定是十倍的耐心，让你有足够的安全感，信任感，其实那时候应该是水到渠成的事了，不需要我刻意去做什么。 最后是我所做的给你带来的感受，都是我的表达方式的问题，最想表达的是可以为你做很多很多，但这些不应该是对你造成的一种负担，而应该是一种自热而然的感受即可。 这是关于感情的成长吗？ 知道我为什么会这么快认定你吗？为什么我这么热情？在你身上看到很多东西，内心坚定，生活气息，自在，你内心深处应该还有更多，很多值得学习的，猛然发现这些都是向往和追求的。最令人向往的感情应该是彼此成就，我还在思考我有什么值得你原谅的，要是没有的话，应该没有上面所有的如果了。 你的感受最最重要，我不做预期，不知道那天晚上脑袋抽哪根筋什么预期，简直毫无意义，我现在所做的两点，第一，取得你的原谅，第二，画一个句号，这个句号不是重新开始而是一个心安，至少不要把我归类到那个男生。 更新原则：静默更新，不在通知，也许还会加你，不过不会很频繁，不要有什么压力，也许你从没看过，但这并不影响我独自走过这段经历，也不应该影响你此刻的经历。内在实力和感知力力，而不是表现形式。 最重要一点，如果你需要我随时准备好。 ","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E7%8B%AC%E7%99%BD/","summary":"真的为那天晚上所说的话无比后悔，\u0026ldquo;理性上追求克制与平静，感性上被感情所淹没\u0026quot;形成了情感的对立面。你可能把我归类为你同学","title":"独白"},{"content":"\r一个午后点燃了一颗心 岁月不会抹去我的记忆里你所给的阳光 却悄悄的使我不同 一个女孩在有心人的心中 永远不会遗忘 想到这些 十分犹豫 生活太脆太薄 甚至不比一株花经得住风雨年华 倾心自然的眼啊 人生 热情的可珍 同一人事上 第二次的凑巧是不会有的 我平生只见过一次天蓝 给自己宽慰 说\n行过很多路 见过多次海 看过许多天空 却只恋一个最好心灵的人。 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;2022.10.03\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E8%87%B4%E5%A8%9C/","summary":"一个午后点燃了一颗心 岁月不会抹去我的记忆里你所给的阳光 却悄悄的使我不同 一个女孩在有心人的心中 永远不会遗忘 想到这些 十分犹豫 生活太脆太薄 甚至不比","title":"致娜"},{"content":" 💓 这个网站是为你准备的礼物，没有计划添加文字，为了获得你的原谅想在每一页写上文字，由于我不是做前端的水平有限，最近发现很多bug，特别是不同屏幕适应问题，在大一点的屏幕显示效果很好，笔记本屏幕比较小的话显示有问题，尝试很多方法暂时没能修复，所以就把文字内容放到我的个人博客，添加一个写给娜的专栏，点击每一页的图片跳到这里对应的文章。另外的网站会添一些好玩的小功能，简单的写几句话。 从为什么加你开始吧，因为襄阳，从小就知道这个城市，而且在小时候内心有一种向往，包含了祖辈的敬仰。你是一年多来第一次主动接触的女孩，因为这一年多我花很大一部分时间用来走出上一段感情，这就是你说的我感情不稳定的原因，关于过去的感情会专门写一篇，其实想更多的了解你的过去。 网站有一个是一个计数器会自动记录我们相识多久了，到10月2号是第10天，10天时间我们居然那么熟悉了，对于一个慢热的人，从未如此快速的走近其他人。我们聊了很多很多了，你说的很多话我都记得了，很多还需要未来来实现。你是一个很有智慧的女生，才10天怎么可能会接受一个人呢，我不知道哪里抽筋了，就在出差之前非要一个结果，那个晚上一个晚上没有睡，终于想明白了，是因为我太想走进你的生活，想得走火入魔一样。此刻想想才10天，未来日子还有很久很久呢，即使出差也就一两个月，放在时间的长河里太短太短了。 看看那个晚上自己说的话，真的应该抽我自己，怎么写出那么自私、自我的话，心中有那么多多情感要表达，却偏偏写了那样伤你心的话。我是你也是会删了，永远不想在见到这个人。但请相信我，我是一个知错能改的，就像我们一开始那样你说需要分享式交流，这是你给我的一个成长启迪。让你相信不是说说就行的，需要看怎么做。就当这是一次对我的惩罚吧，你期待一个成熟稳重的人，我是这样的性格当然还有很多不成熟的地方需要完善，这些都不是我说说，而是应该相处后你来评价的。 每次和你聊完天我都会思考哪里有没有说的不合适的，比如关于随礼那次，十一我遇到了同样的事情，当时我说的和我做的就很不一样，我还是主动随了，因为那是对曾经友谊的纪念。2号晚上你发消息的我看了很多很多遍，读懂你很多顾虑、感受还有给我的的机会，平时在生活中我是很照顾他人的感受的，朋友同事都这样评价过我。 关于信任你做的很对很对，女孩子保护好自己，我为什么想知道你离那个地铁站近，是因为第三个礼物需要送到。你的观点是需要继续观察观察我，这是合情合理的。我需要有耐心去让你观察与评价。耐心，一个长跑型选手是很有耐心的。 我知道你会认为我写的上面的东西全篇都是自我，很多都是回想、思考你所说的话后我想我应该怎么做的。 关于未来计划，不知道能不能再次打动你，获得你的原谅，但我会在一个不让你厌烦的距离来请求你的谅解,10天对应的最少是10个月吧，应该会是更久吧。网站每周周末必更，也可能会一周两更。\n","permalink":"https://liuz0123.gitee.io/zain/posts/na/%E9%81%93%E6%AD%89/","summary":"💓 这个网站是为你准备的礼物，没有计划添加文字，为了获得你的原谅想在每一页写上文字，由于我不是做前端的水平有限，最近发现很多bug，特别是不同","title":"请求娜的原谅"},{"content":"内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区的互斥 虚拟文件系统 第1章 内核引导和初始化 处理器上电-\u0026gt;执行引导程序-\u0026gt;加载内核到内存-\u0026gt;执行内核-\u0026gt;内核初始化-\u0026gt;启动用户空间第一个进程 ARM64处理器到物理地址0取第一条指令\n1.1 引导程序 1.1.1 入口_start ARM64处理器U-Boot程序执行过程，入口u-boot/arch/arm/cpu/armv8/start.S标识_start\n.globl\t_start _start: #if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER) #include \u0026lt;asm/boot0-linux-kernel-header.h\u0026gt; #elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) #include \u0026lt;asm/arch/boot0.h\u0026gt; #else b\treset #endif 1.1.2 reset reset: /* Allow the board to save important registers */ /* 允许板卡保存重要的寄存器*/ b\tsave_boot_params .globl\tsave_boot_params_ret save_boot_params_ret: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl // 初始化系统控制寄存器 #endif /* * 异常级别可能是3、2或者1，初始状态： * 小端字节序，禁止MMU，禁止指令/数据缓存 */ adr x0, vectors witch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 // 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址 mrs x0, scr_el3 // 设置安全配置寄存器SCR_EL3 orr x0, x0, #0xf /* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */ msr scr_el3, x0 msr cptr_el3, xzr /* 启用浮点和SIMD功能*/ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* 初始化寄存器CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 // 异常级别2 mov x0, #0x33ff msr cptr_el2, x0 /* 启用浮点和SIMD功能 */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u0026lt;\u0026lt; 20 msr cpacr_el1, x0 /* 启用浮点和SIMD功能 */ 0: … /* 应用ARM处理器特定的勘误表*/ bl apply_core_errata /* 处理器特定的初始化*/ bl lowlevel_init // 执行board_init_f()所需最小初始化 #if defined(CONFIG_ARMV8_SPIN_TABLE) \u0026amp;\u0026amp; !defined(CONFIG_SPL_BUILD) branch_if_master x0, x1, master_cpu b spin_table_secondary_jump // arch/arm/cpu/armv8/spin_tabli.c /* 绝对不会返回*/ #elif defined(CONFIG_ARMV8_MULTIENTRY) branch_if_master x0, x1, master_cpu /* * 从处理器 */ slave_cpu: wfe ldr x1, =CPU_RELEASE_ADDR // 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数 ldr x0, [x1] cbz x0, slave_cpu br x0 /* 跳转到指定地址*/ #endif /* CONFIG_ARMV8_MULTIENTRY */ master_cpu: bl _main // 主处理器执行函数 U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序\n1.1.3 函数_main // arch/arm/lib/crt0_64.S ENTRY(_main) /* * 设置初始的C语言运行环境，并且调用board_init_f(0)。 */ #if defined(CONFIG_SPL_BUILD) \u0026amp;\u0026amp; defined(CONFIG_SPL_STACK ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节*/ mov x0, sp bl board_init_f_alloc_reserve // 在栈的顶部为结构体global_data分配空间 mov sp, x0 /* 设置gd */ mov x18, x0 bl board_init_f_init_reserve // 函数board_init_f_init_reserve，初始化结构体global_data mov x0, #0 bl board_init_f // common/board_f.c 执行数组init_sequence_f中的每个函数 #if !defined(CONFIG_SPL_BUILD) /* * 设置中间环境（新的栈指针和gd），然后调用函数 * relocate_code(addr_moni)。 * */ ldr x0, [x18, #GD_START_ADDR_SP] /* 把寄存器x0设置为gd-\u0026gt;start_addr_sp */ bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节 */ ldr x18, [x18, #GD_BD] /* 把寄存器x18设置为gd-\u0026gt;bd */ sub x18, x18, #GD_SIZE /* 新的gd在bd的下面 */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* 把寄存器x9设置为gd-\u0026gt;reloc_off */ add lr, lr, x9 /* 在重定位后新的返回地址 */ ldr x0, [x18, #GD_RELOCADDR] /* 把寄存器x0设置为gd-\u0026gt;relocaddr */ b relocate_code relocation_return: /* * 设置最终的完整环境 */ bl c_runtime_cpu_setup /* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/ #endif /* !CONFIG_SPL_BUILD */ #if defined(CONFIG_SPL_BUILD) bl spl_relocate_stack_gd /* 可能返回空指针 重新定位栈*/ /* * 执行“sp = (x0 != NULL) ? x0 : sp”， * 规避这个约束： * 带条件的mov指令不能把栈指针寄存器作为操作数 */ mov x1, sp cmp x0, #0 csel x0, x0, x1, ne mov sp, x0 #endif /* * 用0初始化未初始化数据段 */ ldr x0, =__bss_start /* 这是自动重定位*/ ldr x1, =__bss_end /* 这是自动重定位*/ clear_loop: str xzr, [x0], #8 cmp x0, x1 b.lo clear_loop /* 调用函数board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ b board_init_r /* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */ /* 不会运行到这里，因为函数board_init_r()不会返回*/ ENDPROC(_main) 1.1.4 函数run_main_loop 数组init_sequence_r最后一个函数run_main_loop，函数执行流程；\nrun_main_loop main_loop bootdely_process # 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量) autoboot_command abortboot # 等待用户按键 run_command_list # 未等待到按键，自动执行环境变量bootcmd bootm命令处理函数do_bootm\ndo_bootm do_bootm_states bootm_start # 初始化全局变量bootm_header_timages bootm_find_os # 把内核镜像从存储设备读到内存 bootm_find_other # ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件 bootm_load_os # 解压病加载内核到正确位置 bootm_os_get_boot_func # 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux do_bootm_linux(flag=BOOTM_STATE_OS_PREP) # 调用boot_prep_linux boot_prep_linux # 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件 boot_selected_os # do_bootm_linux(flag=BOOTM_STATE_OS_GO) boot_jump_linux # 负责跳转到Linux内核 boot_jum_linux do_nonsec_virt_switch smp_kick_all_cpus # CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3 dcache_disable # 禁用处理器的缓存和内存管理单元 # 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el2 switch_to_el1 armv8_switch_to_el1 内核入口 # 在异常级别2执行内核 armv8_switch_to_el2 内核入口 1.2 内核初始化 内核初始化分为汇编语言部分和C语言部分\n1.2.1 汇编语言部分 ARM64架构内核入口_head，直接跳转到标号stext\n// linux-4.14.295/arch/arm64/kernel/head.S _head: #ifdef CONFIG_EFI // 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS add x13, x18, #0x16 b stext #else b stext // 跳转到内核起始位置 .long0 // 保留 #endif stext\n// linux-4.14.295/arch/arm64/kernel/head.S ENTRY(stext) bl preserve_boot_args // 把引导程序传递的4个参数保存在全局数组boot_args中 bl el2_setup // 降级到异常级别1, 寄存器w0存放cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR偏移，默认值是0 bl set_cpu_boot_mode_flag // __boot_cpu_mode[2] 数组 bl __create_page_tables // 创建页表映射 /* * 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” * 了解细节。 * 返回的时候，处理器已经为开启内存管理单元做好准备， * 转换控制寄存器已经设置好。 */ bl __cpu_setup // 初始化处理器 b __primary_switch // 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel ENDPROC(stext) 函数el2_setup 1.如果异常级别是1，那么在异常级别1执行内核。 2.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。 1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。\n2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核\n基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程\n// 打开KVM字符设备文件。 fd = open(\u0026#34;/dev/kvm\u0026#34;, O_RDWR); // 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。 vmfd = ioctl(fd, KVM_CREATE_VM, 0); // KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符 vcpu_fd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 从QEMU切换到客户操作系统的过程如下。 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。 为了提高切换速度，ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2\n函数__create_page_tables 函数__primary_switch 1.2.2 C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。\n（1）创建1号线程，即init线程，线程函数是kernel_init。\n（2）创建2号线程，即kthreadd线程，负责创建内核线程。\n（3）0号线程最终变成空闲线程。\ninit线程继续初始化，执行的主要操作如下。\n（1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。\n（2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。\n（3）smp_init()：初始化SMP系统，启动所有从处理器。\n（4）do_initcalls()：执行级别0～7的初始化。 保存在全局变量kimage_voffset中。\n（5）用0初始化内核的未初始化数据段。\n（6）调用C语言函数start_kernel。\n1.3.2　C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。\n（1）创建1号线程，即init线程，线程函数是kernel_init。\n（2）创建2号线程，即kthreadd线程，负责创建内核线程。\n（3）0号线程最终变成空闲线程。\ninit线程继续初始化，执行的主要操作如下。\n（1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。\n（2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。\n（3）smp_init()：初始化SMP系统，启动所有从处理器。\n（4）do_initcalls()：执行级别0～7的初始化。\n（5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。\n（6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。\n（7）free_initmem()：释放初始化代码和数据占用的内存。\n（8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。\n级别0～7的初始化，是指使用以下宏注册的初始化函数：\n// include/linux/init.h #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 1.2.3 SMP系统的引导 ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","summary":"内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区","title":"Linux内核深度解析"},{"content":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉取更新代码 git pull # 推送 git push # 合并已push的commit git rebase -i HEAD~n # 强制更新覆盖本次 git fetch --all git reset --hard HEAD git pull # 强制推送 git push -u origin br_master --force # 回合代码 git rebase master # 回退已提交commit git reset --soft \u0026lt;commit-ID\u0026gt; # 忽略部分文件提交 git add filename # 放入本地栈 git stash -u -k git commit git push # 弹出本地栈 git stash pop git配置 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@163.com\u0026#34; git config --list user.name=xxx user.email=xxx@163.com # 生成秘钥 ssh-keygen -t rsa -C \u0026#39;xxx@163.com\u0026#39; # cd ~/.ssh 将 id_rsa.pub 添加道GitHub # 测试链接 ssh -T git@github.com # 设置默认编辑为vim git config --global core.editor \u0026#34;vim\u0026#34; 玩转WSL(6)之Git配置\ngit同时配置Gitee和Github\nGit设置换行符为LF\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/git/","summary":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉","title":"git"},{"content":"python logging # logging.yaml： version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #保留50个log文件 encoding: utf8 server_file_handler: class: logging.handlers.RotatingFileHandler level: INFO # 只在文件中记录INFO级别及以上的log formatter: upgrade filename: ./logs/server.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 loggers: server: level: DEBUG #允许打印DEBUG及以上log handlers: [server_file_handler] propagate: true #设为false则禁止将日志消息传递给父级记录器的处理程序中 root: level: DEBUG handlers: [console, all_file_handler] # logger.py # logging.py from fileinput import filename import os import time import yaml import logging.config import logging import datetime #import coloredlogs class Logger(): def __init__(self, log_name=\u0026#34;log.log\u0026#34;, log_path = \u0026#34;./logs\u0026#34;, default_path = \u0026#34;logging.yaml\u0026#34;, default_level = logging.INFO,env_key = \u0026#34;LOG_CFG\u0026#34;): self.log_name = log_name self.log_path = log_path #time_stamp = time. now = time.strftime(\u0026#39;%Y-%m-%d %H_%M_%S_\u0026#39;) # 文件的命令以及打开路径 log_filename = self.log_path + \u0026#34;/\u0026#34; + now + self.log_name with open(file=default_path, mode=\u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;)as file: logging_yaml = yaml.load(stream=file, Loader=yaml.FullLoader) logging_yaml[\u0026#39;handlers\u0026#39;][\u0026#39;all_file_handler\u0026#39;][\u0026#39;filename\u0026#39;] = log_filename print(\u0026#34;logging_yaml \u0026#34;,logging_yaml) handlers = logging_yaml[\u0026#39;handlers\u0026#39;] for key, value in handlers.items(): if \u0026#39;filename\u0026#39; in value: log_path = (os.path.split(value[\u0026#39;filename\u0026#39;])[0]) print(\u0026#34;log_path\u0026#34;) if not os.path.exists(log_path): os.makedirs(log_path) # 配置logging日志：主要从文件中读取handler的配置、formatter（格式化日志样式）、logger记录器的配置 logging.config.dictConfig(config=logging_yaml) ###设置完毕### # 获取根记录器：配置信息从yaml文件中获取 root = logging.getLogger() # 子记录器的名字与配置文件中loggers字段内的保持一致 server = logging.getLogger(\u0026#34;server\u0026#34;) print(\u0026#34;rootlogger:\u0026#34;, root.handlers) print(\u0026#34;serverlogger:\u0026#34;, server.handlers) print(\u0026#34;子记录器与根记录器的handler是否相同：\u0026#34;, root.handlers[0] == server.handlers[0]) if __name__ ==\u0026#39;__main__\u0026#39;: Logger() logging.info(\u0026#34;first log\u0026#34;) 参考链接：\nhttps://blog.csdn.net/weixin_43988680/article/details/123528294 https://zhuanlan.zhihu.com/p/425678081 https://blog.csdn.net/qq_35812205/article/details/126480417 https://blog.csdn.net/TracelessLe/article/details/108887001 c log zlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/logging/","summary":"python logging # logging.yaml： version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #保留50个lo","title":"logging"},{"content":"多年经验总结，写出最惊艳的 Markdown 高级用法\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/markown/","summary":"多年经验总结，写出最惊艳的 Markdown 高级用法","title":"Markown"},{"content":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxcommand/","summary":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown","title":"LinuxCommand"},{"content":"openbenchmark\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/benchmark/","summary":"openbenchmark","title":"benchmark"},{"content":"1.cmake简述 CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\nCMake工程简单例子\ncmake_minimum_required(VERSION 3.12) project(myproj) find_package(Poco REQUIRED COMPONENTS Net Util) add_executable(MyExe) target_source(MyExe PRIVATE \u0026#34;main.cpp\u0026#34;) target_link_library(MyExe PRIVATE Poco::Net PocoUtil) target_complie_definition(MyExe PRIVATE std_cxx_14) 2.Target 和围绕 Target 的配置 C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为target，创建命令分别是add_library()和add_executable()。其中链接库的类型又分为很多种，最常用的就是SHARED以及STATIC，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。 指定target的源文件：\ntarget_source(MyLib PRVIATE \u0026#34;main.cpp\u0026#34; \u0026#34;func.cpp\u0026#34;) PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值\n较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) 命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：\ntarget_source(MyLib PRIVATE ${SRCS}) 配置target时通常还需要指定头文件目录：\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/) 编译时需要的语言特性：\ntarget_compile_features(MyLib PRIVATE std_cxx_14) 编译时的宏定义：\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3) 参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra) 3.Build Specification 和 Usage Requirement C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库 CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。\n一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：\ntarget_compile_features(MyLib PRIVATE cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：\ntarget_compile_features(MyLib PUBLIC cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) 当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可\narget_compile_features(MyLib INTERFACE cxx_std_14) Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，\n4.寻找和使用链接库 C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。 在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。\n4.1 通过 Config file 找到依赖 Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement\nCMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。\n4.2 通过 Find file 找到依赖 对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。\nCMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。 库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake) ${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。 通过 CMake 的find_library和find_path两个命令就可以完成任务：\nfind_library(MPI_LIBRARY NAMES mpi HINTS \u0026#34;${CMAKE_PREFIX_PATH}/lib\u0026#34; ${MPI_LIB_PATH} # 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值 ) find_path(MPI_INCLUDE_DIR NAMES mpi.h PATHS \u0026#34;${CMAKE_PREFIX_PATH}/include\u0026#34; ${MPI_INCLUDE_PATH} # 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值 ) 4.3.find_package 的处理 find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：\n# 要求大版本号为2的SFML库的graphic模块 find_package(SFML 2 COMPONENTS graphics REQUIRED) # SFML提供的target名字为sfml-graphics target_link_libraries(MyEXE PRIVATE sfml-graphics) 5.使用 CMake 来编译 CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：\ncmake --build . 使用\u0026ndash;buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。 对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：\ncmake --build . --config Release 参考链接: cmake https://ukabuer.me/blog/more-modern-cmake/ Makefile ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/cmake/","summary":"\u003ch2 id=\"1cmake简述\"\u003e1.cmake简述\u003c/h2\u003e\n\u003cp\u003e CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\u003c/p\u003e","title":"cmake"},{"content":"一.简单句子分析 英语句子= 主干+修饰成分 分析句子结构: 一个中心 + 两个要点 一个中心: 动词. 句子必须右动词 两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者. 句子的核心是主谓结构\nn个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。\n英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.\n{% pullquote mindmap mindmap-md %}\n英文句子 简单句 主 + 谓 主 + 谓 + 宾 主 + 谓 + 宾 + 宾补 主 + 谓 + 间宾 + 直宾 主 + 系 + 表 复合句 名词性从句 主语从句 宾语从句 同位语从句 表语从句 定语从句 状语从句 时间状语从句 地点状语从句 条件状语从句 结果状语从句 让步状语从句 目的状语从句 特殊句式 强调句 虚拟语气 倒装句 类型 陈述句 祈使句 感叹句 疑问句 {% endpullquote %}\n英语语法从整体上来讲是通过五部分来组成 1、简单句 2、并列句、复合句 3、三大从句 4、特殊句式 5、类型\n补语 补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。 修饰成分 介词短语 从句 非谓语动词 时间状语 论主语的补语，而后将宾语的补语作为一种变形来讨论\n1.1 S + V （主+谓） 句子不可或缺的两部分. 名词/代词/不定式/动名词 + 动词 谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.\n1.2 S + V + C （主+系+表） 主语 +系动词 +表语\n表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。\n系动词包括：\na. be 动词，am, is, are, was, were;\nb. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);\nc. 表变化：become(成为), grow, turn(转变为), go, get, fall;\nd. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).\nappear 显得像是 prove 证实为 become 成为 make 作为\n1.3 S + V + O （主+谓+宾） 主语+谓语+宾语\n谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。\n1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)） 谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。 e.g.,\ngive sb sth = give sth to sb\ntell sb sth = tell sth to sb\n1.5 S + V + O + C（主+谓+宾+宾补） 此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。 主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。\nThere be 句型\nThere be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分\n1.主语：句子所陈述的对象。 2.谓语：主语发出的动作。一般是有动作意义的动词。 3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。 4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。 5. 表语：紧跟系动词后面的成分。 6. 定语：修饰名词或代词的成分。 7. 状语： 修饰形容词、副词、动词或句子的成分。 8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。\n参考链接: https://liam.page/2014/06/21/basic-sentence-and-the-complement/ https://www.zhihu.com/question/30030877/answer/768501967\n参考数据 《语法俱乐部》\n复杂句:从简单句演化而来\n简单句没有什么句序的调整，所以翻译起来基本没有什么难度。\n英语中的修饰成分，分定语和状语两种情况。 英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)\n二、并列句、复合句 简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：\n并列句：简单句+并列词+简单句\n并列词一般有：and / or / but / so /while / yet / for / however\n1）：表示并列：and, not only\u0026hellip;but also\u0026hellip; , neither\u0026hellip;nor\u0026hellip;\nHer father is a doctor and her mother is a teacher .\n2）：表示选择：or, or else, otherwise, either\u0026hellip;or\u0026hellip;\nHurry or you won\u0026rsquo;t make the train.\n3）：表示对比、转折: but, while , yet , however , never ,\nI like tea while she likes coffee .\n4）：表示原因：for\nI am thirsty , for it is hot .\n复合句：简单句+从属连词+简单句\n从属连词有：that / wether/ if\n复合句其实就是我们常说的三大从句，\n三.三大从句 1、名词性从句\n当名词性从句作为句子的不同成分时，又被称呼为不同的名字。\n当作为主语时，称为主语从句。\n当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：\n主语从句 What she said is wrong .\n宾语从句 I said that she was wrong.\n表语从句 The fact is that he doesn’t really try.\n同位语从句 The news that he will come back is ture.\n记住一点，不管什么从句，你把它当成一个”长一点的名词”。\n那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。\n同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。\n2、定语从句\n修饰限定名词，汉语中“的”前面的内容。\n关系代词引导的定语从句\n1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.\n2. whom指人，在定语从句中充当宾语，常可省略。\nMr. Ling is just the boy whom I want to see\n3. which指物，在定语从句中做主语或者宾语，做宾语时可省略\nThis is the pen (which) he bought yesterday.\n4. that指人时，相当于who 或者whom；指物时，相当于which。\n5. whose通常指人，也可指物，在定语从句中做定语。\n指的是谁的。Do you like the book whose cover is yellow?\n关系副词引导的定语从句\nwhen where why\n3、状语从句\n修饰动作的发生的时间、地点、原因、方式\n九大状语从句\n1、时间状语从句\n常用引导词：when, as, while, as soon as, before, after, since , till, until\n特殊引导词：the minute, the moment, the second, every time, the day，the instant,\nI was fat when I was a child.\n2、地点状语从句\n常用引导词：where\n特殊引导词：wherever, anywhere, everywhere\nKeep it where you can see it.\n3、原因状语从句\n常用引导词：because, since, as, for\n特殊引导词：seeing that, now that, in that, considering that, given that.\nMy friends dislike me because I’m beautiful .\n4、目的状语从句\n常用引导词：so that, in order that\n特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that\nstudy hard so that you can pass the exam.\n5、结果状语从句\n常用引导词：so … that, so… that, such … that,\n特殊引导词：such that, to the degree that, to the extent that, to such a degree that,\nHe got up so early that he caught the first bus.\n6、条件状语从句\n常用引导词：if, unless,\n特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that\nIf you ask him, he will help you.\n7、方式状语从句\n常用引导词：as, as if, how\n特殊引导词：the way\nThink as i think\n8、比较状语从句\n常用引导词：as(同级比较), than(不同程度的比较)\n特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B\nThe house is three times as big as ours.\n9、让步状语从句\n常用引导词：though, although, even if, even though\n特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\nThough I believe it, yet I must consider.\n四.特殊句式 1、强调句\nIt is （名词 / 介宾）指的是被强调的内容that （\u0026hellip;\u0026hellip;..）\nIt was she whom we are talking about.\n2、倒装句\n正常句序 ：主谓宾\n倒装句序 ：谓主宾\nwe can win only through hard work .\nonly through hard work can we win .\n3、虚拟语气，假设不可能发生的事情\n1、对过去情况的虚拟\n从句用 had done\n主句用 would could might should have done\n2、对现在情况的虚拟\n从句用 did , was变成were\n主句用 would could might should do\n3、对将来情况虚拟\n从句用 did ，was 变成 were，should do,were to do\n主句用 would could might should do\n五.类型 陈述句\ni like English very much . 我非常喜欢英语。\n疑问句\nis this your key ? 这是你的钥匙吗？\n祈使句\n一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。\nmind you head 小心碰头！\n第二种祈使句以let开头\nLet\u0026rsquo;s have another try\n感叹句\nwhat a brave girl ! 真是个勇敢的女孩子\nhttps://zhuanlan.zhihu.com/p/400448345\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%B8%80/","summary":"\u003ch2 id=\"一简单句子分析\"\u003e一.简单句子分析\u003c/h2\u003e\n\u003cp\u003e \u003cstrong\u003e英语句子= 主干+修饰成分\u003c/strong\u003e\n 分析句子结构:\n  一个中心 + 两个要点\n  一个中心: 动词. 句子必须右动词\n  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.\n  \u003cstrong\u003e句子的核心是主谓结构\u003c/strong\u003e\u003c/p\u003e","title":"英语语法一"},{"content":"hugo运行 hugo -F --cleanDestinationDir # 本地预览 hugo server 参考链接：\nhttps://www.sulvblog.cn/\nhttps://www.jianshu.com/p/fa95c0c1fdab\nhttps://lishensuo.github.io/\nhttps://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612\nhttps://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38\nhttps://blog.csdn.net/qq_45975757/article/details/108923612\nmongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.6.7\u0026#34;} 托管 为了提高访问速度托管在gitee上，迁移完成后将会同时托管到github中。 通过不同分支保存源码和静态网页内容，用br_hugo管理源码，master分支管理public\nhexo # 清理缓存 hexo clean # 生成网页 hexo g # 启动本地服务端口 hexo s # 发布到github hexo d # 强制推送备份源码分支 git push -f origin backup GitHub Pages + Hexo使用及配置 github上创建一个 username.github.io 的工程，username 必须为github的用户名\n参考链接 https://www.jianshu.com/p/f82c76b90336\nhttps://www.jianshu.com/p/5d0b31032d55\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\nhttps://theme-next.org/\nhttps://hexo.io/zh-cn/docs/\nhttps://www.jianshu.com/p/3a05351a37dc\nhttps://www.zhyong.cn/posts/ca02/\nhttp://theme-next.iissnan.com/\nhttps://liam.page/\nhttps://liam.page/en/\nHexo博客添加helper-live2d动态模型插件 https://blog.csdn.net/qq_30930805/article/details/ ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/blog/","summary":"hugo运行 hugo -F --cleanDestinationDir # 本地预览 hugo server 参考链接： https://www.sulvblog.cn/ https://www.jianshu.com/p/fa95c0c1fdab https://lishensuo.github.io/ https://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612 https://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38 https://blog.csdn.net/qq_45975757/article/details/108923612 mongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#3","title":"hexo-\u003ehugo迁移"},{"content":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接： ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334\n安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239\nubuntu 显示 https://ubuntuqa.com/article/8837.html\nhttps://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html\nUbunut 22.04 LTS 版本 GNU/Linux核心\nGCC 11.2.0 binutils 2.38 glibc 2.35 编译工具链\nPython 3.10.4 Perl 5.34.0 LLVM 14 golang 1.18 rustc 1.58 OpenJDK Ruby 3.0 systemd 249.11 OpenSSL 3.0 虚拟化\nqemu 6.2.0 libvirt 8.0.0 virt-manager 4.0.0 Linux包管理 snap flameshot截图工具 # 快捷方式 flameshot gui https://www.cnblogs.com/kendoziyu/p/how_to_screenshot_in_ubuntu2004.html ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxtool/","summary":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接： ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334 安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239 ubuntu 显示 https://ubuntuqa.com/article/8837.html https://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html Ubunut 22.04 LTS 版本 GNU/Lin","title":"linuxTool"},{"content":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # shift + : 低行模式 wq # 保存退出 w! # 保存 !q # 放弃退出 gg # 回到文件首部 GG # 到文件尾部 / # 查找 p # 粘贴 x # 删除光标所在字符 nx # 删除光标所在处后n个字符 d # 删除一行 D # 删除光标到行尾 dG # 删除光标到文件尾 u # 撤销 yy # 复制当前行 dd # 剪切当前行 %s/old/new # 替换old字符为new 史上最全的vim快捷键 Vim使用笔记 Windows使用Vim 在Windows系统中，安装git后已经存在vim，找到vim.exe所在目录，添加到环境变量path中即可。 Windows下载 Vim安装 参考博客：在Windows下安装和使用vim PowerVim PowerVim快捷键 ;n # 打开文件目录树显示在屏幕左侧 ;m # 打开当前函数和变量目录树显示在屏幕右侧 ;w # 保存文件 ;u # 向上翻半屏 ;d # 向下翻半屏 ;1 # 光标快速移动到行首 ;2 # 光标快速移动到行末 ;a # 快速切换.h和cpp文件，写C++的时候很方便 ;e # 打开一个新文件 ;z # 切回shell交互命令，输入fg在切回vim，非常实用 ;s # 水平分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;v # 竖直分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;fw # 查找项目内关键字 ;ff # 查找项目内文件名 ;gt # 跳转到变量或者函数定义的地方，前提是安装ctags，并且在在PowerVim输入 ;tg命令 Jump to the definition of the keyword where the cursor is located, but make sure you have make ctags ;gr # 跳回，对应着;gt ;tg # 对当前目录打ctag ;y # 保存当前选中的目录到系统剪切板，前提是vim支持系统剪切板的寄存器 dsfa;w ;h/l/k/j # 光标向左右上下窗口移动，特别是打开多个窗口。使用这个快捷键组合非常实用 ;gg # 按顺序光标跳转各个窗口 # Shortcuts without ; e # 快速删除光标所在的词 tabc # 关闭当前tab，可以用:tabnew来打开一个新的tab Close tab, of course you should :tabnew a file first. F1 # 编译C++代码，自己写的C++例子的时候一键编译。前提手动在当前目录建一个bin文件夹，这是用来存放编译产生的执行文件 gc # 快速注释选中的块（是visual模式下选中的块） gcc # 快速当前行 { # 光标向上移动一个代码块s } # 光标向下移动一个代码块 PowerVim安装及配置 【VIM】PowerVim安装及使用\nPowerVim - 使Vim更加强大易用\n安装PowerVim 问题解决过程记录\nctags ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vim/","summary":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # shift + : 低行模式 wq # 保存退出 w! # 保存 !q # 放弃退出 gg # 回到文件首部 GG #","title":"vim"},{"content":"CMD命令 # 查询本机IP ipconfig # 向对方电脑发送消息 msg /server 192.168.1.100 * 消息 # 查看本机用户信息 net user # 查看共享资源 net share # 查看网站IP nsloopup www.baidu.com # 查看WiFi配置文件 netsh wlan show # 管道符，输出到文件 | 1.txt # windows 工具软件 Snipaste 截图软件 支持自定义设置快捷键 Download\nZoomIt 屏幕缩放、标记、录制 展示小工具 whois 居然可以在Windows使用 Download\nSysinternals 工具集 Download\neveryting 快速查找文件 Download\n7zip 开源压缩软件 Download\nWiztree 磁盘文件占用 Download\nWindows Terminal 取代传统cmd显示，可集成PowerShell， 登录wsl， 未来Windows将设置为默认终端 微软商店\nPowerShell 一款shell，支持Windows、linux、mac，推荐Windows结合 Windows Terminal使用, 使Windows像Linux终端一样爽 Download\nwinget search Microsoft.PowerShell winget install Microsoft.PowerShell 参考链接：\nWindows Powershell和Windows Terminal的区别\n安装和设置 Windows 终端\nQ-Dir 多窗口资源管理器 Download\nFileZilla 多协议文件传送，支持FTP、SFTP，包含Client和Server，支持Windows、Linux、mac Download\n终端连接程序 secureCRT 需要破解 https://blog.csdn.net/qq_39052513/article/details/104692026\ngeek windows卸载工具，清理注册表，删除缓存文件，开箱即用 Download\nvscode vscode 上传图片 # 上传剪贴板中的图片到服务器。 ctrl + alt + u # 打开文件浏览器选择图片上传。 ctrl + alt + e https://www.jianshu.com/p/868b3a2028f8 https://zhuanlan.zhihu.com/p/131584831 Windows包管理 Scoop Scoop 是 Windows 的命令行安装程序，是一个强大的包管理工具\n项目地址\n使用教程\nChocolatey choro Windows软件管理工具Chocolatey的安装和使用\nwinget 官方推出 谁用Windows 终端安装程序？ 我！\n# 使用 WinGet 安装一遍 winget install postman winget search postman # 卸载，再用 Scoop 安装一遍 scoop install postman vcpkg C/C++ 库管理工具，跨平台 Get started with vcpkg\ncget https://cget.readthedocs.io/en/latest/#\n开源库集成器Vcpkg全教程\nWSL 安装ubuntu20.04 安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe\n卸载wsl wslconfig /l # 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令 wslconfig /u Ubuntu 参考链接：WSL系列操作：安装，卸载\n设置wsl # 更改默认root用户登录 ubuntu1804.exe config --default-user root # 更改默认登陆目录 # list 中 Ubuntu-20.04 条目中添加 \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu-20.04\u0026#34; # 以管理员权限运行cmd # 停止 net stop LxssManager # 启动 net start LxssManager 图床 https://blog.csdn.net/qq_44314954/article/details/122951033\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;未整理部分\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nrustdesk 远程开源软件\nmaya\nimagine\nscreentogif\nditto\nbleachbit\nqbittorrent\ngrammarly\npotplayer https://iptv-org.github.io/iptv/index.m3u\n剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键\n线上思维导图 https://gitmind.cn/app/template 在线文档转换 https://www.aconvert.com/cn/ 开源软件下载网站 https://www.fosshub.com/#\nwindows ternial 添加 git base 到ternial chrome插件 油猴\nwindows输入英文中间有间隙 进入了全角模式，选择半角即可\nReact Router http://react-guide.github.io/react-router-cn/index.html\nyoutube 下载 https://www.ganbey.com/youtube-download-3774\nzlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\ngdb https://leetcode-cn.com/circle/article/7mxorv\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/windowssoftware/","summary":"CMD命令 # 查询本机IP ipconfig # 向对方电脑发送消息 msg /server 192.168.1.100 * 消息 # 查看本机用户信息 net user # 查看共享资源 net share # 查看网站IP nsloopup www.baidu.com # 查看WiFi配置文件 netsh","title":"WindowsSoftware"},{"content":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04\nWindows\n镜像烧录工具 软碟通UltraISO 写入镜像，树莓派刷镜像\nVentoy 官方网站 Ventoy支持多个ISO镜像，开源，支持Linux和Windows ventoy详细使用教程 制作完启动盘，将ISO复制到U盘即可\nWinPE 支持多镜像 支持多镜像\n安装系统 小米 F2设置boot密码，重启F12安装Ubuntu\nThinkpad 1.关闭bitlocker 2.f1进入bios关闭security boot 3.f12进入boot，选择启动U盘\nQ\u0026amp;A 什么功能Windows上有，在Linux没有又没有替代方法 ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","summary":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04 Windows 镜像烧录工具 软碟通UltraISO 写入镜像，树莓派刷镜像 Ventoy 官方网站 Ventoy支持多个ISO镜像，开源，支持","title":"系统安装"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/movie/movie/","summary":"","title":"Movie"},{"content":" QMD 《如愿》-王菲 天后依然\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/music/music/","summary":"QMD 《如愿》-王菲 天后依然","title":"Music"},{"content":"软件故事 1946年 ENIAC\n批处理系统 硬件发展-》 分时系统 机器语言\u0026ndash;纸带 汇编语言\u0026ndash; 指令 操作 Fortran语言 - 第一种高级计算机语言 COBOL 语言 BASIC\n卡耐基 \u0026ndash; 人工智能\nIBM 701 704(Fortran商用) IBM OS/360\n存储时计算机\nUnix c 语言\n欧洲计算机技术： linux 芬兰 万维网 瑞典\nAPPLE II Macish\n微软 收购DOS\nwindows BASIC\n鼠标、 显示器\nC++\nJava Java与互联网\n阿帕奇 IBM linux\n硅谷百年 硅谷 斯坦福、伯克利、圣何塞大学\n特曼\n真空管、晶体管、集成电路 仙童半导体 - 八叛徒 英特尔、AMD、英伟达\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/computerbook/","summary":"\u003ch2 id=\"软件故事\"\u003e软件故事\u003c/h2\u003e\n\u003cp\u003e1946年 ENIAC\u003c/p\u003e\n\u003cp\u003e批处理系统\n硬件发展-》 分时系统\n机器语言\u0026ndash;纸带\n汇编语言\u0026ndash; 指令 操作\nFortran语言 - 第一种高级计算机语言\nCOBOL 语言\nBASIC\u003c/p\u003e","title":"computerbook"},{"content":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使\n《局外人》 加缪 个人主义，无知是最大的邪恶 《culture evolution》 文化的演进 ronald inglehart教授 什么原因猝发个人主义\n《结构性思维》\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/readingplan/","summary":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使 《局外人》 加缪 个人主义，无知是最大的邪恶 《cultur","title":"Reading Plan"},{"content":"豆豆三部曲 《背叛》 《遥远的救世主》 《天幕红尘》\n在细雨中呼唤 余华 普通农村少年以旁观者角度叙述自己的童年少年成长，世间人都处于一辆时光列车中，其中遇到的人和事，不管他们是好的还是坏的，未来的未知都无可逃避，唯一能做好的就是：好好活着，珍惜眼前的一切，做最好的自己。\n死亡不是失去生命，只是走出了时间\n通往奴役之路 如果我们仅仅只是一部无人性的机器中的一个齿轮，这也许不是好事情；但如果我们再也无法脱离它，被束缚在为我们选定的那些上级的身边，那么情况就不知道要糟糕多少倍。当每个人意识到他的命运的不满，就会同他的这种意识一起成长。\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/read/","summary":"豆豆三部曲 《背叛》 《遥远的救世主》 《天幕红尘》 在细雨中呼唤 余华 普通农村少年以旁观者角度叙述自己的童年少年成长，世间人都处于一辆时光列车中，其","title":"读书"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/","summary":"","title":"闲言碎语"},{"content":"编译 注意wsl中需要root用户编译 https://dynamorio.org/page_building.html cmake \\ -DCMAKE_TOOLCHAIN_FILE=/mnt/e/code/dynamorio/make/toolchain-android=arm64.cmake \\ -DANDROID_TOOLCHAIN=/android_toolchain_using \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio cmake \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio 学习链接 DynamoRIO进阶指南 https://blog.csdn.net/oShuangYue12/article/details/109780166 ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/dynamorio/","summary":"\u003ch2 id=\"编译\"\u003e编译\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e注意wsl中需要root用户编译\n\u003ca href=\"https://dynamorio.org/page_building.html\"\u003ehttps://dynamorio.org/page_building.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_TOOLCHAIN_FILE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/mnt/e/code/dynamorio/make/toolchain-android\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003earm64.cmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DANDROID_TOOLCHAIN\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/android_toolchain_using \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"DynamoRIO"},{"content":"总结 leetcode基础题目 经典题目： 3.无重复字符的最长子串 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476. 617. 701. 938. 1089. 1207.\n1.两数之和 思路：两层遍历\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) { int i, j; int *ret = (int *)malloc(sizeof(int) * 2); for (i = 0; i \u0026lt; numsSize; i++) { int key = target - nums[i]; for (j = i + 1; j \u0026lt; numsSize; j++) { if (nums[j] == key) { ret[0] = i; ret[1] = j; } } } *returnSize = 2; return ret; } 2.两数相加 思路：两个链表，判断链表是否为空or，求和不为空链表节点值，第一次添加头节点，之后添加到尾节点，注意处理进位\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) { struct ListNode *head = NULL, *tail = NULL; int carry = 0; while (l1 || l2) { int n1 = l1 ? l1-\u0026gt;val : 0; int n2 = l2 ? l2-\u0026gt;val : 0; int sum = n1 + n2 + carry; if (!head) { head = tail = malloc(sizeof(struct ListNode)); tail-\u0026gt;val = sum % 10; tail-\u0026gt;next = NULL; } else { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = sum % 10; tail = tail-\u0026gt;next; tail-\u0026gt;next = NULL; } carry = sum / 10; if (l1) { l1 = l1-\u0026gt;next; } if (l2) { l2 = l2-\u0026gt;next; } } if (carry \u0026gt; 0) { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = carry; tail-\u0026gt;next-\u0026gt;next = NULL; } return head; } 3.无重复字符的最长子串 思路：双指针，前后快慢指针，table表标记字符是否出现过，right标记，left去除标记，求right-left最大值\nint lengthOfLongestSubstring(char * s){ int len = strlen(s); printf(\u0026#34;len = %d\\n\u0026#34;, len); int left = 0; int right = 0; char table[256] = {0}; int maxLen = 0; while (right \u0026lt; len) { printf(\u0026#34;%d \\t\u0026#34;, right); if (table[s[right]] == 0) { table[s[right]] = 1; right++; //} else if (table[s[right]] == 1) { } else { table[s[left]] = 0; left++; } maxLen = fmax(maxLen, right - left); } return maxLen; } 4.寻找两个正序数组的中位数 思路：每个数组各自索引，判断大小移动索引，最后判断是奇数还是偶数\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){ int sum = nums1Size + nums2Size; int *nums = (int *)malloc(sizeof(int) * sum); int i = 0, j = 0, k = 0; int half = sum / 2 + 1; while (k \u0026lt; half) { int n; if (i \u0026lt; nums1Size \u0026amp;\u0026amp; j \u0026lt; nums2Size) { n = (nums1[i] \u0026lt; nums2[j]) ? nums1[i++] : nums2[j++]; } else if (i \u0026lt; nums1Size) { n = nums1[i++]; } else if (j \u0026lt; nums2Size) { n = nums2[j++]; } nums[k++] = n; } if (sum % 2 == 0) { return (nums[k-1] + nums[k-2]) / 2.0; } else { return nums[k-1]; } } 6.Z 字形变换 思路：计算位置？\nchar * convert(char * s, int numRows){ uint16_t len = strlen(s); if (len \u0026lt; numRows) { numRows = len; } char* out = calloc(len + 1, sizeof(char)); if (numRows \u0026lt; 2) { memcpy(out, s, len + 1); return out; } uint16_t max = numRows - 1; uint16_t rr = 2 * max; uint16_t i = 0; uint16_t o = 0; uint16_t delta = 0; // first row while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } // middle rows for (uint16_t l = 1; l \u0026lt; max; l++) { i = l; delta = 2 * l; while (i \u0026lt; len) { out[o++] = s[i]; delta = rr - delta; i += delta; } } // last row i = max; while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } return out; } 7.整数反转 思路：(取余数)* 10，注意越界，INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7\nint reverse(int x){ int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev \u0026gt; INT_MAX / 10 || (rev == INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7)) return 0; if (rev \u0026lt; INT_MIN / 10 || (rev == INT_MIN / 10 \u0026amp;\u0026amp; pop \u0026lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } 8.字符串转换整数 (atoi) 思路：\nint myAtoi(char * s){ long flag = 1; long num = 0; //int singleRes=0; while(*s == \u0026#39; \u0026#39;) { s++; } if(*s==\u0026#39;-\u0026#39;) { flag=-1; s++; } else if (*s==\u0026#39;+\u0026#39;) { s++; flag=1; } while(*s!=\u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; (*s\u0026lt;=\u0026#39;9\u0026#39; \u0026amp;\u0026amp; *s\u0026gt;=\u0026#39;0\u0026#39;)) { if(num\u0026gt;INT_MAX/10 || (num==INT_MAX/10 \u0026amp;\u0026amp; *s\u0026gt;\u0026#39;7\u0026#39;)){//因为是从正数转化为负数，所以要都按正数溢出标准 if(flag==1) { return INT_MAX; } else { return INT_MIN; } } else { num=num*10+(*s-\u0026#39;0\u0026#39;); s++; } } if(flag==1) { return num; } else { return -num; } } int myAtoi(char * s){ int minusFlag = 0; int length = strlen(s); long int result = 0; char numberBuffer[11]; int counter = 0; while (s[counter] == \u0026#39; \u0026#39;) { counter++; } s = \u0026amp;s[counter]; counter = 0; for (int i = 0; i \u0026lt; length; i++) { if (i == 0) { if (s[0] == \u0026#39;-\u0026#39;) { minusFlag = 1; i++; } else if (s[0] == \u0026#39;+\u0026#39;) { i++; } } if (counter \u0026gt; 10) { if (minusFlag) { return __INT_MAX__ * -1 - 1; } else { return __INT_MAX__; } } if (s[i] \u0026lt; \u0026#39;0\u0026#39; || s[i] \u0026gt; \u0026#39;9\u0026#39;) { break; } if (counter == 0 \u0026amp;\u0026amp; s[i] == \u0026#39;0\u0026#39;) { continue; } numberBuffer[counter] = s[i]; counter++; } int i = 0; while (counter \u0026gt; 0) { if (minusFlag) { result -= (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } else { result += (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } i++; counter--; } if (result \u0026gt; __INT_MAX__) { return __INT_MAX__; } else if (result \u0026lt; __INT_MAX__ * -1 - 1) { return __INT_MAX__ * -1 - 1; } return result; } 9.回文数 思路：将每一位按序装入数组，遍历数组首尾是否相等 ; 递归\nbool isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int table[20] = {0}; int count = 0; while (x) { table[count++] = x % 10; x = x / 10; printf(\u0026#34;x = %d\\n\u0026#34;, x); } for (int i = 0; i \u0026lt; count / 2; i++) { if (table[i] != table[count - i - 1]) { return false; } } return true; } bool isPalindrome(int x){ if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } 11.盛最多水的容器 思路：双指针，头尾向中间\nint maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int maxNum = 0; while (left \u0026lt; right) { int hMax = fmin(height[left], height[right]); int tmp = hMax * (right - left); maxNum = fmax(maxNum, tmp); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return maxNum; } int maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int mArea = 0; while (left \u0026lt; right) { int h = fmin(height[left], height[right]); int m = h * (right - left); mArea = fmax(mArea, m); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return mArea; } int maxArea(int* height, int heightSize){ // Start with maximum container width int start = 0; int end = heightSize - 1; int res = 0; while (start \u0026lt; end) { // Calculate current area by taking minimum of two heights int currArea = (end - start) * fmin(height[start], height[end]); if (currArea \u0026gt; res) res = currArea; if (height[start] \u0026lt; height[end]) { start = start + 1; } else { end = end - 1; } } return res; } 12.整数转罗马数字 思路：\nconst int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; const char* symbols[] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; char* intToRoman(int num) { char* roman = malloc(sizeof(char) * 16); roman[0] = \u0026#39;\\0\u0026#39;; for (int i = 0; i \u0026lt; 13; i++) { while (num \u0026gt;= values[i]) { num -= values[i]; strcpy(roman + strlen(roman), symbols[i]); } if (num == 0) { break; } } return roman; } char *getOne(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;IX\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;VIII\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;VII\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;VI\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;V\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;IV\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;III\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;II\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;I\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getTen(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;XC\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;LXXX\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;LXX\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;LX\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;L\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;XL\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;XXX\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;XX\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;X\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getHundred(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;CM\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;DCCC\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;DCC\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;DC\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;D\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;CD\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;CCC\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;CC\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;C\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getThousand(char c) { switch (c) { case \u0026#39;3\u0026#39;: return \u0026#34;MMM\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;MM\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;M\u0026#34;; default: return NULL; } } char * intToRoman(int num){ int length; char number[5]; char *s = malloc(16 * sizeof(char)); sprintf(number, \u0026#34;%i\u0026#34;, num); length = strlen(number); switch (length) { case 4: sprintf(s, \u0026#34;%s%s%s%s\u0026#34;, getThousand(number[0]), getHundred(number[1]), getTen(number[2]), getOne(number[3])); break; case 3: sprintf(s, \u0026#34;%s%s%s\u0026#34;, getHundred(number[0]), getTen(number[1]), getOne(number[2])); break; case 2: sprintf(s, \u0026#34;%s%s\u0026#34;, getTen(number[0]), getOne(number[1])); break; case 1: s = getOne(number[0]); break; default: break; } return s; } 13.罗马数字转整数 思路：\nint romanToInt(char * s){ int romanToInt = 0; for (int i = 0; i \u0026lt; strlen(s); i++) { switch (s[i]) { case \u0026#39;I\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;V\u0026#39; || s[i + 1] == \u0026#39;X\u0026#39;) { romanToInt -= 1; break; } } romanToInt += 1; break; case \u0026#39;V\u0026#39;: romanToInt += 5; break; case \u0026#39;X\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;L\u0026#39; || s[i + 1] == \u0026#39;C\u0026#39;) { romanToInt -= 10; break; } } romanToInt += 10; break; case \u0026#39;L\u0026#39;: romanToInt += 50; break; case \u0026#39;C\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;D\u0026#39; || s[i + 1] == \u0026#39;M\u0026#39;) { romanToInt -= 100; break; } } romanToInt += 100; break; case \u0026#39;D\u0026#39;: romanToInt += 500; break; case \u0026#39;M\u0026#39;: romanToInt += 1000; break; default: break; } } return romanToInt; } 20.有效的括号 思路：配对判断\nbool isValid(char * s) { int i, k = 0, len = strlen(s); char *store = calloc(len, sizeof(char)); for (i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { switch (s[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;{\u0026#39;: case \u0026#39;[\u0026#39;: store[k++] = s[i]; break; case \u0026#39;)\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;(\u0026#39;) goto out; break; case \u0026#39;}\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;{\u0026#39;) goto out; break; case \u0026#39;]\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;[\u0026#39;) goto out; break; } } out: free(store); return s[i] == \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; k == 0; } 21.合并两个有序链表 思路：先添加头，然后判断 l1 != NULL \u0026amp;\u0026amp; l2 != NULL 添加谁\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode* head = NULL; struct ListNode* tmp = NULL; if (l1 == NULL) { return l2; } if (l2 == NULL) { return l1; } if (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { head = tmp = l1; l1 = l1-\u0026gt;next; } else { head = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) { tmp-\u0026gt;next = l1; } if (l2) { tmp-\u0026gt;next = l2; } return head; } return NULL; } struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode *list = NULL; struct ListNode *tmp = NULL; if (!l1) return l2; if (!l2) return l1; if (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { list = tmp = l1; l1 = l1-\u0026gt;next; } else { list = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) tmp-\u0026gt;next = l1; if (l2) tmp-\u0026gt;next = l2; return list; } return NULL; } /* if (!list1) return list2; if (!list2) return list1; if (list1-\u0026gt;val \u0026lt; list2-\u0026gt;val) { list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next, list2); return list1; } else { list2-\u0026gt;next = mergeTwoLists(list1, list2-\u0026gt;next); return list2; } */ 24.两两交换链表中的节点 思路：递归；借助节点\nstruct ListNode* swapPairs(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* first = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); first-\u0026gt;next = head; head = head-\u0026gt;next; return first; } struct ListNode* swapPairs(struct ListNode* head) { if (!head || !head-\u0026gt;next) return head; struct ListNode *tmp = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); tmp-\u0026gt;next = head; return tmp; } 26.删除有序数组中的重复项 思路：++\nint removeDuplicates(int* nums, int numsSize) { if(numsSize == 0) { return 0; } int fast = 1, low = 0; while (fast \u0026lt; numsSize) { if (nums[fast] != nums[low]) { nums[low + 1] = nums[fast]; low++; } fast++; } return low + 1; } int removeDuplicates(int* nums, int numsSize) { int count = 0, i; for (i = 1; i \u0026lt; numsSize; i++) { if (nums[i] == nums[i - 1]) count++; else nums[i - count] = nums[i]; } return numsSize - count; } 27.移除元素 思路：nums[start++] = nums[i];\nint removeElement(int* nums, int numsSize, int val){ int i, start = 0; for (i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != val) { nums[start++] = nums[i]; } } return start; } 28.实现 strStr() 思路：\nint strStr(char * haystack, char * needle){ int i = 0; int j = 0; int k = 0; int hlen = 0; int nlen = 0; if (needle == NULL || *needle == 0) return 0; if (haystack == NULL || *haystack == 0) return -1; hlen = strlen(haystack); nlen = strlen(needle); if (hlen \u0026lt; nlen) return -1; for (i = 0; i \u0026lt;= hlen - nlen; i++) { j = 0; if (haystack[i] != needle[j++]) continue; k = i + 1; for (; j \u0026lt; nlen; j++) { if (haystack[k] != needle[j]) { break; } else { k++; } } if (j == nlen) return i; } return -1; } 29.两数相除 思路：\nint divide(int dividend, int divisor) { int cnt = 0; int sign = 1; if ((dividend ^ divisor) \u0026lt; 0) { // 两数任意一个为负数 sign = -1; } if (divisor == INT_MIN) { // 除数边界值特殊处理 if (dividend == INT_MIN) { return 1; } else { return 0; } } if (dividend == INT_MIN) { // 被除数边界值特殊处理 if (divisor == -1) { return INT_MAX; } else if (divisor == 1) { return INT_MIN; } dividend += abs(divisor); // 先执行一次加操作，避免abs转换溢出 cnt++; } int a = abs(dividend); int b = abs(divisor); while (a \u0026gt;= b) { int c = 1; int s = b; // 需指数级快速逼近，以避免执行超时 while (s \u0026lt; (a \u0026gt;\u0026gt; 1)) { // 逼近至一半，同时避免溢出 s += s; c += c; } cnt += c; a -= s; } return (sign == -1) ? -cnt : cnt; } int divide(int dividend, int divisor){ int sign = 1; long int output = 0; if (dividend \u0026lt; 0) { sign *= -1; } else { dividend *= -1; } if (divisor \u0026lt; 0) { sign *= -1; } else { divisor *= -1; } while (dividend \u0026lt;= divisor) { long int tmp = 0; long int div = divisor; while (dividend \u0026lt;= div) { tmp += (tmp + 1); dividend -= div; div += div; } if (output \u0026gt;= INT_MAX) { if (sign == -1) { return INT_MIN; } else { return INT_MAX; } } output += tmp; } return output * sign; } 35.搜索插入位置 思路：\nint searchInsert(int* nums, int numsSize, int target) { int left = 0; int right = numsSize - 1; int mid; while (left \u0026lt;= right) { // mid = (right + left) / 2; mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return left; } int searchInsert(int* nums, int numsSize, int target) { int idx = numsSize - 1; if (numsSize \u0026gt; 0) { if (target \u0026gt; nums[idx]) { return numsSize; } return searchInsert(nums, numsSize - 1, target); } return 0; } 38.外观数列 思路：\nchar * countAndSay(int n) { char *p = (char *)malloc(5000); char *p1 = (char *)malloc(5000); p[0] = \u0026#39;1\u0026#39;; p[1] = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt; n; ++i) { int x = 0; for(int j = 0; p[j]; ++j) { int y = 1; //计数器 while (p[j+1] \u0026amp;\u0026amp; p[j] == p[j+1]) { ++y; ++j; } p1[x++] = y+48; p1[x++] = p[j]; } strcpy(p, p1); p[x] = \u0026#39;\\0\u0026#39;; } return p; } char * countAndSay(int n) { // Calculating the length of array double result = 1.0; for (int i = 0; i \u0026lt; n - 1; i++) { result *= 1.4; } int k, j, count, convert = (int)result; // Creating array with the length calculated above char *arr = malloc(convert + 4); arr[0] = \u0026#39;1\u0026#39;; arr[1] = \u0026#39;\\0\u0026#39;; for (int i = 2, length; i \u0026lt;= n; i++) { length = strlen(arr); char newArr[length * 2]; strcpy(newArr, arr); k = 0; j = 0; count = 1; while (newArr[j] != \u0026#39;\\0\u0026#39;) { if (newArr[j] == newArr[j + 1]) { count++; j++; } else { arr[k] = (48 + count); arr[k + 1] = newArr[j]; arr[k + 2] = \u0026#39;\\0\u0026#39;; j++; k += 2; count = 1; } } } return arr; } 53.最大子数组和 思路：累加，动态规划\nint maxcmp(int a, int b) { return a \u0026gt;= b ? a : b; } int maxSubArray(int* nums, int numsSize) { int maxSoFar = nums[0]; int maxEndingHere = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]); maxSoFar = maxcmp(maxSoFar, maxEndingHere); } return maxSoFar; } 66.加一 思路：判断是否发生进位，最后判断最高位是否进位\n// The returned array must be malloced, assume caller calls free(). int *plusOne(int *digits, int digitsSize, int *returnSize) { for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { if (digits[i] \u0026lt; 9) { digits[i]++; *returnSize = digitsSize; return digits; } else { digits[i] = 0; } } int* newdigit = (int *)malloc(sizeof(int) * (digitsSize + 1)); newdigit[0] = 1; for (int i = 1; i \u0026lt; (digitsSize + 1); i++) { newdigit[i] = digits[i-1]; } *returnSize = digitsSize + 1; return newdigit; } int* plusOne(int* digits, int digitsSize, int* returnSize) { *returnSize = digitsSize; digits[digitsSize - 1] += 1; int carry = digits[digitsSize - 1] / 10; for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { digits[i] = (carry + digits[i]) % 10; int t = carry; carry = (carry + digits[i]) / 10; printf(\u0026#34;carry = %d\\n\u0026#34;, carry); } if (carry == 1) { *returnSize = digitsSize + 1; int *res = malloc(sizeof(int) * (*returnSize)); res[0] = 1; for (int i = 0; i \u0026lt; digitsSize; i++) { res[i+1] = digits[i]; } return res; } return digits; } 82.删除排序链表中的重复元素 II 思路：递归，判断是否和下一个链表值相等\nstruct ListNode* deleteDuplicates(struct ListNode* head) { /* if (head == NULL) { return NULL; } if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; */ if (head == NULL) return NULL; if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { /* Remove all duplicate numbers */ while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; } 83.删除排序链表中的重复元素 思路：判断相等，next = next-\u0026gt;next\n/* struct ListNode* deleteDuplicates(struct ListNode* head){ if (head == NULL) { return NULL; } int table[201] = {0}; struct ListNode* cur = head; table[cur-\u0026gt;val + 100] = 1; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next) { if (table[cur-\u0026gt;next-\u0026gt;val + 100] == 1) { if (cur-\u0026gt;next-\u0026gt;next != NULL) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; continue; } else { cur-\u0026gt;next = NULL; break; } } else { table[cur-\u0026gt;next-\u0026gt;val + 100] = 1; } cur = cur-\u0026gt;next; } return head; } */ struct ListNode* deleteDuplicates(struct ListNode* head) { struct ListNode* cur = head; while (cur \u0026amp;\u0026amp; cur-\u0026gt;next) { if (cur-\u0026gt;val == cur-\u0026gt;next-\u0026gt;val) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; } else { cur = cur-\u0026gt;next; } } return head; } /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* deleteDuplicates(struct ListNode* head) { if (head == NULL) { return NULL; } else { struct ListNode* s = head; struct ListNode* t = head-\u0026gt;next; while (t != NULL) { if (s-\u0026gt;val == t-\u0026gt;val) { struct ListNode* y; y=s-\u0026gt;next; s-\u0026gt;next=t-\u0026gt;next; t=y-\u0026gt;next; free(y); } else { s=s-\u0026gt;next; t=t-\u0026gt;next; } } } return head; } 84.柱状图中最大的矩形 思路：单调栈？\nint largestRectangleArea(int* heights, int heightsSize){ /* int *data = (int*)malloc(sizeof(int) * (heightsSize + 2)); int *stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); //给heights前后+0，成新数组data data[0] = 0; for (int i = 1; i \u0026lt;= heightsSize; i++) { data[i] = heights[i - 1]; } data[heightsSize + 1] = 0; int j = 0, area = 0; stack[j] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; data[stack[j]] \u0026gt;= data[i]) { int sidx = stack[j - 1]; int h = data[stack[j]]; //area = fmax(area, data[stack[top]] * (i - stack[top - 1] - 1)); area = fmax(area, h * (i - sidx - 1)); j--; } stack[++j] = i; } return area; */ int* stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); int* nheights = (int*)malloc(sizeof(int) * (heightsSize + 2)); for (int i = 0; i \u0026lt; heightsSize; i++) { nheights[i+1] = heights[i]; } nheights[0] = 0; nheights[heightsSize + 1] = 0; int maxArea = 0; int top = 0; stack[top] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (top \u0026gt; 0 \u0026amp;\u0026amp; nheights[stack[top]] \u0026gt;= nheights[i]) { int h = nheights[stack[top]]; int s = stack[top - 1]; int area = nheights[stack[top]] * (i - s -1); maxArea = fmax(maxArea, area); top--; } top++; stack[top] = i; } return maxArea; } void showIntArr(const char *brief, int *arr, uint32_t nums) { printf(\u0026#34;%s:\u0026#34;, brief); for (uint32_t i = 0; i \u0026lt; nums; i++) { printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); return; } int largestRectangleArea(int* heights, int heightsSize){ int *stack = (int *)malloc(sizeof(int) * (heightsSize + 1)); uint32_t stackIdx = 0; int maxAns = 0; int tmpAns = 0; int high = 0; int wide = 0; stack[stackIdx++] = -1; for (uint32_t i = 0; i \u0026lt; heightsSize; i++) { //showIntArr(\u0026#34;stack\u0026#34;, stack, stackIdx); if (stackIdx == 1) { /* 单调栈为空 */ stack[stackIdx++] = i; continue; } // printf(\u0026#34;stackIdx - 1 [%d]\\n\u0026#34;, stackIdx - 1); if (heights[i] \u0026gt;= heights[stack[stackIdx - 1]]) { stack[stackIdx++] = i; continue; } while ((stackIdx \u0026gt; 1) \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stack[stackIdx - 1]]) { /* 遍历到的元素小于栈顶元素 */ high = heights[stack[stackIdx - 1]]; stackIdx--; wide = i - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;i[%u] high[%d] wide[%d]\\n\u0026#34;, i, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } stack[stackIdx++] = i; } while (stackIdx \u0026gt; 1) { high = heights[stack[stackIdx - 1]]; stackIdx--; wide = heightsSize - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;ele[%d] high[%d] wide[%d]\\n\u0026#34;, heightsSize, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } return maxAns; } 94.二叉树的中序遍历 思路：递归，中序，注意封装递归函数\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void processTraversal(struct TreeNode* root, int* res, int* size) { if (!root) { return; } processTraversal(root-\u0026gt;left, res, size); res[*size] = root-\u0026gt;val; *size += 1; processTraversal(root-\u0026gt;right, res, size); } int* inorderTraversal(struct TreeNode* root, int* returnSize){ int* res = malloc(sizeof(int) * 256); *returnSize = 0; processTraversal(root, res, returnSize); return res; } 101.对称二叉树 思路：递归判断，注意递归出口判断条件\nbool checkSymmetric(struct TreeNode *left, struct TreeNode *right) { if (!left || !right) return left == right; if (left-\u0026gt;val != right-\u0026gt;val) return 0; return checkSymmetric(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; checkSymmetric(left-\u0026gt;right, right-\u0026gt;left); } bool isSymmetric(struct TreeNode *root) { return root == NULL || checkSymmetric(root-\u0026gt;left, root-\u0026gt;right); } 104.二叉树的最大深度 思路：求树深度递归 return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxval(int a, int b) { return a \u0026gt; b ? a : b; } int maxDepth(struct TreeNode *root) { if (root == NULL) { return 0; } return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 1; } return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } int maxDepth(struct TreeNode* root) { if (root == NULL) { return 0; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return fmax(left, right); } 108.将有序数组转换为二叉搜索树 思路：递归处理从中间分左右两部分，先添加当前节点在递归。\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* convertBST(int* nums, int left, int right) { if (left \u0026gt; right) { return NULL; } else { int mid = (right + left) / 2; struct TreeNode* new_val = malloc(sizeof(struct TreeNode)); new_val-\u0026gt;val = nums[mid]; new_val-\u0026gt;left = convertBST(nums, left, mid - 1); new_val-\u0026gt;right = convertBST(nums, mid + 1, right); return new_val; } } struct TreeNode* sortedArrayToBST(int* nums, int numsSize){ if (numsSize == 0) { return NULL; } return convertBST(nums, 0, numsSize - 1); } 109.有序链表转换二叉搜索树 思路：先找到中间节点和尾节点，将中间节点添加到树上，递归处理中间节点前部和后部两部分，递归出口为找不着新节点\n/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* buildBST(struct ListNode* head, struct ListNode* tail) { if (head == tail) { return NULL; } struct ListNode* slow = head; struct ListNode* fast = head; while (fast != tail \u0026amp;\u0026amp; fast-\u0026gt;next != tail) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } //struct TreeNode* node = (struct TreeNode)malloc(sizeof(struct TreeNode)); struct TreeNode *node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = slow-\u0026gt;val; node-\u0026gt;left = buildBST(head, slow); node-\u0026gt;right = buildBST(slow-\u0026gt;next, tail); return node; } struct TreeNode* sortedListToBST(struct ListNode* head){ if (!head) { return NULL; } return buildBST(head, NULL); } 110.平衡二叉树 思路：分别求左右子树的深度height，比较左右深度差值。递归判断左右子树是否为平衡二叉树\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 0; } else { return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } } bool isBalanced(struct TreeNode* root){ if (root == NULL) { return 1; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return abs(left - right) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } 112. 路径总和 思路：递归：左右子树 递归出口； 注意书判空\nbool hasPathSum(struct TreeNode* root, int targetSum){ if (root == NULL) { return false; } if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL \u0026amp;\u0026amp; root-\u0026gt;val == targetSum) { return true; } return hasPathSum(root-\u0026gt;left, targetSum - root-\u0026gt;val) || hasPathSum(root-\u0026gt;right, targetSum - root-\u0026gt;val); } 121.买卖股票的最佳时机 思路：动态规划，股票是连续收益的 maxcmp(0, maxCur + prices[i] - prices[i - 1])，收益累计\nint maxcmp(int a, int b) { return (a \u0026gt;= b) ? a : b; } int maxProfit(int* prices, int pricesSize){ int maxCur = 0, maxSoFar = 0; for (int i = 1; i \u0026lt; pricesSize; i++) { maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]); maxSoFar = maxcmp(maxSoFar, maxCur); printf(\u0026#34;i = %d\\t maxCur = %d \\t maxSoFar = %d\\n\u0026#34;, i, maxCur, maxSoFar); } return maxSoFar; } 125.验证回文串 思路：判断是否是字母和数字，库函数 isalnum; 注意库函数 isalpha 为判断是否为字母。头尾双指针，逼近中间，注意非数字字母忽略\nbool isPalindrome(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt;= right) { //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[left])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left])) { left++; } //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[right])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right])) { right--; } printf(\u0026#34;left = %d\\t right = %d\\n\u0026#34;, left, right); if (tolower(s[left]) != tolower(s[right])) { return false; } left++; right--; } return true; } 136.只出现一次的数字 思路：n ^ n = 0 一个数与自己异或为 0\nint singleNumber(int* nums, int numsSize){ int res = 0; for (int i = 0; i \u0026lt; numsSize; i++) { res = res ^ nums[i]; } return res; } 141.环形链表 思路：快慢双指针，fast一次走两步，slow一次走一步，判断是否能相遇\nbool hasCycle(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; while (slow \u0026amp;\u0026amp; fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { return true; } } return false; } 142.环形链表 II 思路：快慢双指针，判断出环向后，从链表入口开始，和slow指针相同速度遍历，直到相遇\nstruct ListNode *detectCycle(struct ListNode *head) { struct ListNode* slow = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* fast = (struct ListNode*)malloc(sizeof(struct ListNode)); slow = head; fast = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { struct ListNode* entry = head; while (slow != entry) { slow = slow-\u0026gt;next; entry = entry-\u0026gt;next; } return entry; } } return NULL; } 153.寻找旋转排序数组中的最小值 思路：二分查找\nint findMin(int* nums, int numsSize){ int low = 0; int high = numsSize - 1; while (low \u0026lt; high) { int mid = low + (high - low) / 2; if (nums[mid] \u0026lt; nums[high]) { high = mid; } else { low = mid + 1; } } return nums[low]; } int findMin(int* nums, int numsSize){ int i; for (i = 0; i \u0026lt; numsSize - 1; i++) { if (nums[i] \u0026gt; nums[(i+1)]) { return nums[i+1]; } } return nums[0]; } 160.相交链表 思路： 一、 二、先统计两个链表结点个数，然后长链表先走个数差位\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *cur1 = headA; struct ListNode *cur2 = headB; if (cur1 == NULL || cur2 == NULL) return NULL; while (cur1 \u0026amp;\u0026amp; cur2 \u0026amp;\u0026amp; cur1 != cur2) { cur1 = cur1-\u0026gt;next; cur2 = cur2-\u0026gt;next; if (cur1 == cur2) { return cur1; } if (!cur1) { cur1 = headB; } if (!cur2) { cur2 = headA; } } return cur1; } 169.多数元素 思路：选定一个主元素，计数器\nint majorityElement(int* nums, int numsSize){ int count = 1; int majorNum = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { if (count == 0) { majorNum = nums[i]; count++; } else if (majorNum == nums[i]) { count++; } else { count--; } } return majorNum; } 173.二叉搜索树迭代器 思路：\ntypedef struct { int* res; int size; int idx; } BSTIterator; int getTreeSize(struct TreeNode* root) { if (root == NULL) { return 0; } return 1 + getTreeSize(root-\u0026gt;left) + getTreeSize(root-\u0026gt;right); } void inorder(int* ret, int* retSize, struct TreeNode* root) { if (root == NULL) { return; } inorder(ret, retSize, root-\u0026gt;left); ret[(*retSize)++] = root-\u0026gt;val; inorder(ret, retSize, root-\u0026gt;right); } int* inorderTraversal(int* retSize, struct TreeNode* root) { *retSize = 0; int* ret = malloc(sizeof(int) * getTreeSize(root)); inorder(ret, retSize, root); return ret; } BSTIterator* bSTIteratorCreate(struct TreeNode* root) { BSTIterator* ret = malloc(sizeof(BSTIterator)); ret-\u0026gt;res = inorderTraversal(\u0026amp;(ret-\u0026gt;size), root); ret-\u0026gt;idx = 0; return ret; } int bSTIteratorNext(BSTIterator* obj) { return obj-\u0026gt;res[(obj-\u0026gt;idx)++]; } bool bSTIteratorHasNext(BSTIterator* obj) { return (obj-\u0026gt;idx \u0026lt; obj-\u0026gt;size); } void bSTIteratorFree(BSTIterator* obj) { free(obj-\u0026gt;res); free(obj); } 189.轮转数组 思路： 一、每次移动一个数 二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个\nvoid moveOne(int* nums, int numsSize) { int tmp = nums[numsSize - 1]; for (int i = numsSize - 1; i \u0026gt; 0; i--) { nums[i] = nums[i-1]; } nums[0] = tmp; } void rotate(int* nums, int numsSize, int k) { for (int i = 0; i \u0026lt; k; i++) { moveOne(nums, numsSize); } } /* */ void swap(int* a, int* b) { int t = *a; *a = *b; *b = t; } void reverse(int* nums, int start, int end) { while (start \u0026lt; end) { swap(\u0026amp;nums[start], \u0026amp;nums[end]); start += 1; end -= 1; } } void rotate(int* nums, int numsSize, int k) { k %= numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, k - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, k, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); } /* void rotate(int* nums, int numsSize, int k){ for (int i = 0; i \u0026lt; k; i++) { int lastElement = nums[numsSize - 1]; for (int j = numsSize - 1; j \u0026gt; 0; j--) { nums[j] = nums[j - 1]; } nums[0] = lastElement; } }*/ /* void rotate(int* nums, int numsSize, int k){ if (k == numsSize / 2 \u0026amp;\u0026amp; numsSize % 2 != 1) { for (int i = 0; i \u0026lt; k; i++) { int tmp = nums[i]; nums[i] = nums[k+i]; nums[k+i] = tmp; } return; } int i = 0; int tmp = nums[0]; int p = 0; int count = 0; do { p = (i + k) % numsSize; printf(\u0026#34;p = %d\\n\u0026#34;,p); int t = nums[p]; nums[p] = tmp; tmp = t; i = p; } while (i != 0); } */ 190.颠倒二进制位 思路：32位，\nuint32_t reverseBits(uint32_t n) { uint32_t m = 0; int cnt = 32; while (cnt) { m \u0026lt;\u0026lt;= 1; m += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;= 1; cnt--; } return m; } 191.位1的个数 思路：n \u0026amp; 0x1\nint hammingWeight(uint32_t n) { int cnt = 0; while (n) { if (n \u0026amp; 0x1) { cnt++; } n \u0026gt;\u0026gt;= 1; } return cnt; } 201.数字范围按位与 思路：n \u0026amp; (n - 1) 去除n最高位的1\nint rangeBitwiseAnd(int left, int right){ while (left \u0026lt; right) { right \u0026amp;= right - 1; } return right; } 203.移除链表元素 思路：递归\nstruct ListNode *removeElements(struct ListNode *head, int val) { if (head == NULL) { return NULL; } if (head-\u0026gt;val == val) { return removeElements(head-\u0026gt;next, val); } else { head-\u0026gt;next = removeElements(head-\u0026gt;next, val); } return head; } 206.反转链表 思路：\nstruct ListNode* reverseList(struct ListNode* head){ struct ListNode* res = NULL; while (head) { struct ListNode* pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } 209.长度最小的子数组 思路：双指针：累加sum，判断sum，大于target，计算长度，减sum，移动left\nint minSubArrayLen(int target, int* nums, int numsSize){ int i = 0; int sum = 0; int len = INT_MAX; for (int j = 0; j \u0026lt; numsSize; j++) { sum += nums[j]; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,j-i+1); sum -= nums[i]; i++; } } } if (len==INT_MAX) { len=0; } return len; } int minSubArrayLen(int target, int* nums, int numsSize){ int left = 0; int right = 0; int sum = 0; int len = INT_MAX; while (right \u0026lt; numsSize) { sum += nums[right]; right++; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,right-left); sum -= nums[left]; left++; } } } if (len == INT_MAX) { len = 0; } return len; } 215.数组中的第K个最大元素 思路：排序，第k个最大\nint Cmp(const void* a, const void* b) { return *(int *)b - *(int *)a; } int findKthLargest(int* nums, int numsSize, int k){ qsort(nums, numsSize, sizeof(int), Cmp); return nums[k-1]; } 217.存在重复元素 思路： 一、排序，比较前一个数和当前数是否相等 二、uthash\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } bool containsDuplicate(int* nums, int numsSize){ if (numsSize \u0026lt;= 1) { return true; } qsort(nums, numsSize, sizeof(int), Cmp); for (int i = 1; i \u0026lt; numsSize; i++) { if (nums[i-1] == nums[i]) { return true; } } return false; } struct my_struct { int id; UT_hash_handle hh; }; struct my_struct *users = NULL; bool containsDuplicate(int* nums, int numsSize){ struct my_struct *s; HASH_FIND_INT(users, nums[i], s); if (s == NULL) { s = (struct my_struct*)malloc(sizeof(struct my_struct)); s-\u0026gt;id = nums[i]; HASH_ADD_INT(users, id, s); } else { return true; } return false; } 226.翻转二叉树 思路：判空，交换左右子树，递归调用\nstruct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode* tmp = root-\u0026gt;left; root-\u0026gt;left = root-\u0026gt;right; root-\u0026gt;right = tmp; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); return root; } struct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode *left = (struct TreeNode *)malloc(sizeof(struct TreeNode)); struct TreeNode *right = (struct TreeNode *)malloc(sizeof(struct TreeNode)); left = invertTree(root-\u0026gt;left); right = invertTree(root-\u0026gt;right); root-\u0026gt;left = right; root-\u0026gt;right = left; return root; } 231.2的幂 思路：一：累计除2，判断最后是否为1，即整除 二、递归，判断对2取余\nbool isPowerOfTwo(int n) { if (!n) { return false; } while (n % 2 == 0) { n /= 2; } return n == 1; } bool isPowerOfTwo(int n){ if (n == 0) { return false; } if (n == 1) { return true; } bool res = false; if (n % 2 != 0) { return false; }else { res = isPowerOfTwo(n/2); } return res; } bool isPowerOfTwo(int n){ //用位运算来判断有几个1，要是只有一个1那就是2的幂。 if (n \u0026gt;= 2147483647 || n \u0026lt;= -2147483648) { return false; } int nu m =0; while (n\u0026gt;0 \u0026amp;\u0026amp; n!=0) { n \u0026amp;= (n-1); num++; } if (num!=1) { return false; } return true; } 234.回文链表 思路； 一、通过一个数组记录链表中的元素值，在判断数组是否是回文。 二、翻转链表后半部分\n#define MAXSIZE 100000 bool isPalindrome(struct ListNode* head){ int size = 0; int nums[MAXSIZE] = {0}; struct ListNode* p = head; // 判断条件 while (p) { nums[size++] = p-\u0026gt;val; p = p-\u0026gt;next; } printf(\u0026#34;size = %d\\n\u0026#34;, size); int left = 0; int right = size - 1; while (left \u0026lt;= right) { if (nums[left] != nums[right]) { return false; } left++; right--; } return true; } struct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } bool isPalindrome(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; struct ListNode *last; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; faast = fast-\u0026gt;next-\u0026gt;next; } if (fast != NULL) { slow = slow-\u0026gt;next; } last = reverse(slow); while (last) { if (head-\u0026gt;val != last-\u0026gt;val) { return 0; } head = head-\u0026gt;next; last = last-\u0026gt;next; } return 1; } 242.有效的字母异位词 思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录\u0026ndash;，最后，判断表格中所有值是否为零\n#define NUMSIZE 256 bool isAnagram(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); if (sLen != tLen) { return false; } int table[256] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; tLen; i++) { table[t[i]]--; } for (int i = 0; i \u0026lt; NUMSIZE; i++) { if (table[i] != 0) { return false; } } return true; } 268.丢失的数字 思路：边求和，边减去数组中的数字\nint missingNumber(int* nums, int numsSize){ int mNum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { mNum += (i + 1); mNum -= nums[i]; } return mNum; } 278.第一个错误的版本 思路：二分查找\nint firstBadVersion(int n) { int left = 1; int right = n; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (isBadVersion(mid) \u0026amp;\u0026amp; !isBadVersion(mid-1)) { return mid; } else if (isBadVersion(mid) \u0026amp;\u0026amp; isBadVersion(mid-1)) { right = mid - 1; } else { left = mid + 1; } } return -1; } int firstBadVersion(int n) { int low = 1, high = n; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (isBadVersion(mid)) { high = mid - 1; } else { low = mid + 1; } } return low; } 283.移动零 思路：不等于零时向数组中添加，等于零时跳过，最后填充0 nums[start++] = nums[i]\nvoid moveZeroes(int* nums, int numsSize){ int start = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != 0) { nums[start++] = nums[i]; } } for (; start \u0026lt; numsSize; start++) { nums[start] = 0; } } 287.寻找重复整数 思路：循环遍历，标记，判断是否标记过，return\n#define MAXSIZE 100001 int findDuplicate(int* nums, int numsSize){ int table[MAXSIZE] = {0}; for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] != 0) { return nums[i]; } else { table[nums[i]]++; } } return -1; } 344.反转字符串 思路：双指针，交换\nvoid reverseString(char* s, int sSize){ int left =0; int right = sSize - 1; while (left \u0026lt; right) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; } } 367.有效的完全平方数 思路：for 循环，条件 i * i \u0026lt;= num\nbool isPerfectSquare(int num) { for (long i = 0; i * i \u0026lt;= num; i++) { if (i * i == num) { return true; } } return false; } 387.字符串中的第一个唯一字符 思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。\n#define NUMSIZE 256 int firstUniqChar(char * s){ int sLen = strlen(s); int table[NUMSIZE] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; sLen; i++) { if (table[s[i]] == 1) { return i; } } return -1; } 389.找不同 思路：字符可以转化为数字，为了防止溢出通过 - \u0026lsquo;a\u0026rsquo;，求两个字符串的差值，在加上\u0026rsquo;a\u0026rsquo;\nchar findTheDifference(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); int nS = 0; int nT = 0; for (int i = 0; i \u0026lt; sLen; i++) { nS += s[i] - \u0026#39;a\u0026#39;; } for (int i = 0; i \u0026lt; tLen; i++) { nT += t[i] - \u0026#39;a\u0026#39;; } return (char)(nT - nS + \u0026#39;a\u0026#39;); } 404.左叶子之和 思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树\nint sumOfLeftLeaves(struct TreeNode* root){ if (root == NULL) { return 0; } int sum = 0; if (root-\u0026gt;left) { if (root-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;left-\u0026gt;right == NULL) { sum += root-\u0026gt;left-\u0026gt;val; } } return sum + sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } int isleaf(struct TreeNode* root) { return root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL; } int sumOfLeftLeaves(struct TreeNode* root) { if(root == NULL) { return 0; } if (root-\u0026gt;left) { if(isleaf(root-\u0026gt;left)) { // 此处直接递归，少一层调用 return root-\u0026gt;left-\u0026gt;val + sumOfLeftLeaves(root-\u0026gt;right); } } return sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } 442.数组中重复的数据 思路： 一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。 二、\n#define MAXSIZE 100000 int* findDuplicates(int* nums, int numsSize, int* returnSize){ int table[MAXSIZE] = {0}; *returnSize = 0; int *res = (int *)malloc(sizeof(int) * MAXSIZE); for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] == 1) { res[*returnSize] = nums[i]; (*returnSize)++; } else { table[nums[i]]++; } } return res; } int* findDuplicates(int* nums, int numsSize, int* returnSize) { int table[100000] = {0}; int *res = (int *)malloc(sizeof(int) * 100000); int j = 0; for (int i = 0; i \u0026lt; numsSize; i++) { table[nums[i]]++; if (table[nums[i]] == 2) { res[j++] = nums[i]; } } *returnSize = j; return res; } 461.汉明距离 思路： 一、求 x ^ y 中 1 的个数 二、比较x，y的每一位 和 1与\nint hammingDistance(int x, int y) { int n = x ^ y; int res = 0; while (n) { int p = n \u0026amp; 1; if (p) { res++; } n \u0026gt;\u0026gt;= 1; } return res; } int hammingDistance(int x, int y){ int count = 0; while (x || y) { int nX = x \u0026amp; 0x1; int nY = y \u0026amp; 0x1; if (nX != nY) { count++; } x \u0026gt;\u0026gt;= 1; y \u0026gt;\u0026gt;= 1; } return count; } 476.数字的补数 思路： 一、按位与1求与，再取反(!)，然后移位， 二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^\nint findComplement(int num){ int res = 0; int count = 0; while (num) { int t = !(num \u0026amp; 0x1); t \u0026lt;\u0026lt;= count; printf(\u0026#34;t = %d\\n\u0026#34;, t); res += t; count++; num\u0026gt;\u0026gt;=1; } return res; } int findComplement(int num){ int totalBits = 0; int tmp = num; while (tmp) { totalBits++; tmp \u0026gt;\u0026gt;= 1; } int flipNumber = 1; for (int i = 1; i \u0026lt; totalBits; i++) { flipNumber += UINT32_C(1) \u0026lt;\u0026lt; i; } num = num ^ flipNumber; return num; } 509.斐波那契数列 思路：一、递归 二、迭代\n递归 int fib(int n){ if (n \u0026lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); } 迭代 int fib(int n){ if (n \u0026lt;= 1) { return n; } int* nums = (int *)malloc(sizeof(int) * (n + 1)); nums[0] = 0; nums[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { nums[i] = nums[i - 1] + nums[i - 2]; } return nums[n]; } 520.检测大写字母 思路： 一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。 二、\nbool detectCapitalUse(char * word){ int len = strlen(word); if (len \u0026lt;= 1) { return true; } int i = 1; if (isupper(word[i])) { i = 0; while (word[i] != \u0026#39;\\0\u0026#39;) { if (!isupper(word[i])) { return false; } i++; } } else { while (word[i] != \u0026#39;\\0\u0026#39;) { if (isupper(word[i])) { return false; } i++; } } return true; } bool detectCapitalUse(char * word){ int len = strlen(word); if (len == 1) { return true; } for (int i = 1; i \u0026lt; len; i++) { // word[0] 每次都需要判断，一个复杂度。 if (isupper(word[0]) \u0026amp;\u0026amp; isupper(word[1])) { if (!isupper(word[i])) { return false; } } else { if (isupper(word[i])) { return false; } } } return true; } 561.拆分数组I 思路：排序，取偶数位求和。\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int arrayPairSum(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), Cmp); int minSum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (i % 2 == 0) { minSum += nums[i]; } } return minSum; } 617.合并二叉树 思路：递归，判空，\nstruct TreeNode* newNode(int val) { struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = val; node-\u0026gt;left = NULL; node-\u0026gt;right = NULL; return node; } struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){ /* if (root1 == NULL \u0026amp;\u0026amp; root2 == NULL) { return NULL; } */ if (root1 == NULL) { return root2; } if (root2 == NULL) { return root1; } /* struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val += root1 == NULL ? 0 : root1-\u0026gt;val; root-\u0026gt;val += root2 == NULL ? 0 : root2-\u0026gt;val; root-\u0026gt;left = NULL; root-\u0026gt;right = NULL; */ int val = (root1 == NULL ? 0 : root1-\u0026gt;val) + (root2 == NULL ? 0 : root2-\u0026gt;val); struct TreeNode* root = newNode(val); root-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return root; } 647.回文子串 思路：左侧判断去重，左右判断相等。\nint countSubstrings(char * s) { int len = strlen(s); int res = len; // 每个字符都是回文 for (int i = 0; i \u0026lt; len; i++) { int p = i - 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; s[p] == s[i]) { // 左侧去重 res++; p--; } int q = i + 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; q \u0026lt; len \u0026amp;\u0026amp; s[p] == s[q]) { // 判断左右相等 res++; p--; q++; } } return res; } int countSubstrings(char * s){ int len = strlen(s); int count = 0; for (int i = 0; i \u0026lt; len; i++) { count += countPalin(s, i, i, len); if (i != len - 1) { count += countPalin(s, i, i+1, len); } } return count; } int countPalin(char *s, int head, int tail, int len) { int ret = (s[head] == s[tail]) ? 1 : 0; if (ret \u0026amp;\u0026amp; head - 1 \u0026gt;= 0 \u0026amp;\u0026amp; tail + 1 \u0026lt; len) { ret += countPalin(s, head - 1, tail + 1, len); } return ret; } 674.最长连续递增序列 思路：双循环判断，\nint findLengthOfLCIS(int* nums, int numsSize){ if (numsSize == 1) { return 1; } int p2 = 0; int res = 0; for (int i = 1; i \u0026lt; numsSize; i++) { while (i \u0026lt; numsSize \u0026amp;\u0026amp; nums[i-1] \u0026lt; nums[i]) { i++; } res = res \u0026gt; i - p2 ? res : i - p2; p2 = i; } return res; } int findLengthOfLCIS(int* nums, int numsSize){ int maxLen = 0; int i = 0; while (i \u0026lt; numsSize) { int start = i; while (start + 1 \u0026lt; numsSize \u0026amp;\u0026amp; nums[start] \u0026lt; nums[start + 1]) { start++; } maxLen = maxLen \u0026gt; (start - i + 1) ? maxLen : (start - i + 1); start++; i = start; } return maxLen; } 700.二叉搜索树中的搜索 思路：递归，注意 判空 root == NULL\nstruct TreeNode* searchBST(struct TreeNode* root, int val){ if (root == NULL) { return NULL; } if (root-\u0026gt;val == val) { return root; } else if (root-\u0026gt;val \u0026gt; val) { return searchBST(root-\u0026gt;left, val); } else { return searchBST(root-\u0026gt;right, val); } return NULL; } 701.二叉搜索树中的插入操作 思路：递归，递归出口，root == NULL, 新建树结点 malloc\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){ if (root == NULL) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode-\u0026gt;val = val; newNode-\u0026gt;left = NULL; newNode-\u0026gt;right = NULL; return newNode; } if (root-\u0026gt;val \u0026lt; val) { root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); } if (root-\u0026gt;val \u0026gt; val) { root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); } return root; } 704.二分查找 思路：二分查找，注意 left \u0026lt;= right ，包含等于\nint search(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 709.转换成小写字母 思路；库函数 isupper, tolower\nchar * toLowerCase(char * s){ int len = strlen(s); for (int i = 0; i \u0026lt; len; i++) { if (isupper(s[i])) { s[i] = tolower(s[i]); } } return s; } 771.宝石和石头 思路：表记录stones中每个字符个数，求和jewels字符表中的值\nint numJewelsInStones(char * jewels, char * stones){ int table[256] = {0}; int sLen = strlen(stones); for (int i = 0; i \u0026lt; sLen; i++) { table[stones[i]]++; } int jLen = strlen(jewels); int sum = 0; for (int i = 0; i \u0026lt; jLen; i++) { sum += table[jewels[i]]; } return sum; } 852.山脉数组的峰顶索引 思路：判断条件，完全\nint peakIndexInMountainArray(int* arr, int arrSize){ int low = 1, high = arrSize; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026gt; arr[mid + 1]) return mid; else if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026lt; arr[mid + 1]) low = mid + 1; else high = mid - 1; } return -1; } 876.链表的中间结点 思路：快慢指针，第二个指针通过 偶数判断 for循环\nstruct ListNode* middleNode(struct ListNode* head){ struct ListNode* pos1 = head; struct ListNode* pos2 = head; for (int i = 0; pos1-\u0026gt;next != NULL; pos1 = pos1-\u0026gt;next, i++) { if (i % 2 == 0) { pos2 = pos2-\u0026gt;next; } } return pos2; } 905.按奇偶排序数组 思路: 一、双指针，同917 二、判断，前后索引移动，双指针\n解法一： int* sortArrayByParity(int* nums, int numsSize, int* returnSize) { *returnSize = numsSize; int start = 0; int end = numsSize - 1; while (start \u0026lt; end) { while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 == 0) { start++; } while (end \u0026gt; start \u0026amp;\u0026amp; nums[end] % 2 == 1) { end--; } while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 != 0 \u0026amp;\u0026amp; nums[end] % 2 != 1) { int tmp = nums[start]; nums[start] = nums[end]; nums[end] = tmp; start++; end--; } } return nums; } int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int left = 0; int right = numsSize - 1; while (left \u0026lt; right) { if (nums[left] % 2 == 0) { left++; continue; } if (nums[right] % 2 == 1) { right--; continue; } int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; left++; right--; } return nums; } 解法二； int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ int *res = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int j = 0; int p = numsSize - 1; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] % 2 == 0) { res[j] = nums[i]; j++; } else { res[p] = nums[i]; p--; } } return res; } 917.仅仅反转字母 思路：双指针，库函数 isalpha， continue\nchar * reverseOnlyLetters(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt; right) { if (!isalpha(s[left])) { left++; continue; } if (!isalpha(s[right])) { right--; continue; } //if (isalpha(s[left]) \u0026amp;\u0026amp; isalpha(s[right])) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; //} } return s; } 938.二叉搜索树的范围和 int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } if (low \u0026gt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;right, low, high); } if (high \u0026lt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;left, low, high); } return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } else if (root-\u0026gt;val \u0026gt;= low \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= high) { return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } else { return rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } } 965.单值二叉树 思路：递归，递归出口：root == NULL\nbool isUnivalTree(struct TreeNode* root){ // root不判空会报错： // member access within null pointer of type \u0026#39;struct TreeNode\u0026#39; if (root == NULL) { return true; } // 多余 /* if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return true; } */ if (root-\u0026gt;left != NULL) { if (root-\u0026gt;left-\u0026gt;val != root-\u0026gt;val) { return false; } } if (root-\u0026gt;right != NULL) { if (root-\u0026gt;right-\u0026gt;val != root-\u0026gt;val) { return false; } } return isUnivalTree(root-\u0026gt;left) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;right); } 977.有序数组的平方 思路: 一、先平方，再排序 二、双指针，左右指针比较绝对值大小，从后向前填充结果数组\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { //squareNum[i] = nums[i] * nums[i]; squareNum[i] = pow(nums[i], 2); } qsort(squareNum, numsSize, sizeof(int), Cmp); return squareNum; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int left = 0; int right = numsSize - 1; int i = numsSize - 1; while (left \u0026lt; right) { if (fabs(nums[left]) \u0026gt; nums[right]) { squareNum[i--] = nums[left] * nums[left]; left++; } else { squareNum[i--] = nums[right] * nums[right]; right--; } } squareNum[i] = nums[left] * nums[left]; return squareNum; } 1089.复写零 思路：将原数组复制一份，根据复制数组，修改原数组值\nvoid duplicateZeros(int* arr, int arrSize) { int b[arrSize]; // = {0}; memcpy(b, arr, sizeof(int) * arrSize); for (int i = 0, j = 0; i \u0026lt; arrSize \u0026amp;\u0026amp; j \u0026lt; arrSize; i++) { arr[j++] = b[i]; if (j \u0026lt; arrSize \u0026amp;\u0026amp; b[i] == 0) { arr[j++] = 0; } }W } void duplicateZeros(int* arr, int arrSize){ int * nums = (int *)malloc(sizeof(int) * arrSize); for (int i = 0; i \u0026lt; arrSize; i++) { nums[i] = arr[i]; } int j = 0; for (int i = 0; i \u0026lt; arrSize; i++, j++) { arr[i] = nums[j]; if (i + 1 \u0026lt; arrSize \u0026amp;\u0026amp; nums[j] == 0) { arr[++i] = 0; } } } 1184.公交站间的距离 思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){ if (start \u0026gt; destination) { int tmp = start; start = destination; destination = tmp; } int min = 0; int sum = 0; for (int i = 0; i \u0026lt; distanceSize; i++) { sum += distance[i]; if (i \u0026gt;= start \u0026amp;\u0026amp; i \u0026lt; destination) { min += distance[i]; } } min = min \u0026lt; (sum - min) ? min : sum - min; return min; } 1189. “气球” 的最大数量 思路：统计字符次数，注意 字符串指针 取值 *p 或者 字符数组 test[i]\nint maxNumberOfBalloons(char * text){ int len = strlen(text); int table[5] = {0}; char* p = text; while (*p != \u0026#39;\\0\u0026#39;) { if (*p == \u0026#39;b\u0026#39;) { table[0]++; } if (*p == \u0026#39;a\u0026#39;) { table[1]++; } if (*p == \u0026#39;l\u0026#39;) { table[2]++; } if (*p == \u0026#39;o\u0026#39;) { table[3]++; } if (*p == \u0026#39;n\u0026#39;) { table[4]++; } p++; } table[2] /= 2; table[3] /= 2; int min = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { min = min \u0026lt; table[i] ? min : table[i]; } return min; } /* int maxNumberOfBalloons(char * text){ int len = strlen(text); int testNum[5] = {0}; for (int i = 0; i \u0026lt; len; i++) { if (text[i] == \u0026#39;b\u0026#39;) { testNum[0]++; } if (text[i] == \u0026#39;a\u0026#39;) { testNum[1]++; } if (text[i] == \u0026#39;l\u0026#39;) { testNum[2]++; } if (text[i] == \u0026#39;o\u0026#39;) { testNum[3]++; } if (text[i] == \u0026#39;n\u0026#39;) { testNum[4]++; } } testNum[2] /= 2; testNum[3] /= 2; int res = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { res = res \u0026lt; testNum[i] ? res : testNum[i]; } return res; } */ 1207.独一无二的出现次数 解法一\n通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true\nuniqueOccurrences bool uniqueOccurrences(int* arr, int arrSize){ int table[2001] = {0}; for (int i = 0; i \u0026lt; arrSize; i++) { table[arr[i] + 1000]++; printf(\u0026#34;table[arr[%d] + 1000] = %d\\n\u0026#34;, i, table[arr[i] + 1000]); } int table1[2001] = {0}; for (int i = 0; i \u0026lt; 2001; i++) { table1[i] = 0; if (table[i] != 0) { if (table1[table[i]] != 0) { printf(\u0026#34;table1[table[%d]] = %d\\n\u0026#34;, i, table1[table[i]]); return false; } else { table1[table[i]]++; } } } return true; } 解法二：\n同解法一\n/* */ bool uniqueOccurrences(int* arr, int arrSize){ int hashTable[2001]={0};//初始化一张表，下标对应元素值，存储对应元素出现的次数 for(int i=0;i\u0026lt;arrSize;i++) { hashTable[arr[i]+1000]++; } bool visited[1001]={false}; for(int i=0;i\u0026lt;2001;i++) { if(hashTable[i]) { //如果i在数组中 if(visited[hashTable[i]]) { //如果之前出现过与i相同的重复次数 return false; } else { visited[hashTable[i]]=true;//说明与i相同的重复次数还未出现，设置为已访问过 } } } return true; } 参考博客： https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/leetcode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/","summary":"总结 leetcode基础题目 经典题目： 3.无重复字符的最长子串 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476.","title":"leetcode基础题目"},{"content":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？\nLinux内核代码下载 Linux kernel官网 https://www.kernel.org/\n解压 linux-5.19.10.tar.xz\ntar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035\nlinux内核线上阅读 linux、u-boot、qemu、glibc、llvm、grub https://elixir.bootlin.com/ U-boot # 下载源代码 git clone https://source.denx.de/u-boot/u-boot.git # 或 git clone https://github.com/u-boot/u-boot # 切换分支 git checkout v2020.10 官网 https://www.denx.de/wiki/U-Boot/ 代码网站 https://source.denx.de/u-boot 什么是U-Boot以及如何下载U-Boot源码 https://blog.csdn.net/zhuguanlin121/article/details/119008893 gdb 《100个gdb小技巧》\nkbuild Kbuild: the Linux Kernel Build System Kernel Build System¶\nhttps://www.zhihu.com/question/47039391/answer/2287806626\nELF 开源库 lief\n参考链接： https://blog.csdn.net/GrayOnDream/article/details/124564129\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linuxreadtool/","summary":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？ Linux内核代码下载 Linux kernel官网 https://www.kernel.org/ 解压 linux-5.19.10.tar.xz tar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035 linux内核线上阅读 li","title":"Linux Read Tool"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/tech/tech/","summary":"","title":"Tech"},{"content":"\rZain\u0026#39;s Blog\r一个记录技术、阅文、生活的博客\r👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego\n","permalink":"https://liuz0123.gitee.io/zain/links/","summary":"Zain\u0026#39;s Blog 一个记录技术、阅文、生活的博客 👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego","title":"🤝闲言俗语"},{"content":"\n英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 思考、觉悟、成长、沉静，时而逗比，时而安静，明心见性 👉Hugo博客交流群\r787018782\n","permalink":"https://liuz0123.gitee.io/zain/about/","summary":"英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 思考、觉悟、成长、沉静，时","title":"🙋🏻‍♂️关于"}]