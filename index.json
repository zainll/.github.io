[{"content":" 代码随想录网站 https://programmercarl.com/ 一.数组 1.数组基础 数组是存放在连续内存空间上的相同类型数据的集合\n数组下标都是从0开始的。 数组内存空间的地址是连续的 数组的在内存空间的地址是连续的，在删除或者增添元素的时候，就要移动其他元素的地址 2.二分查找 704.二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 \\\n思路 有序数组，数组中无重复元素 -\u0026gt; 使用二分法的前提条件 二分查找区间的定义就是不变量，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则 区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)\n左闭右闭\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，left == right有意义，使用 \u0026lt;= if（nums[middle] \u0026gt; target）right赋值 middle-1，当前nums[target]不是target，查找区间结束下标位置是middle-1 // 版本一 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left \u0026lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 \u0026lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] \u0026gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] \u0026lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 左闭右开\nwhile（left \u0026lt; right）使用 \u0026lt;，left == right 在区间[left, right]没有意义 if（nums[middle] \u0026gt; target）right更新为 middle，即下一个查询区间不会比较nums[middle] // 版本二 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right) while (left \u0026lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 \u0026lt; int middle = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[middle] \u0026gt; target) { right = middle; // target 在左区间，在[left, middle)中 } else if (nums[middle] \u0026lt; target) { left = middle + 1; // target 在右区间，在[middle + 1, right)中 } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 总结 区间定义理解，在循环中检查根据查找区间的定义来做边界处理 区间定义是不变量，在循环中坚持根据查找区间的定义来做边界处理，即循环不变规则 \\\n相关题目 35.搜索插入位置 34.在排序数组中查找元素的第一个和最后一个位置 69.x 的平方根 367.有效的完全平方数 c:\n// 左闭右闭[left, right] int search(int *nums, int numsSize, int target) { int left = 0; int right = numsSize - 1; int middle = 0; // left 小于 target，说明区间中元素不为0 while(left \u0026lt;= right) { // 更新查找小毕middle值 middle = (left + right) / 2; // taget 可能在 [left, middle - 1]区间 if (nums[middle] \u0026gt; target) { right = middle - 1; } else if (nums[middle] \u0026lt; target) ( // target肯在[middle + 1, right]区间 left = middle + 1; ) else if (nums[middle] == target) { return middle; } } // 未找到taget元素 返回-1 return -1; } 左闭右开区间 [left, right) int search(int* nums, int numsSize, int target){ int length = numsSize; int left = 0; int right = length;\t//定义target在左闭右开的区间里，即：[left, right) int middle = 0; while(left \u0026lt; right){ // left == right时，区间[left, right)属于空集，所以用 \u0026lt; 避免该情况 int middle = left + (right - left) / 2; if(nums[middle] \u0026lt; target){ //target位于(middle , right) 中为保证集合区间的左闭右开性，可等价为[middle + 1,right) left = middle + 1; }else if(nums[middle] \u0026gt; target){ //target位于[left, middle)中 right = middle ; }else{\t// nums[middle] == target ，找到目标值target return middle; } } //未找到目标值，返回-1 return -1; } 3.移除元素 27.移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度 \\\n思路 数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖 \\\n暴力解法 两层for循环，一个for循环遍历数组元素，第二个for循环更新数组\nint removeElement(int* nums, int numsSize, int val){ int i = 0, j = 0; for (; i \u0026lt; numsSize; i++) { if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位 for (j = i + 1; j \u0026lt; numsSize; j++) { nums[j-1] = nums[j]; } i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位 numsSize--; // 此时数组的大小-1 } } return numsSize; } ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/","summary":"代码随想录网站 https://programmercarl.com/ 一.数组 1.数组基础 数组是存放在连续内存空间上的相同类型数据的集合 数组下标都是从0开始的。 数组内存空间的地址是连续的 数组的在","title":"代码随想录"},{"content":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF http://gen.lib.rus.ec/ https://libgen.li/ https://libgen.gs/ https://sci-hub.41610.org/library-genesis https://libgen.rs/search.php?\u0026amp;req=KVM\u0026amp;phrase=1\u0026amp;view=simple\u0026amp;column=def\u0026amp;sort=year\u0026amp;sortmode=DESC https://libgen.rs/ zlibrary PDF 2022.12.31 1libaray 不可用 Z-library Bot 可用 2022.11.30 telegram机器人可用 1libaray 2022.11.04美国邮政检查局查封域名，预期仅能用Tor 访问 .onion域名 https://zh.u1lib.org/ https://en.ru1lib.org/ FreeTechBooks 计算机科学类 http://www.freetechbooks.com/ https://www.freetechbooks.com/ 古登宝计划 http://www.gutenberg.org/ Planet eBook 国内可访问 https://www.planetebook.com/ 布克书屋 https://iao.su/3064/comment-page-1 https://www.bukebook.cn yudu https://express.yudu.com/ kindle 社区 书伴 https://bookfere.com/post/4.html calibre 参考链接： http://www.360doc.com/content/20/0219/14/5008209_893150066.shtml http://www.sohu.com/a/215001801_490529\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/ebookwebsite/","summary":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF","title":"电子书网站"},{"content":"总结 leetcode基础题目 经典题目： 3.无重复字符的最长子串 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476. 617. 701. 938. 1089. 1207.\n1.两数之和 思路：两层遍历\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) { int i, j; int *ret = (int *)malloc(sizeof(int) * 2); for (i = 0; i \u0026lt; numsSize; i++) { int key = target - nums[i]; // 临时变量外层计算一次 for (j = i + 1; j \u0026lt; numsSize; j++) { if (nums[j] == key) { ret[0] = i; ret[1] = j; break; } } } *returnSize = 2; return ret; } 2.两数相加 思路：两个链表，判断链表是否为空or，求和不为空链表节点值，第一次添加头节点，之后添加到尾节点，注意处理进位\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) { struct ListNode *head = NULL, *tail = NULL; int carry = 0; while (l1 || l2) { int n1 = l1 ? l1-\u0026gt;val : 0; int n2 = l2 ? l2-\u0026gt;val : 0; int sum = n1 + n2 + carry; if (!head) { head = tail = malloc(sizeof(struct ListNode)); tail-\u0026gt;val = sum % 10; tail-\u0026gt;next = NULL; } else { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = sum % 10; tail = tail-\u0026gt;next; tail-\u0026gt;next = NULL; } carry = sum / 10; if (l1) { l1 = l1-\u0026gt;next; } if (l2) { l2 = l2-\u0026gt;next; } } if (carry \u0026gt; 0) { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = carry; tail-\u0026gt;next-\u0026gt;next = NULL; } return head; } 3.无重复字符的最长子串 思路：双指针，前后快慢指针，table表标记字符是否出现过，right标记，left去除标记，求right-left最大值\nint lengthOfLongestSubstring(char * s){ int len = strlen(s); printf(\u0026#34;len = %d\\n\u0026#34;, len); int left = 0; int right = 0; char table[256] = {0}; int maxLen = 0; while (right \u0026lt; len) { printf(\u0026#34;%d \\t\u0026#34;, right); if (table[s[right]] == 0) { table[s[right]] = 1; right++; //} else if (table[s[right]] == 1) { } else { table[s[left]] = 0; left++; } maxLen = fmax(maxLen, right - left); } return maxLen; } 4.寻找两个正序数组的中位数 思路：每个数组各自索引，判断大小移动索引，最后判断是奇数还是偶数\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){ int sum = nums1Size + nums2Size; int *nums = (int *)malloc(sizeof(int) * sum); int i = 0, j = 0, k = 0; int half = sum / 2 + 1; while (k \u0026lt; half) { int n; if (i \u0026lt; nums1Size \u0026amp;\u0026amp; j \u0026lt; nums2Size) { n = (nums1[i] \u0026lt; nums2[j]) ? nums1[i++] : nums2[j++]; } else if (i \u0026lt; nums1Size) { n = nums1[i++]; } else if (j \u0026lt; nums2Size) { n = nums2[j++]; } nums[k++] = n; } if (sum % 2 == 0) { return (nums[k-1] + nums[k-2]) / 2.0; } else { return nums[k-1]; } } 6.Z 字形变换 思路：计算位置？\nchar * convert(char * s, int numRows){ uint16_t len = strlen(s); if (len \u0026lt; numRows) { numRows = len; } char* out = calloc(len + 1, sizeof(char)); if (numRows \u0026lt; 2) { memcpy(out, s, len + 1); return out; } uint16_t max = numRows - 1; uint16_t rr = 2 * max; uint16_t i = 0; uint16_t o = 0; uint16_t delta = 0; // first row while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } // middle rows for (uint16_t l = 1; l \u0026lt; max; l++) { i = l; delta = 2 * l; while (i \u0026lt; len) { out[o++] = s[i]; delta = rr - delta; i += delta; } } // last row i = max; while (i \u0026lt; len) { out[o++] = s[i]; i += rr; } return out; } 7.整数反转 思路：(取余数)* 10，注意越界，INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7\nint reverse(int x){ int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev \u0026gt; INT_MAX / 10 || (rev == INT_MAX / 10 \u0026amp;\u0026amp; pop \u0026gt; 7)) return 0; if (rev \u0026lt; INT_MIN / 10 || (rev == INT_MIN / 10 \u0026amp;\u0026amp; pop \u0026lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } 8.字符串转换整数 (atoi) 思路：\nint myAtoi(char * s){ long flag = 1; long num = 0; //int singleRes=0; while(*s == \u0026#39; \u0026#39;) { s++; } if(*s==\u0026#39;-\u0026#39;) { flag=-1; s++; } else if (*s==\u0026#39;+\u0026#39;) { s++; flag=1; } while(*s!=\u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; (*s\u0026lt;=\u0026#39;9\u0026#39; \u0026amp;\u0026amp; *s\u0026gt;=\u0026#39;0\u0026#39;)) { if(num\u0026gt;INT_MAX/10 || (num==INT_MAX/10 \u0026amp;\u0026amp; *s\u0026gt;\u0026#39;7\u0026#39;)){//因为是从正数转化为负数，所以要都按正数溢出标准 if(flag==1) { return INT_MAX; } else { return INT_MIN; } } else { num=num*10+(*s-\u0026#39;0\u0026#39;); s++; } } if(flag==1) { return num; } else { return -num; } } int myAtoi(char * s){ int minusFlag = 0; int length = strlen(s); long int result = 0; char numberBuffer[11]; int counter = 0; while (s[counter] == \u0026#39; \u0026#39;) { counter++; } s = \u0026amp;s[counter]; counter = 0; for (int i = 0; i \u0026lt; length; i++) { if (i == 0) { if (s[0] == \u0026#39;-\u0026#39;) { minusFlag = 1; i++; } else if (s[0] == \u0026#39;+\u0026#39;) { i++; } } if (counter \u0026gt; 10) { if (minusFlag) { return __INT_MAX__ * -1 - 1; } else { return __INT_MAX__; } } if (s[i] \u0026lt; \u0026#39;0\u0026#39; || s[i] \u0026gt; \u0026#39;9\u0026#39;) { break; } if (counter == 0 \u0026amp;\u0026amp; s[i] == \u0026#39;0\u0026#39;) { continue; } numberBuffer[counter] = s[i]; counter++; } int i = 0; while (counter \u0026gt; 0) { if (minusFlag) { result -= (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } else { result += (numberBuffer[i] - \u0026#39;0\u0026#39;) * pow(10.0, counter - 1); } i++; counter--; } if (result \u0026gt; __INT_MAX__) { return __INT_MAX__; } else if (result \u0026lt; __INT_MAX__ * -1 - 1) { return __INT_MAX__ * -1 - 1; } return result; } 9.回文数 思路：将每一位按序装入数组，遍历数组首尾是否相等 ; 递归\nbool isPalindrome(int x) { if (x \u0026lt; 0) { return false; } int table[20] = {0}; int count = 0; while (x) { table[count++] = x % 10; x = x / 10; printf(\u0026#34;x = %d\\n\u0026#34;, x); } for (int i = 0; i \u0026lt; count / 2; i++) { if (table[i] != table[count - i - 1]) { return false; } } return true; } bool isPalindrome(int x){ if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } 11.盛最多水的容器 思路：双指针，头尾向中间\nint maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int maxNum = 0; while (left \u0026lt; right) { int hMax = fmin(height[left], height[right]); int tmp = hMax * (right - left); maxNum = fmax(maxNum, tmp); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return maxNum; } int maxArea(int* height, int heightSize) { int left = 0; int right = heightSize - 1; int mArea = 0; while (left \u0026lt; right) { int h = fmin(height[left], height[right]); int m = h * (right - left); mArea = fmax(mArea, m); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return mArea; } int maxArea(int* height, int heightSize){ // Start with maximum container width int start = 0; int end = heightSize - 1; int res = 0; while (start \u0026lt; end) { // Calculate current area by taking minimum of two heights int currArea = (end - start) * fmin(height[start], height[end]); if (currArea \u0026gt; res) res = currArea; if (height[start] \u0026lt; height[end]) { start = start + 1; } else { end = end - 1; } } return res; } 12.整数转罗马数字 思路：\nconst int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; const char* symbols[] = {\u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34;}; char* intToRoman(int num) { char* roman = malloc(sizeof(char) * 16); roman[0] = \u0026#39;\\0\u0026#39;; for (int i = 0; i \u0026lt; 13; i++) { while (num \u0026gt;= values[i]) { num -= values[i]; strcpy(roman + strlen(roman), symbols[i]); } if (num == 0) { break; } } return roman; } char *getOne(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;IX\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;VIII\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;VII\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;VI\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;V\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;IV\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;III\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;II\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;I\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getTen(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;XC\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;LXXX\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;LXX\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;LX\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;L\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;XL\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;XXX\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;XX\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;X\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getHundred(char c) { switch (c) { case \u0026#39;9\u0026#39;: return \u0026#34;CM\u0026#34;; case \u0026#39;8\u0026#39;: return \u0026#34;DCCC\u0026#34;; case \u0026#39;7\u0026#39;: return \u0026#34;DCC\u0026#34;; case \u0026#39;6\u0026#39;: return \u0026#34;DC\u0026#34;; case \u0026#39;5\u0026#39;: return \u0026#34;D\u0026#34;; case \u0026#39;4\u0026#39;: return \u0026#34;CD\u0026#34;; case \u0026#39;3\u0026#39;: return \u0026#34;CCC\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;CC\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;C\u0026#34;; case \u0026#39;0\u0026#39;: return \u0026#34;\u0026#34;; default: return NULL; } } char *getThousand(char c) { switch (c) { case \u0026#39;3\u0026#39;: return \u0026#34;MMM\u0026#34;; case \u0026#39;2\u0026#39;: return \u0026#34;MM\u0026#34;; case \u0026#39;1\u0026#39;: return \u0026#34;M\u0026#34;; default: return NULL; } } char * intToRoman(int num){ int length; char number[5]; char *s = malloc(16 * sizeof(char)); sprintf(number, \u0026#34;%i\u0026#34;, num); length = strlen(number); switch (length) { case 4: sprintf(s, \u0026#34;%s%s%s%s\u0026#34;, getThousand(number[0]), getHundred(number[1]), getTen(number[2]), getOne(number[3])); break; case 3: sprintf(s, \u0026#34;%s%s%s\u0026#34;, getHundred(number[0]), getTen(number[1]), getOne(number[2])); break; case 2: sprintf(s, \u0026#34;%s%s\u0026#34;, getTen(number[0]), getOne(number[1])); break; case 1: s = getOne(number[0]); break; default: break; } return s; } 13.罗马数字转整数 思路：\nint romanToInt(char * s){ int romanToInt = 0; for (int i = 0; i \u0026lt; strlen(s); i++) { switch (s[i]) { case \u0026#39;I\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;V\u0026#39; || s[i + 1] == \u0026#39;X\u0026#39;) { romanToInt -= 1; break; } } romanToInt += 1; break; case \u0026#39;V\u0026#39;: romanToInt += 5; break; case \u0026#39;X\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;L\u0026#39; || s[i + 1] == \u0026#39;C\u0026#39;) { romanToInt -= 10; break; } } romanToInt += 10; break; case \u0026#39;L\u0026#39;: romanToInt += 50; break; case \u0026#39;C\u0026#39;: if (i + 1 \u0026lt; strlen(s)) { if (s[i + 1] == \u0026#39;D\u0026#39; || s[i + 1] == \u0026#39;M\u0026#39;) { romanToInt -= 100; break; } } romanToInt += 100; break; case \u0026#39;D\u0026#39;: romanToInt += 500; break; case \u0026#39;M\u0026#39;: romanToInt += 1000; break; default: break; } } return romanToInt; } 20.有效的括号 思路：配对判断\nbool isValid(char * s) { int i, k = 0, len = strlen(s); char *store = calloc(len, sizeof(char)); for (i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { switch (s[i]) { case \u0026#39;(\u0026#39;: case \u0026#39;{\u0026#39;: case \u0026#39;[\u0026#39;: store[k++] = s[i]; break; case \u0026#39;)\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;(\u0026#39;) goto out; break; case \u0026#39;}\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;{\u0026#39;) goto out; break; case \u0026#39;]\u0026#39;: if (k \u0026lt; 1 || store[--k] != \u0026#39;[\u0026#39;) goto out; break; } } out: free(store); return s[i] == \u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; k == 0; } 21.合并两个有序链表 思路：先添加头，然后判断 l1 != NULL \u0026amp;\u0026amp; l2 != NULL 添加谁\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode* head = NULL; struct ListNode* tmp = NULL; if (l1 == NULL) { return l2; } if (l2 == NULL) { return l1; } if (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { head = tmp = l1; l1 = l1-\u0026gt;next; } else { head = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) { tmp-\u0026gt;next = l1; } if (l2) { tmp-\u0026gt;next = l2; } return head; } return NULL; } struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { struct ListNode *list = NULL; struct ListNode *tmp = NULL; if (!l1) return l2; if (!l2) return l1; if (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { list = tmp = l1; l1 = l1-\u0026gt;next; } else { list = tmp = l2; l2 = l2-\u0026gt;next; } while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { tmp-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { tmp-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } tmp = tmp-\u0026gt;next; } if (l1) tmp-\u0026gt;next = l1; if (l2) tmp-\u0026gt;next = l2; return list; } return NULL; } /* if (!list1) return list2; if (!list2) return list1; if (list1-\u0026gt;val \u0026lt; list2-\u0026gt;val) { list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next, list2); return list1; } else { list2-\u0026gt;next = mergeTwoLists(list1, list2-\u0026gt;next); return list2; } */ 24.两两交换链表中的节点 思路：递归；借助节点\nstruct ListNode* swapPairs(struct ListNode* head) { if (head == NULL || head-\u0026gt;next == NULL) { return head; } struct ListNode* first = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); first-\u0026gt;next = head; //head = head-\u0026gt;next; return first; } struct ListNode* swapPairs(struct ListNode* head) { if (!head || !head-\u0026gt;next) return head; struct ListNode *tmp = head-\u0026gt;next; head-\u0026gt;next = swapPairs(head-\u0026gt;next-\u0026gt;next); tmp-\u0026gt;next = head; return tmp; } 26.删除有序数组中的重复项 思路：快慢双指针，不重复时赋值，慢指针右移\nint removeDuplicates(int* nums, int numsSize) { if(numsSize == 0) { return 0; } int fast = 1, low = 0; while (fast \u0026lt; numsSize) { if (nums[fast] != nums[low]) { nums[low + 1] = nums[fast]; // 此处 low++ 出错 low++; } fast++; } return low + 1; } int removeDuplicates(int* nums, int numsSize) { int count = 0, i; for (i = 1; i \u0026lt; numsSize; i++) { if (nums[i] == nums[i - 1]) count++; else nums[i - count] = nums[i]; } return numsSize - count; } 27.移除元素 思路：判断不等于指定值，nums[start++] = nums[i];\nint removeElement(int* nums, int numsSize, int val){ int i, start = 0; for (i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != val) { nums[start++] = nums[i]; } } return start; } 28.实现 strStr() 思路：双层for循环，外层判断首个字符，内层逐个判断\nint strStr(char * haystack, char * needle){ int i = 0; int j = 0; int k = 0; int hlen = 0; int nlen = 0; if (needle == NULL || *needle == 0) return 0; if (haystack == NULL || *haystack == 0) return -1; hlen = strlen(haystack); nlen = strlen(needle); if (hlen \u0026lt; nlen) return -1; for (i = 0; i \u0026lt;= hlen - nlen; i++) { j = 0; if (haystack[i] != needle[j++]) continue; k = i + 1; for (; j \u0026lt; nlen; j++) { if (haystack[k] != needle[j]) { break; } else { k++; } } if (j == nlen) return i; } return -1; } 29.两数相除 思路：1.先判断符号 2.再判断边界 3.取绝对值，正数 4. \u0026raquo; 1 移位折半\nint divide(int dividend, int divisor) { int cnt = 0; int sign = 1; if ((dividend ^ divisor) \u0026lt; 0) { // 两数任意一个为负数 sign = -1; } if (divisor == INT_MIN) { // 除数边界值特殊处理 if (dividend == INT_MIN) { return 1; } else { return 0; } } if (dividend == INT_MIN) { // 被除数边界值特殊处理 if (divisor == -1) { return INT_MAX; } else if (divisor == 1) { return INT_MIN; } dividend += abs(divisor); // 先执行一次加操作，避免abs转换溢出 cnt++; } int a = abs(dividend); int b = abs(divisor); while (a \u0026gt;= b) { int c = 1; int s = b; // 需指数级快速逼近，以避免执行超时 while (s \u0026lt; (a \u0026gt;\u0026gt; 1)) { // 逼近至一半，同时避免溢出 s += s; c += c; } cnt += c; a -= s; } return (sign == -1) ? -cnt : cnt; } int divide(int dividend, int divisor){ int sign = 1; long int output = 0; if (dividend \u0026lt; 0) { sign *= -1; } else { dividend *= -1; } if (divisor \u0026lt; 0) { sign *= -1; } else { divisor *= -1; } while (dividend \u0026lt;= divisor) { long int tmp = 0; long int div = divisor; while (dividend \u0026lt;= div) { tmp += (tmp + 1); dividend -= div; div += div; } if (output \u0026gt;= INT_MAX) { if (sign == -1) { return INT_MIN; } else { return INT_MAX; } } output += tmp; } return output * sign; } 35.搜索插入位置 思路：二分法\nint searchInsert(int* nums, int numsSize, int target) { int left = 0; int right = numsSize - 1; int mid; while (left \u0026lt;= right) { // mid = (right + left) / 2; mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return left; } int searchInsert(int* nums, int numsSize, int target) { int idx = numsSize - 1; if (numsSize \u0026gt; 0) { if (target \u0026gt; nums[idx]) { return numsSize; } return searchInsert(nums, numsSize - 1, target); } return 0; } 38.外观数列 思路：？？？\nchar * countAndSay(int n) { char *p = (char *)malloc(5000); char *p1 = (char *)malloc(5000); p[0] = \u0026#39;1\u0026#39;; p[1] = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt; n; ++i) { int x = 0; for(int j = 0; p[j]; ++j) { int y = 1; //计数器 while (p[j+1] \u0026amp;\u0026amp; p[j] == p[j+1]) { ++y; ++j; } p1[x++] = y+48; p1[x++] = p[j]; } strcpy(p, p1); p[x] = \u0026#39;\\0\u0026#39;; } return p; } char * countAndSay(int n) { // Calculating the length of array double result = 1.0; for (int i = 0; i \u0026lt; n - 1; i++) { result *= 1.4; } int k, j, count, convert = (int)result; // Creating array with the length calculated above char *arr = malloc(convert + 4); arr[0] = \u0026#39;1\u0026#39;; arr[1] = \u0026#39;\\0\u0026#39;; for (int i = 2, length; i \u0026lt;= n; i++) { length = strlen(arr); char newArr[length * 2]; strcpy(newArr, arr); k = 0; j = 0; count = 1; while (newArr[j] != \u0026#39;\\0\u0026#39;) { if (newArr[j] == newArr[j + 1]) { count++; j++; } else { arr[k] = (48 + count); arr[k + 1] = newArr[j]; arr[k + 2] = \u0026#39;\\0\u0026#39;; j++; k += 2; count = 1; } } } return arr; } 53.最大子数组和 思路：累加，动态规划\nint maxcmp(int a, int b) { return a \u0026gt;= b ? a : b; } int maxSubArray(int* nums, int numsSize) { int maxSoFar = nums[0]; int maxEndingHere = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]); maxSoFar = maxcmp(maxSoFar, maxEndingHere); } return maxSoFar; } 66.加一 思路：判断是否发生进位，最后判断最高位是否进位\n// The returned array must be malloced, assume caller calls free(). int *plusOne(int *digits, int digitsSize, int *returnSize) { for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { if (digits[i] \u0026lt; 9) { digits[i]++; *returnSize = digitsSize; return digits; } else { digits[i] = 0; } } int* newdigit = (int *)malloc(sizeof(int) * (digitsSize + 1)); newdigit[0] = 1; for (int i = 1; i \u0026lt; (digitsSize + 1); i++) { newdigit[i] = digits[i-1]; } *returnSize = digitsSize + 1; return newdigit; } int* plusOne(int* digits, int digitsSize, int* returnSize) { *returnSize = digitsSize; digits[digitsSize - 1] += 1; int carry = digits[digitsSize - 1] / 10; for (int i = digitsSize - 1; i \u0026gt;= 0; i--) { digits[i] = (carry + digits[i]) % 10; int t = carry; carry = (carry + digits[i]) / 10; printf(\u0026#34;carry = %d\\n\u0026#34;, carry); } if (carry == 1) { *returnSize = digitsSize + 1; int *res = malloc(sizeof(int) * (*returnSize)); res[0] = 1; for (int i = 0; i \u0026lt; digitsSize; i++) { res[i+1] = digits[i]; } return res; } return digits; } 82.删除排序链表中的重复元素 II 思路：递归，判断是否和下一个链表值相等\nstruct ListNode* deleteDuplicates(struct ListNode* head) { /* if (head == NULL) { return NULL; } if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; */ if (head == NULL) return NULL; if (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { /* Remove all duplicate numbers */ while (head-\u0026gt;next \u0026amp;\u0026amp; head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { head = head-\u0026gt;next; } return deleteDuplicates(head-\u0026gt;next); } else { head-\u0026gt;next = deleteDuplicates(head-\u0026gt;next); } return head; } 83.删除排序链表中的重复元素 思路：判断相等，next = next-\u0026gt;next\n/* struct ListNode* deleteDuplicates(struct ListNode* head){ if (head == NULL) { return NULL; } int table[201] = {0}; struct ListNode* cur = head; table[cur-\u0026gt;val + 100] = 1; while (cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;next) { if (table[cur-\u0026gt;next-\u0026gt;val + 100] == 1) { if (cur-\u0026gt;next-\u0026gt;next != NULL) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; continue; } else { cur-\u0026gt;next = NULL; break; } } else { table[cur-\u0026gt;next-\u0026gt;val + 100] = 1; } cur = cur-\u0026gt;next; } return head; } */ struct ListNode* deleteDuplicates(struct ListNode* head) { struct ListNode* cur = head; while (cur \u0026amp;\u0026amp; cur-\u0026gt;next) { if (cur-\u0026gt;val == cur-\u0026gt;next-\u0026gt;val) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; } else { cur = cur-\u0026gt;next; } } return head; } /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* deleteDuplicates(struct ListNode* head) { if (head == NULL) { return NULL; } else { struct ListNode* s = head; struct ListNode* t = head-\u0026gt;next; while (t != NULL) { if (s-\u0026gt;val == t-\u0026gt;val) { struct ListNode* y; y=s-\u0026gt;next; s-\u0026gt;next=t-\u0026gt;next; t=y-\u0026gt;next; free(y); } else { s=s-\u0026gt;next; t=t-\u0026gt;next; } } } return head; } 84.柱状图中最大的矩形 思路：单调栈？\nint largestRectangleArea(int* heights, int heightsSize){ /* int *data = (int*)malloc(sizeof(int) * (heightsSize + 2)); int *stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); //给heights前后+0，成新数组data data[0] = 0; for (int i = 1; i \u0026lt;= heightsSize; i++) { data[i] = heights[i - 1]; } data[heightsSize + 1] = 0; int j = 0, area = 0; stack[j] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; data[stack[j]] \u0026gt;= data[i]) { int sidx = stack[j - 1]; int h = data[stack[j]]; //area = fmax(area, data[stack[top]] * (i - stack[top - 1] - 1)); area = fmax(area, h * (i - sidx - 1)); j--; } stack[++j] = i; } return area; */ int* stack = (int*)malloc(sizeof(int) * (heightsSize + 2)); int* nheights = (int*)malloc(sizeof(int) * (heightsSize + 2)); for (int i = 0; i \u0026lt; heightsSize; i++) { nheights[i+1] = heights[i]; } nheights[0] = 0; nheights[heightsSize + 1] = 0; int maxArea = 0; int top = 0; stack[top] = 0; for (int i = 1; i \u0026lt;= heightsSize + 1; i++) { while (top \u0026gt; 0 \u0026amp;\u0026amp; nheights[stack[top]] \u0026gt;= nheights[i]) { int h = nheights[stack[top]]; int s = stack[top - 1]; int area = nheights[stack[top]] * (i - s -1); maxArea = fmax(maxArea, area); top--; } top++; stack[top] = i; } return maxArea; } void showIntArr(const char *brief, int *arr, uint32_t nums) { printf(\u0026#34;%s:\u0026#34;, brief); for (uint32_t i = 0; i \u0026lt; nums; i++) { printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); return; } int largestRectangleArea(int* heights, int heightsSize){ int *stack = (int *)malloc(sizeof(int) * (heightsSize + 1)); uint32_t stackIdx = 0; int maxAns = 0; int tmpAns = 0; int high = 0; int wide = 0; stack[stackIdx++] = -1; for (uint32_t i = 0; i \u0026lt; heightsSize; i++) { //showIntArr(\u0026#34;stack\u0026#34;, stack, stackIdx); if (stackIdx == 1) { /* 单调栈为空 */ stack[stackIdx++] = i; continue; } // printf(\u0026#34;stackIdx - 1 [%d]\\n\u0026#34;, stackIdx - 1); if (heights[i] \u0026gt;= heights[stack[stackIdx - 1]]) { stack[stackIdx++] = i; continue; } while ((stackIdx \u0026gt; 1) \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stack[stackIdx - 1]]) { /* 遍历到的元素小于栈顶元素 */ high = heights[stack[stackIdx - 1]]; stackIdx--; wide = i - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;i[%u] high[%d] wide[%d]\\n\u0026#34;, i, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } stack[stackIdx++] = i; } while (stackIdx \u0026gt; 1) { high = heights[stack[stackIdx - 1]]; stackIdx--; wide = heightsSize - stack[stackIdx - 1] - 1; tmpAns = high * wide; //printf(\u0026#34;ele[%d] high[%d] wide[%d]\\n\u0026#34;, heightsSize, high, wide); if (tmpAns \u0026gt; maxAns) { maxAns = tmpAns; } } return maxAns; } 94.二叉树的中序遍历 思路：递归，中序，注意封装递归函数\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void processTraversal(struct TreeNode* root, int* res, int* size) { if (!root) { return; } processTraversal(root-\u0026gt;left, res, size); res[*size] = root-\u0026gt;val; *size += 1; processTraversal(root-\u0026gt;right, res, size); } int* inorderTraversal(struct TreeNode* root, int* returnSize){ int* res = malloc(sizeof(int) * 256); *returnSize = 0; processTraversal(root, res, returnSize); return res; } 101.对称二叉树 思路：递归判断，注意递归出口判断条件\nbool checkSymmetric(struct TreeNode *left, struct TreeNode *right) { if (!left || !right) return left == right; if (left-\u0026gt;val != right-\u0026gt;val) return 0; return checkSymmetric(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; checkSymmetric(left-\u0026gt;right, right-\u0026gt;left); } bool isSymmetric(struct TreeNode *root) { return root == NULL || checkSymmetric(root-\u0026gt;left, root-\u0026gt;right); } 104.二叉树的最大深度 思路：求树深度递归 return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxval(int a, int b) { return a \u0026gt; b ? a : b; } int maxDepth(struct TreeNode *root) { if (root == NULL) { return 0; } return 1 + maxval(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 1; } return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } int maxDepth(struct TreeNode* root) { if (root == NULL) { return 0; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return fmax(left, right); } 108.将有序数组转换为二叉搜索树 思路：递归处理从中间分左右两部分，先添加当前节点在递归。\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* convertBST(int* nums, int left, int right) { if (left \u0026gt; right) { return NULL; } else { int mid = (right + left) / 2; struct TreeNode* new_val = malloc(sizeof(struct TreeNode)); new_val-\u0026gt;val = nums[mid]; new_val-\u0026gt;left = convertBST(nums, left, mid - 1); new_val-\u0026gt;right = convertBST(nums, mid + 1, right); return new_val; } } struct TreeNode* sortedArrayToBST(int* nums, int numsSize){ if (numsSize == 0) { return NULL; } return convertBST(nums, 0, numsSize - 1); } 109.有序链表转换二叉搜索树 思路：先找到中间节点和尾节点，将中间节点添加到树上，递归处理中间节点前部和后部两部分，递归出口为找不着新节点\n/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* buildBST(struct ListNode* head, struct ListNode* tail) { if (head == tail) { return NULL; } struct ListNode* slow = head; struct ListNode* fast = head; while (fast != tail \u0026amp;\u0026amp; fast-\u0026gt;next != tail) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } //struct TreeNode* node = (struct TreeNode)malloc(sizeof(struct TreeNode)); struct TreeNode *node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = slow-\u0026gt;val; node-\u0026gt;left = buildBST(head, slow); node-\u0026gt;right = buildBST(slow-\u0026gt;next, tail); return node; } struct TreeNode* sortedListToBST(struct ListNode* head){ if (!head) { return NULL; } return buildBST(head, NULL); } 110.平衡二叉树 思路：分别求左右子树的深度height，比较左右深度差值。递归判断左右子树是否为平衡二叉树\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int max(int a, int b) { return a \u0026gt;= b ? a : b; } int height(struct TreeNode* root) { if (root == NULL) { return 0; } else { return 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); } } bool isBalanced(struct TreeNode* root){ if (root == NULL) { return 1; } int left = height(root-\u0026gt;left); int right = height(root-\u0026gt;right); return abs(left - right) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } 112. 路径总和 思路：递归：左右子树 递归出口； 注意书判空\nbool hasPathSum(struct TreeNode* root, int targetSum){ if (root == NULL) { return false; } if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL \u0026amp;\u0026amp; root-\u0026gt;val == targetSum) { return true; } return hasPathSum(root-\u0026gt;left, targetSum - root-\u0026gt;val) || hasPathSum(root-\u0026gt;right, targetSum - root-\u0026gt;val); } 121.买卖股票的最佳时机 思路：动态规划，股票是连续收益的 maxcmp(0, maxCur + prices[i] - prices[i - 1])，收益累计\nint maxcmp(int a, int b) { return (a \u0026gt;= b) ? a : b; } int maxProfit(int* prices, int pricesSize){ int maxCur = 0, maxSoFar = 0; for (int i = 1; i \u0026lt; pricesSize; i++) { maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]); maxSoFar = maxcmp(maxSoFar, maxCur); printf(\u0026#34;i = %d\\t maxCur = %d \\t maxSoFar = %d\\n\u0026#34;, i, maxCur, maxSoFar); } return maxSoFar; } 125.验证回文串 思路：判断是否是字母和数字，库函数 isalnum; 注意库函数 isalpha 为判断是否为字母。头尾双指针，逼近中间，注意非数字字母忽略\nbool isPalindrome(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt;= right) { //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[left])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left])) { left++; } //while (left \u0026lt; right \u0026amp;\u0026amp; !isalpha(s[right])) { while (left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right])) { right--; } printf(\u0026#34;left = %d\\t right = %d\\n\u0026#34;, left, right); if (tolower(s[left]) != tolower(s[right])) { return false; } left++; right--; } return true; } 136.只出现一次的数字 思路：n ^ n = 0 一个数与自己异或为 0\nint singleNumber(int* nums, int numsSize){ int res = 0; for (int i = 0; i \u0026lt; numsSize; i++) { res = res ^ nums[i]; } return res; } 141.环形链表 思路：快慢双指针，fast一次走两步，slow一次走一步，判断是否能相遇\nbool hasCycle(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; while (slow \u0026amp;\u0026amp; fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { return true; } } return false; } 142.环形链表 II 思路：快慢双指针，判断出环向后，从链表入口开始，和slow指针相同速度遍历，直到相遇\nstruct ListNode *detectCycle(struct ListNode *head) { struct ListNode* slow = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* fast = (struct ListNode*)malloc(sizeof(struct ListNode)); slow = head; fast = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) { struct ListNode* entry = head; while (slow != entry) { slow = slow-\u0026gt;next; entry = entry-\u0026gt;next; } return entry; } } return NULL; } 153.寻找旋转排序数组中的最小值 思路：二分查找\nint findMin(int* nums, int numsSize){ int low = 0; int high = numsSize - 1; while (low \u0026lt; high) { int mid = low + (high - low) / 2; if (nums[mid] \u0026lt; nums[high]) { high = mid; } else { low = mid + 1; } } return nums[low]; } int findMin(int* nums, int numsSize){ int i; for (i = 0; i \u0026lt; numsSize - 1; i++) { if (nums[i] \u0026gt; nums[(i+1)]) { return nums[i+1]; } } return nums[0]; } 160.相交链表 思路： 一、 二、先统计两个链表结点个数，然后长链表先走个数差位\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *cur1 = headA; struct ListNode *cur2 = headB; if (cur1 == NULL || cur2 == NULL) return NULL; while (cur1 \u0026amp;\u0026amp; cur2 \u0026amp;\u0026amp; cur1 != cur2) { cur1 = cur1-\u0026gt;next; cur2 = cur2-\u0026gt;next; if (cur1 == cur2) { return cur1; } if (!cur1) { cur1 = headB; } if (!cur2) { cur2 = headA; } } return cur1; } 169.多数元素 思路：选定一个主元素，计数器\nint majorityElement(int* nums, int numsSize){ int count = 1; int majorNum = nums[0]; for (int i = 1; i \u0026lt; numsSize; i++) { if (count == 0) { majorNum = nums[i]; count++; } else if (majorNum == nums[i]) { count++; } else { count--; } } return majorNum; } 173.二叉搜索树迭代器 思路：\ntypedef struct { int* res; int size; int idx; } BSTIterator; int getTreeSize(struct TreeNode* root) { if (root == NULL) { return 0; } return 1 + getTreeSize(root-\u0026gt;left) + getTreeSize(root-\u0026gt;right); } void inorder(int* ret, int* retSize, struct TreeNode* root) { if (root == NULL) { return; } inorder(ret, retSize, root-\u0026gt;left); ret[(*retSize)++] = root-\u0026gt;val; inorder(ret, retSize, root-\u0026gt;right); } int* inorderTraversal(int* retSize, struct TreeNode* root) { *retSize = 0; int* ret = malloc(sizeof(int) * getTreeSize(root)); inorder(ret, retSize, root); return ret; } BSTIterator* bSTIteratorCreate(struct TreeNode* root) { BSTIterator* ret = malloc(sizeof(BSTIterator)); ret-\u0026gt;res = inorderTraversal(\u0026amp;(ret-\u0026gt;size), root); ret-\u0026gt;idx = 0; return ret; } int bSTIteratorNext(BSTIterator* obj) { return obj-\u0026gt;res[(obj-\u0026gt;idx)++]; } bool bSTIteratorHasNext(BSTIterator* obj) { return (obj-\u0026gt;idx \u0026lt; obj-\u0026gt;size); } void bSTIteratorFree(BSTIterator* obj) { free(obj-\u0026gt;res); free(obj); } 189.轮转数组 思路： 一、每次移动一个数 二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个\nvoid moveOne(int* nums, int numsSize) { int tmp = nums[numsSize - 1]; for (int i = numsSize - 1; i \u0026gt; 0; i--) { nums[i] = nums[i-1]; } nums[0] = tmp; } void rotate(int* nums, int numsSize, int k) { for (int i = 0; i \u0026lt; k; i++) { moveOne(nums, numsSize); } } /* */ void swap(int* a, int* b) { int t = *a; *a = *b; *b = t; } void reverse(int* nums, int start, int end) { while (start \u0026lt; end) { swap(\u0026amp;nums[start], \u0026amp;nums[end]); start += 1; end -= 1; } } void rotate(int* nums, int numsSize, int k) { k %= numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, 0, k - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); reverse(nums, k, numsSize - 1); for (int i = 0; i \u0026lt; numsSize; i++) { printf(\u0026#34;nums[%d] = %d\\t\u0026#34;, i, nums[i]); } printf(\u0026#34;\\n\u0026#34;); } /* void rotate(int* nums, int numsSize, int k){ for (int i = 0; i \u0026lt; k; i++) { int lastElement = nums[numsSize - 1]; for (int j = numsSize - 1; j \u0026gt; 0; j--) { nums[j] = nums[j - 1]; } nums[0] = lastElement; } }*/ /* void rotate(int* nums, int numsSize, int k){ if (k == numsSize / 2 \u0026amp;\u0026amp; numsSize % 2 != 1) { for (int i = 0; i \u0026lt; k; i++) { int tmp = nums[i]; nums[i] = nums[k+i]; nums[k+i] = tmp; } return; } int i = 0; int tmp = nums[0]; int p = 0; int count = 0; do { p = (i + k) % numsSize; printf(\u0026#34;p = %d\\n\u0026#34;,p); int t = nums[p]; nums[p] = tmp; tmp = t; i = p; } while (i != 0); } */ 190.颠倒二进制位 思路：32位，\nuint32_t reverseBits(uint32_t n) { uint32_t m = 0; int cnt = 32; while (cnt) { m \u0026lt;\u0026lt;= 1; m += (n \u0026amp; 0x1); n \u0026gt;\u0026gt;= 1; cnt--; } return m; } 191.位1的个数 思路：n \u0026amp; 0x1\nint hammingWeight(uint32_t n) { int cnt = 0; while (n) { if (n \u0026amp; 0x1) { cnt++; } n \u0026gt;\u0026gt;= 1; } return cnt; } 201.数字范围按位与 思路：n \u0026amp; (n - 1) 去除n最高位的1\nint rangeBitwiseAnd(int left, int right){ while (left \u0026lt; right) { right \u0026amp;= right - 1; } return right; } 203.移除链表元素 思路：递归\nstruct ListNode *removeElements(struct ListNode *head, int val) { if (head == NULL) { return NULL; } if (head-\u0026gt;val == val) { return removeElements(head-\u0026gt;next, val); } else { head-\u0026gt;next = removeElements(head-\u0026gt;next, val); } return head; } 206.反转链表 思路：\nstruct ListNode* reverseList(struct ListNode* head){ struct ListNode* res = NULL; while (head) { struct ListNode* pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } 209.长度最小的子数组 思路：双指针：累加sum，判断sum，大于target，计算长度，减sum，移动left\nint minSubArrayLen(int target, int* nums, int numsSize){ int i = 0; int sum = 0; int len = INT_MAX; for (int j = 0; j \u0026lt; numsSize; j++) { sum += nums[j]; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,j-i+1); sum -= nums[i]; i++; } } } if (len==INT_MAX) { len=0; } return len; } int minSubArrayLen(int target, int* nums, int numsSize){ int left = 0; int right = 0; int sum = 0; int len = INT_MAX; while (right \u0026lt; numsSize) { sum += nums[right]; right++; if (sum \u0026lt; target) { continue; } else { while (sum \u0026gt;= target) { len = fmin(len,right-left); sum -= nums[left]; left++; } } } if (len == INT_MAX) { len = 0; } return len; } 215.数组中的第K个最大元素 思路：排序，第k个最大\nint Cmp(const void* a, const void* b) { return *(int *)b - *(int *)a; } int findKthLargest(int* nums, int numsSize, int k){ qsort(nums, numsSize, sizeof(int), Cmp); return nums[k-1]; } 217.存在重复元素 思路： 一、排序，比较前一个数和当前数是否相等 二、uthash\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } bool containsDuplicate(int* nums, int numsSize){ if (numsSize \u0026lt;= 1) { return true; } qsort(nums, numsSize, sizeof(int), Cmp); for (int i = 1; i \u0026lt; numsSize; i++) { if (nums[i-1] == nums[i]) { return true; } } return false; } struct my_struct { int id; UT_hash_handle hh; }; struct my_struct *users = NULL; bool containsDuplicate(int* nums, int numsSize){ struct my_struct *s; HASH_FIND_INT(users, nums[i], s); if (s == NULL) { s = (struct my_struct*)malloc(sizeof(struct my_struct)); s-\u0026gt;id = nums[i]; HASH_ADD_INT(users, id, s); } else { return true; } return false; } 226.翻转二叉树 思路：判空，交换左右子树，递归调用\nstruct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode* tmp = root-\u0026gt;left; root-\u0026gt;left = root-\u0026gt;right; root-\u0026gt;right = tmp; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); return root; } struct TreeNode* invertTree(struct TreeNode* root){ if (root == NULL) { return NULL; } struct TreeNode *left = (struct TreeNode *)malloc(sizeof(struct TreeNode)); struct TreeNode *right = (struct TreeNode *)malloc(sizeof(struct TreeNode)); left = invertTree(root-\u0026gt;left); right = invertTree(root-\u0026gt;right); root-\u0026gt;left = right; root-\u0026gt;right = left; return root; } 231.2的幂 思路：一：累计除2，判断最后是否为1，即整除 二、递归，判断对2取余\nbool isPowerOfTwo(int n) { if (!n) { return false; } while (n % 2 == 0) { n /= 2; } return n == 1; } bool isPowerOfTwo(int n){ if (n == 0) { return false; } if (n == 1) { return true; } bool res = false; if (n % 2 != 0) { return false; }else { res = isPowerOfTwo(n/2); } return res; } bool isPowerOfTwo(int n){ //用位运算来判断有几个1，要是只有一个1那就是2的幂。 if (n \u0026gt;= 2147483647 || n \u0026lt;= -2147483648) { return false; } int nu m =0; while (n\u0026gt;0 \u0026amp;\u0026amp; n!=0) { n \u0026amp;= (n-1); num++; } if (num!=1) { return false; } return true; } 234.回文链表 思路； 一、通过一个数组记录链表中的元素值，在判断数组是否是回文。 二、翻转链表后半部分\n#define MAXSIZE 100000 bool isPalindrome(struct ListNode* head){ int size = 0; int nums[MAXSIZE] = {0}; struct ListNode* p = head; // 判断条件 while (p) { nums[size++] = p-\u0026gt;val; p = p-\u0026gt;next; } printf(\u0026#34;size = %d\\n\u0026#34;, size); int left = 0; int right = size - 1; while (left \u0026lt;= right) { if (nums[left] != nums[right]) { return false; } left++; right--; } return true; } struct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } bool isPalindrome(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; struct ListNode *last; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; faast = fast-\u0026gt;next-\u0026gt;next; } if (fast != NULL) { slow = slow-\u0026gt;next; } last = reverse(slow); while (last) { if (head-\u0026gt;val != last-\u0026gt;val) { return 0; } head = head-\u0026gt;next; last = last-\u0026gt;next; } return 1; } 242.有效的字母异位词 思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录\u0026ndash;，最后，判断表格中所有值是否为零\n#define NUMSIZE 256 bool isAnagram(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); if (sLen != tLen) { return false; } int table[256] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; tLen; i++) { table[t[i]]--; } for (int i = 0; i \u0026lt; NUMSIZE; i++) { if (table[i] != 0) { return false; } } return true; } 268.丢失的数字 思路：边求和，边减去数组中的数字\nint missingNumber(int* nums, int numsSize){ int mNum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { mNum += (i + 1); mNum -= nums[i]; } return mNum; } 278.第一个错误的版本 思路：二分查找\nint firstBadVersion(int n) { int left = 1; int right = n; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (isBadVersion(mid) \u0026amp;\u0026amp; !isBadVersion(mid-1)) { return mid; } else if (isBadVersion(mid) \u0026amp;\u0026amp; isBadVersion(mid-1)) { right = mid - 1; } else { left = mid + 1; } } return -1; } int firstBadVersion(int n) { int low = 1, high = n; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (isBadVersion(mid)) { high = mid - 1; } else { low = mid + 1; } } return low; } 283.移动零 思路：不等于零时向数组中添加，等于零时跳过，最后填充0 nums[start++] = nums[i]\nvoid moveZeroes(int* nums, int numsSize){ int start = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] != 0) { nums[start++] = nums[i]; } } for (; start \u0026lt; numsSize; start++) { nums[start] = 0; } } 287.寻找重复整数 思路：循环遍历，标记，判断是否标记过，return\n#define MAXSIZE 100001 int findDuplicate(int* nums, int numsSize){ int table[MAXSIZE] = {0}; for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] != 0) { return nums[i]; } else { table[nums[i]]++; } } return -1; } 344.反转字符串 思路：双指针，交换\nvoid reverseString(char* s, int sSize){ int left =0; int right = sSize - 1; while (left \u0026lt; right) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; } } 367.有效的完全平方数 思路：for 循环，条件 i * i \u0026lt;= num\nbool isPerfectSquare(int num) { for (long i = 0; i * i \u0026lt;= num; i++) { if (i * i == num) { return true; } } return false; } 387.字符串中的第一个唯一字符 思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。\n#define NUMSIZE 256 int firstUniqChar(char * s){ int sLen = strlen(s); int table[NUMSIZE] = {0}; for (int i = 0; i \u0026lt; sLen; i++) { table[s[i]]++; } for (int i = 0; i \u0026lt; sLen; i++) { if (table[s[i]] == 1) { return i; } } return -1; } 389.找不同 思路：字符可以转化为数字，为了防止溢出通过 - \u0026lsquo;a\u0026rsquo;，求两个字符串的差值，在加上\u0026rsquo;a\u0026rsquo;\nchar findTheDifference(char * s, char * t){ int sLen = strlen(s); int tLen = strlen(t); int nS = 0; int nT = 0; for (int i = 0; i \u0026lt; sLen; i++) { nS += s[i] - \u0026#39;a\u0026#39;; } for (int i = 0; i \u0026lt; tLen; i++) { nT += t[i] - \u0026#39;a\u0026#39;; } return (char)(nT - nS + \u0026#39;a\u0026#39;); } 404.左叶子之和 思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树\nint sumOfLeftLeaves(struct TreeNode* root){ if (root == NULL) { return 0; } int sum = 0; if (root-\u0026gt;left) { if (root-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;left-\u0026gt;right == NULL) { sum += root-\u0026gt;left-\u0026gt;val; } } return sum + sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } int isleaf(struct TreeNode* root) { return root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL; } int sumOfLeftLeaves(struct TreeNode* root) { if(root == NULL) { return 0; } if (root-\u0026gt;left) { if(isleaf(root-\u0026gt;left)) { // 此处直接递归，少一层调用 return root-\u0026gt;left-\u0026gt;val + sumOfLeftLeaves(root-\u0026gt;right); } } return sumOfLeftLeaves(root-\u0026gt;left) + sumOfLeftLeaves(root-\u0026gt;right); } 442.数组中重复的数据 思路： 一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。 二、\n#define MAXSIZE 100000 int* findDuplicates(int* nums, int numsSize, int* returnSize){ int table[MAXSIZE] = {0}; *returnSize = 0; int *res = (int *)malloc(sizeof(int) * MAXSIZE); for (int i = 0; i \u0026lt; numsSize; i++) { if (table[nums[i]] == 1) { res[*returnSize] = nums[i]; (*returnSize)++; } else { table[nums[i]]++; } } return res; } int* findDuplicates(int* nums, int numsSize, int* returnSize) { int table[100000] = {0}; int *res = (int *)malloc(sizeof(int) * 100000); int j = 0; for (int i = 0; i \u0026lt; numsSize; i++) { table[nums[i]]++; if (table[nums[i]] == 2) { res[j++] = nums[i]; } } *returnSize = j; return res; } 461.汉明距离 思路： 一、求 x ^ y 中 1 的个数 二、比较x，y的每一位 和 1与\nint hammingDistance(int x, int y) { int n = x ^ y; int res = 0; while (n) { int p = n \u0026amp; 1; if (p) { res++; } n \u0026gt;\u0026gt;= 1; } return res; } int hammingDistance(int x, int y){ int count = 0; while (x || y) { int nX = x \u0026amp; 0x1; int nY = y \u0026amp; 0x1; if (nX != nY) { count++; } x \u0026gt;\u0026gt;= 1; y \u0026gt;\u0026gt;= 1; } return count; } 476.数字的补数 思路： 一、按位与1求与，再取反(!)，然后移位， 二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^\nint findComplement(int num){ int res = 0; int count = 0; while (num) { int t = !(num \u0026amp; 0x1); t \u0026lt;\u0026lt;= count; printf(\u0026#34;t = %d\\n\u0026#34;, t); res += t; count++; num\u0026gt;\u0026gt;=1; } return res; } int findComplement(int num){ int totalBits = 0; int tmp = num; while (tmp) { totalBits++; tmp \u0026gt;\u0026gt;= 1; } int flipNumber = 1; for (int i = 1; i \u0026lt; totalBits; i++) { flipNumber += UINT32_C(1) \u0026lt;\u0026lt; i; } num = num ^ flipNumber; return num; } 509.斐波那契数列 思路：一、递归 二、迭代\n递归 int fib(int n){ if (n \u0026lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); } 迭代 int fib(int n){ if (n \u0026lt;= 1) { return n; } int* nums = (int *)malloc(sizeof(int) * (n + 1)); nums[0] = 0; nums[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { nums[i] = nums[i - 1] + nums[i - 2]; } return nums[n]; } 520.检测大写字母 思路： 一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。 二、\nbool detectCapitalUse(char * word){ int len = strlen(word); if (len \u0026lt;= 1) { return true; } int i = 1; if (isupper(word[i])) { i = 0; while (word[i] != \u0026#39;\\0\u0026#39;) { if (!isupper(word[i])) { return false; } i++; } } else { while (word[i] != \u0026#39;\\0\u0026#39;) { if (isupper(word[i])) { return false; } i++; } } return true; } bool detectCapitalUse(char * word){ int len = strlen(word); if (len == 1) { return true; } for (int i = 1; i \u0026lt; len; i++) { // word[0] 每次都需要判断，一个复杂度。 if (isupper(word[0]) \u0026amp;\u0026amp; isupper(word[1])) { if (!isupper(word[i])) { return false; } } else { if (isupper(word[i])) { return false; } } } return true; } 561.拆分数组I 思路：排序，取偶数位求和。\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int arrayPairSum(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), Cmp); int minSum = 0; for (int i = 0; i \u0026lt; numsSize; i++) { if (i % 2 == 0) { minSum += nums[i]; } } return minSum; } 617.合并二叉树 思路：递归，判空，\nstruct TreeNode* newNode(int val) { struct TreeNode* node = malloc(sizeof(struct TreeNode)); node-\u0026gt;val = val; node-\u0026gt;left = NULL; node-\u0026gt;right = NULL; return node; } struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){ /* if (root1 == NULL \u0026amp;\u0026amp; root2 == NULL) { return NULL; } */ if (root1 == NULL) { return root2; } if (root2 == NULL) { return root1; } /* struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val += root1 == NULL ? 0 : root1-\u0026gt;val; root-\u0026gt;val += root2 == NULL ? 0 : root2-\u0026gt;val; root-\u0026gt;left = NULL; root-\u0026gt;right = NULL; */ int val = (root1 == NULL ? 0 : root1-\u0026gt;val) + (root2 == NULL ? 0 : root2-\u0026gt;val); struct TreeNode* root = newNode(val); root-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return root; } 647.回文子串 思路：左侧判断去重，左右判断相等。\nint countSubstrings(char * s) { int len = strlen(s); int res = len; // 每个字符都是回文 for (int i = 0; i \u0026lt; len; i++) { int p = i - 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; s[p] == s[i]) { // 左侧去重 res++; p--; } int q = i + 1; while (p \u0026gt;= 0 \u0026amp;\u0026amp; q \u0026lt; len \u0026amp;\u0026amp; s[p] == s[q]) { // 判断左右相等 res++; p--; q++; } } return res; } int countSubstrings(char * s){ int len = strlen(s); int count = 0; for (int i = 0; i \u0026lt; len; i++) { count += countPalin(s, i, i, len); if (i != len - 1) { count += countPalin(s, i, i+1, len); } } return count; } int countPalin(char *s, int head, int tail, int len) { int ret = (s[head] == s[tail]) ? 1 : 0; if (ret \u0026amp;\u0026amp; head - 1 \u0026gt;= 0 \u0026amp;\u0026amp; tail + 1 \u0026lt; len) { ret += countPalin(s, head - 1, tail + 1, len); } return ret; } 674.最长连续递增序列 思路：双循环判断，\nint findLengthOfLCIS(int* nums, int numsSize){ if (numsSize == 1) { return 1; } int p2 = 0; int res = 0; for (int i = 1; i \u0026lt; numsSize; i++) { while (i \u0026lt; numsSize \u0026amp;\u0026amp; nums[i-1] \u0026lt; nums[i]) { i++; } res = res \u0026gt; i - p2 ? res : i - p2; p2 = i; } return res; } int findLengthOfLCIS(int* nums, int numsSize){ int maxLen = 0; int i = 0; while (i \u0026lt; numsSize) { int start = i; while (start + 1 \u0026lt; numsSize \u0026amp;\u0026amp; nums[start] \u0026lt; nums[start + 1]) { start++; } maxLen = maxLen \u0026gt; (start - i + 1) ? maxLen : (start - i + 1); start++; i = start; } return maxLen; } 700.二叉搜索树中的搜索 思路：递归，注意 判空 root == NULL\nstruct TreeNode* searchBST(struct TreeNode* root, int val){ if (root == NULL) { return NULL; } if (root-\u0026gt;val == val) { return root; } else if (root-\u0026gt;val \u0026gt; val) { return searchBST(root-\u0026gt;left, val); } else { return searchBST(root-\u0026gt;right, val); } return NULL; } 701.二叉搜索树中的插入操作 思路：递归，递归出口，root == NULL, 新建树结点 malloc\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){ if (root == NULL) { struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode)); newNode-\u0026gt;val = val; newNode-\u0026gt;left = NULL; newNode-\u0026gt;right = NULL; return newNode; } if (root-\u0026gt;val \u0026lt; val) { root-\u0026gt;right = insertIntoBST(root-\u0026gt;right, val); } if (root-\u0026gt;val \u0026gt; val) { root-\u0026gt;left = insertIntoBST(root-\u0026gt;left, val); } return root; } 704.二分查找 思路：二分查找，注意 left \u0026lt;= right ，包含等于\nint search(int* nums, int numsSize, int target){ int left = 0; int right = numsSize - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 709.转换成小写字母 思路；库函数 isupper, tolower\nchar * toLowerCase(char * s){ int len = strlen(s); for (int i = 0; i \u0026lt; len; i++) { if (isupper(s[i])) { s[i] = tolower(s[i]); } } return s; } 771.宝石和石头 思路：表记录stones中每个字符个数，求和jewels字符表中的值\nint numJewelsInStones(char * jewels, char * stones){ int table[256] = {0}; int sLen = strlen(stones); for (int i = 0; i \u0026lt; sLen; i++) { table[stones[i]]++; } int jLen = strlen(jewels); int sum = 0; for (int i = 0; i \u0026lt; jLen; i++) { sum += table[jewels[i]]; } return sum; } 852.山脉数组的峰顶索引 思路：判断条件，完全\nint peakIndexInMountainArray(int* arr, int arrSize){ int low = 1, high = arrSize; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026gt; arr[mid + 1]) return mid; else if (arr[mid - 1] \u0026lt; arr[mid] \u0026amp;\u0026amp; arr[mid] \u0026lt; arr[mid + 1]) low = mid + 1; else high = mid - 1; } return -1; } 876.链表的中间结点 思路：快慢指针，第二个指针通过 偶数判断 for循环\nstruct ListNode* middleNode(struct ListNode* head){ struct ListNode* pos1 = head; struct ListNode* pos2 = head; for (int i = 0; pos1-\u0026gt;next != NULL; pos1 = pos1-\u0026gt;next, i++) { if (i % 2 == 0) { pos2 = pos2-\u0026gt;next; } } return pos2; } 905.按奇偶排序数组 思路: 一、双指针，同917 二、判断，前后索引移动，双指针\n解法一： int* sortArrayByParity(int* nums, int numsSize, int* returnSize) { *returnSize = numsSize; int start = 0; int end = numsSize - 1; while (start \u0026lt; end) { while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 == 0) { start++; } while (end \u0026gt; start \u0026amp;\u0026amp; nums[end] % 2 == 1) { end--; } while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] % 2 != 0 \u0026amp;\u0026amp; nums[end] % 2 != 1) { int tmp = nums[start]; nums[start] = nums[end]; nums[end] = tmp; start++; end--; } } return nums; } int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int left = 0; int right = numsSize - 1; while (left \u0026lt; right) { if (nums[left] % 2 == 0) { left++; continue; } if (nums[right] % 2 == 1) { right--; continue; } int tmp = nums[left]; nums[left] = nums[right]; nums[right] = tmp; left++; right--; } return nums; } 解法二； int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ int *res = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int j = 0; int p = numsSize - 1; for (int i = 0; i \u0026lt; numsSize; i++) { if (nums[i] % 2 == 0) { res[j] = nums[i]; j++; } else { res[p] = nums[i]; p--; } } return res; } 917.仅仅反转字母 思路：双指针，库函数 isalpha， continue\nchar * reverseOnlyLetters(char * s){ int len = strlen(s); int left = 0; int right = len - 1; while (left \u0026lt; right) { if (!isalpha(s[left])) { left++; continue; } if (!isalpha(s[right])) { right--; continue; } //if (isalpha(s[left]) \u0026amp;\u0026amp; isalpha(s[right])) { char c = s[left]; s[left] = s[right]; s[right] = c; left++; right--; //} } return s; } 938.二叉搜索树的范围和 int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } if (low \u0026gt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;right, low, high); } if (high \u0026lt; root-\u0026gt;val) { return rangeSumBST(root-\u0026gt;left, low, high); } return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } int rangeSumBST(struct TreeNode* root, int low, int high){ if (root == NULL) { return 0; } else if (root-\u0026gt;val \u0026gt;= low \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= high) { return root-\u0026gt;val + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } else { return rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } } 965.单值二叉树 思路：递归，递归出口：root == NULL\nbool isUnivalTree(struct TreeNode* root){ // root不判空会报错： // member access within null pointer of type \u0026#39;struct TreeNode\u0026#39; if (root == NULL) { return true; } // 多余 /* if (root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return true; } */ if (root-\u0026gt;left != NULL) { if (root-\u0026gt;left-\u0026gt;val != root-\u0026gt;val) { return false; } } if (root-\u0026gt;right != NULL) { if (root-\u0026gt;right-\u0026gt;val != root-\u0026gt;val) { return false; } } return isUnivalTree(root-\u0026gt;left) \u0026amp;\u0026amp; isUnivalTree(root-\u0026gt;right); } 977.有序数组的平方 思路: 一、先平方，再排序 二、双指针，左右指针比较绝对值大小，从后向前填充结果数组\nint Cmp(const void* a, const void* b) { return *(int *)a - *(int *)b; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; for (int i = 0; i \u0026lt; numsSize; i++) { //squareNum[i] = nums[i] * nums[i]; squareNum[i] = pow(nums[i], 2); } qsort(squareNum, numsSize, sizeof(int), Cmp); return squareNum; } int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* squareNum = (int *)malloc(sizeof(int) * numsSize); *returnSize = numsSize; int left = 0; int right = numsSize - 1; int i = numsSize - 1; while (left \u0026lt; right) { if (fabs(nums[left]) \u0026gt; nums[right]) { squareNum[i--] = nums[left] * nums[left]; left++; } else { squareNum[i--] = nums[right] * nums[right]; right--; } } squareNum[i] = nums[left] * nums[left]; return squareNum; } 1089.复写零 思路：将原数组复制一份，根据复制数组，修改原数组值\nvoid duplicateZeros(int* arr, int arrSize) { int b[arrSize]; // = {0}; memcpy(b, arr, sizeof(int) * arrSize); for (int i = 0, j = 0; i \u0026lt; arrSize \u0026amp;\u0026amp; j \u0026lt; arrSize; i++) { arr[j++] = b[i]; if (j \u0026lt; arrSize \u0026amp;\u0026amp; b[i] == 0) { arr[j++] = 0; } }W } void duplicateZeros(int* arr, int arrSize){ int * nums = (int *)malloc(sizeof(int) * arrSize); for (int i = 0; i \u0026lt; arrSize; i++) { nums[i] = arr[i]; } int j = 0; for (int i = 0; i \u0026lt; arrSize; i++, j++) { arr[i] = nums[j]; if (i + 1 \u0026lt; arrSize \u0026amp;\u0026amp; nums[j] == 0) { arr[++i] = 0; } } } 1184.公交站间的距离 思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){ if (start \u0026gt; destination) { int tmp = start; start = destination; destination = tmp; } int min = 0; int sum = 0; for (int i = 0; i \u0026lt; distanceSize; i++) { sum += distance[i]; if (i \u0026gt;= start \u0026amp;\u0026amp; i \u0026lt; destination) { min += distance[i]; } } min = min \u0026lt; (sum - min) ? min : sum - min; return min; } 1189. “气球” 的最大数量 思路：统计字符次数，注意 字符串指针 取值 *p 或者 字符数组 test[i]\nint maxNumberOfBalloons(char * text){ int len = strlen(text); int table[5] = {0}; char* p = text; while (*p != \u0026#39;\\0\u0026#39;) { if (*p == \u0026#39;b\u0026#39;) { table[0]++; } if (*p == \u0026#39;a\u0026#39;) { table[1]++; } if (*p == \u0026#39;l\u0026#39;) { table[2]++; } if (*p == \u0026#39;o\u0026#39;) { table[3]++; } if (*p == \u0026#39;n\u0026#39;) { table[4]++; } p++; } table[2] /= 2; table[3] /= 2; int min = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { min = min \u0026lt; table[i] ? min : table[i]; } return min; } /* int maxNumberOfBalloons(char * text){ int len = strlen(text); int testNum[5] = {0}; for (int i = 0; i \u0026lt; len; i++) { if (text[i] == \u0026#39;b\u0026#39;) { testNum[0]++; } if (text[i] == \u0026#39;a\u0026#39;) { testNum[1]++; } if (text[i] == \u0026#39;l\u0026#39;) { testNum[2]++; } if (text[i] == \u0026#39;o\u0026#39;) { testNum[3]++; } if (text[i] == \u0026#39;n\u0026#39;) { testNum[4]++; } } testNum[2] /= 2; testNum[3] /= 2; int res = INT_MAX; for (int i = 0; i \u0026lt; 5; i++) { res = res \u0026lt; testNum[i] ? res : testNum[i]; } return res; } */ 1207.独一无二的出现次数 解法一\n通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true\nuniqueOccurrences bool uniqueOccurrences(int* arr, int arrSize){ int table[2001] = {0}; for (int i = 0; i \u0026lt; arrSize; i++) { table[arr[i] + 1000]++; printf(\u0026#34;table[arr[%d] + 1000] = %d\\n\u0026#34;, i, table[arr[i] + 1000]); } int table1[2001] = {0}; for (int i = 0; i \u0026lt; 2001; i++) { table1[i] = 0; if (table[i] != 0) { if (table1[table[i]] != 0) { printf(\u0026#34;table1[table[%d]] = %d\\n\u0026#34;, i, table1[table[i]]); return false; } else { table1[table[i]]++; } } } return true; } 解法二：\n同解法一\n/* */ bool uniqueOccurrences(int* arr, int arrSize){ int hashTable[2001]={0};//初始化一张表，下标对应元素值，存储对应元素出现的次数 for(int i=0;i\u0026lt;arrSize;i++) { hashTable[arr[i]+1000]++; } bool visited[1001]={false}; for(int i=0;i\u0026lt;2001;i++) { if(hashTable[i]) { //如果i在数组中 if(visited[hashTable[i]]) { //如果之前出现过与i相同的重复次数 return false; } else { visited[hashTable[i]]=true;//说明与i相同的重复次数还未出现，设置为已访问过 } } } return true; } 参考博客： https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/leetcode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/","summary":"总结 leetcode基础题目 经典题目： 3.无重复字符的最长子串 4. 6. 7. 8. 9. 11. 12. 13. 21. 24. 28. 38. 53. 66. 82. 94. 104. 108. 109. 110. 112. 121. 136. 142. 160. 169. 173. 189. 201. 203. 206. 217. 226. 231. 234. 367. 389. 442. 476.","title":"leetcode基础题目"},{"content":"1 程序性能 程序性能是指运行程序所需要的内存大小(空间复杂度)和时间(时间复杂度),运行时间和占用空间是算法性能最关键的指标。 软件程序性能衡量指标: 响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力\n1.1 空间复杂度 空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。 算法在计算机存储器上所占用的存储空间，包括存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间。\n1.2 时间复杂度 时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。\n1.2.1 常见算法大O 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k) 1.2.2 常见数据结构 {% pullquote mindmap mindmap-md %}\n数据结构与算法 线性表 数组 链表 单链表 双链表 循环链表 双向循环链表 静态链表 栈 顺序栈 链式栈 队列 普通队列 双端队列 阻塞队列 并发队列 阻塞并发队列 散列表 散列函数 冲突解决 链表法 开放地址 其他 动态扩容 位置 树 二叉树 二叉查找树 平衡二叉树 平衡二叉查找树 AVL树 红黑树 完全二叉树 满二叉树 多路查找树 B树 B+树 2-3树 2-3-4树 堆 小顶堆 大顶堆 优先级队列 斐波那契堆 二项堆 其他 树状数组 线段树 图 图的存储 邻接矩阵 邻接表 拓扑排序 最短路径 关键路径 最小生成树 二分图 最大流 复杂度分析 空间复杂度 时间复杂度 基本算法思想 分治法 递归算法 贪心算法 动态规划 回溯法 枚举法 排序 O(n^2) 冒泡排序 插入排序 选择排序 希尔排序 O(nlogn) 归并排序 快速排序 堆排序 O(n) 计数排序 基数排序 桶排序 搜索 深度优先搜索 广度优先搜索 A*启发式搜索 查找 线性表查找 树结构查找 散列表查找 字符串匹配 朴素 KMP Robin-Karp Boyer-Moore AC自动机 Trie 后缀数组 其他 数论 计算几何 概率分析 并查集 拓扑网络 矩阵运算 {% endpullquote %} 本章参考： 复杂度速查表 https://liam.page/2016/06/20/big-O-cheat-sheet/ 2 基本数据结构 2.1 线性表 线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。 数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。 两种情况下数据的存储问题： 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”； 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”\n2.1.1 数组 数组是一批相同数据的集合。数组的三部分：地址 大小 和 空间。数组的保存形式为线性表。\nint arr[10]; // /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...) // 数组初始化 int arr1[3] = {1, 2, 3}; char arr6[] = \u0026#34;abcdef\u0026#34;; // 指针 int *ptr = NULL;//定义一个整型的指针变量，初始化为NULL char *ptr = NULL;//定义一个字符的指针变量，初始化为NULL // 二维数组 int arr[3][5] = { 0 }; // C 传递数组给函数 // void myFunction(int *param) void myFunction(int param[10]) void myFunction(int param[]) // C 从函数返回数组 int * myFunction() { ... } array #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct array { int size; int used; int *arr; }; void dump(struct array *array) { for (int idx = 0; idx \u0026lt; array-\u0026gt;used; idx++) { printf(\u0026#34;[%02d]: %08d\\n\u0026#34;, idx, array-\u0026gt;arr[idx]); } } void alloc(struct array *array) { array-\u0026gt;arr = (int *)malloc(array-\u0026gt;size * sizeof(int)); } int insert(struct array *array, int elem) { int idx; if (array-\u0026gt;used \u0026gt;= array-\u0026gt;size) return -1; for (idx = 0; idx \u0026lt; array-\u0026gt;used; idx++) { if (array-\u0026gt;arr[idx] \u0026gt; elem) break; } if (idx \u0026lt; array-\u0026gt;used) memmove(\u0026amp;array-\u0026gt;arr[idx+1], \u0026amp;array-\u0026gt;arr[idx], (array-\u0026gt;used - idx) * sizeof(int)); array-\u0026gt;arr[idx] = elem; array-\u0026gt;used++; return idx; } int delete(struct array *array, int idx) { if (idx \u0026lt; 0 || idx \u0026gt;= array-\u0026gt;used) return -1; memmove(\u0026amp;array-\u0026gt;arr[idx], \u0026amp;array-\u0026gt;arr[idx+1], (array-\u0026gt;used - idx - 1) * sizeof(int)); array-\u0026gt;used--; return 0; } int search(struct array *array, int elem) { for (int idx = 0; idx \u0026lt; array-\u0026gt;used; idx++) { if (array-\u0026gt;arr[idx] == elem) return idx; if (array-\u0026gt;arr[idx] \u0026gt; elem) return -1; } return -1; } int main() { struct array ten_int = {10, 0, NULL}; alloc(\u0026amp;ten_int); if (!ten_int.arr) { return -1; } insert(\u0026amp;ten_int, 1); insert(\u0026amp;ten_int, 3); insert(\u0026amp;ten_int, 2); printf(\u0026#34;=== insert 1, 3, 2\\n\u0026#34;); dump(\u0026amp;ten_int); int idx = search(\u0026amp;ten_int, 2); printf(\u0026#34;2 is at position %d\\n\u0026#34;, idx); idx = search(\u0026amp;ten_int, 9); printf(\u0026#34;9 is at position %d\\n\u0026#34;, idx); printf(\u0026#34;=== delete [6] element \\n\u0026#34;); delete(\u0026amp;ten_int, 6); dump(\u0026amp;ten_int); printf(\u0026#34;=== delete [0] element \\n\u0026#34;); delete(\u0026amp;ten_int, 0); dump(\u0026amp;ten_int); return 0; } 二分搜索 基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0） 左闭右闭[left, right]：high = mid - 1; 左闭右开[left, right)：high = mid; 二分搜索的时间复杂度为 对数时间O(logn)\n// 左闭 右闭区间 [left, right] // low = mid + 1 high = mid - 1 int binary_search(int key, int a[], int n) { int low = 0; int high = n - 1; int mid, count = 0, count1 = 0; while(low \u0026lt; high) { count++; mid = (low + high) / 2; if (key \u0026lt; a[mid]) { high = mid - 1; } else if (key \u0026gt; a[mid]) { low = mid + 1; } else if (key == a[mid]) { count1++; break; } } if (count1 == 0) { return 1; } return 0; } 2.1.2 单链表 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素\ntypedef struct ListElmt_ { void *data; // 数据成员 struct ListElmt_ * next; // next指针 } ListElmt; typedef struct List_ { int size; int (*match)(const void *key1, const void *key2); void (*destroy)(void *data); ListElmt *head; ListElmt *tail; } List; 单链表操作：插入、删除、 如何判断单链表存在回环？ 设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。\n翻转链表\nstruct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head-\u0026gt;next; pre_node-\u0026gt;next = res; res = pre_node; } return res; } singleList #ifndef __SINGLELIST_H__ #define __SINGLELIST_H__ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef struct listNode { struct listNode *next; void *value; }listNode; typedef struct linkedList { listNode *head; size_t len; size_t typesize; void(*dup)(void*, void*); int(*match)(void*, void*); void(*free)(void*); }linkedList; #define listSetDupMethod(l,m) ((l)-\u0026gt;dup = (m)) #define listSetFreeMethod(l,m) ((l)-\u0026gt;free = (m)) #define listSetMatchMethod(l,m) ((l)-\u0026gt;match = (m)) #define listGetDupMethod(l) ((l)-\u0026gt;dup) #define listGetFree(l) ((l)-\u0026gt;free) #define listGetMatchMethod(l) ((l)-\u0026gt;match) linkedList *listCreate(); void listRelease(linkedList *list); void listEmpty(linkedList *list); linkedList *listAddNodeHead(linkedList *list, void *value); linkedList *listAddNodeTail(linkedList *list, void *value); linkedList *listInsertNode(linkedList *list, listNode *old_node, void *value, bool after); void listDelNode(linkedList *list, listNode *node); listNode *listSearchKey(linkedList *list, void *key); listNode *listIndex(linkedList *list, long index); linkedList* listRewind(linkedList *list); size_t listLength(linkedList *list); #endif // !__SINGLELIST_H__ // #include \u0026#34;singleList.h\u0026#34; #include \u0026lt;string.h\u0026gt; linkedList * listCreate() { linkedList *list = NULL; list = malloc(sizeof(*list)); if (NULL == list) { return NULL; } list-\u0026gt;dup = NULL; list-\u0026gt;free = NULL; list-\u0026gt;match = NULL; list-\u0026gt;head = NULL; list-\u0026gt;len = 0; return list; } // void listRelease(linkedList *list) { if (NULL == list) { return; } listEmpty(list); free(list); list = NULL; } void listEmpty(linkedList *list) { if (NULL == list) { return; } while (NULL != list-\u0026gt;head) { listNode *pNode = list-\u0026gt;head; list-\u0026gt;head = pNode-\u0026gt;next; if (NULL != list-\u0026gt;free) { list-\u0026gt;free(pNode-\u0026gt;value); } else { free(pNode-\u0026gt;value); } pNode-\u0026gt;next = NULL; free(pNode); pNode = NULL; } } linkedList * listAddNodeHead(linkedList *list, void * value) { if (NULL == list || NULL == value) { return list; } listNode *node = NULL; node = malloc(sizeof(*node)); if (NULL == node) { return list; } node-\u0026gt;value = value; node-\u0026gt;next = list-\u0026gt;head; list-\u0026gt;head = node; ++list-\u0026gt;len; return list; } linkedList * listAddNodeTail(linkedList *list, void *value) { if (NULL == list || NULL == value) { return list; } listNode *node = NULL; node = malloc(sizeof(*node)); if (NULL == node) { return list; } node-\u0026gt;value = value; node-\u0026gt;next = NULL; if (NULL == list-\u0026gt;head \u0026amp;\u0026amp; list-\u0026gt;len == 0) { list-\u0026gt;head = node; } else { listNode *tail = list-\u0026gt;head; listNode *pre = list-\u0026gt;head; while (NULL != tail) { pre = tail; tail = tail-\u0026gt;next; } pre-\u0026gt;next = node; } ++list-\u0026gt;len; return list; } linkedList * listInsertNode(linkedList *list, listNode *old_node, void *value, bool after) { if (NULL == list || NULL == old_node) { return list; } listNode *pNode = NULL; pNode = malloc(sizeof(*pNode)); if (NULL == pNode) { return list; } pNode-\u0026gt;value = value; if (after) { pNode-\u0026gt;next = old_node-\u0026gt;next; old_node-\u0026gt;next = pNode; } else { listNode *pre = list-\u0026gt;head; while (pre-\u0026gt;next != old_node) { pre = pre-\u0026gt;next; } if (NULL != pre) { pre-\u0026gt;next = pNode; pNode-\u0026gt;next = old_node; } } ++list-\u0026gt;len; return list; } // void listDelNode(linkedList *list, listNode *node) { if (NULL == list || NULL == node) { return; } listNode *pre = list-\u0026gt;head; listNode *cur = list-\u0026gt;head; while (NULL != cur \u0026amp;\u0026amp; cur != node) { pre = cur; cur = cur-\u0026gt;next; } // if (NULL == pre) { return; } pre-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next = NULL; --list-\u0026gt;len; if (NULL != list-\u0026gt;free) { list-\u0026gt;free(node-\u0026gt;value); free(node); node = NULL; } } listNode * listSearchKey(linkedList *list, void *key) { if (NULL == list) { return NULL; } listNode *node = list-\u0026gt;head; while (NULL != node) { if (NULL != list-\u0026gt;match) { if (list-\u0026gt;match(key, node-\u0026gt;value) == 0) { return node; } } else { if (key == node-\u0026gt;value) { return node; } } node = node-\u0026gt;next; } return NULL; } listNode * listIndex(linkedList *list, long index) { if (NULL == list) { return NULL; } if (index \u0026lt;= 0 || index \u0026gt; list-\u0026gt;len) { return NULL; } listNode *pNode = list-\u0026gt;head; for (long i = 0; i \u0026lt; index; ++i) { pNode = pNode-\u0026gt;next; } return pNode; } linkedList* listRewind(linkedList *list) { if (NULL == list) { return NULL; } listNode *head = list-\u0026gt;head; listNode *pre = NULL; listNode *next = NULL; while (NULL != head) { next = head-\u0026gt;next; head-\u0026gt;next = pre; pre = head; head = next; } list-\u0026gt;head = pre; return list; } size_t listLength(linkedList *list) { if (NULL == list) { return 0; } return list-\u0026gt;len; } single_list #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; struct single_list { struct single_list *next; int val; }; struct single_list_head { struct single_list *head; }; bool is_empty(struct single_list_head *head) { return head-\u0026gt;head == NULL; } void dump(struct single_list_head *head) { struct single_list *tmp = head-\u0026gt;head; int idx = 0; while (tmp) { printf(\u0026#34;[%02d]: %08d\\n\u0026#34;, idx++, tmp-\u0026gt;val); tmp = tmp-\u0026gt;next; } } void insert(struct single_list **prev, struct single_list *elem) { if (!prev) return; elem-\u0026gt;next = *prev; *prev = elem; } void insert_head(struct single_list_head *head, struct single_list *elem) { insert(\u0026amp;head-\u0026gt;head, elem); } struct single_list* del(struct single_list **prev) { struct single_list *tmp; if (!prev) return NULL; if (*prev == NULL) return NULL; tmp = *prev; *prev = (*prev)-\u0026gt;next; tmp-\u0026gt;next = NULL; return tmp; }; struct single_list* delete_head(struct single_list_head* head) { return del(\u0026amp;head-\u0026gt;head); }; struct single_list** search(struct single_list_head* head, int target) { struct single_list **prev, *tmp; for (prev = \u0026amp;head-\u0026gt;head, tmp = *prev; tmp \u0026amp;\u0026amp; (tmp-\u0026gt;val \u0026lt; target); prev = \u0026amp;tmp-\u0026gt;next, tmp = *prev); return prev; }; void reverse(struct single_list_head* head) { struct single_list_head tmp = {NULL}; struct single_list *elem; while (!is_empty(head)) { elem = delete_head(head); insert_head(\u0026amp;tmp, elem); } head-\u0026gt;head = tmp.head; } bool is_cyclic(struct single_list_head* head) { struct single_list *s1, *s2; s1 = s2 = head-\u0026gt;head; while(s1 \u0026amp;\u0026amp; s2) { s1 = s1-\u0026gt;next; s2 = s2-\u0026gt;next ? s2-\u0026gt;next-\u0026gt;next:s2-\u0026gt;next; if (s1 == s2) return true; } return false; } struct single_list* middle(struct single_list_head* head) { struct single_list *s1, *s2; struct single_list pseudo_head; pseudo_head.next = head-\u0026gt;head; s1 = s2 = \u0026amp;pseudo_head; while (true) { if (!s2 || !s2-\u0026gt;next) return s1; s1 = s1-\u0026gt;next; s2 = s2-\u0026gt;next-\u0026gt;next; } return NULL; }; int main() { struct single_list_head head = {NULL}; struct single_list lists[10]; struct single_list **prev; int idx; for (idx = 0; idx \u0026lt; 10; idx++) { lists[idx].val = idx; lists[idx].next = NULL; } insert_head(\u0026amp;head, \u0026amp;lists[6]); insert_head(\u0026amp;head, \u0026amp;lists[5]); insert_head(\u0026amp;head, \u0026amp;lists[4]); insert_head(\u0026amp;head, \u0026amp;lists[1]); insert_head(\u0026amp;head, \u0026amp;lists[0]); printf(\u0026#34;=== insert 0, 1, 4, 5, 6\\n\u0026#34;); dump(\u0026amp;head); prev = search(\u0026amp;head, 2); insert(prev, \u0026amp;lists[2]); printf(\u0026#34;=== insert 2\\n\u0026#34;); dump(\u0026amp;head); printf(\u0026#34;middle elem is %d\\n\u0026#34;, middle(\u0026amp;head)-\u0026gt;val); prev = search(\u0026amp;head, 2); if ((*prev) \u0026amp;\u0026amp; ((*prev)-\u0026gt;val == 2)) printf(\u0026#34;The list contains 2\\n\u0026#34;); else printf(\u0026#34;The list not contains 2\\n\u0026#34;); del(prev); prev = search(\u0026amp;head, 2); printf(\u0026#34;After remove 2\\n\u0026#34;); if ((*prev) \u0026amp;\u0026amp; ((*prev)-\u0026gt;val == 2)) printf(\u0026#34;The list contains 2\\n\u0026#34;); else printf(\u0026#34;The list not contains 2\\n\u0026#34;); dump(\u0026amp;head); printf(\u0026#34;After reverse \\n\u0026#34;); reverse(\u0026amp;head); dump(\u0026amp;head); printf(\u0026#34;middle elem is %d\\n\u0026#34;, middle(\u0026amp;head)-\u0026gt;val); lists[0].next = \u0026amp;lists[6]; printf(\u0026#34;list is%s cyclic\\n\u0026#34;, is_cyclic(\u0026amp;head)?\u0026#34;\u0026#34;:\u0026#34; not\u0026#34;); return 0; } LinkedListAlgo #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; /** * 1) 单链表反转 * 2) 链表中环的检测 * 3) 两个有序的链表合并 * 4) 删除链表倒数第 n 个结点 * 5) 求链表的中间结点 * * Author: Smallfly */ typedef struct SinglyLinkedNode { int data; struct SinglyLinkedNode* next; } SinglyLinkedNode; void insertNode(SinglyLinkedNode** head_ref, int data); void printLinkedList(SinglyLinkedNode* head); /** 反转单链表 */ void reverse(SinglyLinkedNode** head_ref) { if (*head_ref == NULL) return; SinglyLinkedNode *prev = NULL; SinglyLinkedNode *current = *head_ref; while (current) { SinglyLinkedNode *next = current-\u0026gt;next; if (!next) { // 到达尾结点时，将地址存入 head_ref *head_ref = current; } current-\u0026gt;next = prev; prev = current; current = next; } } void test_reverse() { SinglyLinkedNode* head = NULL; insertNode(\u0026amp;head, 3); insertNode(\u0026amp;head, 2); insertNode(\u0026amp;head, 1); reverse(\u0026amp;head); printLinkedList(head); } /** 检测单链表是否有环 */ // 这里使用一级指针也可以 int checkCircle(SinglyLinkedNode** head_ref) { if (*head_ref == NULL) return 0; SinglyLinkedNode *slow = *head_ref, *fast = *head_ref; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if (slow == fast) return 1; } return 0; } void test_checkCircle() { SinglyLinkedNode* head = NULL; insertNode(\u0026amp;head, 3); insertNode(\u0026amp;head, 2); insertNode(\u0026amp;head, 1); int result1 = checkCircle(\u0026amp;head); printf(\u0026#34;has circle: %d\\n\u0026#34;, result1); // make circle linklist SinglyLinkedNode* current = malloc(sizeof(SinglyLinkedNode)); current-\u0026gt;data = 0; SinglyLinkedNode* h = current; for (int i = 1; i \u0026lt; 4; ++i) { SinglyLinkedNode* node = malloc(sizeof(SinglyLinkedNode)); node-\u0026gt;data = i; current-\u0026gt;next = node; //reset current node current = node; } current-\u0026gt;next = h; int result2 = checkCircle(\u0026amp;h); printf(\u0026#34;has circle: %d\\n\u0026#34;, result2); } /** 有序链表合并 */ void moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref); SinglyLinkedNode* mergeSortedLinkedList(SinglyLinkedNode* la, SinglyLinkedNode* lb) { // 辅助结点，next 指针持有合并后的有序链表 SinglyLinkedNode dummy; // 有序链表的尾结点 SinglyLinkedNode* tail = \u0026amp;dummy; while (1) { // 如果有一个链表为空，直接与另一个链表接起来 if (!la) { tail-\u0026gt;next = lb; break; } else if (!lb) { tail-\u0026gt;next = la; break; } // 将头结点较小的优先添加到 tail if (la-\u0026gt;data \u0026lt;= lb-\u0026gt;data) { moveNode(\u0026amp;(tail-\u0026gt;next), \u0026amp;la); } else { moveNode(\u0026amp;(tail-\u0026gt;next), \u0026amp;lb); } tail = tail-\u0026gt;next; } return dummy.next; } // 将 src_ref 的头结点，添加到 dest_ref 的头部。 void moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref) { if (*src_ref == NULL) return; SinglyLinkedNode* new_node = *src_ref; *src_ref = new_node-\u0026gt;next; new_node-\u0026gt;next = *dest_ref; *dest_ref = new_node; } void test_mergeSortedLinkedList() { SinglyLinkedNode* a = NULL; insertNode(\u0026amp;a, 10); insertNode(\u0026amp;a, 5); insertNode(\u0026amp;a, 0); SinglyLinkedNode* b = NULL; insertNode(\u0026amp;b, 8); insertNode(\u0026amp;b, 6); insertNode(\u0026amp;b, 3); SinglyLinkedNode* result = mergeSortedLinkedList(a, b); printLinkedList(result); SinglyLinkedNode* result2 = mergeSortedLinkedList(a, NULL); printLinkedList(result2); } /** 删除倒数第 K 个结点 */ void deleteLastKth(SinglyLinkedNode** head_ref, int k) { if (*head_ref == NULL || k == 0) return; // 快指针向前移动 k-1 SinglyLinkedNode* fast = *head_ref; int i = 1; while (i \u0026lt; k \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; ++i; } // 如果快指针为空，说明结点个数小于 k if (fast == NULL) return; SinglyLinkedNode* slow = *head_ref; SinglyLinkedNode* prev = NULL; while (fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next; prev = slow; slow = slow-\u0026gt;next; } // 如果 prev 为空，头结点刚好是第 k 个结点 if (!prev) { (*head_ref) = (*head_ref)-\u0026gt;next; } else { prev-\u0026gt;next = slow-\u0026gt;next; } free(slow); } void test_deleteLastKth() { SinglyLinkedNode* head = NULL; insertNode(\u0026amp;head, 1); insertNode(\u0026amp;head, 2); insertNode(\u0026amp;head, 3); insertNode(\u0026amp;head, 4); insertNode(\u0026amp;head, 5); // 1. 删除头结点 deleteLastKth(\u0026amp;head, 5); printLinkedList(head); // 2. 删除中间结点 deleteLastKth(\u0026amp;head, 2); printLinkedList(head); } /** 求中间结点 */ SinglyLinkedNode* findMiddleNode(SinglyLinkedNode* head) { if (!head) return NULL; SinglyLinkedNode* slow = head; SinglyLinkedNode* fast = head; // 1. 慢指针走一步，快指针两步 while (fast-\u0026gt;next != NULL \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return slow; } void test_findMiddleNode() { SinglyLinkedNode* head = NULL; insertNode(\u0026amp;head, 1); insertNode(\u0026amp;head, 2); insertNode(\u0026amp;head, 3); insertNode(\u0026amp;head, 4); insertNode(\u0026amp;head, 5); SinglyLinkedNode* middleNode = findMiddleNode(head); printf(\u0026#34;%d\\n\u0026#34;, middleNode-\u0026gt;data); printLinkedList(head); } /** 工具方法 */ // 插入新结点到链表头部 void insertNode(SinglyLinkedNode** head_ref, int data) { SinglyLinkedNode* new_node = malloc(sizeof(SinglyLinkedNode)); new_node-\u0026gt;data = data; new_node-\u0026gt;next = *head_ref; *head_ref = new_node; } // 打印链表 void printLinkedList(SinglyLinkedNode* node) { printf(\u0026#34;--- start ---\\n\u0026#34;); while (node) { printf(\u0026#34;data: %d\\n\u0026#34;, node-\u0026gt;data); node = node-\u0026gt;next; } printf(\u0026#34;--- end ---\\n\u0026#34;); } // 跑测试 void test() { test_reverse(); // test_checkCircle(); // test_mergeSortedLinkedList(); // test_deleteLastKth(); // test_findMiddleNode(); } linklist_jinshaohui /************************************************************************* \u0026gt; File Name: lisklist.c \u0026gt; Author: jinshaohui \u0026gt; Mail: jinshaohui789@163.com \u0026gt; Time: 18-10-07 ************************************************************************/ #include\u0026lt;stdio.h\u0026gt; struct stlistNode { int val; struct listNode *next; }listNode; /*反转链表*/ listNode reverseList(listNode *head) { listNode *prev = NULL; listNode *next = NULL; while(head != NULL) { next = head-\u0026gt;next; head-\u0026gt;next = prev; prev = head; head = next; } return prev; } /*判断链表是否有环*/ int hasCycle(listNode *head) { listNode * fast = head; listNode * low = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { low = low-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (low == fast) { return 1; } } return 0; } /*合并有序链表*/ listNode *mergeTwoLists(listNode *l1,listNode *l2) { listNode head = {0}; listNode *pRes = \u0026amp;head; while(1) { if(l1 == NULL) { pRes-\u0026gt;next = l2; } if (l2 == NULL) { pRes-\u0026gt;next = l1; } if(l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { pRes-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { pRes-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } pRes = pRes-\u0026gt;next; } return head; } /* *删除链表倒数第n个节点，并返回链表头节点 */ listNode * removeNthFromEnd(listNode*headi,int n) { listNode *fast = head; listNode *prev = NULL; listNpde *next = head; int k = n; /*快指针往后移动k-1*/ while((k \u0026gt; 1) \u0026amp;\u0026amp; (fast != NULL)) { fast = fast-\u0026gt;next; k--; } /*说明链表数目不足n个*/ if (fast == NULL) { return head; } while (fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next; prev = next; next = next-\u0026gt;next; } if(prev == NULL) { head = head-\u0026gt;next; } else { prev-\u0026gt;next = prev-\u0026gt;next-\u0026gt;next; } return head; } /*求链表的中间节点*/ listNode *middleNode(listNode *head) { listNode * fast = head; listNode * low = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { low = low-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return low; } 2.1.3 双链表 双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。\ntypedef struct DListElmt_ { void *data; struct DListElmt_ *prev; struct DListElmt_ *next; } DListElmt; typedef struct DList_ { int size; int (*match)(const void *key1, const void *key2); void (*destroy)(void *data); DListElmt *head; DListElmt *tail; } DList; Dlist // Dlist.h #include\u0026lt;stdio.h\u0026gt; typedef struct DlistNode { //双向链表中每一个节点 struct DlistNode *prev; //节点前项指针 struct DlistNode *next; //节点后项指针 int data; //数据 }stDlistNode; typedef struct Dlisthead { //定义链表总体 int size; //链表长度 stDlistNode *head; //头指针 stDlistNode *tail; //尾部指针 }stDlistHead; // Dlist.c #include\u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026#34;./Dlist.h\u0026#34; void dlist_init(stDlistHead *dlist) //链表初始化 { dlist-\u0026gt;size = 0; dlist-\u0026gt;head = NULL; dlist-\u0026gt;tail = NULL; return; } void dlist_destory(stDlistHead *dlist) //删除链表 { stDlistNode *pNode = NULL; while(dlist-\u0026gt;size \u0026gt; 0) { pNode = dlist-\u0026gt;head; dlist-\u0026gt;head = dlist-\u0026gt;head-\u0026gt;next; free(pNode); dlist-\u0026gt;size--; } memset(dlist,0,sizeof(stDlistHead)); return; } int dlist_insert_head(stDlistHead *dlist,stDlistNode *pNode,int data) //插入头结点，操作的链表，操作的节点，数据 { if(pNode == NULL) { //当只传递一个数据时 pNode = (stDlistNode *)malloc(sizeof(stDlistNode)); //新建节点，为节点分配空间（malloc（）可能需要#include\u0026lt;malloc.h\u0026gt;） if (pNode == NULL) { return -1; } } pNode-\u0026gt;data = data; pNode-\u0026gt;prev = NULL; pNode-\u0026gt;next = NULL; if (dlist-\u0026gt;size == 0) { //如果链表长度为0，即链表当前无节点， dlist-\u0026gt;head = pNode; dlist-\u0026gt;tail = pNode; } else { //如果链表已有节点，则令新插入节点为头节点 pNode-\u0026gt;next = dlist-\u0026gt;head; dlist-\u0026gt;head-\u0026gt;prev = pNode; dlist-\u0026gt;head = pNode; } dlist-\u0026gt;size++; //每成功调用一次，链表长度+1 return 0; } stDlistNode * dlist_remove_tail(stDlistHead *dlist) //删除尾部节点,并返回删除节点 { stDlistNode *pNode = NULL; if(dlist-\u0026gt;size == 0) { return NULL; } pNode = dlist-\u0026gt;tail; if(dlist-\u0026gt;size \u0026gt; 1) { dlist-\u0026gt;tail = dlist-\u0026gt;tail-\u0026gt;prev; dlist-\u0026gt;tail-\u0026gt;next = NULL; } else { dlist-\u0026gt;head = NULL; dlist-\u0026gt;tail = NULL; } dlist-\u0026gt;size--; return pNode; } void dlist_remove_node(stDlistHead * dlist,stDlistNode *pNode) //删除指定节点 { if ((dlist == NULL)||(pNode == NULL)) { return; } if (dlist-\u0026gt;head == pNode) { dlist-\u0026gt;head = dlist-\u0026gt;head-\u0026gt;next; } else if (dlist-\u0026gt;tail == pNode) { dlist-\u0026gt;tail = pNode-\u0026gt;prev; dlist-\u0026gt;tail-\u0026gt;next = NULL; } else { pNode-\u0026gt;prev-\u0026gt;next = pNode-\u0026gt;next; pNode-\u0026gt;next-\u0026gt;prev = pNode-\u0026gt;prev; } dlist-\u0026gt;size--; pNode-\u0026gt;prev = NULL; pNode-\u0026gt;next = NULL; if (dlist-\u0026gt;size == 0) { memset(dlist,0,sizeof(stDlistHead)); //将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容 } return; } stDlistNode * dlist_search(stDlistHead * dlist,int data) //根据值搜索节点，并返回 { stDlistNode *pNode = dlist-\u0026gt;head; while(pNode != NULL) { if (pNode-\u0026gt;data == data) { return pNode; } pNode = pNode-\u0026gt;next; } return NULL; } void dlist_dump(stDlistHead *dlist) //显示链表中的数据 { int no = 0; stDlistNode *pNode = dlist-\u0026gt;head; while(pNode != NULL) { printf(\u0026#34;\\r\\n [%d] = %d\u0026#34;,no++,pNode-\u0026gt;data); pNode = pNode-\u0026gt;next; //将pNode的下一个节点赋值给pNode，推进循环 } return; } void Lru_dlist(stDlistHead *dlist,int data) //LRU（最近最少使用）缓存淘汰算法 { stDlistNode *pNode = NULL; pNode = dlist_search(dlist,data); if (pNode != NULL) { //如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部 dlist_remove_node(dlist,pNode); } else if(dlist-\u0026gt;size \u0026gt;= 4) { //没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部 pNode = dlist_remove_tail(dlist); } dlist_insert_head(dlist ,pNode,data); return; } int main() { stDlistHead dlist = {0}; stDlistNode * pNode = NULL; dlist_init(\u0026amp;dlist); printf(\u0026#34;\\r\\n inset 1,2,3\u0026#34;); dlist_insert_head(\u0026amp;dlist,NULL,1); dlist_insert_head(\u0026amp;dlist,NULL,2); dlist_insert_head(\u0026amp;dlist,NULL,3); dlist_dump(\u0026amp;dlist); pNode = dlist_remove_tail(\u0026amp;dlist); if(pNode != NULL) { printf(\u0026#34;\\r\\n remove %d\u0026#34;,pNode-\u0026gt;data); } dlist_insert_head(\u0026amp;dlist,pNode,4); dlist_dump(\u0026amp;dlist); Lru_dlist(\u0026amp;dlist,5); dlist_dump(\u0026amp;dlist); Lru_dlist(\u0026amp;dlist,6); dlist_dump(\u0026amp;dlist); Lru_dlist(\u0026amp;dlist,7); dlist_dump(\u0026amp;dlist); Lru_dlist(\u0026amp;dlist,5); dlist_dump(\u0026amp;dlist); while(dlist.size \u0026gt; 0) { pNode = dlist_remove_tail(\u0026amp;dlist); if(pNode != NULL) { printf(\u0026#34;\\r\\n remove %d\u0026#34;,pNode-\u0026gt;data); free (pNode); } } return 0; } linux/list // linux内核源码双向链表实现include/linux/list.h #ifndef _LIST_HEAD_H #define _LIST_HEAD_H // 双向链表节点 struct list_head { struct list_head *next, *prev; }; // 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。 #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } // 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。 #define LIST_HEAD(name) \\ struct list_head name = LIST_HEAD_INIT(name) // 初始化节点：将list节点的前继节点和后继节点都是指向list本身。 static inline void INIT_LIST_HEAD(struct list_head *list) { list-\u0026gt;next = list; list-\u0026gt;prev = list; } // 添加节点：将new插入到prev和next之间。 static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-\u0026gt;prev = new; new-\u0026gt;next = next; new-\u0026gt;prev = prev; prev-\u0026gt;next = new; } // 添加new节点：将new添加到head之后，是new称为head的后继节点。 static inline void list_add(struct list_head *new, struct list_head *head) { __list_add(new, head, head-\u0026gt;next); } // 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。 static inline void list_add_tail(struct list_head *new, struct list_head *head) { __list_add(new, head-\u0026gt;prev, head); } // 从双链表中删除entry节点。 static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; prev-\u0026gt;next = next; } // 从双链表中删除entry节点。 static inline void list_del(struct list_head *entry) { __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } // 从双链表中删除entry节点。 static inline void __list_del_entry(struct list_head *entry) { __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } // 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。 static inline void list_del_init(struct list_head *entry) { __list_del_entry(entry); INIT_LIST_HEAD(entry); } // 用new节点取代old节点 static inline void list_replace(struct list_head *old, struct list_head *new) { new-\u0026gt;next = old-\u0026gt;next; new-\u0026gt;next-\u0026gt;prev = new; new-\u0026gt;prev = old-\u0026gt;prev; new-\u0026gt;prev-\u0026gt;next = new; } // 双链表是否为空 static inline int list_empty(const struct list_head *head) { return head-\u0026gt;next == head; } // 获取\u0026#34;MEMBER成员\u0026#34;在\u0026#34;结构体TYPE\u0026#34;中的位置偏移 #define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) // 根据\u0026#34;结构体(type)变量\u0026#34;中的\u0026#34;域成员变量(member)的指针(ptr)\u0026#34;来获取指向整个结构体变量的指针 #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) // 遍历双向链表 #define list_for_each(pos, head) \\ for (pos = (head)-\u0026gt;next; pos != (head); pos = pos-\u0026gt;next) #define list_for_each_safe(pos, n, head) \\ for (pos = (head)-\u0026gt;next, n = pos-\u0026gt;next; pos != (head); \\ pos = n, n = pos-\u0026gt;next) #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) #endif 2.1.4 跳表 跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。\nskiplist /************************************************************************* \u0026gt; File Name: skiplist.h \u0026gt; Author: jinshaohui \u0026gt; Mail: jinshaohui789@163.com \u0026gt; Time: 18-10-31 \u0026gt; Desc: ************************************************************************/ #ifndef __SKIP_LIST_H__ #define __SKIP_LIST_H__ typedef struct _node { int key; /*key是唯一的*/ int value; /*存储的内容*/ int max_level; /*当前节点最大层数*/ struct _node *next[0];/*level层链表结构*/ }node; typedef struct _skiplist { int level; int count; node *head; }skiplist; /*根据当前结构体元素的地址，获取到结构体首地址*/ #define offsetof(TYPE,MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) #define container(ptr,type,member) ({\\ const typeof( ((type *)0)-\u0026gt;member) *__mptr = (ptr);\\ (type *) ( (char *)__mptr - offsetof(type,member));}) #endif #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;assert.h\u0026gt; #include\u0026#34;./skiplist.h\u0026#34; /*创建node节点*/ node* skip_list_create_node(int level,int key,int value) { node * tmp = NULL; tmp =(node *)malloc(sizeof(node) + level*sizeof(node *)); assert(tmp != NULL); memset(tmp,0,sizeof(node) + level*sizeof(node*)); tmp-\u0026gt;key = key; tmp-\u0026gt;value = value; tmp-\u0026gt;max_level = level; return tmp; } /*创建跳表的表头，max_level层数*/ skiplist * skip_list_create(int max_level) { int i = 0; skiplist * list = NULL; list = (skiplist *)malloc (sizeof(skiplist)); assert(list != NULL); list-\u0026gt;level = 1; list-\u0026gt;count = 0; list-\u0026gt;head = skip_list_create_node(max_level,0,0); if(list-\u0026gt;head == NULL) { free(list); return NULL; } return list; } /*skiplist 销毁*/ void skip_list_destory(skiplist * list) { int i = 0; node * tmp = NULL; if((list == NULL) || (list-\u0026gt;head == NULL)) { return; } while(list-\u0026gt;head-\u0026gt;next[0] != NULL) { tmp = list-\u0026gt;head-\u0026gt;next[0]; list-\u0026gt;head-\u0026gt;next[0] = tmp-\u0026gt;next[0]; free(tmp); } free(list-\u0026gt;head); free(list); return; } /*插入元素获得层数，是随机产生的*/ int skip_list_level(skiplist * list) { int i = 0; int level = 1; for (i = 1; i \u0026lt; list-\u0026gt;head-\u0026gt;max_level; i++) { if ((rand()%2) == 1) { level++; } } return level; } int skip_list_insert(skiplist *list,int key,int value) { int i = 0; int level = 0; node **update = NULL;/*用来更新每层的指针*/ node *tmp = NULL; node *prev = NULL; if (list == NULL) { return 1; } /*申请update空间用于保存每层的指针*/ update = (node **)malloc(sizeof(node *)*list-\u0026gt;head-\u0026gt;max_level); if (update == NULL) { return 2; } /*逐层查询节点的*/ prev = list-\u0026gt;head; for (i = (list-\u0026gt;level -1); i \u0026gt;= 0; i--) { /*初始化每level层的头指针*/ while(((tmp = prev-\u0026gt;next[i]) != NULL) \u0026amp;\u0026amp; (tmp-\u0026gt;key \u0026lt; key)) { prev = tmp; } update[i] = prev; } /*当前key已经存在，返回错误*/ if ((tmp!= NULL) \u0026amp;\u0026amp; (tmp-\u0026gt;key == key)) { return 3; } /*获取插入元素的随机层数，并更新跳表的最大层数*/ level = skip_list_level(list); /*创建当前数据节点*/ tmp = skip_list_create_node(level,key,value); if (tmp == NULL) { return 4; } /*更新最大层数*/ if (level \u0026gt; list-\u0026gt;level) { for (i = list-\u0026gt;level;i \u0026lt; level; i ++) { update[i] = list-\u0026gt;head; } list-\u0026gt;level = level; } /*逐层更新节点的指针*/ for(i = 0; i \u0026lt; level; i++) { tmp-\u0026gt;next[i] = update[i]-\u0026gt;next[i]; update[i]-\u0026gt;next[i] = tmp; } list-\u0026gt;count++; return 0; } int skip_list_delete(skiplist * list, int key ,int *value) { int i = 0; node **update = NULL;/*用来更新每层的指针*/ node *tmp = NULL; node *prev = NULL; if ((list == NULL) \u0026amp;\u0026amp; (value == NULL)\u0026amp;\u0026amp; (list-\u0026gt;count == 0)) { return 1; } /*申请update空间用于保存每层的指针*/ update = (node **)malloc(sizeof(node *)*list-\u0026gt;level); if (update == NULL) { return 2; } /*逐层查询节点的*/ prev = list-\u0026gt;head; for (i = (list-\u0026gt;level -1); i \u0026gt;= 0; i--) { /*初始化每level层的头指针*/ while(((tmp = prev-\u0026gt;next[i]) != NULL) \u0026amp;\u0026amp; (tmp-\u0026gt;key \u0026lt; key)) { prev = tmp; } update[i] = prev; } if ((tmp != NULL) \u0026amp;\u0026amp; (tmp-\u0026gt;key == key)) { *value = tmp-\u0026gt;value; /*逐层删除*/ for(i = 0; i \u0026lt; list-\u0026gt;level; i++) { if(update[i]-\u0026gt;next[i] == tmp) { update[i]-\u0026gt;next[i] = tmp-\u0026gt;next[i]; } } free(tmp); tmp = NULL; /*更新level的层数*/ for (i = list-\u0026gt;level - 1; i \u0026gt;= 0; i++) { if (list-\u0026gt;head-\u0026gt;next[i] == NULL ) { list-\u0026gt;level--; } else { break; } } list-\u0026gt;count--; } else { return 3;/*未找到节点*/ } return 0 ; } /*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/ int skip_list_search(skiplist *list,int key,int *value) { int i = 0; node *prev = NULL; node *tmp = NULL; if((list == NULL) || (list-\u0026gt;count == 0) || (value == NULL)) { return 1; } prev = list-\u0026gt;head; for(i = list-\u0026gt;level - 1; i \u0026gt;= 0; i--) { while(((tmp = prev-\u0026gt;next[i]) != NULL) \u0026amp;\u0026amp; (tmp-\u0026gt;key \u0026lt;= key)) { if (tmp-\u0026gt;key == key) { *value = tmp-\u0026gt;value; return 0; } prev = tmp; } } return -1; } void skip_list_dump(skiplist *list) { int i = 0; node *ptmp = NULL; printf(\u0026#34;\\r\\n----------------------------------------------\u0026#34;); printf(\u0026#34;\\r\\n skip list level[%d],count[%d]\u0026#34;,list-\u0026gt;level,list-\u0026gt;count); for(i = list-\u0026gt;level - 1; i \u0026gt;= 0; i --) { ptmp = list-\u0026gt;head-\u0026gt;next[i]; printf(\u0026#34;\\r\\n level[%d]:\u0026#34;,i); while(ptmp != NULL) { printf(\u0026#34;%d-%d \u0026#34;,ptmp-\u0026gt;key,ptmp-\u0026gt;value); ptmp = ptmp-\u0026gt;next[i]; } } printf(\u0026#34;\\r\\n----------------------------------------------\u0026#34;); return; } int main() { int res = 0; int key = 0; int value = 0; skiplist *list = NULL; list = skip_list_create(5); assert(list != NULL); while(1) { printf(\u0026#34;\\r\\n 请输入key 和 value，当key = 1000时，退出输入：\u0026#34;); scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;key,\u0026amp;value); if (key == 1000) { break; } res = skip_list_insert(list,key,value); if (res != 0) { printf(\u0026#34;\\r\\n skip list insert %d,failed,res=%d.\u0026#34;,key,res); } } skip_list_dump(list); while(1) { printf(\u0026#34;\\r\\n 通过key 查询value的数值，当key = 1000时，退出查询\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;key); if(key == 1000) { break; } res = skip_list_search(list,key,\u0026amp;value); if (res != 0) { printf(\u0026#34;\\r\\n skip list search %d,failed,res=%d.\u0026#34;,key,res); } else { printf(\u0026#34;\\r\\n skip list search %d,sucessful,value=%d.\u0026#34;,key,value); } } skip_list_dump(list); while(1) { printf(\u0026#34;\\r\\n 通过key 删除节点，当key = 1000时，退出删除\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;key); if(key == 1000) { break; } res = skip_list_delete(list,key,\u0026amp;value); if (res != 0) { printf(\u0026#34;\\r\\n skip list search %d,failed,res=%d.\u0026#34;,key,res); } else { printf(\u0026#34;\\r\\n skip list search %d,sucessful,value=%d.\u0026#34;,key,value); } } skip_list_dump(list); skip_list_destory(list); return 0; } 2.1.5 栈 栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。 可通过链表来实现栈stack,允许插入和删除的为栈顶(top),另一端为栈底(bottom),栈中每个元素为frame,栈只支持三个操作:pop,top,push.\ntypedef List Stack; #define stack_init list_init; int stack_push(Stack *stack, const void *data); int stack_pop(Stack *stack, void **data); #define stack_peek(stack) ((stack)-\u0026gt;head == NULL ? NULL : (stack)-\u0026gt;head-\u0026gt;data); #define stack_size list_size; c语言顺序栈\n// 元素elem进栈 int push(char *a, int top, char elem) { a[++top] = elem; return top; } // 数据元素出栈 int pop(char *a, int top) { if (top == -1) { return -1; } top--; return top; } arrayStack /************************************************************************* \u0026gt; File Name: arrayStack \u0026gt; Author: jinshaohui \u0026gt; Mail: jinshaohui789@163.com \u0026gt; Time: 18-10-12 \u0026gt; Desc: 数组实现顺序栈 ************************************************************************/ #ifndef ARRAY_STACJ_H #define ARRAY_STACJ_H typedef struct _array_stack { int size;/*栈的大小*/ int pos;/*当前存储元素的个数，即栈顶元素下表*/ int *array;/*数据存储区*/ }stArrayStack; #define arrayStack_size(arrayStack) (arrayStack-\u0026gt;size) #define arrayStack_is_empty(arrayStack) (arrayStack-\u0026gt;pos == -1) #define arrayStack_is_full(arrayStack) (arrayStack-\u0026gt;pos == (arrayStack-\u0026gt;size-1)) #endif #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026#34;./arrayStack.h\u0026#34; /*创建并初始化顺序栈*/ stArrayStack * arrayStack_create(int size) { stArrayStack *parrStack = NULL; parrStack = (stArrayStack *)malloc(sizeof(stArrayStack)); if (parrStack == NULL) { return NULL; } parrStack-\u0026gt;size = size; parrStack-\u0026gt;pos = -1; parrStack-\u0026gt;array = (int *)malloc(sizeof(int)*size); if(parrStack-\u0026gt;array == NULL) { free(parrStack); return NULL; } return parrStack; } /*销毁顺序栈*/ void arrayStack_destory(stArrayStack * parrStack) { if(parrStack == NULL) { return; } if (parrStack-\u0026gt;array != NULL) { free(parrStack-\u0026gt;array); } free(parrStack); return; } /*出栈*/ int arrayStack_pop(stArrayStack *parrStack) { int data = 0; if(arrayStack_is_empty(parrStack)) { return -1; } data = parrStack-\u0026gt;array[parrStack-\u0026gt;pos]; parrStack-\u0026gt;pos--; return data; } /*入栈*/ int arrayStack_push(stArrayStack *parrStack,int data) { if(arrayStack_is_full(parrStack)) { return -1; } parrStack-\u0026gt;pos++; parrStack-\u0026gt;array[parrStack-\u0026gt;pos] = data; return 0; } int arrayStack_push_new(stArrayStack*parrStack,int data) { int *ptmp = NULL; /*如果栈不满，直接插入*/ if(!arrayStack_is_full(parrStack)) { return arrayStack_push(parrStack,data); } /*如果栈已经满，申请内存*/ ptmp = (int *)malloc(2*parrStack-\u0026gt;size*sizeof(int)); if (ptmp == NULL) { return -1; } memcpy(ptmp,parrStack-\u0026gt;array,parrStack-\u0026gt;size*sizeof(int)); free(parrStack-\u0026gt;array); parrStack-\u0026gt;array = ptmp; parrStack-\u0026gt;size = 2*parrStack-\u0026gt;size; parrStack-\u0026gt;pos++; parrStack-\u0026gt;array[parrStack-\u0026gt;pos] = data; return ; } void arrayStack_dump(stArrayStack *parrStack) { int i = 0; if (arrayStack_is_empty(parrStack)) { printf(\u0026#34;\\r\\n arrayStack is empty.\u0026#34;); return; } printf(\u0026#34;\\r\\narrayStack size = %d,pos= %d,\u0026#34;, parrStack-\u0026gt;size,parrStack-\u0026gt;pos); for(i = 0; i \u0026lt;= parrStack-\u0026gt;pos; i++) { printf(\u0026#34;\\r\\narry[%d] = %d\u0026#34;,i,parrStack-\u0026gt;array[i]); } } int main() { int i = 0; int ret = 0; stArrayStack * parrStack = NULL; printf(\u0026#34;\\r\\n create size = 4 arrayStack.\u0026#34;); parrStack = arrayStack_create(4); if (parrStack == NULL) { printf(\u0026#34;\\r\\n create size = 4 arrayStack faided.\u0026#34;); return 0; } for (i = 0; i \u0026lt; 5; i++) { ret = arrayStack_push(parrStack,i); if(ret != 0) { printf(\u0026#34;\\r\\n push size = %d arrayStack faided.\u0026#34;,i); } } arrayStack_dump(parrStack); ret = arrayStack_push_new(parrStack,4); if(ret != 0) { printf(\u0026#34;\\r\\n push size = %d arrayStack faided.\u0026#34;,4); } arrayStack_dump(parrStack); arrayStack_destory(parrStack); return; } 链栈\ntypedef struct lineStack { char data; struct lineStack *next; }lineStack; lineStack* push(lineStack * stack, char a){ lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; line-\u0026gt;next=stack; stack=line; return stack; } lineStack * pop(lineStack * stack){ if (stack) { lineStack * p=stack; stack=stack-\u0026gt;next; printf(\u0026#34;弹栈元素：%c \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;栈顶元素：%c\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;栈已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;栈内没有元素\u0026#34;); return stack; } return stack; } linklist_stack /************************************************************************* \u0026gt; File Name: linklist_stack \u0026gt; Author: jinshaohui \u0026gt; Mail: jinshaohui789@163.com \u0026gt; Time: 18-10-12 \u0026gt; Desc: ************************************************************************/ #ifndef STACK_LINK_LIST_H #define STACK_LINK_LIST_H typedef struct _linkliststack { int data; struct _linkliststack *next; }linklist_stack; #define stack_is_empty(liststack) (liststack-\u0026gt;next == NULL) #endif #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include \u0026#34;./linklist_stack.h\u0026#34; linklist_stack * stack_create() { linklist_stack * stack = NULL; stack = (linklist_stack *)malloc(sizeof(linklist_stack)); if (stack == NULL) { return NULL; } stack-\u0026gt;next = NULL; return stack; } void stack_destory(linklist_stack* stack) { linklist_stack * ptmp = NULL; while(!stack_is_empty(stack)) { ptmp = stack-\u0026gt;next; stack-\u0026gt;next = stack-\u0026gt;next-\u0026gt;next; free(ptmp); } free(stack); return; } int stack_push(linklist_stack *stack,int data) { linklist_stack * ptmp = NULL; ptmp = (linklist_stack *)malloc(sizeof(linklist_stack)); if (ptmp == NULL) { return -1; } ptmp-\u0026gt;data = data; ptmp-\u0026gt;next = stack-\u0026gt;next; stack-\u0026gt;next = ptmp; return 0; } int stack_pop(linklist_stack*stack,int *data) { linklist_stack *ptmp = NULL; if (data == NULL) { return -1; } if(stack_is_empty(stack)) { return -1; } *data = stack-\u0026gt;next-\u0026gt;data; ptmp = stack-\u0026gt;next; stack-\u0026gt;next = ptmp-\u0026gt;next; free(ptmp); return 0; } void stack_dump(linklist_stack *stack) { linklist_stack * ptmp = stack-\u0026gt;next; while(ptmp != NULL) { printf(\u0026#34;\\r\\n data = %d\u0026#34;,ptmp-\u0026gt;data); ptmp = ptmp-\u0026gt;next; } return; } int main() { int i = 0; int ret = 0; int data = 0; linklist_stack * stack = NULL; stack = stack_create(); if (stack == NULL) { printf(\u0026#34;\\r\\n stack create falied.\u0026#34;); return 0; } for (i = 0; i \u0026lt; 4; i++) { ret = stack_push(stack,i); if(ret != 0) { printf(\u0026#34;\\r\\n stack push %d falied.\u0026#34;,i); } } stack_dump(stack); for (i = 0; i \u0026lt; 5; i++) { ret = stack_pop(stack,\u0026amp;data); if(ret != 0) { printf(\u0026#34;\\r\\n stack pop%d falied.\u0026#34;, i); } else { printf(\u0026#34;\\r\\n data = %d,\u0026#34;,data); } } stack_destory(stack); return 0; } 2.1.6 队列 队列，在前端(front)进行删除操作，后端(rear)进行插入操作; 按照先进先出(FIFO)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。 队列也可通过数组和链表实现。\ntypedef List Queue; #define queue_init list_init; #define queue_destroy list_destroy; int queue_enqueue(Queue *queue, const void *data); int queue_dequeue(Queue *queue, void **data); #define queue_peek(queue) ((queue)-\u0026gt;head == NULL ? NULL : (queue)-\u0026gt;head-\u0026gt;data); #define queue_size list_size; array_queue /************************************************************************* \u0026gt; File Name: array_queue \u0026gt; Author: jinshaohui \u0026gt; Mail: jinshaohui789@163.com \u0026gt; Time: 18-10-12 \u0026gt; Desc: ************************************************************************/ #ifndef ARRAY_QUEUE_H #define ARRAY_QUEUE_H typedef struct _array_queue { int size;/*队列的大小*/ int num; /*当前存储数据的大小*/ int head;/*队列的头*/ int tail;/*队列的尾*/ int *array;/*数据存储区*/ }array_queue; #define array_queue_is_empty(array_queue) (array_queue-\u0026gt;num == 0) #define array_queue_is_full(array_queue) ((array_queue-\u0026gt;num) == (array_queue-\u0026gt;size)) #endif #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026#34;./array_queue.h\u0026#34; array_queue * array_queue_create(int size) { array_queue * queue = NULL; queue = (array_queue*)malloc(sizeof(array_queue)); if (queue == NULL) { return NULL; } queue-\u0026gt;array = (int *)malloc(sizeof(int)*size); if (queue-\u0026gt;array == NULL) { free(queue); return NULL; } queue-\u0026gt;size = size; queue-\u0026gt;num = 0; queue-\u0026gt;head = 0; queue-\u0026gt;tail = 0; return queue; } void array_queue_destory(array_queue *queue) { if (queue == NULL) { return; } if (queue-\u0026gt;array != NULL) { free(queue-\u0026gt;array); } free(queue); return; } /*入队列 */ int array_queue_enqueue(array_queue *queue,int data) { /*队列为空，或者队列满时，返回-1*/ if ((queue == NULL) || (array_queue_is_full(queue))) { return -1; } queue-\u0026gt;num++; queue-\u0026gt;array[queue-\u0026gt;tail] = data; queue-\u0026gt;tail = (queue-\u0026gt;tail + 1) % queue-\u0026gt;size; return 0; } /*出队列*/ int array_queue_dequeue(array_queue * queue,int *data) { /*队列为空，数据存储为空，队列为空时返回-1*/ if ((queue == NULL) || (data == NULL) || (array_queue_is_empty(queue))) { return -1; } *data = queue-\u0026gt;array[queue-\u0026gt;head]; queue-\u0026gt;num--; queue-\u0026gt;head = (queue-\u0026gt;head + 1) % queue-\u0026gt;size; return 0; } void array_queue_dump(array_queue *queue) { int i = 0; int pos = 0; if ((queue == NULL) || (array_queue_is_empty(queue))) { printf(\u0026#34;\\r\\n queue is empty\u0026#34;); return; } printf(\u0026#34;\\r\\n size:%d,num:%d,head:%d,tali:%d\u0026#34;, queue-\u0026gt;size,queue-\u0026gt;num,queue-\u0026gt;head,queue-\u0026gt;tail); for (i = 0; i \u0026lt; queue-\u0026gt;num; i ++) { pos = (queue-\u0026gt;head + i) %queue-\u0026gt;size; printf(\u0026#34;\\r\\n array[%d] = %d\u0026#34;,pos,queue-\u0026gt;array[pos]); } return; } int main() { int i = 0; int ret = 0; int data = 0; array_queue * queue = NULL; queue = array_queue_create(4); if (queue == NULL) { printf(\u0026#34;\\r\\n queue is create failed.\u0026#34;); return 0; } /*队列时空时，出队返回错误*/ ret = array_queue_dequeue(queue, \u0026amp;data); if (ret != 0) { printf(\u0026#34;\\r\\n queue %d dequeue failed.\u0026#34;,ret); } /*队列大小是4，入队5个，最后一个报错*/ for (i = 0; i \u0026lt; 5; i++) { ret = array_queue_enqueue(queue,i); if (ret != 0) { printf(\u0026#34;\\r\\n queue %d enqueue failed.\u0026#34;,i); } } array_queue_dump(queue); ret = array_queue_dequeue(queue, \u0026amp;data); if (ret != 0) { printf(\u0026#34;\\r\\n queue %d dequeue failed.\u0026#34;,i); } printf(\u0026#34;\\r\\n queue %d dequue.\u0026#34;,data); array_queue_dump(queue); data = 5; printf(\u0026#34;\\r\\n queue %d enqueue.\u0026#34;,data); ret = array_queue_enqueue(queue,data); if (ret != 0) { printf(\u0026#34;\\r\\n queue %d enqueue failed.\u0026#34;,data); } array_queue_dump(queue); array_queue_destory(queue); return 0; } list_queue #ifndef LINK_LIST_QUEUE_H #define LINK_LIST_QUEUE_H typedef struct _list_queue_node { void *data; struct _list_queue_node *next; }queue_node; typedef struct _list_queue { int num; queue_node *head; queue_node *tail; }list_queue; #define list_queue_is_empty(queue) ((queue-\u0026gt;num) == 0) list_queue *list_queue_create(); int list_queue_enqueue(list_queue *queue,void *data); int list_queue_dequeue(list_queue *queue,void **data); #endif // #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026#34;./list_queue.h\u0026#34; /*创建队列头*/ list_queue *list_queue_create() { list_queue * queue = NULL; queue = (list_queue *)malloc(sizeof(list_queue)); if(queue == NULL) { return NULL; } queue-\u0026gt;num = 0; queue-\u0026gt;head = NULL; queue-\u0026gt;tail = NULL; return queue; } /*入队*/ int list_queue_enqueue(list_queue *queue,void *data) { queue_node *ptmp = NULL; if(queue == NULL) { return -1; } ptmp = (queue_node *)malloc(sizeof(queue_node)); if (ptmp == NULL) { return -1; } ptmp-\u0026gt;data = data; ptmp-\u0026gt;next = NULL; if (queue-\u0026gt;head == NULL) { queue-\u0026gt;head = ptmp; } else { queue-\u0026gt;tail-\u0026gt;next = ptmp; } queue-\u0026gt;tail = ptmp; queue-\u0026gt;num++; return 0; } /*出队*/ int list_queue_dequeue(list_queue *queue,void **data) { queue_node * ptmp = NULL; if ((queue == NULL) || (data == NULL) || list_queue_is_empty(queue)) { return -1; } *data = queue-\u0026gt;head-\u0026gt;data; ptmp = queue-\u0026gt;head; queue-\u0026gt;head = queue-\u0026gt;head-\u0026gt;next; queue-\u0026gt;num--; if (queue-\u0026gt;head == NULL) { queue-\u0026gt;tail = NULL; } free(ptmp); return 0; } ring_queue #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; struct ring_queue { int cap; int head, tail; int *_q; }; int alloc_queue(struct ring_queue* queue, int cap) { if (!queue || cap \u0026lt; 0) return -1; if (queue-\u0026gt;_q) return -1; queue-\u0026gt;_q = (int *)malloc(cap * sizeof(int)); if (!queue-\u0026gt;_q) return -1; queue-\u0026gt;head = queue-\u0026gt;tail = 0; queue-\u0026gt;cap = cap; return 0; } void free_queue(struct ring_queue *queue) { queue-\u0026gt;cap = 0; queue-\u0026gt;head = queue-\u0026gt;tail = 0; free(queue-\u0026gt;_q); } int _valid_index(int curr, int step, int cap) { return (curr + step) % cap; } int _next(int curr, int cap) { return _valid_index(curr, 1, cap); } bool is_empty(struct ring_queue *queue) { return (queue-\u0026gt;head == queue-\u0026gt;tail); } bool is_full(struct ring_queue *queue) { int next_tail = _next(queue-\u0026gt;tail, queue-\u0026gt;cap); return (next_tail == queue-\u0026gt;head); } int enqueue(struct ring_queue* queue, int elem) { if (is_full(queue)) return -1; queue-\u0026gt;_q[queue-\u0026gt;tail] = elem; queue-\u0026gt;tail = _next(queue-\u0026gt;tail, queue-\u0026gt;cap); return 0; } int dequeue(struct ring_queue* queue, int *elem) { if (is_empty(queue)) return -1; if (elem) *elem = queue-\u0026gt;_q[queue-\u0026gt;head]; queue-\u0026gt;head = _next(queue-\u0026gt;head, queue-\u0026gt;cap); return 0; } int size(struct ring_queue* queue) { int size = queue-\u0026gt;tail - queue-\u0026gt;head; if (size \u0026lt; 0) size += queue-\u0026gt;cap; return size; } void dump(struct ring_queue* queue) { int i, idx; printf(\u0026#34;Queue has %d elements with %d capacity\\n\u0026#34;, size(queue), queue-\u0026gt;cap); for (i = 0; i \u0026lt; size(queue); i++) { idx = _valid_index(queue-\u0026gt;head, i, queue-\u0026gt;cap); printf(\u0026#34;[%02d]: %08d\\n\u0026#34;, idx, queue-\u0026gt;_q[idx]); } } int main() { struct ring_queue queue = {0, 0, 0, NULL}; int i; if (alloc_queue(\u0026amp;queue, 8)) { printf(\u0026#34;Failed to allocate a queue\\n\u0026#34;); return -1; } printf(\u0026#34;A new queue is %s\\n\u0026#34;, is_empty(\u0026amp;queue)?\u0026#34;empty\u0026#34;:\u0026#34;not empty\u0026#34;); enqueue(\u0026amp;queue, 1); printf(\u0026#34;After enqueue 1 element, queue is %s\\n\u0026#34;, is_empty(\u0026amp;queue)?\u0026#34;empty\u0026#34;:\u0026#34;not empty\u0026#34;); dequeue(\u0026amp;queue, NULL); printf(\u0026#34;After dequeue 1 element, queue is %s\\n\u0026#34;, is_empty(\u0026amp;queue)?\u0026#34;empty\u0026#34;:\u0026#34;not empty\u0026#34;); for (i = 0; i \u0026lt; 7; i++) enqueue(\u0026amp;queue, i); printf(\u0026#34;After enqueue 7 element, queue is %s\\n\u0026#34;, is_full(\u0026amp;queue)?\u0026#34;full\u0026#34;:\u0026#34;not full\u0026#34;); for (i = 0; i \u0026lt; 4; i++) { dequeue(\u0026amp;queue, NULL); enqueue(\u0026amp;queue, i); } printf(\u0026#34;After enqueue/dequeue 4 element, queue is %s\\n\u0026#34;, is_full(\u0026amp;queue)?\u0026#34;full\u0026#34;:\u0026#34;not full\u0026#34;); printf(\u0026#34;Head is %d, Tail is %d\\n\u0026#34;, queue.head, queue.tail); dump(\u0026amp;queue); free_queue(\u0026amp;queue); return 0; } 队列应用：进程通信 消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.\nlinux内核 \u0026lt;sys/msg.h\u0026gt; 头文件中定义了消息队列结构\nstruct msqid_ds { struct ipc_perm msg_perm; struct msg* msg_first; // 指向队列中第一个消息 struct msg* msg_last; // 队列中最后一个消息 ... } Linux消息队列函数接口\n// 创建和访问一个消息队列 int msgget(key_t key, int msgflg); // 把消息添加到消息队列中 int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); // 从一个消息对立获取消息 int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); // 控制消息队列 int msgctl(int msgid, int command, struct msgid_ds *buf); 2.1.7 leetcode题目 重复N次的元素\u0026lt;数组\u0026gt;\n两数相加\u0026lt;链表\u0026gt;\n基本计算器\u0026lt;栈\u0026gt;\n设计循环队列\u0026lt;队列\u0026gt;\n2.2 哈希表 哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。 每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.\n2.2.1 哈希函数设计 直接地址法 关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址. H(k) = aK*i + b\n数字分析法 取关键字数中分布均匀的若干作为哈希地址\n平方取中法 取关键字平方中间几位作为散列地址\n折叠法 把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址\n除留取余法 关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址. H(K) = K MOD P\nuthash用法 /************************************************************************* \u0026gt; File Name: listhash.h \u0026gt; Author: jinshaohui \u0026gt; Mail: jinshaohui789@163.com \u0026gt; Time: 18-11-06 \u0026gt; Desc: 根据linux内核模块hashtab编写用户层hashtab接口 linux-4.19.1\\security\\selinux\\ss\\hashtab.c linux-4.19.1\\security\\selinux\\ss\\hashtab.h ************************************************************************/ #ifndef __HASHTAB_H__ #define __HASHTAB_H__ typedef struct _hashtab_node { void * key; void * data; struct _hashtab_node *next; }hashtab_node; typedef struct _hashtab { hashtab_node **htables; /*哈希桶*/ int size; /*哈希桶的最大数量*/ int nel; /*哈希桶中元素的个数*/ int (*hash_value)(struct _hashtab *h,const void *key); /*哈希函数*/ int (*keycmp)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/ void (*hash_node_free)(hashtab_node *node); }hashtab; #define HASHTAB_MAX_NODES (0xffffffff) typedef int (*hash_key_func)(struct _hashtab *h,const void *key); /*哈希函数*/ typedef int (*keycmp_func)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/ typedef void (*hash_node_free_func)(hashtab_node *node); /*根据当前结构体元素的地址，获取到结构体首地址*/ #define offsetof(TYPE,MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) #define container(ptr,type,member) ({\\ const typeof( ((type *)0)-\u0026gt;member) *__mptr = (ptr);\\ (type *) ( (char *)__mptr - offsetof(type,member));}) hashtab * hashtab_create(int size,hash_key_func hash_value, keycmp_func keycmp,hash_node_free_func hash_node_free); void hashtab_destory(hashtab *h); int hashtab_insert(hashtab * h,void *key,void *data); hashtab_node *hashtab_delete(hashtab *h, void *key); void *hashtab_search(hashtab*h,void *key); #endif #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;assert.h\u0026gt; #include\u0026#34;listhash.h\u0026#34; #ifdef MEMORY_TEST #include\u0026lt;mcheck.h\u0026gt; #endif hashtab * hashtab_create(int size,hash_key_func hash_value, keycmp_func keycmp,hash_node_free_func hash_node_free) { hashtab * h = NULL; int i = 0; if ((size \u0026lt; 0) || (hash_value == NULL) || (keycmp == NULL)) { return NULL; } h = (hashtab *)malloc(sizeof(hashtab)); if (h == NULL) { return NULL; } h-\u0026gt;htables = (hashtab_node **)malloc(size * sizeof(hashtab_node*)); if (h-\u0026gt;htables == NULL) { return NULL; } h-\u0026gt;size = size; h-\u0026gt;nel = 0; h-\u0026gt;hash_value = hash_value; h-\u0026gt;keycmp = keycmp; h-\u0026gt;hash_node_free = hash_node_free; for (i = 0; i \u0026lt; size; i++) { h-\u0026gt;htables[i] = NULL; } return h; } void hashtab_destory(hashtab *h) { int i = 0; hashtab_node * cur = NULL; hashtab_node * tmp = NULL; if (h == NULL) { return; } for (i = 0; i \u0026lt;h-\u0026gt;size; i++) { cur = h-\u0026gt;htables[i]; while (cur != NULL) { tmp = cur; cur = cur-\u0026gt;next; h-\u0026gt;hash_node_free(tmp); } h-\u0026gt;htables[i] = NULL; } free(h-\u0026gt;htables); free(h); return; } int hashtab_insert(hashtab * h,void *key,void *data) { unsigned int hvalue = 0; int i = 0; hashtab_node *cur = NULL; hashtab_node *prev = NULL; hashtab_node *newnode = NULL; if ((h == NULL) || (key == NULL) || (data == NULL)) { return 1; } /*获取hash 数值*/ hvalue = h-\u0026gt;hash_value(h,key); cur = h-\u0026gt;htables[hvalue]; /*hash桶中元素是从小到大排列的，找到要插入的位置*/ while((cur != NULL) \u0026amp;\u0026amp; (h-\u0026gt;keycmp(h,key,cur-\u0026gt;key) \u0026gt; 0)) { prev = cur; cur = cur-\u0026gt;next; } /*如果key和当前key比对一致，直接返回，数据已经存在*/ if ((cur != NULL) \u0026amp;\u0026amp; (h-\u0026gt;keycmp(h,key,cur-\u0026gt;key) == 0)) { return 2; } newnode = (hashtab_node *)malloc(sizeof(hashtab_node)); if (newnode == NULL) { return 3; } newnode-\u0026gt;key = key; newnode-\u0026gt;data = data; if (prev == NULL) { newnode-\u0026gt;next = h-\u0026gt;htables[hvalue]; h-\u0026gt;htables[hvalue] = newnode; } else { newnode-\u0026gt;next = prev-\u0026gt;next; prev-\u0026gt;next = newnode; } h-\u0026gt;nel++; return 0; } hashtab_node *hashtab_delete(hashtab *h, void *key) { int hvalue = 0; int i = 0; hashtab_node *cur = NULL; hashtab_node *prev = NULL; if ((h == NULL) || (key == NULL)) { return NULL; } /*获取hash 数值*/ hvalue = h-\u0026gt;hash_value(h,key); cur = h-\u0026gt;htables[hvalue]; /*hash桶中元素是从小到大排列的，找到要插入的位置*/ while((cur != NULL) \u0026amp;\u0026amp; (h-\u0026gt;keycmp(h,key,cur-\u0026gt;key) \u0026gt;= 0)) { if (h-\u0026gt;keycmp(h,key,cur-\u0026gt;key) == 0) { if (prev == NULL) { h-\u0026gt;htables[hvalue] = cur-\u0026gt;next; } else { prev-\u0026gt;next = cur-\u0026gt;next; } return cur; } prev = cur; cur = cur-\u0026gt;next; } return NULL; } void *hashtab_search(hashtab*h,void *key) { int hvalue = 0; int i = 0; hashtab_node *cur = NULL; if ((h == NULL) || (key == NULL)) { return NULL; } /*获取hash 数值*/ hvalue = h-\u0026gt;hash_value(h,key); cur = h-\u0026gt;htables[hvalue]; /*hash桶中元素是从小到大排列的，找到要插入的位置*/ while((cur != NULL) \u0026amp;\u0026amp; (h-\u0026gt;keycmp(h,key,cur-\u0026gt;key) \u0026gt;= 0)) { if (h-\u0026gt;keycmp(h,key,cur-\u0026gt;key) == 0) { return cur-\u0026gt;data; } cur = cur-\u0026gt;next; } return NULL; } void hashtab_dump(hashtab *h) { int i = 0; hashtab_node * cur = NULL; if (h == NULL) { return ; } printf(\u0026#34;\\r\\n----开始--size[%d],nel[%d]------------\u0026#34;,h-\u0026gt;size,h-\u0026gt;nel); for( i = 0; i \u0026lt; h-\u0026gt;size; i ++) { printf(\u0026#34;\\r\\n htables[%d]:\u0026#34;,i); cur = h-\u0026gt;htables[i]; while((cur != NULL)) { printf(\u0026#34;key[%s],data[%s] \u0026#34;,cur-\u0026gt;key,cur-\u0026gt;data); cur = cur-\u0026gt;next; } } printf(\u0026#34;\\r\\n----结束--size[%d],nel[%d]------------\u0026#34;,h-\u0026gt;size,h-\u0026gt;nel); } struct test_node { char key[80]; char data[80]; }; unsigned int siample_hash(const char *str) { register unsigned int hash = 0; register unsigned int seed = 131; while(*str) { hash = hash*seed + *str++; } return hash \u0026amp; (0x7FFFFFFF); } int hashtab_hvalue(hashtab *h,const void *key) { return (siample_hash(key) % h-\u0026gt;size); } int hashtab_keycmp(hashtab *h,const void *key1,const void *key2) { return strcmp(key1,key2); } void hashtab_node_free(hashtab_node*node) { struct test_node * ptmp = NULL; ptmp = container(node-\u0026gt;key,struct test_node,key); free(ptmp); free(node); } int main () { int i = 0; int res = 0; char *pres = NULL; hashtab_node * node = NULL; struct test_node *p = NULL; hashtab *h = NULL; #ifdef MEMORY_TEST setenv(\u0026#34;MALLOC_TRACE\u0026#34;,\u0026#34;1.txt\u0026#34;,1); mtrace(); #endif h = hashtab_create(5,hashtab_hvalue,hashtab_keycmp,hashtab_node_free); assert(h!= NULL); while(1) { p = (struct test_node*)malloc(sizeof(struct test_node)); assert(p != NULL); printf(\u0026#34;\\r\\n 请输入key 和value，当可以等于\\\u0026#34;quit\\\u0026#34;时退出\u0026#34;); scanf(\u0026#34;%s\u0026#34;,p-\u0026gt;key); scanf(\u0026#34;%s\u0026#34;,p-\u0026gt;data); if(strcmp(p-\u0026gt;key,\u0026#34;quit\u0026#34;) == 0) { free(p); break; } res = hashtab_insert(h,p-\u0026gt;key,p-\u0026gt;data); if (res != 0) { free(p); printf(\u0026#34;\\r\\n key[%s],data[%s] insert failed %d\u0026#34;,p-\u0026gt;key,p-\u0026gt;data,res); } else { printf(\u0026#34;\\r\\n key[%s],data[%s] insert success %d\u0026#34;,p-\u0026gt;key,p-\u0026gt;data,res); } } hashtab_dump(h); while(1) { p = (struct test_node*)malloc(sizeof(struct test_node)); assert(p != NULL); printf(\u0026#34;\\r\\n 请输入key 查询value的数值，当可以等于\\\u0026#34;quit\\\u0026#34;时退出\u0026#34;); scanf(\u0026#34;%s\u0026#34;,p-\u0026gt;key); if(strcmp(p-\u0026gt;key,\u0026#34;quit\u0026#34;) == 0) { free(p); break; } pres = hashtab_search(h,p-\u0026gt;key); if (pres == NULL) { printf(\u0026#34;\\r\\n key[%s] search data failed\u0026#34;,p-\u0026gt;key); } else { printf(\u0026#34;\\r\\n key[%s],search data[%s] success\u0026#34;,p-\u0026gt;key,pres); } free(p); } hashtab_dump(h); while(1) { p = (struct test_node*)malloc(sizeof(struct test_node)); assert(p != NULL); printf(\u0026#34;\\r\\n 请输入key 删除节点的数值，当可以等于\\\u0026#34;quit\\\u0026#34;时退出\u0026#34;); scanf(\u0026#34;%s\u0026#34;,p-\u0026gt;key); if(strcmp(p-\u0026gt;key,\u0026#34;quit\u0026#34;) == 0) { free(p); break; } node = hashtab_delete(h,p-\u0026gt;key); if (node == NULL) { printf(\u0026#34;\\r\\n key[%s] delete node failed \u0026#34;,p-\u0026gt;key); } else { printf(\u0026#34;\\r\\n key[%s],delete data[%s] success\u0026#34;,node-\u0026gt;key,node-\u0026gt;data); h-\u0026gt;hash_node_free(node); } free(p); hashtab_dump(h); } hashtab_destory(h); #ifdef MEMORY_TEST muntrace(); #endif return 0; } hash_table #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; /* One implementation of hash table with linear probing. */ #define HASH_SHIFT 4 #define HASH_SIZE (1 \u0026lt;\u0026lt; HASH_SHIFT) #define HASH_MASK (HASH_SIZE - 1) struct hash_table { unsigned int used; unsigned long entry[HASH_SIZE]; }; void hash_table_reset(struct hash_table *table) { int i; table-\u0026gt;used = 0; for (i = 0; i \u0026lt; HASH_SIZE; i++) table-\u0026gt;entry[i] = ~0; } unsigned int hash_function(unsigned long value) { return value \u0026amp; HASH_MASK; } void dump_hash_table(struct hash_table *table) { int i; for (i = 0; i \u0026lt; HASH_SIZE; i++) { if (table-\u0026gt;entry[i] == ~0) printf(\u0026#34;%2u: nil \\n\u0026#34;, i); else printf(\u0026#34;%2u:%10lu -\u0026gt; %2u\\n\u0026#34;, i, table-\u0026gt;entry[i], hash_function(table-\u0026gt;entry[i])); } } void hash_function_test() { int i; srandom(time(NULL)); for (i = 0; i \u0026lt; 10; i++) { unsigned long val = random(); printf(\u0026#34;%10lu -\u0026gt; %2u\\n\u0026#34;, val, hash_function(val));; } } unsigned int next_probe(unsigned int prev_key) { return (prev_key + 1) \u0026amp; HASH_MASK; } void next_probe_test() { int i; unsigned int key1, key2; key1 = 0; for (i = 0; i \u0026lt; HASH_SIZE; i++) { key2 = next_probe(key1); printf(\u0026#34;%2u -\u0026gt; %2u\\n\u0026#34;, key1, key2); key1 = key2; } } void hash_table_add(struct hash_table *table, unsigned long value) { unsigned int key = hash_function(value); if (table-\u0026gt;used \u0026gt;= HASH_SIZE) return; while (table-\u0026gt;entry[key] != ~0) key = next_probe(key); table-\u0026gt;entry[key] = value; table-\u0026gt;used++; } unsigned int hash_table_slot(struct hash_table *table, unsigned long value) { int i; unsigned int key = hash_function(value); for (i = 0; i \u0026lt; HASH_SIZE; i++) { if (table-\u0026gt;entry[key] == value || table-\u0026gt;entry[key] == ~0) break; key = next_probe(key); } return key; } bool hash_table_find(struct hash_table *table, unsigned long value) { return table-\u0026gt;entry[hash_table_slot(table, value)] == value; } void hash_table_del(struct hash_table *table, unsigned long value) { unsigned int i, j, k; if (!hash_table_find(table, value)) return; i = j = hash_table_slot(table, value); while (true) { table-\u0026gt;entry[i] = ~0; do { j = next_probe(j); if (table-\u0026gt;entry[j] == ~0) return; k = hash_function(table-\u0026gt;entry[j]); } while ((i \u0026lt;= j) ? (i \u0026lt; k \u0026amp;\u0026amp; k \u0026lt;= j) : (i \u0026lt; k || k \u0026lt;= j)); table-\u0026gt;entry[i] = table-\u0026gt;entry[j]; i = j; } table-\u0026gt;used++; } void hash_table_add_test() { struct hash_table table; hash_table_reset(\u0026amp;table); hash_table_add(\u0026amp;table, 87645); printf(\u0026#34;Table has%s 87645\\n\u0026#34;, hash_table_find(\u0026amp;table, 87645) ? \u0026#34;\u0026#34;:\u0026#34;n\u0026#39;t\u0026#34;); printf(\u0026#34;Table has%s 87647\\n\u0026#34;, hash_table_find(\u0026amp;table, 87647) ? \u0026#34;\u0026#34;:\u0026#34;n\u0026#39;t\u0026#34;); } void hash_table_del_test1() { struct hash_table table; hash_table_reset(\u0026amp;table); hash_table_add(\u0026amp;table, 0x1ff0); hash_table_add(\u0026amp;table, 0x2ff0); hash_table_add(\u0026amp;table, 0x3ff0); dump_hash_table(\u0026amp;table); printf(\u0026#34;=== Remove 0x1ff0\\n\u0026#34;); hash_table_del(\u0026amp;table, 0x1ff0); dump_hash_table(\u0026amp;table); } void hash_table_del_test2() { struct hash_table table; hash_table_reset(\u0026amp;table); hash_table_add(\u0026amp;table, 0x1ff0); hash_table_add(\u0026amp;table, 0x1ff1); hash_table_add(\u0026amp;table, 0x1ff2); hash_table_add(\u0026amp;table, 0x2ff0); dump_hash_table(\u0026amp;table); printf(\u0026#34;=== Remove 0x1ff0\\n\u0026#34;); hash_table_del(\u0026amp;table, 0x1ff0); dump_hash_table(\u0026amp;table); } int main() { //hash_function_test(); //next_probe_test(); //hash_table_add_test(); hash_table_del_test2(); return 0; } 2.2.2 哈希冲突 理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.\n解决哈希冲突常用方法:\n链地址法 将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中. 线性探测 二次探测 2.2.3 uthash uthash的插入、查找、删除的操作时间都是常量\n#include \u0026#34;uthash.h\u0026#34; struct my_struct { int id; /* we\u0026#39;ll use this field as the key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; struct my_struct *users = NULL; void add_user(struct my_struct *s) { HASH_ADD_INT(users, id, s); } uthash用法 #include \u0026lt;stdio.h\u0026gt; /* gets */ #include \u0026lt;stdlib.h\u0026gt; /* atoi, malloc */ #include \u0026lt;string.h\u0026gt; /* strcpy */ #include \u0026#34;uthash.h\u0026#34; struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; struct my_struct *users = NULL; void add_user(int user_id, char *name) { struct my_struct *s; HASH_FIND_INT(users, \u0026amp;user_id, s); /* id already in the hash? */ if (s==NULL) { s = (struct my_struct *)malloc(sizeof *s); s-\u0026gt;id = user_id; HASH_ADD_INT( users, id, s ); /* id: name of key field */ } strcpy(s-\u0026gt;name, name); } struct my_struct *find_user(int user_id) { struct my_struct *s; HASH_FIND_INT(users, \u0026amp;user_id, s); /* s: output pointer */ return s; } void delete_user(struct my_struct *user) { HASH_DEL(users, user); /* user: pointer to deletee */ free(user); } void delete_all() { struct my_struct *current_user, *tmp; HASH_ITER(hh, users, current_user, tmp) { HASH_DEL(users, current_user); /* delete it (users advances to next) */ free(current_user); /* free it */ } } void print_users() { struct my_struct *s; for(s=users; s != NULL; s=(struct my_struct*)(s-\u0026gt;hh.next)) { printf(\u0026#34;user id %d: name %s\\n\u0026#34;, s-\u0026gt;id, s-\u0026gt;name); } } int name_sort(struct my_struct *a, struct my_struct *b) { return strcmp(a-\u0026gt;name,b-\u0026gt;name); } int id_sort(struct my_struct *a, struct my_struct *b) { return (a-\u0026gt;id - b-\u0026gt;id); } void sort_by_name() { HASH_SORT(users, name_sort); } void sort_by_id() { HASH_SORT(users, id_sort); } int main(int argc, char *argv[]) { char in[10]; int id=1, running=1; struct my_struct *s; unsigned num_users; while (running) { printf(\u0026#34; 1. add user\\n\u0026#34;); printf(\u0026#34; 2. add/rename user by id\\n\u0026#34;); printf(\u0026#34; 3. find user\\n\u0026#34;); printf(\u0026#34; 4. delete user\\n\u0026#34;); printf(\u0026#34; 5. delete all users\\n\u0026#34;); printf(\u0026#34; 6. sort items by name\\n\u0026#34;); printf(\u0026#34; 7. sort items by id\\n\u0026#34;); printf(\u0026#34; 8. print users\\n\u0026#34;); printf(\u0026#34; 9. count users\\n\u0026#34;); printf(\u0026#34;10. quit\\n\u0026#34;); gets(in); switch(atoi(in)) { case 1: printf(\u0026#34;name?\\n\u0026#34;); add_user(id++, gets(in)); break; case 2: printf(\u0026#34;id?\\n\u0026#34;); gets(in); id = atoi(in); printf(\u0026#34;name?\\n\u0026#34;); add_user(id, gets(in)); break; case 3: printf(\u0026#34;id?\\n\u0026#34;); s = find_user(atoi(gets(in))); printf(\u0026#34;user: %s\\n\u0026#34;, s ? s-\u0026gt;name : \u0026#34;unknown\u0026#34;); break; case 4: printf(\u0026#34;id?\\n\u0026#34;); s = find_user(atoi(gets(in))); if (s) delete_user(s); else printf(\u0026#34;id unknown\\n\u0026#34;); break; case 5: delete_all(); break; case 6: sort_by_name(); break; case 7: sort_by_id(); break; case 8: print_users(); break; case 9: num_users=HASH_COUNT(users); printf(\u0026#34;there are %u users\\n\u0026#34;, num_users); break; case 10: running=0; break; } } delete_all(); /* free any structures */ return 0; } 参考链接 官网:https://troydhanson.github.io/uthash/ https://blog.csdn.net/fan_h_l/article/details/107241520 https://blog.csdn.net/whatday/article/details/95926766 https://www.cnblogs.com/pam-sh/p/12827658.html 2.2.4 leetcode题目 设计哈希集合\n设计哈希映射\n根据字符出现频率排序\n2.3 树与二叉树 树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);\n树的特点:\n没有父节点的节点称为根节点 每个非根节点有且只有一个父节点 除了根结点外,每个子节点可分为多个不相交的子树 树中没有环路 2.3.1 概述 节点的度: 一个节点含有子树的个数 树的度: 树中最大的节点度 叶节点: 度为零的节点 父节点 子节点 兄弟节点 节点的层次 深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0 高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0. 森林 树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。\n2.3.2 树的种类 无序树 有序树 二叉树: 每个节点最多含有两个子树的树.\n完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列. 满二叉树:所有叶节点都最底层的完全二叉树. 平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树. 排序二叉树:二叉查找树 霍夫曼树:带权路径最短的二叉树(又称最优二叉树).\nB树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.\n二叉树 二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树 自平衡二叉查找树 AVL树 红黑树 加权平衡树 AA树 B树 B树 B+树 堆 二项堆 斐波那契堆 Trie 后缀树 基数树 三叉查找树 树有多种结构形式，包括二叉树、。\n2.3.3 二叉树 二叉树两个条件:\n本身是有序树 树中包含的各个节点的度不能超过2,即只能是0,1或者2 二叉树中结点包含三部分：一个数据成员两个左右指针。\ntypedef struct BiTreeNode_ { void *data; struct BiTreeNode_ *left; struct BiTreeNode_ *right; }BiTreeNode; typedef struct BiTree_ { int size; int (*compare)(const void *key1, const void *key2); void (*destroy)(void *data); BiTreeNode *root; }BiTree; /*树根*/ typedef struct tree{ Node * root; }Tree; 二叉树 #include\u0026lt;assert.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026#34;list_queue.h\u0026#34; typedef struct _treenode { int data; struct _treenode *lchild; struct _treenode *rchild; }Tnode,Tree; void binarytree_create(Tree **Root) { int a = 0; printf(\u0026#34;\\r\\n输入节点数值((当输入为100时，当前节点创建完成))):\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); if (a == 100) { *Root = NULL; } else { *Root = (Tnode *)malloc(sizeof(Tnode)); if (*Root == NULL) { return; } (*Root)-\u0026gt;data = a; printf(\u0026#34;\\r\\n create %d 的左孩子:\u0026#34;,a); binarytree_create(\u0026amp;((*Root)-\u0026gt;lchild)); printf(\u0026#34;\\r\\n create %d 的右孩子:\u0026#34;,a); binarytree_create(\u0026amp;((*Root)-\u0026gt;rchild)); } return ; } void binarytree_destory(Tree *root) { if (root == NULL) { return; } binarytree_destory(root-\u0026gt;lchild); binarytree_destory(root-\u0026gt;rchild); free(root); } /*先序遍历:根结点--》左子树---》右子树*/ void binarytree_preorder(Tree *root) { if (root == NULL) { return; } printf(\u0026#34; %d \u0026#34;,root-\u0026gt;data); binarytree_preorder(root-\u0026gt;lchild); binarytree_preorder(root-\u0026gt;rchild); return; } /*中序遍历:左子树--》跟节点---》右子树*/ void binarytree_inorder(Tree *root) { if (root == NULL) { return; } binarytree_inorder(root-\u0026gt;lchild); printf(\u0026#34; %d \u0026#34;,root-\u0026gt;data); binarytree_inorder(root-\u0026gt;rchild); return; } /*后序遍历:左子树---》右子树-》根节点*/ void binarytree_postorder(Tree *root) { if (root == NULL) { return; } binarytree_postorder(root-\u0026gt;lchild); binarytree_postorder(root-\u0026gt;rchild); printf(\u0026#34; %d \u0026#34;,root-\u0026gt;data); return; } void binarytree_levelorder(Tree * root) { list_queue *queue = NULL; Tnode * node = NULL; if(root == NULL) { return; } queue = list_queue_create(); /*根节点先入队*/ list_queue_enqueue(queue,(void *)root); while(!list_queue_is_empty(queue)) { list_queue_dequeue(queue,(void *)\u0026amp;node); printf(\u0026#34; %d \u0026#34;,node-\u0026gt;data); if(node-\u0026gt;lchild != NULL) { list_queue_enqueue(queue,(void *)node-\u0026gt;lchild); } if(node-\u0026gt;rchild != NULL) { list_queue_enqueue(queue,(void *)node-\u0026gt;rchild); } } free(queue); } /*打印叶子节点*/ void binarytree_printfleaf(Tree *root) { if (root == NULL) { return; } if ((root-\u0026gt;lchild == NULL) \u0026amp;\u0026amp; (root-\u0026gt;rchild == NULL)) { printf(\u0026#34; %d \u0026#34;,root-\u0026gt;data); } else { binarytree_printfleaf(root-\u0026gt;lchild); binarytree_printfleaf(root-\u0026gt;rchild); } } /*打印叶子的个数*/ int binarytree_getleafnum(Tree*root) { if (root == NULL) { return 0; } if ((root-\u0026gt;lchild == NULL) \u0026amp;\u0026amp; (root-\u0026gt;rchild == NULL)) { return 1; } return binarytree_getleafnum(root-\u0026gt;lchild) + binarytree_getleafnum(root-\u0026gt;rchild); } /*打印数的高度*/ int binarytree_gethigh(Tree *root) { int lhigh = 0; int rhigh = 0; if (root == NULL) { return 0; } lhigh = binarytree_gethigh(root-\u0026gt;lchild); rhigh = binarytree_gethigh(root-\u0026gt;rchild); return ((lhigh \u0026gt; rhigh)?(lhigh + 1):(rhigh + 1)); } int main() { Tree *root = NULL; setenv(\u0026#34;MALLOC_TRACE\u0026#34;,\u0026#34;1.txt\u0026#34;,1); mtrace(); printf(\u0026#34;\\r\\n创建二叉树:\u0026#34;); binarytree_create(\u0026amp;root); printf(\u0026#34;\\r\\n先序遍历二叉树:\u0026#34;); binarytree_preorder(root); printf(\u0026#34;\\r\\n中序遍历二叉树:\u0026#34;); binarytree_inorder(root); printf(\u0026#34;\\r\\n后序遍历二叉树:\u0026#34;); binarytree_postorder(root); printf(\u0026#34;\\r\\n层次遍历二叉树:\u0026#34;); binarytree_levelorder(root); printf(\u0026#34;\\r\\n打印二叉树叶子节点:\u0026#34;); binarytree_printfleaf(root); printf(\u0026#34;\\r\\n打印二叉树叶子节点个数:%d\u0026#34;,binarytree_getleafnum(root)); printf(\u0026#34;\\r\\n打印二叉树高度:%d\u0026#34;,binarytree_gethigh(root)); binarytree_destory(root); muntrace(); return 0; } binarytree #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; /* Implement binary tree in array */ #define MAX_TREE_NODES (1 \u0026lt;\u0026lt; 8) struct node { int data; }; struct binary_tree { union { unsigned long nodes; struct node *n[MAX_TREE_NODES]; }; }; void init_binary_tree(struct binary_tree *tree) { int i; for(i = 0; i \u0026lt; MAX_TREE_NODES; i++) { tree-\u0026gt;n[i] = NULL; } } struct node* create_node(int data) { struct node* n; n = malloc(sizeof(struct node)); if (n) n-\u0026gt;data = data; return n; } void fake_a_tree(struct binary_tree* tree) { /* data is in ordered */ int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5}; init_binary_tree(tree); /* root start at 1 */ for (i = 0; i \u0026lt; 10; i++) tree-\u0026gt;n[i+1] = create_node(data[i]); tree-\u0026gt;nodes = 10; } void _in_order(struct binary_tree* tree, int index) { if (!tree-\u0026gt;n[index]) return; /* left child at (index \u0026lt;\u0026lt; 1) */ _in_order(tree, index \u0026lt;\u0026lt; 1); printf(\u0026#34;[%2d]: %4d\\n\u0026#34;, index, tree-\u0026gt;n[index]-\u0026gt;data); /* right child at (index \u0026lt;\u0026lt; 1) + 1 */ _in_order(tree, (index \u0026lt;\u0026lt; 1) + 1); } void in_order(struct binary_tree* tree) { _in_order(tree, 1); } int main() { struct binary_tree tree; fake_a_tree(\u0026amp;tree); in_order(\u0026amp;tree); return 0; } 二叉树性质:\n二叉树中,第i层最多有 2^(i-1)个节点 如果二叉树的深度为K,则二叉树最多有2^K - 1个节点 二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1 满二叉树 如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。\n完全二叉树 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。\n先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。 // 递归 void traversal(TreeNode* cur) { if (cur == NULL) return; printf(\u0026#34;cur-\u0026gt;val = %d\\n\u0026#34;, cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 } void preorderTraversal(TreeNode* root) { traversal(root); } // 迭戈 #define MAXSIZE 10000 int* preorderTraversal(TreeNode* root) { struct TreeNode st[MAXSIZE]; int top = 0; int result[MAXSIZE]; if (root == NULL) return result; st[top] = root; int i = 0; while (top \u0026gt;= 0) { TreeNode* node = st[top]; // 中 top--; result[i++] = node-\u0026gt;val; if (node-\u0026gt;right) { // 右（空节点不入栈） st[++top] = node-\u0026gt;right } if (node-\u0026gt;left) { // 左（空节点不入栈） st[++top] = node-\u0026gt;left; } } return result; } 中序遍历：先访问左子结点，然后根结点，最后右子结点。 后序遍历：先访问左子结点，然后右子结点，最后根结点。 层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。 void traversal(TreeNode* cur) { if (cur == NULL) return; printf(\u0026#34;cur-\u0026gt;val = %d\\n\u0026#34;, cur-\u0026gt;val); // 中 traversal(cur-\u0026gt;left, vec); // 左 traversal(cur-\u0026gt;right, vec); // 右 } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; traversal(root, result); return result; } 2.3.4 二叉查找树(BST) 二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:\n若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值 若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值 任意节点的左,右子树也分别为二叉查找树 没有键值相等的节点 一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。 二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。查找,插入操作的复杂度是 O(logn)，搜索,插入,删除复杂度等于树高,期望O(logn),最坏为O(n),(树退化为线性表)n为树中结点数。 保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。\n二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。\n查找算法 1.若b是空树,则搜索失败,否则; 2.若x等于b的根节点的数据域之值,则查找成功; 3.若x小于b的根节点的数据域之值,则搜索左子树 4.查找右子树\n插入算法 1.若b是空树,则将s所指节点作为根节点插入;否则 2.若s-\u0026gt;data等于b的根节点的数据域值,则返回,否则; 3.若s-\u0026gt;data小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则 4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)\n删除算法 1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.\nbinarysearch #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status; typedef char ElemType; typedef struct node { ElemType data; struct node *lchild, *rchild; } BTree, *BTreePtr; /**************** 插入 **********************/ Status Insert(BTreePtr *T, ElemType e) { BTreePtr p; if (*T == NULL) { *T = (BTreePtr)malloc(sizeof(BTree)); (*T)-\u0026gt;data = e; return TRUE; } else { p = *T; while ( p != NULL) { if (e \u0026gt; p-\u0026gt;data) { if (p-\u0026gt;rchild == NULL) { p-\u0026gt;rchild = (BTreePtr) malloc (sizeof(BTree)); p-\u0026gt;rchild-\u0026gt;data = e; return TRUE; } p = p-\u0026gt;rchild; } else { if (p-\u0026gt;lchild == NULL) { p-\u0026gt;lchild = (BTreePtr) malloc (sizeof(BTree)); p-\u0026gt;lchild-\u0026gt;data = e; return TRUE; } p = p-\u0026gt;lchild; } } } return FALSE; } /**************** 删除 **********************/ Status Delete(BTreePtr T, ElemType e) { BTreePtr p, pp, minP, minPP, child; child = NULL; p = T; pp = NULL; while ( (p != NULL) \u0026amp;\u0026amp; (p-\u0026gt;data != e) ) { pp = p; if (e \u0026gt; p-\u0026gt;data) { p = p-\u0026gt;rchild; } else { p = p-\u0026gt;lchild; } } if (p == NULL) return FALSE; //双节点 if ((p-\u0026gt;lchild != NULL) \u0026amp;\u0026amp; (p-\u0026gt;rchild != NULL) { minPP = p; minP = p-\u0026gt;rchild; while (minP-\u0026gt;lchild != NULL) { minPP = minP; minP = minP-\u0026gt;lchild; } p-\u0026gt;data = minP-\u0026gt;data; minPP-\u0026gt;lchild = minP-\u0026gt;rchild; free(minP); return TRUE; } //有一个节点 if ((p-\u0026gt;lchild != NULL) || (p-\u0026gt;rchild != NULL)) { //应该将原有的pp同child连接在一起 if (p-\u0026gt;lchild) { child = p-\u0026gt;lchild; } else { child = p-\u0026gt;rchild; } if(pp-\u0026gt;data\u0026gt;p-\u0026gt;data) { pp-\u0026gt;lchild=child; } else { pp-\u0026gt;rchild=child; } free(p); return TRUE; } //没有节点 if (pp-\u0026gt;lchild == p) {//这里面临pp除p以外的节点为null的情况 pp-\u0026gt;lchild = child; } else { pp-\u0026gt;rchild = child; } return TRUE; } /**************** 查找 **********************/ Status Find(BTreePtr T, ElemType e) { if (T == NULL) return FALSE; while ((T != NULL) \u0026amp;\u0026amp; (T-\u0026gt;data != e)) { if (e \u0026gt; T-\u0026gt;data) { T = T-\u0026gt;rchild; } else { T = T-\u0026gt;lchild; } } if (T) { return TRUE; } else { return FALSE; } } /**************** 最大值 **********************/ ElemType FindMax(BTreePtr T) { ElemType max; while(T != NULL) { max = T-\u0026gt;data; T = T-\u0026gt;rchild; } return max; } /**************** 最小值 **********************/ ElemType FindMin(BTreePtr T) { ElemType min; while(T != NULL) { min = T-\u0026gt;data; T = T-\u0026gt;lchild; } return min; } void PreOrderTraverse(BTreePtr T)//前序遍历二叉树 { if (T == NULL) return; if(T) { printf(\u0026#34;%d \u0026#34;,T-\u0026gt;data); PreOrderTraverse(T-\u0026gt;lchild); PreOrderTraverse(T-\u0026gt;rchild); } } void DestroyTree(BTreePtr T) { if (T) { if (T-\u0026gt;lchild) { DestroyTree(T-\u0026gt;lchild); } if(T-\u0026gt;rchild) { DestroyTree(T-\u0026gt;rchild); } free(T); T = NULL; } } /***************** 执行测试 *************************/ int main(int argc, char const *argv[]) { BTreePtr T; T = NULL; int a[] = {33, 16, 50, 13, 18, 34, 58, 15, 17, 25, 51, 66, 19, 27, 55}; int i; for (i = 0; i \u0026lt; 15; i++) { Insert(\u0026amp;T, a[i]); } printf(\u0026#34;Max is %d\\n\u0026#34;, FindMax(T)); printf(\u0026#34;Min is %d\\n\u0026#34;, FindMin(T)); Delete(T, 18); Delete(T, 13); PreOrderTraverse(T); DestroyTree(T); return 0; } bst #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; enum child_dir { left_child, right_child, root, }; struct node { unsigned long data; struct node *left; struct node *right; }; struct root { struct node *r; }; void dump(struct node *node, int level, enum child_dir dir) { if (!node) return; dump(node-\u0026gt;right, level + 1, right_child); if (dir == left_child) printf(\u0026#34;%*s\\n\u0026#34;, level*3, \u0026#34;|\u0026#34;); printf(\u0026#34;%*s - %05lu\\n\u0026#34;, level*3, \u0026#34; \u0026#34;, node-\u0026gt;data); if (dir == right_child) printf(\u0026#34;%*s\\n\u0026#34;, level*3, \u0026#34;|\u0026#34;); dump(node-\u0026gt;left, level + 1, left_child); } struct node* find(struct root *root, unsigned long data) { struct node* n = root-\u0026gt;r; while (n) { if (n-\u0026gt;data == data) return n; if (data \u0026lt; n-\u0026gt;data) n = n-\u0026gt;left; else n = n-\u0026gt;right; } return NULL; } struct node* new_node(unsigned long data) { struct node *n; n = malloc(sizeof(struct node)); n-\u0026gt;data = data; n-\u0026gt;left = n-\u0026gt;right = NULL; return n; } void insert(struct root *root, struct node *new) { struct node *parent; if (!root-\u0026gt;r) { root-\u0026gt;r = new; return; } parent = root-\u0026gt;r; while (true) { /* Don\u0026#39;t support duplicate data */ if (new-\u0026gt;data == parent-\u0026gt;data) break; if (new-\u0026gt;data \u0026lt; parent-\u0026gt;data) { if (!parent-\u0026gt;left) { parent-\u0026gt;left = new; break; } parent = parent-\u0026gt;left; } else { if (!parent-\u0026gt;right) { parent-\u0026gt;right = new; break; } parent = parent-\u0026gt;right; } } } struct node* delete(struct root *root, unsigned long data) { struct node *n = root-\u0026gt;r, **p = \u0026amp;root-\u0026gt;r; struct node *child; while (n \u0026amp;\u0026amp; n-\u0026gt;data != data) { if (data \u0026lt; n-\u0026gt;data) { p = \u0026amp;n-\u0026gt;left; n = n-\u0026gt;left; } else { p = \u0026amp;n-\u0026gt;right; n = n-\u0026gt;right; } } if (!n) return NULL; if (n-\u0026gt;left \u0026amp;\u0026amp; n-\u0026gt;right) { struct node *rn = n-\u0026gt;right, **rp = \u0026amp;n-\u0026gt;right; while (rn-\u0026gt;left) { rp = \u0026amp;rn-\u0026gt;left; rn = rn-\u0026gt;left; } n-\u0026gt;data = rn-\u0026gt;data; n = rn; p = rp; } child = n-\u0026gt;left ? n-\u0026gt;left : n-\u0026gt;right; *p = child; return NULL; } void insert_test() { struct root tree; struct node* n; tree.r = NULL; insert(\u0026amp;tree, new_node(9)); insert(\u0026amp;tree, new_node(5)); insert(\u0026amp;tree, new_node(2)); insert(\u0026amp;tree, new_node(8)); insert(\u0026amp;tree, new_node(18)); insert(\u0026amp;tree, new_node(13)); insert(\u0026amp;tree, new_node(21)); insert(\u0026amp;tree, new_node(20)); dump(tree.r, 0, root); n = find(\u0026amp;tree, 18); if (n \u0026amp;\u0026amp; n-\u0026gt;data == 18) printf(\u0026#34;Get 18\\n\u0026#34;); } void delete_test() { struct root tree; struct node* n; tree.r = NULL; insert(\u0026amp;tree, new_node(9)); insert(\u0026amp;tree, new_node(5)); insert(\u0026amp;tree, new_node(2)); insert(\u0026amp;tree, new_node(8)); insert(\u0026amp;tree, new_node(18)); insert(\u0026amp;tree, new_node(13)); insert(\u0026amp;tree, new_node(21)); insert(\u0026amp;tree, new_node(20)); dump(tree.r, 0, root); delete(\u0026amp;tree, 20); printf(\u0026#34;Delete 20\\n\u0026#34;); dump(tree.r, 0, root); delete(\u0026amp;tree, 9); printf(\u0026#34;Delete 9\\n\u0026#34;); dump(tree.r, 0, root); } int main() { //insert_test(); delete_test(); return 0; } 2.3.5 平衡树 平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升. 平衡指所有叶子的深度趋于平衡,更广义指树上所有可能查找的均摊复杂度偏低.平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡. 对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.\nAVL树 在AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡. 高度为h的AVL树,总节点数最多为2^h-1; 当前节点数为N时,高度h最多为:\nlog(5*0.5 * (N + 1)) - 2\n红黑树 红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn) 红黑树相对于AVL树,牺牲了部分平衡性以换取插入\\删除操作时少量的旋转操作,整体性能优于AVL树.\n红黑树与AVL树的相比: AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好. AVL的查找性能通常比红黑树好 如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.\n红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求: 1.节点是红或黑色 2.根是黑色 3.所有叶子都是黑色(叶子是NIL节点) 4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.) 5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点. 红黑树关键特性:从根到叶子的最长的可能路径不多于最短的可能路径的两倍长.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.\nB+树 B+树通常用于数据库和操作系统的文件系统中.B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度.B+树元素自底向上插入,与二叉树相反. B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.\n字典树 Trie #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status; typedef struct Node { char data; struct Node *children[26]; Status end; } Trie, *TriePtr; void Init(TriePtr *T) { (*T) = (TriePtr)malloc(sizeof(Trie)); (*T)-\u0026gt;data = \u0026#39;/\u0026#39;; (*T)-\u0026gt;end = FALSE; } void Insert(TriePtr T, char *str) { int index; char c; while(c = *str++) { index = c - \u0026#39;a\u0026#39;; if (T-\u0026gt;children[index] == NULL) { TriePtr Node; Node = (TriePtr)malloc(sizeof(Trie)); Node-\u0026gt;data = c; Node-\u0026gt;end = FALSE; T-\u0026gt;children[index] = Node; } T = T-\u0026gt;children[index]; } T-\u0026gt;end = TRUE; } Status Search(TriePtr T, char *str) { int index; char c; while(c = *str++) { index = c - \u0026#39;a\u0026#39;; if (T-\u0026gt;children[index] == NULL) { return FALSE; } T = T-\u0026gt;children[index]; } if (T-\u0026gt;end) { return TRUE; } else { return FALSE; } } int main(int argc, char const *argv[]) { TriePtr T; Init(\u0026amp;T); char *str = \u0026#34;hello\u0026#34;; char *str2 = \u0026#34;hi\u0026#34;; Insert(T, str); printf(\u0026#34;str is search %d\\n\u0026#34;, Search(T, str)); printf(\u0026#34;str2 is search %d\\n\u0026#34;, Search(T, str2)); return 0; } 2.3.6 堆树和优先队列 堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的. 堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示. 堆的特性: 必须是完全二叉树 用数组实现 任一节点的值是其子树所有节点的最大值或最小值 最大值时,称为最大堆,也称大顶堆 最小时,称为最小堆,也称小顶堆. 堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)\n堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。 堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。\ntypedef struct Heap_ { int size; int (*compare)(const void *key1, const void *key2); void (*destroy)(void *data); void **tree; } heap #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; /* Implement heap */ #define MAX_HEAP_SIZE (1 \u0026lt;\u0026lt; 8) struct element { int data; }; struct heap { union { unsigned long elements; struct element *elem[MAX_HEAP_SIZE]; }; }; void init_heap(struct heap *heap) { int i; for(i = 0; i \u0026lt; MAX_HEAP_SIZE; i++) { heap-\u0026gt;elem[i] = NULL; } } void dump_heap(struct heap *heap, int index) { struct element *elem; int level; if (index \u0026gt; heap-\u0026gt;elements) return; elem = heap-\u0026gt;elem[index]; level = fls(index); dump_heap(heap, index * 2 + 1); if (!(index % 2) \u0026amp;\u0026amp; index != 1) printf(\u0026#34;%*s\\n\u0026#34;, level*3, \u0026#34;|\u0026#34;); printf(\u0026#34;%*s - %05d\\n\u0026#34;, level*3, \u0026#34; \u0026#34;, elem-\u0026gt;data); if (index % 2 \u0026amp;\u0026amp; index != 1) printf(\u0026#34;%*s\\n\u0026#34;, level*3, \u0026#34;|\u0026#34;); dump_heap(heap, index * 2); } void dump(struct heap *heap, int elements) { int i; for (i = 1; i \u0026lt;= elements; i++) printf(\u0026#34;[%02d]: %4d\\n\u0026#34;, i, heap-\u0026gt;elem[i]-\u0026gt;data); } struct element* create_element(int data) { struct element *elem; elem = malloc(sizeof(struct element)); if (elem) elem-\u0026gt;data = data; return elem; } void fake_a_heap(struct heap *heap) { /* data is in ordered */ int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5}; init_heap(heap); /* root start at 1 */ for (i = 0; i \u0026lt; 10; i++) heap-\u0026gt;elem[i+1] = create_element(data[i]); heap-\u0026gt;elements = 10; } void swap(struct heap *heap, int i, int j) { struct element *tmp; tmp = heap-\u0026gt;elem[j]; heap-\u0026gt;elem[j] = heap-\u0026gt;elem[i]; heap-\u0026gt;elem[i] = tmp; } void heapify(struct heap *heap, int parent) { struct element **elem = heap-\u0026gt;elem; int elements = heap-\u0026gt;elements; int left, right, max; while (true) { left = parent * 2; right = left + 1; max = parent; if (left \u0026lt;= elements \u0026amp;\u0026amp; elem[max]-\u0026gt;data \u0026lt; elem[left]-\u0026gt;data) max = left; if (right \u0026lt;= elements \u0026amp;\u0026amp; elem[max]-\u0026gt;data \u0026lt; elem[right]-\u0026gt;data) max = right; if (max == parent) break; swap(heap, max, parent); parent = max; } } void build_heap(struct heap *heap) { int i; for (i = heap-\u0026gt;elements / 2; i \u0026gt;= 1; i--) heapify(heap, i); } int heap_sort(struct heap *heap) { int elements = heap-\u0026gt;elements; while (heap-\u0026gt;elements) { swap(heap, 1, heap-\u0026gt;elements); heap-\u0026gt;elements--; heapify(heap, 1); } return elements; } int main() { struct heap heap; int elements; fake_a_heap(\u0026amp;heap); dump_heap(\u0026amp;heap, 1); printf(\u0026#34;After Heapify:\\n\u0026#34;); build_heap(\u0026amp;heap); dump_heap(\u0026amp;heap, 1); printf(\u0026#34;After Heap sort:\\n\u0026#34;); elements = heap_sort(\u0026amp;heap); dump(\u0026amp;heap, elements); return 0; } 堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。\n优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。\n优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。\ntypedef Heap PQueue; 2.3.7 leetcode题目 先序遍历构造二叉树 从中序与后序遍历构造二叉树 二叉树的层次遍历 从二叉搜索树到更大和树 二叉搜索树的最近公共祖先 前K个高频单词\u0026lt;堆\u0026gt; 2.4 图 图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:G(V,E).其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.\n图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。 图的访问方式：广度优先和深度优先。\n2.4.1 基础知识 图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。\n一组顶点：用V(vertex)表示顶点集合 一组边：用E(edge)表示边的集合 图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。 (v, w)表示无向边，即v和w是互通的 \u0026lt; v, w \u0026gt;表示有向边，该边始于v，终于w 图可分为连通图和非连通图 连通图：所有的点都右路径相连 非连通图：存在某两个点没有路径相连 强连通图： 图中的顶点度\n度 入度 出度 2.4.2 图表示 图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。 图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。 邻接矩阵表示\n邻接链表表示\ntypedef struct AdjList_ { void *vertex; Set adjacent; }AdjList; typedef struct Graph_ { int vcount; int ecount; int (*match)(const void *key1, const void *key2); List adjlists; } graph #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;time.h\u0026gt; struct vertex; struct vertex_adjs { struct vertex *v; struct vertex_adjs *next; }; struct vertex { int data; struct vertex_adjs *adj; }; #define MAX_GRAPH_VERTEX (1 \u0026lt;\u0026lt; 8) struct graph { struct vertex *vxs[MAX_GRAPH_VERTEX]; }; void init_graph(struct graph *graph) { int i; for (i = 0; i \u0026lt; MAX_GRAPH_VERTEX; i++) graph-\u0026gt;vxs[i] = NULL; } struct vertex *create_vertex(int data) { struct vertex *v; v = malloc(sizeof(struct vertex)); if (v) { v-\u0026gt;data = data; v-\u0026gt;adj = NULL; } return v; } struct vertex_adjs *create_vertex_adj(struct vertex *v) { struct vertex_adjs *v_adj; v_adj = malloc(sizeof(struct vertex_adjs)); if (!v_adj) return NULL; v_adj-\u0026gt;v = v; v_adj-\u0026gt;next = NULL; return v_adj; } void insert_adj(struct vertex *v, struct vertex *adj) { struct vertex_adjs **v_adj; v_adj = \u0026amp;v-\u0026gt;adj; while (*v_adj) v_adj = \u0026amp;(*v_adj)-\u0026gt;next; *v_adj = create_vertex_adj(adj); } void dump_raw(struct graph *graph) { int i; for (i = 0; i \u0026lt; MAX_GRAPH_VERTEX; i++) { struct vertex *v = graph-\u0026gt;vxs[i]; struct vertex_adjs *adj; if (v == NULL) continue; printf(\u0026#34;Vertex[%02d]: %8d -\u0026gt;\u0026#34;, i, v-\u0026gt;data); adj = v-\u0026gt;adj; while (adj) { printf(\u0026#34; %8d,\u0026#34;, adj-\u0026gt;v-\u0026gt;data); adj = adj-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } } /* 1 ----- 2 ----- 3 | / | / | / | / | / | / | / | / | / | / 4 ----- 5 */ void fake_a_graph(struct graph *graph) { int i; init_graph(graph); for (i = 0; i \u0026lt; 5; i++) graph-\u0026gt;vxs[i] = create_vertex(i+1); /* connect 1 -\u0026gt; 2, 1 -\u0026gt; 4 */ insert_adj(graph-\u0026gt;vxs[0], graph-\u0026gt;vxs[1]); insert_adj(graph-\u0026gt;vxs[0], graph-\u0026gt;vxs[3]); /* connect 2 -\u0026gt; 1, 2 -\u0026gt; 3, 2 -\u0026gt; 5, 2 -\u0026gt; 4 */ insert_adj(graph-\u0026gt;vxs[1], graph-\u0026gt;vxs[0]); insert_adj(graph-\u0026gt;vxs[1], graph-\u0026gt;vxs[2]); insert_adj(graph-\u0026gt;vxs[1], graph-\u0026gt;vxs[4]); insert_adj(graph-\u0026gt;vxs[1], graph-\u0026gt;vxs[3]); /* connect 3 -\u0026gt; 2, 3 -\u0026gt; 5 */ insert_adj(graph-\u0026gt;vxs[2], graph-\u0026gt;vxs[1]); insert_adj(graph-\u0026gt;vxs[2], graph-\u0026gt;vxs[4]); /* connect 4 -\u0026gt; 1, 4 -\u0026gt; 2, 4 -\u0026gt; 5 */ insert_adj(graph-\u0026gt;vxs[3], graph-\u0026gt;vxs[0]); insert_adj(graph-\u0026gt;vxs[3], graph-\u0026gt;vxs[1]); insert_adj(graph-\u0026gt;vxs[3], graph-\u0026gt;vxs[4]); /* connect 5 -\u0026gt; 4, 5 -\u0026gt; 2, 5 -\u0026gt; 3 */ insert_adj(graph-\u0026gt;vxs[4], graph-\u0026gt;vxs[3]); insert_adj(graph-\u0026gt;vxs[4], graph-\u0026gt;vxs[1]); insert_adj(graph-\u0026gt;vxs[4], graph-\u0026gt;vxs[3]); } int main() { struct graph g; fake_a_graph(\u0026amp;g); dump_raw(\u0026amp;g); return 0; } 2.4.3 图遍历 图的搜索方法：深度优先搜索和广度优先搜索。 深度优先遍历(DFS) 思路: 从图中某点v出发: 1.访问顶点v 2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历. 3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问. 伪代码:\n// void DFS(Vertex v) { vistied[v] = true; for (v 的每个邻接点 w) { if (!visited[w]) { DFS(w); } } } dfs #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;Graph.h\u0026#34; #define MAX_NODES 1000 int visited[MAX_NODES]; // array to store visiting order // indexed by vertex 0..nV-1 bool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest) { Vertex w; for (w = 0; w \u0026lt; nV; w++) if (adjacent(g, v, w) \u0026amp;\u0026amp; visited[w] == -1) { visited[w] = v; if (w == dest) return true; else if (dfsPathCheck(g, nV, w, dest)) return true; } return false; } bool findPathDFS(Graph g, int nV, Vertex src, Vertex dest) { Vertex v; for (v = 0; v \u0026lt; nV; v++) visited[v] = -1; visited[src] = src; return dfsPathCheck(g, nV, src, dest); } int main(void) { int V = 6; Graph g = newGraph(V); Edge e; e.v = 0; e.w = 1; insertEdge(g, e); e.v = 0; e.w = 4; insertEdge(g, e); e.v = 0; e.w = 5; insertEdge(g, e); e.v = 5; e.w = 4; insertEdge(g, e); e.v = 4; e.w = 2; insertEdge(g, e); e.v = 4; e.w = 3; insertEdge(g, e); e.v = 5; e.w = 3; insertEdge(g, e); e.v = 1; e.w = 2; insertEdge(g, e); e.v = 3; e.w = 2; insertEdge(g, e); int src = 0, dest = 5; if (findPathDFS(g, V, src, dest)) { Vertex v = dest; while (v != src) { printf(\u0026#34;%d - \u0026#34;, v); v = visited[v]; } printf(\u0026#34;%d\\n\u0026#34;, src); } return 0; } 广度优先遍历(BFS) 思路: 1.顶点v入队列 2.当队列非空时则继续执行,否则算法结束. 3.出队列取得队头顶点v\u0026rsquo;,访问顶点v 并标记顶点v已被访问. 4.查找顶点v的第一个邻接顶点col 5.若v的邻接顶点col未被访问过的,则col继续. 6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.\nbfs_queue #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;Graph.h\u0026#34; #include \u0026#34;queue.h\u0026#34; #define MAX_NODES 1000 int visited[MAX_NODES]; // array to store visiting order // indexed by vertex 0..nV-1 bool findPathBFS(Graph g, int nV, Vertex src, Vertex dest) { Vertex v; for (v = 0; v \u0026lt; nV; v++) visited[v] = -1; visited[src] = src; queue Q = newQueue(); QueueEnqueue(Q, src); while (!QueueIsEmpty(Q)) { v = QueueDequeue(Q); Vertex w; for (w = 0; w \u0026lt; nV; w++) ( if (adjacent(g, v, w) \u0026amp;\u0026amp; visited[w] == -1) { visited[w] = v; if (w == dest) return true; else QueueEnqueue(Q, w); } ) } return false; } int main(void) { int V = 10; Graph g = newGraph(V); Edge e; e.v = 0; e.w = 1; insertEdge(g, e); e.v = 0; e.w = 2; insertEdge(g, e); e.v = 0; e.w = 5; insertEdge(g, e); e.v = 1; e.w = 5; insertEdge(g, e); e.v = 2; e.w = 3; insertEdge(g, e); e.v = 3; e.w = 4; insertEdge(g, e); e.v = 3; e.w = 5; insertEdge(g, e); e.v = 3; e.w = 8; insertEdge(g, e); e.v = 4; e.w = 5; insertEdge(g, e); e.v = 4; e.w = 7; insertEdge(g, e); e.v = 4; e.w = 8; insertEdge(g, e); e.v = 5; e.w = 6; insertEdge(g, e); e.v = 7; e.w = 8; insertEdge(g, e); e.v = 7; e.w = 9; insertEdge(g, e); e.v = 8; e.w = 9; insertEdge(g, e); int src = 0, dest = 6; if (findPathBFS(g, V, src, dest)) { Vertex v = dest; while (v != src) { printf(\u0026#34;%d - \u0026#34;, v); v = visited[v]; } printf(\u0026#34;%d\\n\u0026#34;, src); } return 0; } 深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)\n深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置. 广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.\n2.4.4 最短路径 迪杰斯特拉Dijkstra算法 Dijkstra算法适用于权值为正的图. Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离. 在源点可达的情况下,Dijkstra算法的时间复杂度时 O(ElogV) 算法步骤: 1.将所有边初始化为无穷大 2.旋转一个开始的顶点,添加到优先队列中. 3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新. 4.将该点所有邻接顶点添加到优先队列中. 5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5 6.直到所有点都被处理过一次.\n迪杰斯特拉 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAX 20 #define INF 999 int mat[MAX][MAX]; int V; int dist[MAX]; int q[MAX]; int qp = 0; void enqueue(int v) { q[qp++] = v; } int cf(void *a, void *b) { int *x = (int *)a; int *y = (int *)b; return *y - *x; } int dequeue() { qsort(q, qp, sizeof(int), cf); return q[--qp]; } int queue_has_something() { return (qp \u0026gt; 0); } int visited[MAX]; int vp = 0; void dijkstra(int s) { dist[s] = 0; int i; for (i = 0; i \u0026lt; V; ++i) { if (i != s) { dist[i] = INF; } enqueue(i); } while (queue_has_something()) { int u = dequeue(); visited[vp++] = u; for (i = 0; i \u0026lt; V; ++i) { if (mat[u][i]) { if (dist[i] \u0026gt; dist[u] + mat[u][i]) { dist[i] = dist[u] + mat[u][i]; } } } } } int main(int argc, char const *argv[]) { printf(\u0026#34;Enter the number of vertices: \u0026#34;); scanf(\u0026#34; %d\u0026#34;, \u0026amp;V); printf(\u0026#34;Enter the adj matrix: \u0026#34;); int i, j; for (i = 0; i \u0026lt; V; ++i) { for (j = 0; j \u0026lt; V; ++j) { scanf(\u0026#34; %d\u0026#34;, \u0026amp;mat[i][j]); } } dijkstra(0); printf(\u0026#34;\\nNode\\tDist\\n\u0026#34;); for (i = 0; i \u0026lt; V; ++i) { printf(\u0026#34;%d\\t%d\\n\u0026#34;, i, dist[i]); } return 0; } 弗洛伊德Floyd算法 Floyd算法是一个经典的动态规划算法.首先目标是寻找从点i到j的最短路径. Floyd算法可以求出任意两点的最短距离.时间复杂度:O(你^3) 从任意节点i到任意节点j的最短路径不外乎2种可能: 1.是之间从i到j 2是从i到经过若干个节点k到j 设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) \u0026lt; Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\nfor (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (A[i][j] \u0026gt; (A[i][k] + A[k][j])) { A[i][j] = A[i][k] + A[k][j]; path[i][j] = k; } } } } 2.4.5 拓扑排序 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:\n每个顶点出现且只出现一次 若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面. 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。 拓扑排序步骤： 从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出 从图中删除该顶点和所有以它为起点的有向边 重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。 2.4.6 leetcode题目 判断二分图 克隆图 找到小镇的法官 钥匙和房间 最短路径访问所有节点 3 常见算法 3.1 递归思想 3.1.1 递归思想 递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果. 如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.\n斐波那契数列\nint fib(int N) { if (N \u0026lt; = 1) { return N; } return fib(N-1) + fib(N-2); } 递归的过程中,符合后进先出规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是递归终止条件. 递归思想的两个延申算法:分治算法和动态规划. 递归的一般结构:\nvoid func() { if (符合边界条件) { ... return ..; } // 某种形式的调用 func(); } 阶乘函数:\nint factorial(int n) { if (n \u0026lt;= 1) { return 1; } return n * factorial(n-1); } 参考链接:https://www.jianshu.com/p/b2d2edb4ba5b 3.1.2 递归基本步骤: 1.定义一个函数,明确函数功能 2.寻找问题与子问题之间的关系(递推公式) 3.将递推公式在定义的函数中实现 4.推导时间复杂度,判定是否可以接受,无法接受更换算法.\n3.1.3 代表题目 爬楼梯 70 int climbStairs(int n) { int *mem = (int *)malloc(sizeof(int) * (n+1)); int mem[n] = {}; return climb(n, mem); } int climb(int n, int *mem) { if (n == 1) { return 1; } if (n == 2) { return 2; } if (mem[n] \u0026gt; 0) { return mem[n]; } mem[0] = climb(n-1, mem) + climb(n-2, mem); return mem[n]; } 青蛙跳台阶 10-II int numWays(int n) { int num[n+1] = {-1}; return jump(n, num); } int jump(int n, int *num) { if (num[n] != -1) { return num[n]; } if (n == 1 || n == 0) { return 1; } num[n] = (jump(n-1, num) + jump(n-2, num) % 1e9+7); return num[n]; } 3.1.4 触类旁通 反转二叉树 226 1).对于根节点1来说,假设2,3节点下的节点都已经翻转,那么只要翻转2,2节点即满足需求. 2).对于2,3节点来说,也是翻转其左右节点即可. 依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即 invert(root) = invert(root-\u0026gt;left) + invert(root-\u0026gt;right) 加号是追加到root上的意思\ntypedef struct TreeNode { int data; TreeNode *left; TreeNode *right; } TreeNode invertTree(TreeNode *root) { if (root == NULL) { return NULL; } TreeNode *left = (struct TreeNode *)malloc(sizeof(TreeNode)); TreeNode *right = (struct TreeNode *)malloc(sizeof(TreeNode)); left = invertTree(root.left); rgith = invertTree(root.right); root.left = right; root.right = left; return root; } 路径总和 112 给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和. typedef struct TreeNode { int data; struct TreeNode *left; struct TreeNode *right; } bool hasPathSum(TreeNode *root, int sum) { if (root == NULL) { return false; } if (root.left == NULL \u0026amp;\u0026amp; root.right == NULL) { return root.data == sum; } int remain = sum - root.data; return hasPathSum(root.left, remain) || hashPashSum(root.right, remain); } 细胞分裂 https://www.jianshu.com/p/b2d2edb4ba5b\n3.2 分治法 把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题\u0026hellip;，直到可以直接求解，原问题的解为子问题解的合并。 分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。\n3.2.1 概述 分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.\n分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题\u0026hellip;,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的合并.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换 1):数学归纳是使用分治思想. 2):分治思想不一定使用递归结构. 递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是如何分\n3.2.2 策略 分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.\n3.2.3 应用场景 分治法特征:\n问题缩小到一定程度可容易解决. 问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质. 子问题的解可合并为该问题的解. 问题分解的子问题相互独立,子问题之间不包含公告子问题. 3.2.4 步骤 分治法一层递归步骤:\n分解:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题. 解决:若子问题可直接求解,则直接求解,否则递归解各个子问题. 合并:将各个子问题的解合并为原问题的解. 3.2.5 应用 分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。\n求x的n次幂 对数复杂度O(logn)\nint power(int x, int n) { int result; if (n == 1) { return x; } if (n % 2 == 0) { result = power(x, n/2) * power(x, n / 2); } else { result = power(x, (n + 1) / 2) * power(x, (n - 1) / 2); } return result; } 3.2.6 leetcode题目 搜索二维矩阵II 求众数 合并k个排序链表 3.3 排序算法 各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，\n3.3.1 冒泡排序 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 冒泡排序算法复杂度是O(n^2)\nstatic void bubleSort(int[] arr) { int size = arr.length; // for (int out = size - 1; out \u0026gt; 0; out--) { // for (int in = 0; in \u0026lt; out; in++) { if (arr[in] \u0026gt; arr[in + 1]) { swap(arr, in, in + 1); } } } } #define SWAP(a,b) \\ do{\\ (a) ^= (b);\\ (b) ^= (a);\\ (a) ^= (b);\\ }while(0) /*冒泡排序*/ void bubble_sort(int a[],int size) { int i = 0; int j = 0; int swap_flg = 0; if (size \u0026lt; 1) { return; } for (i = size - 1; i \u0026gt; 0; i--) {/*排序的趟数*/ swap_flg = 0;/*每次设置交换标识为0*/ for (j = 0; j \u0026lt; i; j++) { /*本趟排序的遍历元素个数*/ if (a[j] \u0026gt; a[j + 1]) { SWAP(a[j],a[j+1]); swap_flg = 1; } } /*本趟数，无数据交换的话，说明已经有序，直接退出*/ if (swap_flg == 0) { break; } } return; } #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; //整数或浮点数皆可使用 void bubble_sort(T arr[], int len) { int i, j; T temp; for (i = 0; i \u0026lt; len - 1; i++) { for (j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } 3.3.2 选择排序 选择排序算法时间复杂度为O(n^2)\nstatic void selectSort(int[] arr) { int size = arr.lenght; // for (int out = 0; out \u0026lt; size; out++) { int mixIndex = out; // for (int in = out - 1; in \u0026lt; size; in++) { if (arr[mixIndex] \u0026gt; arr[in]) { mixIndex = in; } } if (mixIndex != out) { swap(arr, mixIndex, out); } } } /*选择排序*/ void select_sort(int a[],int size) { int i = 0; int j = 0; int min = 0; for (i = 0; i \u0026lt; size - 1; i++) { min = i; for (j = i + 1; j \u0026lt; size; j++) { if (a[j] \u0026lt; a[min]) { min = j; } } if (min != i) { SWAP(a[i],a[min]); } } return; } 3.3.3 插入排序 插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)\nstatic void insertSort(int[] arr) { int size = arr.lenght; // for (int out = 1; out \u0026lt; size; out++) { // int temp = arr[out]; int in = out; // // while (in - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[in - 1] \u0026gt; temp) { arr[in] = arr[in - 1]; in--; } if (in != out) { arr[in] = temp; } } } /*插入排序*/ void insert_sort(int a[],int size) { for (int i = 1; i \u0026lt; size; i ++)/*需要插入的元素个数*/ { int key = a[i];/*保存插入的元素数据*/ int j = i - 1; /* i 之前的元素都是有序的，找到比key小的插入到他后面， * 比key大的，需要往后挪一个位置*/ while((j \u0026gt;= 0) \u0026amp;\u0026amp; (a[j] \u0026gt; key)) { a[j + 1] = a[j]; j--; } a[j + 1] = key; } return; } int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2)) { char *a = data; void *key; int i, j; if ((key = (char *)malloc(esize)) == NULL) { return -1; } for (j = 1; j \u0026lt; size; j++) { i = j - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; compare(\u0026amp;a[i * esize], key) \u0026gt; 0) { mamcpy(\u0026amp;a[(i + 1) * esize], \u0026amp;a[i * esize], esize); i--; } memcpy(\u0026amp;a[(i + 1) * esize], key, esize); } free(key); return 0; } 3.3.4 希尔排序 希尔排序时间复杂度O(n*(logn)^2)\nstatic void shellSort(int[] arr) { int size = arr.lenght; int h = 1; while (h \u0026lt;= size / 3) { // h = h * 3 + 1; } while (h \u0026gt; 0) { for (int out = h; out \u0026lt; size; out++) { int temp = arr[out]; int in = out; // while (in - h \u0026gt;= 0 \u0026amp;\u0026amp; arr[in - h] \u0026gt; temp) { arr[in] = arr[in - h]; in = in - h; } if (in != out) { arr[in] = temp; } } h = (h - 1) / 3; } } 3.3.5 归并排序 归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。\nint min(int x, int y) { return x \u0026lt; y ? x : y; } void merge_sort(int arr[], int len) { int *a = arr; int *b = (int *)malloc(len * sizeof(int)); int seg, start; for (seg = 1; seg \u0026lt; len; seg += seg) { for (start ) } } #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; void dump(int *arr, int size) { int idx; for (idx = 0; idx \u0026lt; size; idx++) printf(\u0026#34;%08d\\n\u0026#34;, arr[idx]); } void __merge(int *arr, int p, int q, int r) { int *tmp; int i, j, k; tmp = (int*)malloc((r - p + 1) * sizeof(int)); if (!tmp) abort(); for (i = p, j = q + 1, k = 0; i \u0026lt;= q \u0026amp;\u0026amp; j \u0026lt;= r;) { if (arr[i] \u0026lt;= arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } if (i == q + 1) { for (; j \u0026lt;= r;) tmp[k++] = arr[j++]; } else { for (; i \u0026lt;= q;) tmp[k++] = arr[i++]; } memcpy(arr + p, tmp, (r - p + 1) * sizeof(int)); free(tmp); } void __merge_sort(int *arr, int p, int r) { int q; if (p \u0026gt;= r) return; q = (p + r) / 2; __merge_sort(arr, p, q); __merge_sort(arr, q + 1, r); __merge(arr, p, q, r); } void merge_sort(int *arr, int size) { __merge_sort(arr, 0, size - 1); } void merge_verify() { int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56}; __merge(test, 0, 4, 9); dump(test, 10); } void merge_sort_test() { int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56}; merge_sort(test, 10); dump(test, 10); } int main() { //merge_verify(); merge_sort_test(); return 0; } 3.3.6 快速排序 快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)\n快速排序三个步骤：\n分：设定一个分割值并将数据分为两部分。 治：分别在两部分使用递归方式继续使用快速排序方法。 和：对分割部分排序直至完成。 typedef struct _Range { int start; int end; } Range; Range now_Range(int s, int e) { Range r; r.start = s; r.end = e; return r; } void swap(int *x, int *y) { int t = *x; *x = *y; *y = t; } void quick_sort(int arr[], const int len) { if (len \u0026lt;= 0) { return; } Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) { Range range = r[--p]; if (range.start \u0026gt;= range.end) { continue; } int mid = arr[(range.start + range.end) / 2]; int left = range.start; int right = range.end; do { while (arr[left] \u0026lt; mid) { ++left; } while (arr[right] \u0026gt; mid) { --right; } if (left \u0026lt;= right) { swap(\u0026amp;arr[left], \u0026amp;arr[right]); left++; right--; } } while (left \u0026lt;= right); if (range.start \u0026lt; right) { r[p++] = new_Range(range.start, right); } if (range.end \u0026gt; left) { r[p++] = new_Range(left, range.end); } } } void QuickSort(int *arr, int low, int high) { if (low \u0026lt; high) { int i = low; int j = high; int k = arr[low]; while (i \u0026lt; j) { // 从右向左找第一个小于k的数 while (i \u0026lt; j \u0026amp;\u0026amp; arr[j] \u0026gt;= k) { j--; } if (i \u0026lt; j) { arr[i++] = arr[j]; } // 从左向右找第一个大于等于k的数 while (i \u0026lt; j \u0026amp;\u0026amp; arr[i] \u0026lt; k) { i++; } if (i \u0026lt; j) { arr[j--] = arr[i]; } } arr[i] = k; // 递归调用 QuickSort(arr, low, i - 1); // 排序k左边 QuickSort(arr, i + 1, high); // 排序k右边 } } void quick_sort( int *a, int n) { int i, j, p, tmp; if (n \u0026lt; 2) return; p = a[n / 2]; // Get the middle element as pivot .. for ( i = 0, j = n -1;; i++, j--) { while (a[i] \u0026lt; p) i++; while (p \u0026lt; a[j]) j--; if ( i \u0026gt;= j) break; tmp = a[i]; a[i] = a[j]; a[j] = tmp; //swap both .. } quick_sort( a, i); quick_sort( a + i, n - i); } #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; void dump(int *arr, int size) { int idx; for (idx = 0; idx \u0026lt; size; idx++) printf(\u0026#34;%08d\\n\u0026#34;, arr[idx]); } void swap(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } int partition(int *arr, int p, int r) { //int pivot = arr[r]; int i, j; i = j = p; for (; j \u0026lt; r; j++) { if (arr[j] \u0026lt; arr[r]) { if(i != j) { swap(arr + i, arr + j); } i++; } } swap(arr + i, arr + r); return i; } void __quick_sort(int *arr, int p, int r) { int q; if (p \u0026gt;= r) return; q = partition(arr, p, r); __quick_sort(arr, p, q-1); __quick_sort(arr, q+1, r); } void quick_sort(int *arr, int size) { __quick_sort(arr, 0, size - 1); } void quick_sort_test() { int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56}; quick_sort(test, 10); dump(test, 10); } int main() { quick_sort_test(); return 0; } #include \u0026lt;iostream\u0026gt; using namespace std; void Qsort(int arr[], int low, int high){ if (high \u0026lt;= low) return; int i = low; int j = high + 1; int key = arr[low]; while (true) { /*从左向右找比key大的值*/ while (arr[++i] \u0026lt; key) { if (i == high) { break; } } /*从右向左找比key小的值*/ while (arr[--j] \u0026gt; key) { if (j == low) { break; } } if (i \u0026gt;= j) break; /*交换i,j对应的值*/ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } /*中枢值与j对应值交换*/ int temp = arr[low]; arr[low] = arr[j]; arr[j] = temp; Qsort(arr, low, j - 1); Qsort(arr, j + 1, high); } qsort/sort函数 在c语言库函数中已经实现了qsort函数, qsort函数用法:\nvoid qsort(void *base, int nelem, int width, int (*fcmp)(const void *, const void *)); // 参数:1 带排序数组首地址, nelem 数组中待排元素数量 width 各元素所在空间大小 *fcmp 指向函数的指针 // int 数组 int cmp(const void *a, const void *b) { return (*(int *)a - *(int *)b); } qsort(arr, n, sizeof(arr[0]), cmp); // char 数组 int com(const void *a, const void *b) { return *(char *)a - *(char *)b; } char word[100]; qsort(word, 100, sizeof(word[0]), cmp); // double 类型 int cmp(const void *a, const void *b) { return *(double *)a \u0026gt; *(double*)b ? 1 : -1; } double in[100]; qsort(in, 100, sizeof(in[00]), cmp); // struct 结构体 struct Sample { double data; int num; }st[100]; int cmp(const void *a, const void *b) { return (*(Sample *)a).data \u0026gt; (*(Sampel *)b).data ? 1 : -1; } qsort(s, 100, sizeof(s[0]), cmp); // int cmp(const void *a, const void *b) { struct Sample *c = (Sample *)a; struct Sample *d = (Sample *)b; if(c-\u0026gt;x != d-\u0026gt;x) { return c-\u0026gt;x - d-\u0026gt;x; } else { return d-\u0026gt;y - c-\u0026gt;y; } } qsort(s,100,sizeof(s[0]),cmp); truct Sample { int data; char str[100]; }s[100]; //按照结构体中字符串str的字典顺序排序 int cmp (const void *a, const void *b) { return strcmp((*(Sample *)a)-\u0026gt;str , (*(Sample *)b)-\u0026gt;str); } qsort(s,100,sizeof(s[0]),cmp); 3.3.7 堆排序 桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。 存在两个问题： (1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。 (2)对每个数据块里的数据怎样排序。 堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。 堆排序的过程： 1.由输入的无序数组构造一个最大堆，作为初始的无序区 2.把堆顶元素(最大值)和堆尾元素互换 3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。 4.重复步骤2，直到堆的尺寸为1 因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。\n#include\u0026lt;sdtio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; typedef struct node { int key; struct node *next; } KeyNode; void bucket_sort(int keys[], int size, int bucket_size) { int i, j; KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * sizeof(KeyNode*)); for(i = 0;i \u0026lt; bucket_size;i++) { bucket_table[i] = (KeyNode*)malloc(sizeof(KeyNode)); bucket_table[i]-\u0026gt;key = 0; bucket_table[i]-\u0026gt;next = NULL; } for(j = 0;j \u0026lt; size;j++) { KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode)); node-\u0026gt;key = keys[j]; node-\u0026gt;next = NULL; int index = keys[j]/10; KeyNode *p = bucket_table[index]; if(p-\u0026gt;key == 0) { bucket_table[index]-\u0026gt;next = node; (bucket_table[index]-\u0026gt;key)++; } else { while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;key \u0026lt;= node-\u0026gt;key) p = p-\u0026gt;next; node-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = node; (bucket_table[index]-\u0026gt;key)++; } } //print result KeyNode * k = NULL; for(i = 0;i \u0026lt; bucket_size;i++) for(k = bucket_table[i]-\u0026gt;next;k!=NULL;k=k-\u0026gt;next) printf(\u0026#34;%d \u0026#34;,k-\u0026gt;key); printf(\u0026#34;\\n\u0026#34;); } int main() { int raw[] = {49,38,65,97,76,13,27,49}; int size = sizeof(raw)/sizeof(int); bucket_sort(raw,size,10); } void Heapify(int A[], int i, int size) { int lef_child = 2 * i + 1; int right_child = 2 * i + 2; int max = i; if (lef_child \u0026lt; size \u0026amp;\u0026amp; A[lef_child] \u0026gt; A[max]) { max = lef_child; } if (right_child \u0026lt; size \u0026amp;\u0026amp; A[right_child] \u0026gt; A[max]) { max = right_child; } if (max != i) { Swap(A, i max); Heapify(A, max, size); } } int BuildHeap(int A[], int n) { int heap_size = n; for (int i = heap_size / w - 1; i \u0026gt;= 0; i--) { Heapify(A, i, heap_size); return heap_size; } } void HeapSort(int A[], int n) { int heap_size = BuildHeap(A, n); while (heap_size \u0026gt; 1) { Swap(A, 0, heap_size); Heap(A, 0, heap_size); } } 3.3.8 leetcode排序 按奇偶排序数组 对链表进行插入排序 合并区间 最大数 最接近原点的K个点 3.4 贪心算法 3.4.1 基本概念 贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解. 贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.\n3.4.2 描述 贪心算法实现步骤: 1.建立数学模型描述问题 2.把求解的问题分成若干个子问题 3.对每个子问题求解,得到子问题的局部最优解 4.把子问题的解局部最优解合成原来问题的一个解. 实现算法过程:\nwhile (能朝给定总目标前进一步) { 利用可行的决策,求出可行解的一个解元素; } 由所有解元素组合成问题的一个可行解 3.4.3 应用 最小生成树算法 贪心算法经典实践:最小生成树算法 设G=(V, E)是无向连通带权图,即一个网络,E中的每一条边(v,w) 的全为 c[v][w].如果G的字体 G\u0026rsquo; 是一颗包含 G 的所有顶点的数,则称 G\u0026rsquo; 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树. 最小生成树的性质: 设G=(V, E)是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.\nPrim算法 设G=(V, E)是连通带权图, V={1,2,\u0026hellip;,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.\nPrim /** * @file * @author [Timothy Maloney](https://github.com/sl1mb0) * @brief [Prim\u0026#39;s algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm) * implementation in C to find the MST of a weighted, connected graph. * @details Prim\u0026#39;s algorithm uses a greedy approach to generate the MST of a *weighted connected graph. The algorithm begins at an arbitrary vertex v, and *selects a next vertex u, where v and u are connected by a weighted edge whose *weight is the minimum of all edges connected to v. * @references Page 319 \u0026#34;Introduction to the Design and Analysis of Algorithms\u0026#34; *- Anany Levitin * * To test - run \u0026#39;./prim -test\u0026#39; * prim() will find the MST of the following adj. matrix: * *\t0 1 2 3 * 1 0 4 6 * 2 4 0 5 * 3 6 5 0 * * The minimum spanning tree for the above weighted connected graph is given by *the following adj matrix: * *\t0 1 2 3 *\t1 0 0 0 *\t2 0 0 0 *\t3 0 0 0 * * * The following [link](https://visualgo.net/en/mst) provides a visual *representation of graphs that can be used to test/verify the algorithm for *different adj matrices and their weighted, connected graphs. */ #include \u0026lt;assert.h\u0026gt; /// for assert() #include \u0026lt;inttypes.h\u0026gt; /// for uint16_t #include \u0026lt;stdio.h\u0026gt; /// for IO operations #include \u0026lt;string.h\u0026gt; /// for string comparison #define MAX 20 #define INF 999 /** * @brief Finds index of minimum element in edge list for an arbitrary vertex * @param arr graph row * @param N number of elements in arr * @returns index of minimum element in arr */ uint16_t minimum(uint16_t arr[], uint16_t N) { uint16_t index = 0; uint16_t min = INF; for (uint16_t i = 0; i \u0026lt; N; i++) { if (arr[i] \u0026lt; min) { min = arr[i]; index = i; } } return index; } /** * @brief Used to find MST of user-generated adj matrix G * @returns void */ void prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V) { uint16_t u, v; uint16_t E_t[MAX], path[MAX]; uint16_t V_t[MAX], no_of_edges; E_t[0] = 0; // edges for current vertex V_t[0] = 1; // list of visited vertices for (uint16_t i = 1; i \u0026lt; V; i++) { E_t[i] = G[i][0]; path[i] = 0; V_t[i] = 0; } no_of_edges = V - 1; while (no_of_edges \u0026gt; 0) { u = minimum(E_t, V); while (V_t[u] == 1) { E_t[u] = INF; u = minimum(E_t, V); } v = path[u]; MST[v][u] = E_t[u]; MST[u][v] = E_t[u]; no_of_edges--; V_t[u] = 1; for (uint16_t i = 1; i \u0026lt; V; i++) { if (V_t[i] == 0 \u0026amp;\u0026amp; G[u][i] \u0026lt; E_t[i]) { E_t[i] = G[u][i]; path[i] = v; } } } } /** * @brief Self-test implementations * @returns void */ static void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V) { uint16_t test[4][4] = { {0, 1, 2, 3}, {1, 0, 4, 6}, {2, 4, 0, 5}, {3, 6, 5, 0}}; uint16_t solution[4][4] = { {0, 1, 2, 3}, {1, 0, 0, 0}, {2, 0, 0, 0}, {3, 0, 0, 0}}; V = 4; for (uint16_t i = 0; i \u0026lt; V; ++i) { for (uint16_t j = 0; j \u0026lt; V; ++j) { G[i][j] = test[i][j]; } } prim(\u0026amp;(*G), \u0026amp;(*MST), V); for (uint16_t i = 0; i \u0026lt; V; ++i) { for (uint16_t j = 0; j \u0026lt; V; ++j) { assert(MST[i][j] == solution[i][j]); } } } /** * @brief Function user_graph(); * gets user input adj. matrix and finds MST of that graph * @returns void */ void user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V) { printf(\u0026#34;Enter the number of vertices: \u0026#34;); scanf(\u0026#34; %hd\u0026#34;, \u0026amp;V); assert(V \u0026lt;= MAX); printf(\u0026#34;Enter the adj matrix\\n\u0026#34;); uint16_t i, j; for (i = 0; i \u0026lt; V; ++i) { for (j = 0; j \u0026lt; V; ++j) { printf(\u0026#34;G[%d][%d]: \u0026#34;, i, j); scanf(\u0026#34; %hd\u0026#34;, \u0026amp;G[i][j]); if (G[i][j] == 0) G[i][j] = INF; } } prim(\u0026amp;(*G), \u0026amp;(*MST), V); printf(\u0026#34;minimum spanning tree:\\n\u0026#34;); for (i = 0; i \u0026lt; V; ++i) { printf(\u0026#34;\\n\u0026#34;); for (j = 0; j \u0026lt; V; ++j) { printf(\u0026#34;%d\\t\u0026#34;, MST[i][j]); } } } /** * @brief Main function * @param argc commandline argument count (ignored) * @param argv commandline array of arguments (ignored) * @returns 0 on exit */ int main(int argc, char const *argv[]) { uint16_t G[MAX][MAX]; ///\u0026lt; weighted, connected graph G uint16_t MST[MAX][MAX]; ///\u0026lt; adj matrix to hold minimum spanning tree of G uint16_t V; ///\u0026lt; number of vertices in V in G if (argc == 2 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-test\u0026#34;) == 0) { test(\u0026amp;(*G), \u0026amp;(*MST), V); } else { user_graph(\u0026amp;(*G), \u0026amp;(*MST), V); } return 0; } 3.4.4 leetcode题目 柠檬水找零 分发饼干 3.5 动态规划 动态规划(DP):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.\n3.5.1 基本概念 动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录. 动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划. 动态规划与分治法的区别是子问题通常不是独立的.\n3.5.2 描述算法 可采用动态规划的问题3个性质: 1) 最优化原理:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理. 2) 无后效性:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关. 3) 有重叠子问题:\n\u0026ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列. 动态规划求解三要素:\n(1) 问题的节点 (2) 每个阶段的状态 (3) 从前一个阶段转化到后一个阶段之间的递推关系\n最优决策表\nf(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}\n3.5.3 背包问题 问题描述: 有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大. 解题思路: p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为\u0026quot;前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为\u0026quot;前i-1物品放入剩下的容量为v-volume[i]的背包中\u0026quot;,此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].\n状态转移方程:\np[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]} 伪代码描述:\nfor i = 1...N for j = V...0 p[j] = max{p[j-volume[i]] + value[i], p[j]}; dp #include\u0026lt;stdio.h\u0026gt; int v[]={6,3,5,4,6}; int w[]={2,2,6,5,4}; int dp[100][100]; int Max(int a,int b){ if(a\u0026gt;=b){ return a; }else{ return b; } } int getAns(int i,int wi) { for(int x=0;x\u0026lt;=i;x++) { dp[x][0]=0; } for(int x = 0; x \u0026lt;= wi; x++) { dp[0][x]=0; } for(int x = 1; x \u0026lt;= i; x++) { for(int y=1;y\u0026lt;=wi;y++) { if(y\u0026gt;=w[x-1]) { dp[x][y]=Max(dp[x-1][y],v[x-1]+dp[x-1][y-w[x-1]]); } else { dp[x][y]=dp[x-1][y]; } printf(\u0026#34;%4d\u0026#34;,dp[x][y]); } printf(\u0026#34;\\n\u0026#34;); } return dp[i][wi]; } int main() { int max=getAns(5,10); printf(\u0026#34;%d\\n\u0026#34;,max); return 0; } 3.5.4 最长公共子序列 问题描述: 一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS) 给定两个序列X,Y,求两个序列的最长公共子序列. 解题思路: 最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。 最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：\nf[1][1] = same(1,1) f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]} 其中，same(a,b)当X的第a位与Y的第b位完全相同是\u0026quot;1\u0026quot;，否则位\u0026quot;1\u0026quot;。 此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。 该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。\n伪代码:\nfunction LCSLength(X[1..m], Y[1..n]) C = array(0..m, 0..n) for i := 0..m C[i, 0] = 0; for j := 0..n C[0, j] = 0 for i := 1..m for j := 1..n if X[i] = Y[j] C[i, j] := C[i-1, j-1] + 1 else C[i, j] := max(C[i, j-1], C[i-1,j]) return C[m, n] 最长公共序列数 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int dp[100][100]; int Max(int a,int b,int c){ int max=a; if(b\u0026gt;max){ max=b; } if(c\u0026gt;max){ max=c; } return max; } int getMax(char s1[],char s2[],int m,int n){ int i,j; for(i=0;i\u0026lt;m;i++){ //当 s2取 1个的时候 ,s1为可变长度 if(s1[i]==s2[0]){ dp[i][0]=1; for(j=i+1;j\u0026lt;m;j++){ dp[j][0]=1; } break; } } for(i=0;i\u0026lt;n;i++){ //当 s1取 1个的时候 ,s2为可变长度 if(s2[i]==s1[0]){ dp[0][i]=1; for(j=i+1;j\u0026lt;n;j++){ dp[0][j]=1; } break; } } for(i=1;i\u0026lt;m;i++){ for(j=1;j\u0026lt;n;j++){ if(s1[i]==s2[j]){ dp[i][j]=Max(dp[i-1][j-1]+1,dp[i-1][j],dp[i][j-1]); }else{ dp[i][j]=dp[i-1][j]\u0026gt;=dp[i][j-1]?dp[i-1][j]:dp[i][j-1]; } } } return dp[m-1][n-1]; } int main() { int m,n; char s1[100]; char s2[100]; gets(s1); gets(s2); m=strlen(s1); n=strlen(s2); printf(\u0026#34;%d\\n\u0026#34;,getMax(s1,s2,m,n)); return 0; } Fibonacci_dp // Fibonacci Series using Dynamic Programming /* Author: Moinak Banerjee(moinak878) Date : 1 October ,2019 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int fib(int n) { // Out of Range checking if (n \u0026lt; 0) { printf(\u0026#34;\\nNo Such term !\\n\u0026#34;); exit(0); } // declaring array to store fibonacci numbers -- memoization int *f = (int *)malloc((n + 2) * sizeof(int)); // one extra to handle edge case, n = 0 int i; /* let 0th and 1st number of the series be 0 and 1*/ f[0] = 0; f[1] = 1; for (i = 2; i \u0026lt;= n; i++) { // Adding the previous 2 terms to make the 3rd term f[i] = f[i - 1] + f[i - 2]; } int out = f[n]; free(f); return out; } int main(int argc, char *argv[]) { int number; // Asks for the number/position of term in Fibonnacci sequence if (argc == 2) { number = atoi(argv[1]); } else { printf(\u0026#34;Enter the value of n(n starts from 0 ): \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;number); } printf(\u0026#34;The nth term is : %d \\n\u0026#34;, fib(number)); return 0; } 3.5.5 leetcode题目 最大子序和 编辑距离 大礼包 最长上升子序列 3.6 回溯法 3.6.1 基本概念 回溯算法实际上一个类似枚举的搜索尝试过程,主要是在搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就\u0026quot;回溯\u0026quot;返回,尝试别的路径. 回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为\u0026quot;回溯法\u0026quot;. 许多复杂度,规模较大的问题都看看而已使用回溯法,有\u0026quot;通用解题方法\u0026quot;的美称.\n在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法). 若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束. 回溯法一般解题步骤: 1.针对所给问题,确定问题的解空间;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解. 2.确定节点的扩展搜索规则 3.以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索\n伪代码:\n// void iterativeBacktrack() { int t = 1; while (t \u0026gt; 0) { if (f(n, t) \u0026lt;= g(n, t)) { for (int i = f(n,t); i \u0026lt;= g(n,t); i++) { x[t] = h(i); if (constraint(t) \u0026amp;\u0026amp; bound(t)) { // if (solution(t)) { output(x); } else { t++; } } else { t--; } } } } } 3.6.2 八皇后问题 问题描述 八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上. 转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n \u0026gt;= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。 （1）因为所有的皇后都不能放在同一列，因为任意两个a[0]\u0026hellip;a[7]的值不能存在相同的两个值 （2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下： 假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。\n伪代码描述\nint queens(int Queens) { int i, k, flag, not_finish = 1, count = 0, // 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素 int a[Queeens+1]; // 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1 i = 1; a[1] = 1; // 为数组的第一个元素赋初值 while (not_finish) { // not_finish=1 处理尚未结束 while(not_finish \u0026amp;\u0026amp; i \u0026lt;= Queens) { // 处理尚未结束且还没处理到第Queeens个元素 for (flag=1, k=1; flag \u0026amp;\u0026amp; k \u0026lt; i; k++) { // 判断是否有多个皇后在同一行 if (a[k] == a[i]) { flag = 0; } } // 判断是否有多个皇后在同一个对角线 for (k=1; flag \u0026amp;\u0026amp; k \u0026lt; i; k++) { if ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) { flag = 0; } } } } } 3.6.3 leetcode题目 N皇后 括号生成 单词搜索 解数独 4 参考链接 复杂度速查表 https://liam.page/2016/06/20/big-O-cheat-sheet/ 线性表 https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8 单链表 https://www.jianshu.com/p/73f0d8f807aa http://cocofe.cn/\n数据结构 https://github.com/wangzheng0822/algo/ ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"1-程序性能\"\u003e1 程序性能\u003c/h2\u003e","title":"数据结构与算法基础"},{"content":" 操作系统层次Windows10以来已经是现代系统，包括支持了wsl，最近新布丁支持在Linux中运行多个Windows，见过Windows 98、2000、xp、win7 win8到win10，从封闭难用，走向开放现代系统。 上层应用层面 前端改写一切，在移动端各种卡片程序，小程序都在将应用程序推到前端，Google一直在推出各种操作系统，Chrome os已经十年，未来是否会是基于Chrome渲染引擎来构建应用程序？如果应用程序开发转移到前端，在操作系统上新加的一层渲染引擎会是什么？现阶段移动端游戏Unity太过重载不适合应用？ v8？新的渲染层是增加系统开销降低性能？还是由于可知和可控而能够优化提升执行效率？ Linux内核带来了无限可能，高级语言实现内核的尝试从未停止，近期最火热的尝试莫过于rust，rust语言已经引入支持，从重写驱动开始的尝试是很好的策略，未来是否真的能够看到高级语言实现的内核被广泛接受？ 硬件发展，在PC和服务器领域 AMD全面和Intel竞争，在先进工艺的加持下，甚至某些性能已经领先，Zen 4 r7000系列在消费市场性价比很高，牙膏厂也不在挤牙膏了，AMD YES能否继续？ ARM服务器在云厂商自研CPU投入应用很多，云厂商各自研发，市场推广困难，各自使用，百花齐放场景。 国内自主指令集摆脱MIPS后LoongArch完全自主吗？ 如果龙芯3A5000 真的对比⑨代i5，很厉害了，在其传统军工领域性能够用了，政企市场也可接受，服务器领域面相安全要求特殊场景，大市场竞争力不足，当然使用与否不仅仅看性能指标，甚至有时能用就行，性能指标很次要。 RISC-V在物联网领域的大爆发会到来吗？开放硬件之后如何建立生态？可能物联网末端不需要考虑 ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/2022/","summary":"操作系统层次Windows10以来已经是现代系统，包括支持了wsl，最近新布丁支持在Linux中运行多个Windows，见过Windows 9","title":"关于软件，硬件发展的一些不靠谱的看法"},{"content":"Ubuntu22.04 中使用docker容器，在容器内运行qemu可行否？ Docker默认禁用ptrace？\nhttps://www.mocusez.site/posts/1912.html\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/docker/","summary":"Ubuntu22.04 中使用docker容器，在容器内运行qemu可行否？ Docker默认禁用ptrace？ https://www.mocusez.site/posts/1912.html","title":"docker"},{"content":" 说明：插件基于C/C++ Project Generator，原始项目未更新，联系到作者沟通是否合入\n本项目地址: https://github.com/zhuangll/vscode_c_project_config\n支持gtest\n安装 在vscode中安装C/C++ Project Generator插件 下载代码，将代码替换到C/C++ Project Generator插件所在目录，windows环境vscode插件目录,将功能代码复制替换如下目录中 C:\\Users\\\u0026lt;用户名\u0026gt;\\.vscode\\extensions\\danielpinto8zz6.c-cpp-project-generator-1.2.4 mingw安装，选择如下链接下载一个即可，添加到环境变量path中 各版本gcc mingw clang https://winlibs.com/ https://github.com/brechtsanders/winlibs_mingw \\ MinGW-w64 https://www.mingw-w64.org/changelog/ 使用方法 wingows环境需要安装mingw，并添加到环境变量 linux环境适配中，已经部分适配，存在小bug，暂无适配动力\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vscode_c_project_config/","summary":"说明：插件基于C/C++ Project Generator，原始项目未更新，联系到作者沟通是否合入 本项目地址: https://github.com/zhuangll/vscode_c_project_config 支持gtest 安装 在vscode中安装C/","title":"vscode c/c++一键创建工程插件"},{"content":"perf \u0026amp; simpleperf ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/","summary":"perf \u0026amp; simpleperf","title":"性能工具"},{"content":"1. 系统安装 1.1 下载树莓派镜像工具 Raspberry Pi Imager 支持Windows与Linux系统\n官网下载地址：https://www.raspberrypi.com/software/ 1.2 下载系统镜像 树莓派的Ubuntu系统下载地址：https://cn.ubuntu.com/download/raspberry-pi 树莓派的Ubuntu系统 清华下载地址：https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/ 树莓派系统 Raspberry Pi OS ： https://www.raspberrypi.com/software/operating-systems/#raspberry-pi-os-32-bit 2 烧录系统 SD卡 读卡器 2.1 Raspberry Pi Imager软件 1）选择镜像 2）选择SD卡 3）设置里开启ssh及wireless 4）WRITE写入镜像 3.登录系统 # Ubuntu 查询树莓派IP sudo arp-scan -I wlp2s0 --localnet # 连接ssh 1 ssh pi@192.168.18.160 无显示器配置树莓派\n树莓派安装Ubuntu系统\n如何在树莓派上安装 Ubuntu 服务器\n树莓派无屏幕的情况下初始化WIFI设置和开启SSH\nhttps://cloud.tencent.com/developer/article/1863949\n系统信息 AIDA64 https://www.aida64.com/\n1 安装系统 官方镜像2022-04-04-raspios-bullseye-arm64.img.xz，xz格式文件可通过7zip直接解压。\n通过win32diskimager安装\n无显示配置 https://blog.csdn.net/weixin_39591031/article/details/122325148\n配置wifi 开启ssh\n`` sudo raspi-config\n选择Interface Options 选择SSH 开启SSH服务 Yes 连接ssh ssh pi@192.168.18.160\n同一局域网中windows软件IP Scanner 扫描IP Ubuntu - 参考链接： 树莓派官网 https://www.raspberrypi.com/software/ 树莓派无屏幕无网线远程桌面连接配置方法 https://copyfuture.com/blogs-details/202211120526368123 VNC https://www.realvnc.com/en/connect/download/viewer/ ubuntu下类似IP Scan扫描同一局域网的IP https://code84.com/741895.html ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%A0%91%E8%8E%93%E6%B4%BE/","summary":"1. 系统安装 1.1 下载树莓派镜像工具 Raspberry Pi Imager 支持Windows与Linux系统 官网下载地址：https://www.raspberrypi.com/","title":"树莓派"},{"content":"内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区的互斥 虚拟文件系统 第1章 内核引导和初始化 处理器上电-\u0026gt;执行引导程序-\u0026gt;加载内核到内存-\u0026gt;执行内核-\u0026gt;内核初始化-\u0026gt;启动用户空间第一个进程 ARM64处理器到物理地址0取第一条指令\n1.1 引导程序 1.1.1 入口_start ARM64处理器U-Boot程序执行过程，入口u-boot/arch/arm/cpu/armv8/start.S标识_start\n.globl\t_start _start: #if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER) #include \u0026lt;asm/boot0-linux-kernel-header.h\u0026gt; #elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) #include \u0026lt;asm/arch/boot0.h\u0026gt; #else b\treset #endif 1.1.2 reset reset: /* Allow the board to save important registers */ /* 允许板卡保存重要的寄存器*/ b\tsave_boot_params .globl\tsave_boot_params_ret save_boot_params_ret: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl // 初始化系统控制寄存器 #endif /* * 异常级别可能是3、2或者1，初始状态： * 小端字节序，禁止MMU，禁止指令/数据缓存 */ adr x0, vectors witch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 // 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址 mrs x0, scr_el3 // 设置安全配置寄存器SCR_EL3 orr x0, x0, #0xf /* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */ msr scr_el3, x0 msr cptr_el3, xzr /* 启用浮点和SIMD功能*/ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* 初始化寄存器CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 // 异常级别2 mov x0, #0x33ff msr cptr_el2, x0 /* 启用浮点和SIMD功能 */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u0026lt;\u0026lt; 20 msr cpacr_el1, x0 /* 启用浮点和SIMD功能 */ 0: … /* 应用ARM处理器特定的勘误表*/ bl apply_core_errata /* 处理器特定的初始化*/ bl lowlevel_init // 执行board_init_f()所需最小初始化 #if defined(CONFIG_ARMV8_SPIN_TABLE) \u0026amp;\u0026amp; !defined(CONFIG_SPL_BUILD) branch_if_master x0, x1, master_cpu b spin_table_secondary_jump // arch/arm/cpu/armv8/spin_tabli.c /* 绝对不会返回*/ #elif defined(CONFIG_ARMV8_MULTIENTRY) branch_if_master x0, x1, master_cpu /* * 从处理器 */ slave_cpu: wfe // 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数 ldr x1, =CPU_RELEASE_ADDR ldr x0, [x1] cbz x0, slave_cpu br x0 /* 跳转到指定地址*/ #endif /* CONFIG_ARMV8_MULTIENTRY */ master_cpu: bl _main // 主处理器执行函数 U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序\n1.1.3 函数_main // arch/arm/lib/crt0_64.S ENTRY(_main) // 设置初始的C语言运行环境，并且调用board_init_f(0)。 #if defined(CONFIG_SPL_BUILD) \u0026amp;\u0026amp; defined(CONFIG_SPL_STACK ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节*/ mov x0, sp bl board_init_f_alloc_reserve // 在栈的顶部为结构体global_data分配空间 mov sp, x0 mov x18, x0 /* 设置gd */ // 函数board_init_f_init_reserve，初始化结构体global_data bl board_init_f_init_reserve mov x0, #0 bl board_init_f // common/board_f.c 执行数组init_sequence_f中的每个函数 #if !defined(CONFIG_SPL_BUILD) // 设置中间环境（新的栈指针和gd），然后调用函数 // relocate_code(addr_moni) ldr x0, [x18, #GD_START_ADDR_SP] /* 把寄存器x0设置为gd-\u0026gt;start_addr_sp */ bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节 */ ldr x18, [x18, #GD_BD] /* 把寄存器x18设置为gd-\u0026gt;bd */ sub x18, x18, #GD_SIZE /* 新的gd在bd的下面 */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* 把寄存器x9设置为gd-\u0026gt;reloc_off */ add lr, lr, x9 /* 在重定位后新的返回地址 */ ldr x0, [x18, #GD_RELOCADDR] /* 把寄存器x0设置为gd-\u0026gt;relocaddr */ b relocate_code relocation_return: // 设置最终的完整环境 /* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/ bl c_runtime_cpu_setup #endif /* !CONFIG_SPL_BUILD */ #if defined(CONFIG_SPL_BUILD) bl spl_relocate_stack_gd /* 可能返回空指针 重新定位栈*/ // 执行“sp = (x0 != NULL) ? x0 : sp”， // 规避这个约束： // 带条件的mov指令不能把栈指针寄存器作为操作数 mov x1, sp cmp x0, #0 csel x0, x0, x1, ne mov sp, x0 #endif // 用0初始化未初始化数据段 ldr x0, =__bss_start /* 这是自动重定位*/ ldr x1, =__bss_end /* 这是自动重定位*/ clear_loop: str xzr, [x0], #8 cmp x0, x1 b.lo clear_loop /* 调用函数board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ /* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */ b board_init_r /* 不会运行到这里，因为函数board_init_r()不会返回*/ ENDPROC(_main) 1.1.4 函数run_main_loop 数组init_sequence_r最后一个函数run_main_loop，函数执行流程；\nrun_main_loop main_loop bootdely_process # 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量) autoboot_command abortboot # 等待用户按键 run_command_list # 未等待到按键，自动执行环境变量bootcmd bootm命令处理函数do_bootm\ndo_bootm do_bootm_states bootm_start # 初始化全局变量bootm_header_timages bootm_find_os # 把内核镜像从存储设备读到内存 bootm_find_other # ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件 bootm_load_os # 解压病加载内核到正确位置 bootm_os_get_boot_func # 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux do_bootm_linux(flag=BOOTM_STATE_OS_PREP) # 调用boot_prep_linux boot_prep_linux # 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件 boot_selected_os # do_bootm_linux(flag=BOOTM_STATE_OS_GO) boot_jump_linux # 负责跳转到Linux内核 boot_jum_linux do_nonsec_virt_switch smp_kick_all_cpus # CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3 dcache_disable # 禁用处理器的缓存和内存管理单元 # 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el2 switch_to_el1 armv8_switch_to_el1 内核入口 # 在异常级别2执行内核 armv8_switch_to_el2 内核入口 1.2 内核初始化 内核初始化分为汇编语言部分和C语言部分\n1.2.1 汇编语言部分 ARM64架构内核入口_head，直接跳转到标号stext\n// linux-4.14.295/arch/arm64/kernel/head.S _head: #ifdef CONFIG_EFI // 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS add x13, x18, #0x16 b stext #else b stext // 跳转到内核起始位置 .long0 // 保留 #endif stext\n// linux-4.14.295/arch/arm64/kernel/head.S ENTRY(stext) bl preserve_boot_args // 把引导程序传递的4个参数保存在全局数组boot_args中 bl el2_setup // 降级到异常级别1, 寄存器w0存放cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR偏移，默认值是0 bl set_cpu_boot_mode_flag // __boot_cpu_mode[2] 数组 bl __create_page_tables // 创建页表映射 /* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。 * 返回的时候，处理器已经为开启内存管理单元做好准备， * 转换控制寄存器已经设置好。*/ bl __cpu_setup // 初始化处理器 b __primary_switch // 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel ENDPROC(stext) 函数el2_setup a.如果异常级别是1，那么在异常级别1执行内核。 b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。 1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。 \\\n2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核 \\\n基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程 \\\n// 打开KVM字符设备文件。 fd = open(\u0026#34;/dev/kvm\u0026#34;, O_RDWR); // 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。 vmfd = ioctl(fd, KVM_CREATE_VM, 0); // KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符 vcpu_fd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 从QEMU切换到客户操作系统的过程如下。 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。 为了提高切换速度，ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2 \\\n函数__create_page_tables 1）创建恒等映射，虚拟地址=物理地址__enable_mmu开启内存管理单元 2）为内核镜像创建映射 \\\n映射代码节.idmap.text,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址\n函数__primary_switch 1）__enable_mmu开启内存管理单元 2）__primary_switched __enable_mmu执行流程 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址 __primary_switch执行流程 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE) 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体thread_info的地址(init_task.thread_info) 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors) 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中 5）用0初始化内核的未初始化数据段 6）调用C语言函数start_kernel \\\n1.2.2 C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。 （1）创建1号线程，即init线程，线程函数是kernel_init。 （2）创建2号线程，即kthreadd线程，负责创建内核线程。 （3）0号线程最终变成空闲线程。 \\\ninit线程继续初始化，执行的主要操作如下。 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。 （3）smp_init()：初始化SMP系统，启动所有从处理器。 （4）do_initcalls()：执行级别0～7的初始化。 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。 （7）free_initmem()：释放初始化代码和数据占用的内存。 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。 \\\n级别0～7的初始化，是指使用以下宏注册的初始化函数：\n// include/linux/init.h #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 1.2.3 SMP系统的引导 对称多处理器(Symmetirc Multi-Processor SMP) 3种引导从处理器方法 \\\n自旋表 电源状态协调接口 ACPI停车协议 1.3 init进程 init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有sysvinit、busybox init、upstart、systemd和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件/etc/initab\n第2章 进程管理 2.1 进程 Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。 task_struct结构体是进程描述符，主要成员\nvolatile long state; // 进程状态 void *stack; // 指向内核栈 pid_t pid; // 全局进程号 pid_t tgid // 全局的线程组标识符 struct pid_link pid[PIDTYPE_MAX]; // 进程号，进程组标识符和会话标识符 struct task_struct _rcu *real_parent; // real_parent指向真实的父进程 struct task_struct _rcu *parent; // parent指向父进程 struct task_struct *group_leader; // 指向进村组的组长 const struct cred _rcu *real_cred; // real_cred指向主题和真实客体证书 const struct cred _rcu *cred; // cred指向客体证书 char comm[TASK_COMM_LEN]; // 进程名 int prio, static_prio, nornal_prio; // 调度策略 unsigned int rt_priority,prolicy； // 优先级 cpumask_t cpus_allowed; // 允许进程在哪些处理器上运行 struct mm_struct *mm, *active_mm; // 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符 struct file_struct *files; // 打开文件表 struct nsproxy *nsproxy; // 命名空间 struct signal_struct *signal; // 信号处理 struct sigband_struct *sighand; sigset_t blocked, real_blocked; sigset_t saved_sigmask; struct sigpending pending; struct sysv_sem sysvsem; // UNIx系统5信号量和共享内存 struct sysv_shm sysvshm; 2.2 命名空间 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,容器仅仅是通过命名空间隔离？ \\\n命名空间 隔离资源 控制组cgroup 控制组根目录 进程间通信IPC UNIX系统5进程间通信和POSIx消息队列 network 网络协议 挂载mount 挂载点 PID 进程号 user 用户标识符和组标识符 UNIX分时系统(UTS) 主机名和网络信息服务NIS域名 创建新的命名空间方法： 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间 调用unshare创建新的命名空间 进程使用系统调用setns，绑定一个已经存在的命名空间\n进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。\n2.3 进程标识符 标识符 进程标识符 命名空间给进程分配标识符 线程组标识符 线程组中的主进程称为组长，线程组标识符就是组长的进程标识符\n系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组 进程组标识符 进程组标识符是组长的进程标识符。\n进程可以使用系统调用setpgid创建或者加入一个进程组 会话标识符 进程调用系统调用setsid的时候，创建一个新的会话 pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid \\\n进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，\n2.4 进程关系 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。\n2.5 启动程序 ret = fork(); if (ret \u0026gt; 0) { /* 父进程继续执行 */ } else if (ret == 0) { /* 子进程装载程序 */ ret = execve(filename, argv, envp); } else { /* 创建子进程失败 */ } 2.5.1　创建新进程 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的 两个个系统调用创建进程： \\\nfork：子进程是父进程的副本，用写时复制 clone：可控制子进程和父进程共享哪些资源 vfork：创建子进程，子进程用execve装载程序(已废弃) // 数字表示参数个数 SYSCALL_DEFINE0(fork) // 宏展开 asmlinkage表示C语言函数看被汇编代码调用 asmlinkage long sys_fork(void) 创建进程的进程p和被创建进程c三种关系\n新进程是进程p的子进程 clone传入CLONE_PARENT，兄弟关系 clone传入CLONE_THREAD，同属一个线程组 1. _do_fork函数 // kernel/fork.c long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); // tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址 调用copy_process创建新进程 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置 wake_up_new_task唤醒新进程\n2. copy_process函数 （1）标志组合 CLONE_NEWNS \u0026amp; CLONE_FS 新进程属于新挂载命名空间\n共享文件系统信息 CLONE_NEWUSER \u0026amp; CLONE_FS 新进程属于新用户命名空间\n共享文件系统信息 CLONE_THREAD 未设置CLONE_SIGHAND 新进程和当前进程同属一个线程组，\n但不共享信号处理程序 CLONE_SIGHAND 未设置CLONE_VM 新进程和当前进程共享信号处理程序，\n但不共享虚拟内存 （2）dup_task_struct函数 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈 // include/linux/sched.h union thread_union { #ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK struct task_struct task; #endif #ifndef CONFIG_THREAD_INFO_IN_TASK struct thread_info thread_info; #endif unsigned long stack[THREAD_SIZE/sizeof(long)]; }; 内核栈两种布局\nthread_info在内核栈顶部，成员task指向进程描述符 thread_info未占用内核栈 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址 内核栈的长度时THREAD_SIZE，ARM64架构内核栈长度为16KB thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体 // arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long\tflags;\t/* low level flags 底层标志位 */ mm_segment_t\taddr_limit;\t/* address limit 地址限制 */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN u64\tttbr0;\t/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */ #endif u64\tpreempt_count;\t/* 抢占计数器 0 =\u0026gt; preemptible 可抢占, \u0026lt;0 =\u0026gt; bug缺陷 */ }; （3）copy_creds函数 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1\n（4）检查线程数量限制 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS\n（5）sched_fork函数\n为新进程设置调度器相关的参数\n// linux-5.10.102/kernel/sched/core.c 书中为4.x版本 int sched_fork(unsigned long clone_flags, struct task_struct *p) { __sched_fork(clone_flags, p); // 执行基本设置 /* * We mark the process as NEW here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u0026gt;state = TASK_NEW; // 新进程状态设置为TASK_NEW /* * Make sure we do not leak PI boosting priority to the child. */ p-\u0026gt;prio = current-\u0026gt;normal_prio; // 新进程调度优先级设置为当前进程正常优先级 uclamp_fork(p); /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u0026gt;sched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { // 限期进程或实时进程 p-\u0026gt;policy = SCHED_NORMAL; // 调度策略 p-\u0026gt;static_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u0026gt;rt_priority = 0; } else if (PRIO_TO_NICE(p-\u0026gt;static_prio) \u0026lt; 0) // 普通进程 p-\u0026gt;static_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u0026gt;prio = p-\u0026gt;normal_prio = p-\u0026gt;static_prio; set_load_weight(p, false); /* * We don\u0026#39;t need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u0026gt;sched_reset_on_fork = 0; } if (dl_prio(p-\u0026gt;prio)) // 调度优先级是限期调度累的优先级 return -EAGAIN; // 不允许限期进程分叉生成新的限期进程 else if (rt_prio(p-\u0026gt;prio)) // 调度优先级是实时调度类优先级 p-\u0026gt;sched_class = \u0026amp;rt_sched_class; // 调度类设置为实时调度类 else p-\u0026gt;sched_class = \u0026amp;fair_sched_class; // 调度优先级是公平调度类的优先级，调度类设置为公平调度类 init_entity_runnable_average(\u0026amp;p-\u0026gt;se); #ifdef CONFIG_SCHED_INFO if (likely(sched_info_on())) memset(\u0026amp;p-\u0026gt;sched_info, 0, sizeof(p-\u0026gt;sched_info)); #endif #if defined(CONFIG_SMP) p-\u0026gt;on_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026amp;p-\u0026gt;pushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026amp;p-\u0026gt;pushable_dl_tasks); #endif return 0; } （6）复制或共享资源 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数\n// linux-4.14.295/ipc/sem.c int copy_semundo(unsigned long clone_flags, struct task_struct *tsk) { struct sem_undo_list *undo_list; int error; if (clone_flags \u0026amp; CLONE_SYSVSEM) { // CLONE_SYSTEM表示UNIX系统5信号量 error = get_undo_list(\u0026amp;undo_list); if (error) return error; refcount_inc(\u0026amp;undo_list-\u0026gt;refcnt); // 5信号量的撤销请求链表，sem_undo_list 计数+1 tsk-\u0026gt;sysvsem.undo_list = undo_list; } else tsk-\u0026gt;sysvsem.undo_list = NULL; // 新进程5信号量撤销请求链表为空 return 0; } 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表\n// linux-5.10.102/kernel/fork.c static int copy_files(unsigned long clone_flags, struct task_struct *tsk) { struct files_struct *oldf, *newf; int error = 0; /* * A background process may not have any files ... */ oldf = current-\u0026gt;files; if (!oldf) goto out; if (clone_flags \u0026amp; CLONE_FILES) { // CLONE_FIELS共享打开文件表 atomic_inc(\u0026amp;oldf-\u0026gt;count); // files_struct 计数加1 goto out; } newf = dup_fd(oldf, NR_OPEN_MAX, \u0026amp;error); // 新进程把当前进程的打开文件表复制一份 if (!newf) goto out; tsk-\u0026gt;files = newf; error = 0; out: return error; } 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息 函数copy_fs复制或共享文件系统信息\n// linux-5.10.102/kernel/fork.c static int copy_fs(unsigned long clone_flags, struct task_struct *tsk) { struct fs_struct *fs = current-\u0026gt;fs; if (clone_flags \u0026amp; CLONE_FS) { // CLONE_FS共享文件系统信息 /* tsk-\u0026gt;fs is already what we want */ spin_lock(\u0026amp;fs-\u0026gt;lock); if (fs-\u0026gt;in_exec) { spin_unlock(\u0026amp;fs-\u0026gt;lock); return -EAGAIN; } fs-\u0026gt;users++; // fs_struct共享文件系统信息结构体 加1 spin_unlock(\u0026amp;fs-\u0026gt;lock); return 0; } tsk-\u0026gt;fs = copy_fs_struct(fs); // 新进程复制当前进程文件系统信息 if (!tsk-\u0026gt;fs) return -ENOMEM; return 0; } 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 函数copy_sighand复制或共享信号处理程序\n// static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk) { struct sighand_struct *sig; if (clone_flags \u0026amp; CLONE_SIGHAND) { // CLONE_SIGHAND 表示共享信号处理程序 refcount_inc(\u0026amp;current-\u0026gt;sighand-\u0026gt;count); // 引用计数加1 return 0; } // 新进程复制当前进程信号处理程序 sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL); RCU_INIT_POINTER(tsk-\u0026gt;sighand, sig); if (!sig) return -ENOMEM; refcount_set(\u0026amp;sig-\u0026gt;count, 1); spin_lock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); memcpy(sig-\u0026gt;action, current-\u0026gt;sighand-\u0026gt;action, sizeof(sig-\u0026gt;action)); spin_unlock_irq(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); /* Reset all signal handler not set to SIG_IGN to SIG_DFL. */ if (clone_flags \u0026amp; CLONE_CLEAR_SIGHAND) flush_signal_handlers(tsk, 0); return 0; } 5）信号结构体，同属一个线程组的线程才会共享信号结构体 函数copy_signal复制或共享信号结构体\n// linux-5.10.102/kernel/fork.c static int copy_signal(unsigned long clone_flags, struct task_struct *tsk) { struct signal_struct *sig; if (clone_flags \u0026amp; CLONE_THREAD) // CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct return 0; // 为新进程分配结构体，初始化，继承当前进程资源限制 sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL); tsk-\u0026gt;signal = sig; if (!sig) return -ENOMEM; sig-\u0026gt;nr_threads = 1; atomic_set(\u0026amp;sig-\u0026gt;live, 1); refcount_set(\u0026amp;sig-\u0026gt;sigcnt, 1); /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */ sig-\u0026gt;thread_head = (struct list_head)LIST_HEAD_INIT(tsk-\u0026gt;thread_node); tsk-\u0026gt;thread_node = (struct list_head)LIST_HEAD_INIT(sig-\u0026gt;thread_head); init_waitqueue_head(\u0026amp;sig-\u0026gt;wait_chldexit); sig-\u0026gt;curr_target = tsk; init_sigpending(\u0026amp;sig-\u0026gt;shared_pending); INIT_HLIST_HEAD(\u0026amp;sig-\u0026gt;multiprocess); seqlock_init(\u0026amp;sig-\u0026gt;stats_lock); prev_cputime_init(\u0026amp;sig-\u0026gt;prev_cputime); #ifdef CONFIG_POSIX_TIMERS INIT_LIST_HEAD(\u0026amp;sig-\u0026gt;posix_timers); hrtimer_init(\u0026amp;sig-\u0026gt;real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); sig-\u0026gt;real_timer.function = it_real_fn; #endif task_lock(current-\u0026gt;group_leader); memcpy(sig-\u0026gt;rlim, current-\u0026gt;signal-\u0026gt;rlim, sizeof sig-\u0026gt;rlim); task_unlock(current-\u0026gt;group_leader); posix_cpu_timers_init_group(sig); tty_audit_fork(sig); sched_autogroup_fork(sig); sig-\u0026gt;oom_score_adj = current-\u0026gt;signal-\u0026gt;oom_score_adj; sig-\u0026gt;oom_score_adj_min = current-\u0026gt;signal-\u0026gt;oom_score_adj_min; mutex_init(\u0026amp;sig-\u0026gt;cred_guard_mutex); init_rwsem(\u0026amp;sig-\u0026gt;exec_update_lock); return 0; } 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存 \\ 函数copy_mm复制或共享虚拟内存\n// linux-5.10.102/kernel/freezer.c static int copy_mm(unsigned long clone_flags, struct task_struct *tsk) { struct mm_struct *mm, *oldmm; int retval; tsk-\u0026gt;min_flt = tsk-\u0026gt;maj_flt = 0; tsk-\u0026gt;nvcsw = tsk-\u0026gt;nivcsw = 0; #ifdef CONFIG_DETECT_HUNG_TASK tsk-\u0026gt;last_switch_count = tsk-\u0026gt;nvcsw + tsk-\u0026gt;nivcsw; tsk-\u0026gt;last_switch_time = 0; #endif tsk-\u0026gt;mm = NULL; tsk-\u0026gt;active_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ oldmm = current-\u0026gt;mm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); if (clone_flags \u0026amp; CLONE_VM) { // CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct mmget(oldmm); mm = oldmm; goto good_mm; } retval = -ENOMEM; // 新进程复制当前进程的虚拟内存 mm = dup_mm(tsk, current-\u0026gt;mm); if (!mm) goto fail_nomem; good_mm: tsk-\u0026gt;mm = mm; tsk-\u0026gt;active_mm = mm; return 0; fail_nomem: return retval; } 7）命名空间 函数copy_namespace创建或共享命名空间\n// linux-5.10.102/kernel/nsproxy.c int copy_namespaces(unsigned long flags, struct task_struct *tsk) { struct nsproxy *old_ns = tsk-\u0026gt;nsproxy; struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns); struct nsproxy *new_ns; int ret; // 如果共享除了用户以外的所有其他命名空间， // 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1 if (likely(!(flags \u0026amp; (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWCGROUP | CLONE_NEWTIME)))) { if (likely(old_ns-\u0026gt;time_ns_for_children == old_ns-\u0026gt;time_ns)) { get_nsproxy(old_ns); return 0; } } else if (!ns_capable(user_ns, CAP_SYS_ADMIN)) // 进程没有系统管理权限，那么不允许创建新的命名空间 return -EPERM; /* CLONE_NEWIPC must detach from the undolist: after switching * to a new ipc namespace, the semaphore arrays from the old * namespace are unreachable. In clone parlance, CLONE_SYSVSEM * means share undolist with parent, so we must forbid using * it along with CLONE_NEWIPC. */ // 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的 if ((flags \u0026amp; (CLONE_NEWIPC | CLONE_SYSVSEM)) == (CLONE_NEWIPC | CLONE_SYSVSEM)) return -EINVAL; // 创建新的命名空间代理，然后创建或者共享命名空间 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-\u0026gt;fs); if (IS_ERR(new_ns)) return PTR_ERR(new_ns); ret = timens_on_fork(new_ns, tsk); if (ret) { free_nsproxy(new_ns); return ret; } tsk-\u0026gt;nsproxy = new_ns; return 0; } 8）I/O上下文 函数copy_io创建或共享I/O上下文\n// linux-5.10.102/kernel/fork.c static int copy_io(unsigned long clone_flags, struct task_struct *tsk) { #ifdef CONFIG_BLOCK struct io_context *ioc = current-\u0026gt;io_context; struct io_context *new_ioc; if (!ioc) return 0; /* Share io context with parent, if CLONE_IO is set */ if (clone_flags \u0026amp; CLONE_IO) { // CLONE_IO 共享I/O上小文 ioc_task_link(ioc); // 计数nr_tasks加1 tsk-\u0026gt;io_context = ioc; // 共享I/O上下文结构体io_context } else if (ioprio_valid(ioc-\u0026gt;ioprio)) { // 创建新的I/O上下文，初始化，继承当前进程的I/O优先级 new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE); if (unlikely(!new_ioc)) return -ENOMEM; new_ioc-\u0026gt;ioprio = ioc-\u0026gt;ioprio; put_io_context(new_ioc); } #endif return 0; } 9）复制寄存器值 函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct\nARM64架构copy_thread_tls-\u0026gt;copy_thread\n// linux-5.10.102/arch/arm64/kernel/process.c int copy_thread(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz, struct task_struct *p, unsigned long tls) { struct pt_regs *childregs = task_pt_regs(p); // 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值 memset(\u0026amp;p-\u0026gt;thread.cpu_context, 0, sizeof(struct cpu_context)); /* In case p was allocated the same task_struct pointer as some * other recently-exited task, make sure p is disassociated from * any cpu that may have run that now-exited task recently. * Otherwise we could erroneously skip reloading the FPSIMD * registers for p. */ fpsimd_flush_task_state(p); ptrauth_thread_init_kernel(p); if (likely(!(p-\u0026gt;flags \u0026amp; PF_KTHREAD))) { // 用户进程 *childregs = *current_pt_regs(); childregs-\u0026gt;regs[0] = 0; /* Read the current TLS pointer from tpidr_el0 as it may be * out-of-sync with the saved value. * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址， * 因为它可能和保存的值不一致 */ *task_user_tls(p) = read_sysreg(tpidr_el0); if (stack_start) { if (is_compat_thread(task_thread_info(p))) childregs-\u0026gt;compat_sp = stack_start; else childregs-\u0026gt;sp = stack_start; } /* If a TLS pointer was passed to clone, use it for the new thread. * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/ if (clone_flags \u0026amp; CLONE_SETTLS) p-\u0026gt;thread.uw.tp_value = tls; } else { // 内核线程 memset(childregs, 0, sizeof(struct pt_regs)); childregs-\u0026gt;pstate = PSR_MODE_EL1h; if (IS_ENABLED(CONFIG_ARM64_UAO) \u0026amp;\u0026amp; cpus_have_const_cap(ARM64_HAS_UAO)) childregs-\u0026gt;pstate |= PSR_UAO_BIT; spectre_v4_enable_task_mitigation(p); if (system_uses_irq_prio_masking()) childregs-\u0026gt;pmr_save = GIC_PRIO_IRQON; p-\u0026gt;thread.cpu_context.x19 = stack_start; p-\u0026gt;thread.cpu_context.x20 = stk_sz; } p-\u0026gt;thread.cpu_context.pc = (unsigned long)ret_from_fork; p-\u0026gt;thread.cpu_context.sp = (unsigned long)childregs; ptrace_hw_copy_thread(p); return 0; } （7）设置进程号和进程关系 static __latent_entropy struct task_struct *copy_process( struct pid *pid, int trace, int node, struct kernel_clone_args *args) { // 为新进程分配进程号 // pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号 if (pid != \u0026amp;init_struct_pid) { pid = alloc_pid(p-\u0026gt;nsproxy-\u0026gt;pid_ns_for_children); if (IS_ERR(pid)) { retval = PTR_ERR(pid); goto bad_fork_cleanup_thread; } } … // 设置新进程退出时发送给父进程的信号 p-\u0026gt;pid = pid_nr(pid); if (clone_flags \u0026amp; CLONE_THREAD) { p-\u0026gt;exit_signal = -1; // 新线程退出时不需要发送信号给父进程 p-\u0026gt;group_leader = current-\u0026gt;group_leader; // group_leader指向同一个组长 p-\u0026gt;tgid = current-\u0026gt;tgid; // tgid存放组长的进程号 } else { if (clone_flags \u0026amp; CLONE_PARENT) // CLONE_PARENT 新进程和当前进程是兄弟关系 p-\u0026gt;exit_signal = current-\u0026gt;group_leader-\u0026gt;exit_signal; // 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal else // 父子关系 p-\u0026gt;exit_signal = (clone_flags \u0026amp; CSIGNAL); // 新进程的成员exit_signal是调用者指定的信号 p-\u0026gt;group_leader = p; p-\u0026gt;tgid = p-\u0026gt;pid; } // 控制组的进程数控制器检查是否允许创建新进程： // 从当前进程所属的控制组一直到控制组层级的根， // 如果其中一个控制组的进程数量大于或等于限制， // 那么不允许使用fork和clone创建新进程 cgroup_threadgroup_change_begin(current); retval = cgroup_can_fork(p); if (retval) goto bad_fork_free_pid; write_lock_irq(\u0026amp;tasklist_lock); // 为新进程设置父进程 if (clone_flags \u0026amp; (CLONE_PARENT|CLONE_THREAD)) { // 新进程和当前进程拥有相同的父进程 p-\u0026gt;real_parent = current-\u0026gt;real_parent; p-\u0026gt;parent_exec_id = current-\u0026gt;parent_exec_id; } else { p-\u0026gt;real_parent = current; // 新进程的父进程是当前进程 p-\u0026gt;parent_exec_id = current-\u0026gt;self_exec_id; } … spin_lock(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); … if (likely(p-\u0026gt;pid)) { … init_task_pid(p, PIDTYPE_PID, pid); if (thread_group_leader(p)) { // true 新进程和当前进程属于同一个进程组 init_task_pid(p, PIDTYPE_PGID, task_pgrp(current)); // 指向同一个进程组的组长的进程号结构体 init_task_pid(p, PIDTYPE_SID, task_session(current)); // 指向同一个会话的控制进程的进程号结构体 if (is_child_reaper(pid)) { ns_of_pid(pid)-\u0026gt;child_reaper = p; p-\u0026gt;signal-\u0026gt;flags |= SIGNAL_UNKILLABLE; // 1号进程是不能杀死的 } p-\u0026gt;signal-\u0026gt;leader_pid = pid; p-\u0026gt;signal-\u0026gt;tty = tty_kref_get(current-\u0026gt;signal-\u0026gt;tty); p-\u0026gt;signal-\u0026gt;has_child_subreaper = p-\u0026gt;real_parent-\u0026gt;signal-\u0026gt; has_child_subreaper || p-\u0026gt;real_parent-\u0026gt;signal-\u0026gt;is_child_subreaper; list_add_tail(\u0026amp;p-\u0026gt;sibling, \u0026amp;p-\u0026gt;real_parent-\u0026gt;children); // 新进程添加到父进程的子进程链表 // 新进程添加到进程链表中，链表节点是成员tasks， // 头节点是空闲线程的成员tasks（init_task.tasks） list_add_tail_rcu(\u0026amp;p-\u0026gt;tasks, \u0026amp;init_task.tasks); attach_pid(p, PIDTYPE_PGID); // 新进程添加到进程组的进程链表 attach_pid(p, PIDTYPE_SID); // 新进程添加到会话的进程链表 __this_cpu_inc(process_counts); } else { // 创建线程 current-\u0026gt;signal-\u0026gt;nr_threads++; // 线程组的线程计数值加1 atomic_inc(\u0026amp;current-\u0026gt;signal-\u0026gt;live); // 原子变量线程组的第2个线程计数值加1 atomic_inc(\u0026amp;current-\u0026gt;signal-\u0026gt;sigcnt); // 信号结构体的引用计数加1 list_add_tail_rcu(\u0026amp;p-\u0026gt;thread_group, \u0026amp;p-\u0026gt;group_leader-\u0026gt;thread_group); // 线程加入线程组的线程链表 list_add_tail_rcu(\u0026amp;p-\u0026gt;thread_node, \u0026amp;p-\u0026gt;signal-\u0026gt;thread_head); // 线程加入线程组的第二条线程链表 } attach_pid(p, PIDTYPE_PID); // 新进程添加到进程号结构体的进程链表 nr_threads++; // 新进程添加到进程号结构体的进程链表 } total_forks++; spin_unlock(\u0026amp;current-\u0026gt;sighand-\u0026gt;siglock); … write_unlock_irq(\u0026amp;tasklist_lock); proc_fork_connector(p); cgroup_post_fork(p); cgroup_threadgroup_change_end(current); … return p; } 3.唤醒新进程 wake_up_new_task函数唤醒新进程\n// linux-5.10.102/kernel/sched/core.c void wake_up_new_task(struct task_struct *p) { struct rq_flags rf; struct rq *rq; raw_spin_lock_irqsave(\u0026amp;p-\u0026gt;pi_lock, rf.flags); p-\u0026gt;state = TASK_RUNNING; // 切换TASK_RUNNING #ifdef CONFIG_SMP /* Fork balancing, do it here and not earlier because: * - cpus_ptr can change in the fork path * - any previously selected CPU might disappear through hotplug * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq, * as we\u0026#39;re not fully set-up yet.*/ p-\u0026gt;recent_used_cpu = task_cpu(p); rseq_migrate(p); __set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); // 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器 #endif rq = __task_rq_lock(p, \u0026amp;rf); // 锁住运行队列 update_rq_clock(rq); // 更新运行队列的时钟 post_init_entity_util_avg(p); // 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值 activate_task(rq, p, ENQUEUE_NOCLOCK); // 把新进程插入运行队列 trace_sched_wakeup_new(p); check_preempt_curr(rq, p, WF_FORK); // 检查新进程是否可以抢占当前进程 #ifdef CONFIG_SMP if (p-\u0026gt;sched_class-\u0026gt;task_woken) { // 在SMP系统上，调用调度类的task_woken方法 /* Nothing relies on rq-\u0026gt;lock after this, so its fine to * drop it.*/ rq_unpin_lock(rq, \u0026amp;rf); p-\u0026gt;sched_class-\u0026gt;task_woken(rq, p); rq_repin_lock(rq, \u0026amp;rf); } #endif task_rq_unlock(rq, p, \u0026amp;rf); // 释放运行队列的锁 } 4.新进程第一次运行 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数\n// linux-5.10.102/arch/arm64/kernel/entry.S tsk .req x28 //当前进程的thread_info结构体的地址 SYM_CODE_START(ret_from_fork) bl\tschedule_tail // 为上一个进程执行清理操作 cbz\tx19, 1f // not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1 mov\tx0, x20 // 内核线程：x19存放线程函数的地址，x20存放线程函数的参数 blr\tx19 // 调用线程函数 1:\tget_current_task tsk // 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址 b\tret_to_user // 返回用户模式 SYM_CODE_END(ret_from_fork) NOKPROBE(ret_from_fork) copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0 // linux-5.10.102/kernel/sched/core.c asmlinkage __visible void schedule_tail(struct task_struct *prev) __releases(rq-\u0026gt;lock) { struct rq *rq; /* New tasks start with FORK_PREEMPT_COUNT, see there and * finish_task_switch() for details. * * finish_task_switch() will drop rq-\u0026gt;lock() and lower preempt_count * and the preempt_enable() will end up enabling preemption (on * PREEMPT_COUNT kernels).*/ rq = finish_task_switch(prev); // 为上一个进程执行清理操作2.8.6 balance_callback(rq); // 执行运行队列的所有负载均衡回调函数 preempt_enable(); // 开启内核抢占 if (current-\u0026gt;set_child_tid) // pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置 put_user(task_pid_vnr(current), current-\u0026gt;set_child_tid); calculate_sigpending(); } 2.5.2 装载程序 调度器调度新进程，新进程从函数ret_from_fork开始，从系统调用fork返回用户空间，返回值0。然后新进程使用系统调用execve装载程序。Linux内核练个装载程序系统调用： \\\n// 路径名是相对时execve解释为相对调用进程的当前工作目录 int execve(const char *filename, char *const argv[], char *const envp[]); // 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录 // 路径名时绝对的，execveat忽略参数dirfd int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); 参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值\n两个系统调用最终都调用函数do_execveat_common 函数do_open_execat打开可执行文件。 函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器 函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-\u0026gt;p指向在栈底保留一个字长（指针长度）后的位置 函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？ \\ 依次把文件名称、环境字符串和参数字符串压到用户栈 函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止\n1.二进制格式 Linux二进制格式\n// linux-5.10.102/include/linux/binfmts.h struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump;\t/* minimal dump size */ } __randomize_layout; 二进制格式提供3个函数 (1)load_binary 加载普通程序 (2)load_shlib 加载共享库 (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度 二进制格式使用register_binfmt向内核注册\n2.装载ELF程序 ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 linux-5.10.102/include/uapi/linux/elf.h\n目标文件(可重定位文件)，.o，多个模板文件链接生成可执行文件或共享库 可执行文件 共享库 .so 核心转储文件(core dump file) ELF文件分成4部分：ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)，ELF只有首部的位置是固定的。\n程序首部表就是段表(segment table)，段(segment)是从运行角度描述，节(section)是从链接角度描述。 64位ELF文件格式\n参考链接： ELF 格式详解 https://blog.csdn.net/shanandqiu/article/details/115206426 ELF文件格式简介 https://blog.csdn.net/GrayOnDream/article/details/124564129\n# 查看ELF首部 readelf -h \u0026lt;ELF文件\u0026gt; # 查看程序首部表 readelf -l \u0026lt;ELF文件\u0026gt; # 查看节首部表 readelf -S \u0026lt;ELF文件\u0026gt; ELF解析程序 linux-5.10.102/fs/binfmt_elf.c 解析64位ELF程序，和处理器架构无关 linux-5.10.102/fs/compat_binfmt_elf.c 在64位内核中解析32位ELF程序，和处理器架构无 \\\n装载ELF程序函数load_elf_binary\n1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构 2）读取程序首部表 3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。 4）检查解释器的ELF首部，读取解释器的程序首部表 5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间 6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域 7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈 8）把可加载段映射到进程的虚拟地址空间 9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段 10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口 11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈 12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread // linux-5.10.102/arch/arm64/include/asm/processor.h static inline void start_thread_common(struct pt_regs *regs, unsigned long pc) { memset(regs, 0, sizeof(*regs)); forget_syscall(regs); regs-\u0026gt;pc = pc; /* 把程序计数器设置为程序的入口 */ } static inline void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp) { start_thread_common(regs, pc); regs-\u0026gt;pstate = PSR_MODE_EL0t; /* 把处理器状态设置为0，其中异常级别是0 */ spectre_v4_enable_task_mitigation(current); regs-\u0026gt;sp = sp; /*设置用户栈指针 */ } 3.装载脚本程序 脚本程序前两个字节是#!，后面是解释器程序的名称和参数。解释器用来执行脚本程序 linux-5.10.102/fs/binfmt_script.c函数load_script负责装载脚本程序\n1）检查前两个字节是不是脚本程序的标识符 2）解析处解释程序的名称和参数 3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈 4）调用opens_exec打开解释程序文件 5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区 6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止 \\\n2.6 进程退出 进程退出两种情况：进程主动退出和终止进程 Linux内核两个主动退出的系统调用 \\\n// 线程退出 void exit(int status); // 一个线程组所有线程退出 void exit_group(int status); glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数 终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用\n// // 发送信号给进程或进程组 int kill(pid_t pid, int sig); // 发送信号给线程 已废弃 int tkill(int tid, int sig); // 发送信号给线程 int tgkill(int tgid, int tid, int sig); 父进程是否关注子进程退出事假， 1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。进程默认关注子进程退出事件，通过系统调用sigaction对信号SIGHLD设置标志SA_NOCLDWAIT(CLD是child)，子进程退出时不变成僵尸进程或设置忽略信号SIGCHLD 2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 Linux内核3个系统调用等待子进程状态改变：子进程终止、信号SIGSTOP使子进程停止执行或信号SIGCONT使子进程继续执行\npid_t waitpid(pid_t pid, int *wstatus, int options); int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); pit_t wiat4(pit_t pid, int *wstatus, int options, staruct usage *rusage); // 废弃 父进程退出时，给子进程寻找领养者 1）进程属于一个线程组，且还有其他线程，选择任意其他线程 2）选择最亲近的充当\u0026quot;替补领养者\u0026quot;的祖先进程，进程使用系统调用prtctl(PR_SET_CHILD_SUBREAPER)设置为替换领养者 3）选择所属进程号命名空间的1号进程 2.6.1 线程组退出 exit_group 系统调用exit_group执行流程\n一个线程组的两个线程，线程1和线程2，线程1调用exit_group使线程组退出，线程1执行流程： 1）把退出码保存在结构体成员group_exit_code中，传递给线程2 2）给线程组设置正在退出标志 3）向线程2发送杀死信号，唤醒线程2，线程2处理杀死信号 4）线程1调用函数do_exit以退出 线程2退出的执行流程，函数do_group_exit执行流程\n线程2可能发挥用户模式3种情况 （1）执行完系统调用 （2）被中断抢占，中断处理程序执行完 （3）执行指令是生成异常，异常处理程序执行完 \\\ndo_exit函数执行流程 （1）释放各种资源，把资源引用计数减一，如果引用计数变为0，则释放数据结构 （2）调用函数exit_notify，为子进程选择领养者，然后把自己死讯通知父进程 （3）把进程状态设置为死亡(TASK_DEAD) （4）最后一次调用函数__schedule以调度进程 死亡进程调用__schedule时进程调度器处理流程\n// linux-5.10.102/kernel/sched/core.c __schedule() --\u0026gt; context_switch() --\u0026gt; finish_task_switch() static struct rq *finish_task_switch(struct task_struct *prev) __releases(rq-\u0026gt;lock) { … prev_state = prev-\u0026gt;state; … if (unlikely(prev_state == TASK_DEAD)) { if (prev-\u0026gt;sched_class-\u0026gt;task_dead) prev-\u0026gt;sched_class-\u0026gt;task_dead(prev); // 执行调度类task_dead … // 如果结构体thread_info放在进程描述符里面， // 而不是放在内核栈的顶部，那么释放进程的内核栈 put_task_stack(prev); // 进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符 put_task_struct(prev); } … } 2.6.2 终止进程 系统调用kill向线程组或进程组发送信号linux-5.10.102/kernel/signal.c，执行流程 函数__send_signal主要代码\n// linux-5.10.102/kernel/signal.c static int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns) { struct sigpending *pending; struct sigqueue *q; int override_rlimit; int ret = 0, result; … result = TRACE_SIGNAL_IGNORED; // 目标线程忽略信号,不发送信号 if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED))) goto ret; // 确定把信号添加到哪个信号队列和集合 pending = group ? \u0026amp;t-\u0026gt;signal-\u0026gt;shared_pending : \u0026amp;t-\u0026gt;pending; result = TRACE_SIGNAL_ALREADY_PENDING; // 传统信号，并且信号集合已经包含同一个信号,不发送 if (legacy_queue(pending, sig)) goto ret; … // 判断分配信号队列节点时是否可以忽略信号队列长度的限制 if (sig \u0026lt; SIGRTMIN) override_rlimit = (is_si_special(info) || info-\u0026gt;si_code \u0026gt;= 0); else override_rlimit = 0; // 分配一个信号队列节点 q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit); if (q) { list_add_tail(\u0026amp;q-\u0026gt;list, \u0026amp;pending-\u0026gt;list); // 添加到信号队列中 … } else if (!is_si_special(info)) { … } out_set: signalfd_notify(t, sig); sigaddset(\u0026amp;pending-\u0026gt;signal, sig); // 信号添加到信号集合中 // 在线程组中查找一个没有屏蔽信号的线程，唤醒它，让它处理信号 complete_signal(sig, t, group); ret: … return ret; } 2.6.3 查询子进程终止原因 系统调用waitid\nint waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); pid_t waitpid(pid_t pid, int *wstatus, int options); 参数 参数值 含义 idtype P_ALL 等待任意子进程，忽略参数id P_PID 等待进程号为id的子进程 P_PGID 等待进程组标识符是id的任意子进程 options WEXITED 等待退出的子进程 WSTOPPED 等待收到信号SIGSTOP并停止执行的子进程 WCONTINUED 等待收到信号SIGCONT并继续执行的子进程 WNOHANG 如果没有子进程退出，立即返回 WNOWAIT 让子进程处于僵尸状态，以后可以再次查询状态信息 do_wait函数执行流程\n2.7 进程状态 状态 state 含义 就绪状态 TASK_RUNNING 正在运行队列中等待调度器调度 运行状态 TASK_RUNNING 被调度器选中，正在处理器上运行 轻度睡眠 TASK_INTERRUPTIBLE 可信号打断的睡眠状态 中度睡眠 TASK_KILLABLE 只能被致命的信号打断 深度睡眠 TASK_UNINTERRUPTIBLE 不可打断的睡眠状态 僵尸状态 TASK_DEAD 被调度器选中，正在处理器上运行 死亡状态 TASK_DEAD 如果父进程不关注子进程退出事件，那么子进程退出时自动消亡 进程状态变迁 2.8 进程调度 2.8.1 调度策略 Linux内核支持的调度策略 （1）限制进程使用限期调度策略(SCHED_DEADLINE)，3个参数：运行时间runtime，截止期限deadline和周期period （2）实时进程支持两种调度策略：先进先出调度(SCHED_FIFO)和轮流调度(SCHED_RR) （3）普通进程两种调度策略：标准轮流分时(SCHED_NORMAL)和空闲(SCHED_BATCH)，Linux内核引入完全公平调度算法后，批量调度策略废弃。 \\\n2.8.2 进程优先级 限期进程的优先级比实时进程高，实时进程的优先级比普通进程高。 限期进程的优先级是−1。 实时进程的实时优先级是1～99，优先级数值越大，表示优先级越高。 普通进程的静态优先级是100～139，优先级数值越小，表示优先级越高，可通过修改nice值（即相对优先级，取值范围是−20～19）改变普通进程的优先级，优先级等于120加上nice值 task_struct中，4个成员和优先级有关 \\\ninclude/linux/sched.h struct task_struct { … int prio; int static_prio; int normal_prio; unsigned int rt_priority; … }; 优先级 限期进程 实时进程 普通进程 prio\n调度优先级(数值越小，表示优先级越高) 大多数prio等于normal_prio static_prio\n静态优先级 总是0 总是0 120 + nice值数值越小，\n表示优先级越高 normal_prio\n正常优先级(数值越小，表示优先级越高) -1 99 − rt_priority static_prio 实时优先级 总是0 值越大，优先级越高 2.8.3 调度类 Linux内核抽象一个调度类sched_class，目前实现5种调度类，优先级从上到下从高到低：\n调度类 调度策略 调度算法 调度对象 停机调度类\nstop_sched_class 无 无 停机进程 限期调度类\ndl_sched_class SCHED_DEADLINE 最早期限优先 限期进程 实时调度类\nrt_sched_class SCHED_FIFO\nSCHED_RR 先进先出\n轮流调度 实时进程 公平调度类\ncfs_sched_class SCHED_NORMAL\nSCHED_IDIE 完全公平调度算法 普通进程 空闲调度类\nidle_sched_class 无 无 每个处理器上的空闲线程 详细信息参考书籍\n2.8.4 运行队列 每个处理器有一个运行队列，结构体rq，定义全局变量\n// linux-5.10.102/kernel/sched/cpuacct.c DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); // linux-5.10.102/kernel/sched/sched.h struct rq { // 运行队列 ... struct cfs_rq\tcfs; // 公平运行队列 struct rt_rq\trt; // 实时运行队列 struct dl_rq\tdl; // 限期运行队列 ... struct task_struct\t*idle; // 空闲线程 struct task_struct\t*stop; // 迁移线程 }; 2.8.5 任务分组 1.任务分组方式 任务分组方式 控制宏 配置方式 自动组 CONFIG_SCHED_AUTOGROUP /proc/sys/kernel/sched_autogroup_enabled 运行过程中开启关闭，默认值1\n源文件kernel/sched/auto_group.c CPU控制组版本1 CONFIG_CGROUPS\nCONFIG_CGROUP_SCHED mount -t tmpfs cgroup_root /sys/fs/cgroup\nmkdir /sys/fs/cgroup/cpu\nmount -t cgroup -o cpu none /sys/fs/cgroup/cpu\ncd /sys/fs/cgroup/cpu\nmkdir multimedia # 创建\"multimedia\"任务组\nmkdir browser # 创建\"browser\"任务组\necho 2048 \u003e multimedia/cpu.shares\necho 1024 \u003e browser/cpu.shares\necho \u003c pid1\u003e \u003e browser/tasks echo \u003c pid2\u003e \u003e multimedia/tasks\necho \u003c pid1\u003e \u003e browser/cgroup.procs\necho \u003c pid2\u003e \u003e multimedia/cgroup.procs cgroup版本2 mount -t tmpfs cgroup_root /sys/fs/cgroup\nmount -t cgroup2 none /sys/fs/cgroup\ncd /sys/fs/cgroup echo \"+cpu\" \u003e cgroup.subtree_control\nmkdir multimedia # 创建\"multimedia\"任务组 mkdir browser # 创建\"browser\"任务组\necho 2048 \u003e multimedia/cpu.weight\necho 1024 \u003e browser/cpu.weight\necho \u003c pid1\u003e \u003e browser/cgroup.procs\necho \u003c pid2\u003e \u003e multimedia/cgroup.procs echo threaded \u003e browser/cgroup.type echo \u003c pid1\u003e \u003e browser/cgroup.threads echo threaded \u003e multimedia/cgroup.type echo \u003c pid2\u003e \u003e multimedia/cgroup.threads 2. 数据结构 task_group,默认任务组是更任务组(全局变量root_task_group)\n成员 说明 const struct sched_class *sched_class 调度类 struct sched_entity se 公平调度实体 struct sched_dl_entity dl 限期调度实体 任务组在每个处理器上有公平调度实体、公平运行队列、实时调度实体和实时运行队列，根任务组比较特殊：没有公平调度实体和实时调度实体\n每个处理器上，计算任务组的公平调度实体的权重的方法如下（参考源文件“kernel/ sched/fair.c”中的函数update_cfs_shares\n2.8.6 调度进程 调度进程的核心函数是__schedule()\nkernel/sched/core.c // preempt是否抢占，true抢占调度，false主动调度 static void __sched notrace __schedule(bool preempt) { 1. 调用pick_next_task选择下一个进程 2. 调用context_switch切换进程 } 1.选择下一个进程 函数pick_next_task // linux-5.10.102/kernel/sched/core.c static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) { const struct sched_class *class; struct task_struct *p; /* Optimization: we know that if all tasks are in the fair class we can * call that function directly, but only if the @prev task wasn\u0026#39;t of a * higher scheduling class, because otherwise those loose the * opportunity to pull in more work from other CPUs.*/ // 优化：如果所有进程属于公平调度类 // 直接调用公平调度类的pick_next_task方法 if (likely(prev-\u0026gt;sched_class \u0026lt;= \u0026amp;fair_sched_class \u0026amp;\u0026amp; rq-\u0026gt;nr_running == rq-\u0026gt;cfs.h_nr_running)) { p = pick_next_task_fair(rq, prev, rf); if (unlikely(p == RETRY_TASK)) goto restart; /* Assumes fair_sched_class-\u0026gt;next == idle_sched_class */ // 假定公平调度类的下一个调度类是空闲调度类 if (!p) { put_prev_task(rq, prev); p = pick_next_task_idle(rq); } return p; } restart: put_prev_task_balance(rq, prev, rf); for_each_class(class) { p = class-\u0026gt;pick_next_task(rq); if (p) return p; } /* The idle class should always have a runnable task: */ // 空闲调度类应该总是有一个运行的进程 BUG(); } 待补充\n2.切换进程 context_switch 1）switch_mm_irqs_off负责切换进程的用户虚拟地址空间 2）switch_to切换处理器的寄存器\n// linux-5.10.102/kernel/sched/core.c static __always_inline struct rq * context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next, struct rq_flags *rf) { prepare_task_switch(rq, prev, next); // 准备工作，调用prepare_arch_switch /* For paravirt, this is coupled with an exit in switch_to to * combine the page table reload and the switch backend into * one hypercall. */ // 开始上下文切换 arch_start_context_switch(prev); /* * kernel -\u0026gt; kernel lazy + transfer active * user -\u0026gt; kernel lazy + mmgrab() active * * kernel -\u0026gt; user switch + mmdrop() active * user -\u0026gt; user switch */ if (!next-\u0026gt;mm) { // to kernel // 通知处理器架构不需要切换用户虚拟地址空间，加速进程切换的技术称为惰性TLB enter_lazy_tlb(prev-\u0026gt;active_mm, next); next-\u0026gt;active_mm = prev-\u0026gt;active_mm; if (prev-\u0026gt;mm) // from user 切换进程的用户虚拟地址空间 mmgrab(prev-\u0026gt;active_mm); else prev-\u0026gt;active_mm = NULL; } else { // to user membarrier_switch_mm(rq, prev-\u0026gt;active_mm, next-\u0026gt;mm); /* * sys_membarrier() requires an smp_mb() between setting * rq-\u0026gt;curr / membarrier_switch_mm() and returning to userspace. * * The below provides this either through switch_mm(), or in * case \u0026#39;prev-\u0026gt;active_mm == next-\u0026gt;mm\u0026#39; through * finish_task_switch()\u0026#39;s mmdrop(). */ switch_mm_irqs_off(prev-\u0026gt;active_mm, next-\u0026gt;mm, next); if (!prev-\u0026gt;mm) { // from kernel /* will mmdrop() in finish_task_switch(). */ rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm; prev-\u0026gt;active_mm = NULL; } } rq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); prepare_lock_switch(rq, next, rf); /* Here we just switch the register state and the stack. */ // 只切换寄存器状态和栈 switch_to(prev, next, prev); barrier(); return finish_task_switch(prev); } （1）切换用户虚拟地址空间。\n// ARM64架构使用switch_mm_irqs_off include/linux/mmu_context.h #ifndef switch_mm_irqs_off #define switch_mm_irqs_off switch_mm #endif switch_mm函数\n// linux-5.10.102/arch/arm64/include/asm/mmu_context.h static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { if (prev != next) __switch_mm(next); /* Update the saved TTBR0_EL1 of the scheduled-in task as the previous * value may have not been initialised yet (activate_mm caller) or the * ASID has changed since the last run (following the context switch * of another thread of the same process).*/ /* 更新调入进程保存的寄存器TTBR0_EL1值， * 因为可能还没有初始化（调用者是函数activate_mm）， * 或者ASID自从上次运行以来已经改变（在同一个线程组的另一个线程切换上下文以后） * 避免把保留的寄存器TTBR0_EL1值设置为swapper_pg_dir（init_mm；例如通过函数idle_task_exit）*/ update_saved_ttbr0(tsk, next); } static inline void __switch_mm(struct mm_struct *next) { /*init_mm.pgd does not contain any user mappings and it is always * active for kernel addresses in TTBR1. Just set the reserved TTBR0.*/ /*init_mm.pgd没有包含任何用户虚拟地址的映射，对于TTBR1的内核虚拟地址总是有效的。 * 只设置保留的TTBR0 */ if (next == \u0026amp;init_mm) { cpu_set_reserved_ttbr0(); return; } // 为进程分配地址空间标识符 check_and_switch_context(next); } 待补充\n（2）切换寄存器\n// linux-5.10.102/include/asm-generic/switch_to.h #define switch_to(prev, next, last)\t\\ do {\t\\ ((last) = __switch_to((prev), (next)));\t\\ } while (0) 函数__switch_to\n__notrace_funcgraph struct task_struct *__switch_to(struct task_struct *prev, struct task_struct *next) { struct task_struct *last; fpsimd_thread_switch(next); // 切换浮点寄存器 tls_thread_switch(next); // 切换本地存储相关的寄存器 hw_breakpoint_thread_switch(next); // 切换吊事寄存器 contextidr_thread_switch(next); // 把上下文标识符寄存器CONTEXTIDR_EL1设置为下一个进程号 entry_task_switch(next); // 使用处理器变量__entry_task记录下一个进程描述符的地址 uao_thread_switch(next); // 根据下一个进程可访问的虚拟地址空间上限恢复用户访问覆盖（User Access Override，UAO）状态 ssbs_thread_switch(next); // erratum_1418040_thread_switch(next); /* Complete any pending TLB or cache maintenance on this CPU in case * the thread migrates to a different CPU. * This full barrier is also required by the membarrier system * call.*/ // 在这个处理器上执行完前面的所有页表缓存或者缓存维护操作 // 以防线程迁移到其他处理器 // 数据同步屏障，确保屏障前面的缓存维护操作和页表缓存维护操作执行完 dsb(ish); /* MTE thread switching must happen after the DSB above to ensure that * any asynchronous tag check faults have been logged in the TFSR*_EL1 * registers.*/ mte_thread_switch(next); /* the actual thread switch */ // 实际线程切换 切换通用寄存器 last = cpu_switch_to(prev, next); return last; } 1）切换浮点寄存器，函数fpsimd_thread_switch负责切换浮点，内核不允许使用浮点数，只有用户空间可以使用浮点数,切换出去的进程把浮点寄存器的值保存在进程描述符的成员thread.fpsimd_state中。ARM64架构实现的linux-5.10.102/arch/arm64/kernel/fpsimd.c函数fpsimd_thread_switch \\ 2）切换通用寄存器，\n被调用函数负责保存的寄存器x19～x28 寄存器x29，即帧指针（Frame Pointer，FP）寄存器 栈指针（Stack Pointer，SP）寄存器 寄存器x30，即链接寄存器（Link Register，LR），它存放函数的返回地址 用户栈指针寄存器SP_EL0，内核使用它存放当前进程的进程描述符的第一个成员thread_info的地址 cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址\n// linux-5.10.102/arch/arm64/kernel/entry.S SYM_FUNC_START(cpu_switch_to) mov\tx10, #THREAD_CPU_CONTEXT // cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址 add\tx8, x0, x10 // x8存放上一个进程的进程描述符的成员thread.cpu_context的地址 mov\tx9, sp // x9保存栈指针 stp\tx19, x20, [x8], #16\t// store callee-saved registers stp\tx21, x22, [x8], #16 // 把上一个进程的寄存器x19～x28、x29、SP和LR stp\tx23, x24, [x8], #16 // 保存到上一个进程的进程描述符的成员thread.cpu_context中 stp\tx25, x26, [x8], #16 // stp\tx27, x28, [x8], #16 stp\tx29, x9, [x8], #16 str\tlr, [x8] // LR存放函数的返回地址 add\tx8, x1, x10 // x8存放下一个进程的进程描述符的成员thread.cpu_context的地址 ldp\tx19, x20, [x8], #16\t// restore callee-saved registers ldp\tx21, x22, [x8], #16 // 使用下一个进程的进程描述符的成员thread.cpu_context ldp\tx23, x24, [x8], #16 // 保存的值恢复下一个进程的寄存器x19～x28、x29、SP和LR ldp\tx25, x26, [x8], #16 ldp\tx27, x28, [x8], #16 ldp\tx29, x9, [x8], #16 ldr\tlr, [x8] mov\tsp, x9 msr\tsp_el0, x1 // 用户栈指针寄存器SP_EL0设置为下一个进程的进程描述符的第一个成员thread_info的地址 ptrauth_keys_install_kernel x1, x8, x9, x10 scs_save x0, x8 // 函数返回，返回值是寄存器x0的值：上一个进程的进程描述符的地址 scs_load x1, x8 ret SYM_FUNC_END(cpu_switch_to) NOKPROBE(cpu_switch_to) cpu_switch_to切换通用寄存器的过程，从进程prev切换到进程next。进程prev把通用寄存器的值保存在进程描述符的成员thread.cpu_context中，然后进程next从进程描述符的成员thread.cpu_context恢复通用寄存器的值，使用用户栈指针寄存器SP_EL0存放进程next的进程描述符的成员thread_info的地址 \\\nARM64架构切换通用寄存器 链接寄存器存放函数的返回地址，函数cpu_switch_to把链接寄存器设置为进程描述符的成员thread.cpu_context.pc，进程被调度后从返回地址开始执行 进程的返回地址分为以下两种情况:\n创建的新进程，函数copy_thread把进程描述符的成员thread.cpu_context.pc设置为函数ret_from_fork的地址 其他情况，返回地址是函数context_switch中调用函数cpu_switch_to之后的一行代码：“last = 函数cpu_switch_to的返回值”，返回地址记录在进程描述符的成员thread.cpu_context.pc中 （3）清理工作 函数finish_task_switch在从进程prev切换到进程next后为进程prev执行清理工作\n// kernel/sched/core.c static struct rq *finish_task_switch(struct task_struct *prev) __releases(rq-\u0026gt;lock) { struct rq *rq = this_rq(); // rq是当前处理器的运行队列 struct mm_struct *mm = rq-\u0026gt;prev_mm; long prev_state; /* The previous task will have left us with a preempt_count of 2 * because it left us after: *\tschedule() *\tpreempt_disable();\t// 1 *\t__schedule() *\traw_spin_lock_irq(\u0026amp;rq-\u0026gt;lock)\t// 2 * Also, see FORK_PREEMPT_COUNT.*/ if (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET, \u0026#34;corrupted preempt_count: %s/%d/0x%x\\n\u0026#34;, current-\u0026gt;comm, current-\u0026gt;pid, preempt_count())) preempt_count_set(FORK_PREEMPT_COUNT); rq-\u0026gt;prev_mm = NULL; /* A task struct has one reference for the use as \u0026#34;current\u0026#34;. * If a task dies, then it sets TASK_DEAD in tsk-\u0026gt;state and calls * schedule one last time. The schedule call will never return, and * the scheduled task must drop that reference. * * We must observe prev-\u0026gt;state before clearing prev-\u0026gt;on_cpu (in * finish_task), otherwise a concurrent wakeup can get prev * running on another CPU and we could rave with its RUNNING -\u0026gt; DEAD * transition, resulting in a double drop.*/ prev_state = prev-\u0026gt;state; vtime_task_switch(prev); // 计算进程prev的时间统计 perf_event_task_sched_in(prev, current); finish_task(prev); // 把prev-\u0026gt;on_cpu设置为0，表示进程prev没有在处理器上运行；然后释放运行队列的锁，开启硬中断 finish_lock_switch(rq); finish_arch_post_lock_switch(); // 执行处理器架构特定的清理工作,ARM64为空 kcov_finish_switch(current); fire_sched_in_preempt_notifiers(current); /* When switching through a kernel thread, the loop in * membarrier_{private,global}_expedited() may have observed that * kernel thread and not issued an IPI. It is therefore possible to * schedule between user-\u0026gt;kernel-\u0026gt;user threads without passing though * switch_mm(). Membarrier requires a barrier after storing to * rq-\u0026gt;curr, before returning to userspace, so provide them here: * * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly * provided by mmdrop(), * - a sync_core for SYNC_CORE.*/ if (mm) { membarrier_mm_sync_core_before_usermode(mm); mmdrop(mm); } if (unlikely(prev_state == TASK_DEAD)) { // 进程主动退出或者被终止 if (prev-\u0026gt;sched_class-\u0026gt;task_dead) prev-\u0026gt;sched_class-\u0026gt;task_dead(prev); // 所属调度类的task_dead方法 /* * Remove function-return probe instances associated with this * task and put them back on the free list.*/ kprobe_flush_task(prev); /* Task is done with its stack. */ /*释放进程的内核栈 */ put_task_stack(prev); // 把进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符 put_task_struct_rcu_user(prev); } tick_nohz_task_switch(); return rq; } 2.8.7 调度时机 调度进程的时机: （1）进程主动调用schedule()函数 （2）周期性地调度，抢占当前进程，强迫当前进程让出处理器 （3）唤醒进程的时候，被唤醒的进程可能抢占当前进程 （4）创建新进程的时候，新进程可能抢占当前进程。\n1.主动调度 内核中3种主动调度方式： （1）直接调用schedule()函数来调度进程 （2）调用有条件重调度函数cond_resched()。非抢占式内核中，函数cond_resched()判断当前进程是否设置了需要重新调度的标志，如果设置了，就调度进程；抢占式内核中，cond_resched()为空 （3）如果需要等待某个资源，例如互斥锁或信号量，那么把进程的状态设置为睡眠状态，然后调用schedule()函数以调度进程\n2.周期调度 周期调度的函数是scheduler_tick()，它调用当前进程所属调度类的task_tick方法。 （1）限期调度类的周期调度 task_tick \u0026ndash;\u0026gt; task_tick_dl \u0026ndash;\u0026gt; update_curr_dl\n// kernel/sched/deadline.c static void update_curr_dl(struct rq *rq) { struct task_struct *curr = rq-\u0026gt;curr; struct sched_dl_entity *dl_se = \u0026amp;curr-\u0026gt;dl; u64 delta_exec, scaled_delta_exec; ... delta_exec = now - curr-\u0026gt;se.exec_start; if (unlikely((s64)delta_exec \u0026lt;= 0)) { if (unlikely(dl_se-\u0026gt;dl_yielded)) goto throttle; return; } ... dl_se-\u0026gt;runtime -= scaled_delta_exec; // 计算限期进程的剩余运行时间 throttle: // // 如果限期进程用完了运行时间或者主动让出处理器 if (dl_runtime_exceeded(dl_se) || dl_se-\u0026gt;dl_yielded) { dl_se-\u0026gt;dl_throttled = 1; // 设置节流标志 /* If requested, inform the user about runtime overruns. */ if (dl_runtime_exceeded(dl_se) \u0026amp;\u0026amp; (dl_se-\u0026gt;flags \u0026amp; SCHED_FLAG_DL_OVERRUN)) dl_se-\u0026gt;dl_overrun = 1; __dequeue_task_dl(rq, curr, 0); if (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr))) enqueue_task_dl(rq, curr, ENQUEUE_REPLENISH); if (!is_leftmost(curr, \u0026amp;rq-\u0026gt;dl)) resched_curr(rq); } ... } （2）实时调度类的周期调度 \\\n实时调度类的task_tick方法是函数task_tick_rt\n// linux-5.10.102/kernel/sched/rt.c static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued) { struct sched_rt_entity *rt_se = \u0026amp;p-\u0026gt;rt; ... if (p-\u0026gt;policy != SCHED_RR) // 调度策略不是轮流调度 return; // 把时间片减一，如果没用完时间片，那么返回 if (--p-\u0026gt;rt.time_slice) return; // 用完了时间片，那么重新分配时间片 p-\u0026gt;rt.time_slice = sched_rr_timeslice; /* Requeue to the end of queue if we (and all of our ancestors) are not * the only element on the queue */ for_each_sched_rt_entity(rt_se) { if (rt_se-\u0026gt;run_list.prev != rt_se-\u0026gt;run_list.next) { requeue_task_rt(rq, p, 0); resched_curr(rq); return; } } } （3）公平调度类的周期调度 公平调度类的task_tick方法是函数task_tick_fair\n// kernel/sched/fair.c static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026amp;curr-\u0026gt;se; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); entity_tick(cfs_rq, se, queued); } ... } // kernel/sched/fair.c static void entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued) { ... if (cfs_rq-\u0026gt;nr_running \u0026gt; 1) // 公平运行队列的进程数量超过1 check_preempt_tick(cfs_rq, curr); } // kernel/sched/fair.c static void check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr) { unsigned long ideal_runtime, delta_exec; struct sched_entity *se; s64 delta; ideal_runtime = sched_slice(cfs_rq, curr); delta_exec = curr-\u0026gt;sum_exec_runtime - curr-\u0026gt;prev_sum_exec_runtime; if (delta_exec \u0026gt; ideal_runtime) { resched_curr(rq_of(cfs_rq)); /* The current task ran long enough, ensure it doesn\u0026#39;t get * re-elected due to buddy favours.*/ clear_buddies(cfs_rq, curr); return; } /* Ensure that a task that missed wakeup preemption by a * narrow margin doesn\u0026#39;t have to wait for a full slice. * This also mitigates buddy induced latencies under load.*/ if (delta_exec \u0026lt; sysctl_sched_min_granularity) return; se = __pick_first_entity(cfs_rq); delta = curr-\u0026gt;vruntime - se-\u0026gt;vruntime; if (delta \u0026lt; 0) return; if (delta \u0026gt; ideal_runtime) resched_curr(rq_of(cfs_rq)); } （4）中断返回时调度。 ARM64架构的中断处理程序的入口是e10_irq，中断处理程序执行完以后，跳转到标号ret_to_user以返回用户模式。标号ret_to_user判断当前进程的进程描述符的成员thread_info.flags有没有设置标志位集合_TIF_WORK_MASK中的任何一个标志位，如果设置了其中一个标志位，那么跳转到标号work_pending，标号work_pending调用函数do_notify_resume\n// arch/arm64/kernel/entry.S 5.10.102 代码中没有？ ret_to_user: disable_irq // 禁止中断 ldr x1, [tsk, #TSK_TI_FLAGS] and x2, x1, #_TIF_WORK_MASK cbnz x2, work_pending finish_ret_to_user: enable_step_tsk x1, x2 kernel_exit 0 ENDPROC(ret_to_user) work_pending: mov x0, sp /* * 寄存器x0存放第一个参数regs * 寄存器x1存放第二个参数task_struct.thread_info.flags */ bl do_notify_resume #ifdef CONFIG_TRACE_IRQFLAGS bl trace_hardirqs_on // 在用户空间执行时开启中断 #endif ldr x1, [tsk, #TSK_TI_FLAGS] // 重新检查单步执行 b finish_ret_to_user 函数do_notify_resume判断当前进程的进程描述符的成员thread_info.flags有没有设置需要重新调度的标志位_TIF_NEED_RESCHED，如果设置了，那么调用函数schedule()以调度进程。\n// arch/arm64/kernel/signal.c asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int thread_flags) { ... do { if (thread_flags \u0026amp; _TIF_NEED_RESCHED) { schedule(); } else { … } local_irq_disable(); thread_flags = READ_ONCE(current_thread_info()-\u0026gt;flags); } while (thread_flags \u0026amp; _TIF_WORK_MASK); } 3.唤醒进程时抢占 唤醒进程的时候，被唤醒的进程可能抢占当前进程\n唤醒进程时抢占 （1）如果被唤醒的进程和当前进程属于相同的调度类，那么调用调度类的check_preempt_curr方法以检查是否可以抢占当前进程 （2）如果被唤醒的进程所属调度类的优先级高于当前进程所属调度类的优先级，那么给当前进程设置需要重新调度的标志\n调度类 check_preempt_curr方法是函数 算法 停机调度类 check_preempt_curr_stop 空函数 限期调度类 check_preempt_curr_dl 如果被唤醒的进程的绝对截止期限比当前进程的绝对截止期限小，那么给当前进程设置需要重新调度的标志 实时调度类 check_preempt_curr_rt 优先级比当前进程的优先级高，那么给当前进程设置需要重新调度的标志 公平调度类 check_preempt_wakeup 空闲调度类 check_preempt_curr_idle 无条件抢占，给当前进程设置需要重新调度的标志 check_preempt_wakeup函数\n// linux-5.10.102/kernel/sched/fair.c static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) { // 当前进程的调度策略是SCHED_IDLE，被唤醒的进程的调度策略是SCHED_NORMAL或者SCHED_BATCH，那么允许抢占，给当前进程设置需要重新调度的标志 struct task_struct *curr = rq-\u0026gt;curr; struct sched_entity *se = \u0026amp;curr-\u0026gt;se, *pse = \u0026amp;p-\u0026gt;se; ... if (unlikely(task_has_idle_policy(curr)) \u0026amp;\u0026amp; likely(!task_has_idle_policy(p))) goto preempt; if (unlikely(p-\u0026gt;policy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION)) return; // 为当前进程和被唤醒的进程找到两个兄弟调度实体 find_matching_se(\u0026amp;se, \u0026amp;pse); update_curr(cfs_rq_of(se)); BUG_ON(!pse); if (wakeup_preempt_entity(se, pse) == 1) { // 判断是否可以抢占 // 允许抢占，给当前进程设置需要重新调度的标志 ... goto preempt; } return; preempt: resched_curr(rq); ... } static int wakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se) { s64 gran, vdiff = curr-\u0026gt;vruntime - se-\u0026gt;vruntime; if (vdiff \u0026lt;= 0) return -1; gran = wakeup_gran(se); if (vdiff \u0026gt; gran) return 1; return 0; } 4.创建新进程时抢占 使用系统调用fork、clone和 vfork创建新进程使，新进程可抢占当前进程；使用韩式kernel_thread创建新的内核线程是，新内核线程可抢占当前进程 5.内核抢占 内核抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，需要打开配置宏CONFIG_PREEMPT。抢占式内核和非抢占式内核。进程tthread_info结构体一个类型为int的成员preempt_count为抢占计数器。\n待补充\n6.高精度调度时钟 高精度时钟的精度是纳秒,需要通过配置宏启用。\n2.8.8 带宽管理 调度类管理进程占用的处理器带宽的方法\n1.限期调度类的带框管理 每个限期进程有自己的带宽，内核把限期进程的运行时间统计到根实时任务组的运行时间里面了，限期进程共享实时进程的带宽\n// kernel/sched/deadline.c static void update_curr_dl(struct rq *rq) { … if (rt_bandwidth_enabled()) { struct rt_rq *rt_rq = \u0026amp;rq-\u0026gt;rt; raw_spin_lock(\u0026amp;rt_rq-\u0026gt;rt_runtime_lock); if (sched_rt_bandwidth_account(rt_rq)) rt_rq-\u0026gt;rt_time += delta_exec; raw_spin_unlock(\u0026amp;rt_rq-\u0026gt;rt_runtime_lock); } } 2.实时调度类的带宽管理 指定实时进程的带宽有以下两种方式 （1）指定全局带宽：带宽包含的两个参数是周期和运行时间，即指定在每个周期内所有实时进程的运行时间总和。 默认的周期是1秒，默认的运行时间是0.95秒。可以借助文件“/proc/sys/kernel/sched_rt_period_us”设置周期，借助文件“/proc/sys/kernel/sched_rt_runtime_us”设置运行时间 配置宏CONFIG_RT_GROUP_SCHED，即支持实时任务组，那么全局带宽指定了所有实时任务组的总带宽 （2）指定每个实时任务组的带宽：在每个指定的周期，允许一个实时任务组最多执行长时间。当实时任务组在一个周期用完了带宽时，这个任务组将会被节流，不允许继续运行，直到下一个周期。可以使用cgroup设置一个实时任务组的周期和运行时间，cgroup版本1的配置方法如下\ncgroup版本1的配置方法 1）cpu.rt_period_us：周期，默认值是1秒。 2）cpu.rt_runtime_us：运行时间，默认值是0，把运行时间设置为非零值以后才允许把实时进程加入任务组，设置为−1表示没有带宽限制。 cgroup版本1的配置示例如下。 1）挂载cgroup文件系统，把CPU控制器关联到控制组层级树。 mount -t cgroup -o cpu none /sys/fs/cgroup/cpu 2）创建一个任务组。 cd /sys/fs/cgroup/cpu mkdir browser # 创建\"browser\"任务组 3）把实时运行时间设置为10毫秒。 echo 10000 \u003e browser/cpu.rt_runtime_us 4）把一个实时进程加入任务组。 echo \u003e browser/cgroup.procs cgroup版本2从内核4.15版本开始支持CPU控制器，暂时不支持实时进程。\n一个处理器用完了实时运行时间，可以从其他处理器借用实时运行时间，称为实时运行时间共享，对应调度特性RT_RUNTIME_SHARE，默认开启。\nkernel/sched/features.h SCHED_FEAT(RT_RUNTIME_SHARE, true) 实时任务组的带宽存放在结构体task_group的成员rt_bandwidth中：\n// kernel/sched/sched.h struct task_group { … #ifdef CONFIG_RT_GROUP_SCHED … struct rt_bandwidth rt_bandwidth; #endif … }; 节流\n书中详细解释\n3.公平调度类的带宽管理 使用周期和限额指定一个公平任务组的带宽 使用cgroup设置一个公平任务组的周期和限额，cgroup版本1的配置 \\\ncgroup版本1的配置方法 \u0026emsp;cgroup版本2的配置示例 \\ cgroup版本2的配置方法 （1）节流：在以下两种情况下，调度器会检查公平运行队列是否用完运行时间。 1）put_prev_task_fair：调度器把当前正在运行的普通进程放回公平运行队列。 2）pick_next_task_fair：当前正在运行的进程属于公平调度类，调度器选择下一个普通进程。\n（2）周期定时器：在每个周期的开始，重新填充任务组的带宽，把带宽分配给节流的公平运行队列。周期定时器的处理函数是sched_cfs_period_timer，它把主要工作委托给函数do_sched_cfs_period_timer\n// kernel/sched/fair.c static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun) { … throttled = !list_empty(\u0026amp;cfs_b-\u0026gt;throttled_cfs_rq); … __refill_cfs_bandwidth_runtime(cfs_b); // 新填充任务组的带宽 if (!throttled) { cfs_b-\u0026gt;idle = 1; return 0; } … while (throttled \u0026amp;\u0026amp; cfs_b-\u0026gt;runtime \u0026gt; 0) { runtime = cfs_b-\u0026gt;runtime; raw_spin_unlock(\u0026amp;cfs_b-\u0026gt;lock); // 把任务组的可用运行时间分配给节流的公平运行队列 runtime = distribute_cfs_runtime(cfs_b, runtime, runtime_expires); raw_spin_lock(\u0026amp;cfs_b-\u0026gt;lock); throttled = !list_empty(\u0026amp;cfs_b-\u0026gt;throttled_cfs_rq); cfs_b-\u0026gt;runtime -= min(runtime, cfs_b-\u0026gt;runtime); } … } 函数__refill_cfs_bandwidth_runtime负责重新填充任务组的带宽：“把可用运行时间设置成限额，把运行时间的到期时间设置成当前时间加上1个周期”\n// kernel/sched/fair.c void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b) { u64 now; if (cfs_b-\u0026gt;quota == RUNTIME_INF) return; now = sched_clock_cpu(smp_processor_id()); cfs_b-\u0026gt;runtime = cfs_b-\u0026gt;quota; cfs_b-\u0026gt;runtime_expires = now + ktime_to_ns(cfs_b-\u0026gt;period); } 函数distribute_cfs_runtime负责把任务组的可用运行时间分配给节流的公平运行队列\nstatic void distribute_cfs_runtime(struct cfs_bandwidth *cfs_b) { struct cfs_rq *cfs_rq; u64 runtime, remaining = 1; rcu_read_lock(); list_for_each_entry_rcu(cfs_rq, \u0026amp;cfs_b-\u0026gt;throttled_cfs_rq, throttled_list) { struct rq *rq = rq_of(cfs_rq); struct rq_flags rf; rq_lock_irqsave(rq, \u0026amp;rf); if (!cfs_rq_throttled(cfs_rq)) goto next; /* By the above check, this should never be true */ SCHED_WARN_ON(cfs_rq-\u0026gt;runtime_remaining \u0026gt; 0); raw_spin_lock(\u0026amp;cfs_b-\u0026gt;lock); /* cfs_rq-\u0026gt;runtime_remaining是公平运行队列的剩余运行时间 */ runtime = -cfs_rq-\u0026gt;runtime_remaining + 1; if (runtime \u0026gt; cfs_b-\u0026gt;runtime) runtime = cfs_b-\u0026gt;runtime; cfs_b-\u0026gt;runtime -= runtime; remaining = cfs_b-\u0026gt;runtime; raw_spin_unlock(\u0026amp;cfs_b-\u0026gt;lock); cfs_rq-\u0026gt;runtime_remaining += runtime; /* we check whether we\u0026#39;re throttled above */ /* 上面检查过是否被节流 */ if (cfs_rq-\u0026gt;runtime_remaining \u0026gt; 0) unthrottle_cfs_rq(cfs_rq); next: rq_unlock_irqrestore(rq, \u0026amp;rf); if (!remaining) break; } rcu_read_unlock(); } （3）取有余补不足：\n2.9 SMP调度 SMP系统进程调度器特性: （1）使每个处理器负载尽可能均衡 （2）设置进程的处理器亲和性(affinity)，即允许进程在哪些处理器上执行 （3）进程从一个处理器迁移到另一个处理器\n2.9.1 进程的处理器亲和性 进程描述符增加两个成员\n// include/linux/sched.h struct task_struct { … int nr_cpus_allowed; // 保存允许的处理器掩码 cpumask_t cpus_allowed;\t// 保存允许的处理器数量 … }; 1.应用编程接口 内核系统调用\n// sched_setaffinity用来设置进程的处理器亲和性掩码 int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); // sched_getaffinity用来获取进程的处理器亲和性掩码 int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); 内核线程函数设置处理器亲和性掩码\n// kthread_bind用来把一个刚刚创建的内核线程绑定到一个处理器 void kthread_bind(struct task_struct *p, unsigned int cpu); // set_cpus_allowed_ptr用来设置内核线程的处理器亲和性掩码 int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask); 2.使用cpuset配置 cpuset在单独使用的时候，可以使用cpuset伪文件系统配置，配置方法\n2.9.2 对调度器的扩展 SMP系统上，调度类增加方法\n// kernel/sched/sched.h struct sched_class { … #ifdef CONFIG_SMP // 为进程选择运行队列 int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); // 在进程被迁移到新的处理器之前调用 void (*migrate_task_rq)(struct task_struct *p); // 用来在进程被唤醒以后调用 void (*task_woken) (struct rq *this_rq, struct task_struct *task); // 设置处理器亲和性的时候执行调度类的特殊处理 void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); #endif … }; 进程在内存和缓存中的数据是最少的，是有价值的实现负载均衡的机会：1）创建新进程，2）调用execve装载程序\n创建新进程时负载均衡 装载程序时负载均衡 2.9.3 限期调度类的处理器负载均衡 2.9.4 实时调度类的处理器负载均衡 2.9.5 公平调度类的处理器负载均衡 2.9.6 迁移线程 每个处理器有一个迁移线程，线程名称是“migration/\u0026lt;cpu_id\u0026gt;”，属于停机调度类，可以抢占所有其他进程，其他进程不可以抢占它。迁移线程有两个作用 （1）调度器发出迁移请求，迁移线程处理迁移请求，把进程迁移到目标处理器。 （2）执行主动负载均衡。\n2.9.7 隔离处理器 2.10 进程的上下文安全 第3章 内存管理 3.1 内存管理子系统架构 用户空间、内核空间和硬件3个层面 1.用户空间 应用程序使用malloc()申请内存，使用free()释放内存。 malloc()和free()是glibc库的内存分配器ptmalloc提供的接口，ptmalloc使用系统调用brk或mmap向内核以页为单位申请内存，然后划分成小内存块分配给应用程序 用户空间的内存分配器，除了glibc库的ptmalloc，还有谷歌的tcmalloc和FreeBSD的jemalloc\n2.内核空间 （1）内核空间的基本功能 虚拟内存管理负责从进程的虚拟地址空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页 内核使用延迟分配物理内存的策略，进程第一次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页 页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口kmalloc()和释放内存的接口kfree()，支持3种块分配器：SLAB分配器、SLUB分配器和SLOB分配器。 \\\n（2）内核空间的扩展功能。 \\\n不连续页分配器提供了分配内存的接口vmalloc和释放内存的接口vfree 连续内存分配器（Contiguous Memory Allocator，CMA）用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用 \\\n3.硬件层面 处理器包含一个称为内存管理单元（Memory Management Unit，MMU）的部件，负责把虚拟地址转换成物理地址 内存管理单元包含一个称为页表缓存（Translation Lookaside Buffer，TLB）的部件，保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表 \\\n3.2 虚拟地址空间布局 3.2.1 虚拟地址空间划分 ARM64处理器不支持完全的64位虚拟地址，ARMv8.2 标准的大虚拟地址(Large Virtual Address，LVA)支持，并且页长度是64KB，那么虚拟地址的最大宽度是52位 可以为虚拟地址配置比最大宽度小的宽度，并且可以为内核虚拟地址和用户虚拟地址配置不同的宽度。转换控制寄存器（Translation Control Register）TCR_EL1的字段T0SZ定义了必须是全0的最高位的数量，字段T1SZ定义了必须是全1的最高位的数量，用户虚拟地址的宽度是（64-TCR_EL1.T0SZ），内核虚拟地址的宽度是（64-TCR_EL1.T1SZ） \\\n页长度 虚拟地址宽度 4KB 39 16KB 47 64KB 42 可选择48位虚拟地址 3.2.2 用户虚拟地址空间布局 进程的用户虚拟地址空间的起始地址是0，长度是TASK_SIZE，ARM64架构下TASK_SIZE下 （1）32位用户空间程序：TASK_SIZE值是TASK_SIZE_32，即0x100000000，4GB （2）64位用户空间程序：TASK_SIZE值是TASK_SIZE_64，即 2^VA_BITS，VA_BITS是编译内核时选择的虚拟地址位数。 \\\n//arch/arm64/include/asm/memory.h linux4.x #define VA_BITS (CONFIG_ARM64_VA_BITS) #define TASK_SIZE_64 (UL(1) \u0026lt;\u0026lt; VA_BITS) #ifdef CONFIG_COMPAT /* 支持执行32位用户空间程序 */ #define TASK_SIZE_32 UL(0x100000000) /* test_thread_flag(TIF_32BIT)判断用户空间程序是不是32位 */ #define TASK_SIZE (test_thread_flag(TIF_32BIT) ? \\ TASK_SIZE_32 : TASK_SIZE_64) #define TASK_SIZE_OF(tsk) (test_tsk_thread_flag(tsk, TIF_32BIT) ? \\ TASK_SIZE_32 : TASK_SIZE_64) #else #define TASK_SIZE TASK_SIZE_64 #endif /* CONFIG_COMPAT */ // linux-5.10.102/arch/arm64/include/asm/memory.h #define VA_BITS\t(CONFIG_ARM64_VA_BITS) #define _PAGE_OFFSET(va)\t(-(UL(1) \u0026lt;\u0026lt; (va))) #define PAGE_OFFSET\t(_PAGE_OFFSET(VA_BITS)) #define KIMAGE_VADDR\t(MODULES_END) #define BPF_JIT_REGION_START\t(KASAN_SHADOW_END) #define BPF_JIT_REGION_SIZE\t(SZ_128M) #define BPF_JIT_REGION_END\t(BPF_JIT_REGION_START + BPF_JIT_REGION_SIZE) #define MODULES_END\t(MODULES_VADDR + MODULES_VSIZE) #define MODULES_VADDR\t(BPF_JIT_REGION_END) #define MODULES_VSIZE\t(SZ_128M) #define VMEMMAP_START\t(-VMEMMAP_SIZE - SZ_2M) #define VMEMMAP_END\t(VMEMMAP_START + VMEMMAP_SIZE) #define PCI_IO_END\t(VMEMMAP_START - SZ_2M) #define PCI_IO_START\t(PCI_IO_END - PCI_IO_SIZE) #define FIXADDR_TOP\t(PCI_IO_START - SZ_2M) 进程的用户虚拟地址空间包含： （1）代码段、数据段和未初始化数据段 （2）动态库代码段、数据段和初始化数据段 （3）存放动态生成的数据的堆 （4）存放局部变量和实现函数调用的栈 （5）存放在栈底部的环境变量和参数字符串 （6）把文件区间映射到虚拟地址空间的内存映射区域 内核使用内存描述符mm_struct描述进程的用户虚拟地址空间，内存描述符主要成员\natomic_t mm_users; // 共享同一个用户虚拟地址空间进程的数量，即线程组包含的进程的数量 atomic_t mm_count; // 内存描述符的引用计数 struct vm_area_struct *mmap; // 虚拟内存区域链表 struct rb_root mm_rb; // 虚拟内存区域红黑树 unsigned long(*get_unmapped_area)(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags); // 在内存映射区域找到一个没有映射的区域 pgd_t *pgd; // 指向页全局目录，即第一级页表 unsigned long mmap_base; // 内存映射区的起始地址 unsigned long task_size; // 用户虚拟地址空间的长度 unsigned long start_code, end_code; // 代码段的起始地址和结束地址 unsigned long start_data, end_data; // 数据段的起始地址和结束地址 unsigned long start_brk, brk; // 堆的起始地址和结束地址 unsigned long start_stack; // 栈的起始地址 unsigned long arg_start, arg_end; // 参数字符串起始地址和结束地址 unsigned long env_start, env_end; // 环境变量的起始地址和结束地址 struct mm_struct *mm; // 进程mm指向一个内存描述符，内核线程mm为空指针 struct mm_struct　*active_mm; // 进程的active_mm和mm总是指向同一个内存描述符 // 内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符 进程地址空间随机化： （1）进程描述符成员personality是否设置ADDR_NO_RANDOMIZE （2）全局变量randomize_va_spce：0表示关闭虚拟地址空间随机化，1表示内存映射区和栈起始地址随机化，2表示内存映射区、栈和堆起始地址随机化，文件/proc/sys/kernel/randomize_va_space修改 \\\n栈向下增长，起始地址STACK_TOP，\n// arch/arm64/include/asm/processor.h #define STACK_TOP_MAX TASK_SIZE_64 #ifdef CONFIG_COMPAT /* 支持执行32位用户空间程序 */ #define AARCH32_VECTORS_BASE 0xffff0000 #define STACK_TOP (test_thread_flag(TIF_32BIT) ? \\ AARCH32_VECTORS_BASE : STACK_TOP_MAX) #else #define STACK_TOP STACK_TOP_MAX #endif /* CONFIG_COMPAT */ 内存映射区域的起始地址是内存描述符的成员 mmap_base\n用户虚拟地址空间两种布局 新布局：内存映射区域自顶向下增长，起始地址是(STACK_TOP − 栈的最大长度 − 间隙)，默认启用内存映射区域随机化，需要把起始地址减去一个随机值 \\\n进程调用execve以装载ELF文件的时候，函数load_elf_binary将会创建进程的用户虚拟地址空间 \\\n函数arch_pick_mmap_layout负责选择内存映射区域的布局。ARM64架构定义的函数arch_pick_mmap_layout\n// linux-5.10.102/mm/util.c void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack) { unsigned long random_factor = 0UL; if (current-\u0026gt;flags \u0026amp; PF_RANDOMIZE) random_factor = arch_mmap_rnd(); if (mmap_is_legacy(rlim_stack)) { // 自底向上 mm-\u0026gt;mmap_base = TASK_UNMAPPED_BASE + random_factor; mm-\u0026gt;get_unmapped_area = arch_get_unmapped_area; // } else { // 自顶向下 mm-\u0026gt;mmap_base = mmap_base(random_factor, rlim_stack); mm-\u0026gt;get_unmapped_area = arch_get_unmapped_area_topdown; } } static int mmap_is_legacy(struct rlimit *rlim_stack) { if (current-\u0026gt;personality \u0026amp; ADDR_COMPAT_LAYOUT) return 1; if (rlim_stack-\u0026gt;rlim_cur == RLIM_INFINITY) return 1; return sysctl_legacy_va_layout; } 内存映射区域的起始地址的计算\n// linux-5.10.102/arch/arm64/include/asm/efi.h #ifdef CONFIG_COMPAT #define STACK_RND_MASK\t(test_thread_flag(TIF_32BIT) ? \\ 0x7ff \u0026gt;\u0026gt; (PAGE_SHIFT - 12) : \\ 0x3ffff \u0026gt;\u0026gt; (PAGE_SHIFT - 12)) #else #define STACK_RND_MASK\t(0x3ffff \u0026gt;\u0026gt; (PAGE_SHIFT - 12)) #endif // arch/arm64/mm/mmap.c #define MIN_GAP (SZ_128M + ((STACK_RND_MASK \u0026lt;\u0026lt; PAGE_SHIFT) + 1)) #define MAX_GAP (STACK_TOP/6*5) static unsigned long mmap_base(unsigned long rnd) { unsigned long gap = rlimit(RLIMIT_STACK); if (gap \u0026lt; MIN_GAP) gap = MIN_GAP; else if (gap \u0026gt; MAX_GAP) gap = MAX_GAP; return PAGE_ALIGN(STACK_TOP - gap - rnd); } 函数load_elf_binary：函数setup_arg_pages把栈顶设置为STACK_TOP减去随机值，然后把环境变量和参数从临时栈移到最终的用户栈；函数set_brk设置堆的起始地址，如果启用堆随机化，把堆的起始地址加上随机值\n// fs/binfmt_elf.c static int load_elf_binary(struct linux_binprm *bprm) { … retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP), executable_stack); … retval = set_brk(elf_bss, elf_brk, bss_prot); … if ((current-\u0026gt;flags \u0026amp; PF_RANDOMIZE) \u0026amp;\u0026amp; (randomize_va_space \u0026gt; 1)) { current-\u0026gt;mm-\u0026gt;brk = current-\u0026gt;mm-\u0026gt;start_brk = arch_randomize_brk(current-\u0026gt;mm); } … } 3.2.3 内核地址空间布局 ARM64处理器架构内核地址空间布局 (1)先行映射区范围[PAGE_OFFSET, 2^64-1]，起始地址PAGE_OFFSET = (OxFFFF FFFF FFFF FFFF \u0026laquo; (VA_BITS-1))，长度为内核虚拟地址空间的一半，虚拟地址和物理地址是线性关系 \\ 虚拟地址 = ((物理地址-PHYS_OFFSET)+PAGE_OFFSET)，PHY_OFFSET是内存起始物理地址 (2)vmemmap 区域的范围是[VMEMMAP_START, PAGE_OFFSET)，长度是VMEMMAP_SIZE =（线性映射区域的长度 / 页长度 * page结构体的长度上限） (3)PCI I/O区域的范围是[PCI_IO_START, PCI_IO_END)，长度是16MB，结束地址是PCI_IO_END = (VMEMMAP_START − 2MB)。外围组件互联（Peripheral Component Interconnect，PCI）是一种总线标准，PCI I/O区域是PCI设备的I/O地址空间 (4)定映射区域的范围是[FIXADDR_START, FIXADDR_TOP)，长度是FIXADDR_SIZE，结束地址是FIXADDR_TOP = (PCI_IO_START − 2MB) (5)vmalloc区域的范围是[VMALLOC_START, VMALLOC_END），起始地址是VMALLOC_START，等于内核模块区域的结束地址，结束地址是VMALLOC_END = (PAGE_OFFSET − PUD_SIZE − VMEMMAP_SIZE − 64KB)，其中PUD_SIZE是页上级目录表项映射的地址空间的长度 vmalloc区域是函数vmalloc使用的虚拟地址空间，内核镜像在vmalloc区域，起始虚拟地址是(KIMAGE_VADDR + TEXT_OFFSET) ，其中KIMAGE_VADDR是内核镜像的虚拟地址的基准值，等于内核模块区域的结束地址MODULES_END；TEXT_OFFSET是内存中的内核镜像相对内存起始位置的偏移 (6)内核模块区域的范围是[MODULES_VADDR, MODULES_END)，长度是128MB，起始地址是MODULES_VADDR =（内核虚拟地址空间的起始地址 + KASAN影子区域的长度）。内核模块区域是内核模块使用的虚拟地址空间 (7)KASAN影子区域的起始地址是内核虚拟地址空间的起始地址，长度是内核虚拟地址空间长度的1/8。内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具 \\\n3.3 物理地址空间 处理器通过外围设备控制器的寄存器访问外围设备，寄存器分为控制寄存器、状态寄存器和数据寄存器三大类，外围设备的寄存器通常被连续地编址。处理器对外围设备寄存器的编址方式有两种： （1）I/O映射方式(I/O-mapped) （2）内存映射方式(memroy-mapped)：精简指令集的处理器通常只实现一个物理地址空间，外围设备和物理内存使用统一的物理地址空间，处理器可以像访问一个内存单元那样访问外围设备，不需要提供专门的I/O指令 \\\n程序通过虚拟地址访问外设寄存器，内核函数把外设寄存器物理地址映射到虚拟地址空间\n// ioremap()把外设寄存器物理地址映射到内核虚拟地址空间 void* ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); // io_remap_pfn_range()函数把外设寄存器的物理地址映射到进程的用户虚拟地址空间 int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn, unsigned long size, pgprot_t prot); // iounmap()删除函数ioremap()创建映射 void iounmap(void *addr); ARM64架构两种内存类型： （1）正常内存(Normal Memory)：包括物理内存和只读存储器(ROM)，共享属性和可缓存 （2）设备内存(Device Memory)：指分配给外围设备寄存器的物理地址区域，外部共享，不可缓存 ARM64架构3种属性把设备分为4种类型: （1）Device-nGnRnE （2）Device-nGnRE。 （3）Device-nGRE。 （4）Device-GRE \\\n寄存器TCR_EL1（Translation Control Register for Exception Level 1，异常级别1的转换控制寄存器）的字段IPS（Intermediate Physical Address Size，中间物理地址长度）控制物理地址的宽度，IPS字段的长度是3位\n3.4　内存映射 进程在虚拟地址空间中创建映射： （1）文件映射，把文件一个区间映射到进程虚拟地址空间，数据源是存储设备上的文件，文件页 （2）匿名映射，把物理内存映射到进程虚拟地址空间，无数据源，匿名页 修改对其他进程可见和释放传递底层文件，内存映射分为共享映射和私有映射。 \u0026amp;ensp；（1）共享映射：修改数据时映射相同区域的其他进程可以看见，如果是文件支持的映射，修改会传递到底层文件。 （2）私有映射：第一次修改数据时会从数据源复制一个副本，然后修改副本，其他进程看不见，不影响数据源 两个进程可以使用共享的文件映射实现共享内存，进程间通信？。匿名映射通常是私有映射，共享的匿名映射只可能出现在父进程和子进程之间。 进程的虚拟地址空间中，代码段和数据段是私有的文件映射，未初始化数据段、堆和栈是私有的匿名映射 内存映射的原理。 （1）创建内存映射的时候，在进程的用户虚拟地址空间中分配一个虚拟内存区域。 （2）Linux内核采用延迟分配物理内存的策略，在进程第一次访问虚拟页的时候，产生缺页异常。如果是文件映射，那么分配物理页，把文件指定区间的数据读到物理页中，然后在页表中把虚拟页映射到物理页；如果是匿名映射，那么分配物理页，然后在页表中把虚拟页映射到物理页\n3.4.1 应用编程接口 系统调用\n// 1.mmap()创建内存映射 void *mmap(void *addr, size_t length, int prot, int flags, in fd, off_t offset); // 2. mremap()扩大或缩小内存映射，可移动 void *mreemap(void *old_address, size_t old_size, size_t new_size, int flags, ... /*void *new_address */); // 3. munmap() 删除内存印刷 int munmap(void *addr, size_t length); // 4. brk() 设置堆上界 int brk(void *addr); // 6. mprotect()设置虚拟内存区域的访问权限 int mprotect(void *addr, size_t len, int prot); // 7. madvise 箱内核体术内存使用建议，配合内核预读和缓存 int madvise(void *addr, size_t length, int advice); 内核空间函数\n// 1. remap_pfn_range把内存的物理页映射到进程的虚拟地址空间，实现进程和内核共享内存 int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn,unsigned long size, pgprot_t prot); // 2.io_remap_pfn_range把外设寄存器的物理地址映射到进程的虚拟地址空间，进程可以直接访问外设寄存器 int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn, unsigned long size, pgprot_t prot); 应用程序通常使用C标准库提供的函数malloc()申请内存。glibc库的内存分配器ptmalloc使用brk或mmap向内核以页为单位申请虚拟内存，然后把页划分成小内存块分配给应用程序。默认的阈值是128KB，如果应用程序申请的内存长度小于阈值，ptmalloc分配器使用brk向内核申请虚拟内存，否则ptmalloc分配器使用mmap向内核申请虚拟内存 \\\n应用程序可以直接使用mmap向内核申请虚拟内存 系统调用mmap() 系统调用mprotect() 系统调用madvise()\n3.4.2 数据结构 1. 虚拟内存区域 内核使用结构体vm_area_struct描述虚拟内存区域\nstruct vm_area_struct { /* The first cache line has the info for VMA tree walking. */ /* Our start address within vm_mm. */ unsigned long vm_start;\t// 起始地址 /* The first byte after our end address within vm_mm. */ unsigned long vm_end; // 结束地址 /* linked list of VM areas per task, sorted by address */ // 虚拟内存区域链表，按起始地址排序 struct vm_area_struct *vm_next, *vm_prev; // 红黑树节点 struct rb_node vm_rb; /* Largest free memory gap in bytes to the left of this VMA. * Either between this VMA and vma-\u0026gt;vm_prev, or between one of the * VMAs below us in the VMA rbtree and its -\u0026gt;vm_prev. This helps * get_unmapped_area find a free area of the right size.*/ unsigned long rb_subtree_gap; /* Second cache line starts here. */ // 指向内存描述符，即虚拟内存区域所属的用户虚拟地址空间 struct mm_struct *vm_mm;\t/* The address space we belong to. */ /* Access permissions of this VMA. * See vmf_insert_mixed_prot() for discussion.*/ // 保护位，即访问权限 pgprot_t vm_page_prot; unsigned long vm_flags;\t/* Flags, see mm.h. */ /* For areas with an address space and backing store, * linkage into the address_space-\u0026gt;i_mmap interval tree.*/ // 为了支持查询一个文件区间被映射到哪些虚拟内存区域， // 把一个文件映射到的所有虚拟内存区域加入该文件的地址空间结构体 // address_space的成员i_mmap指向的区间树 struct { struct rb_node rb; unsigned long rb_subtree_last; } shared; /* file\u0026#39;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma * list, after a COW of one of the file pages.\tA MAP_SHARED vma * can only be in the i_mmap tree. An anonymous MAP_PRIVATE, stack * or brk vma (with NULL file) can only be in an anon_vma list.*/ // 把虚拟内存区域关联的所有anon_vma实例串联起来。 // 一个虚拟内存区域会关联到父进程的anon_vma实例和自己的anon_vma实例 struct list_head anon_vma_chain; /* Serialized by mmap_lock \u0026amp; * page_table_lock */ // 指向一个anon_vma实例，结构体anon_vma用来组织匿名页 // 被映射到的所有虚拟地址空间 struct anon_vma *anon_vma;\t/* Serialized by page_table_lock */ /* Function pointers to deal with this struct. */ // 虚拟内存操作集合 const struct vm_operations_struct *vm_ops; /* Information about our backing store: */ // 文件偏移，单位是页 unsigned long vm_pgoff;\t/* Offset (within vm_file) in PAGE_SIZE units */ // 文件，如果是私有的匿名映射，该成员是空指针 struct file * vm_file;\t/* File we map to (can be NULL). */ void * vm_private_data;\t/* was vm_pte (shared mem) */ #ifdef CONFIG_SWAP atomic_long_t swap_readahead_info; #endif #ifndef CONFIG_MMU struct vm_region *vm_region;\t/* NOMMU mapping region */ #endif #ifdef CONFIG_NUMA struct mempolicy *vm_policy;\t/* NUMA policy for the VMA */ #endif struct vm_userfaultfd_ctx vm_userfaultfd_ctx; } __randomize_layout; 文件映射的虚拟内存区域 （1）成员vm_file指向文件的一个打开实例（file）。索引节点代表一个文件，描述文件的属性。 （2）成员vm_pgoff存放文件的以页为单位的偏移。 （3）成员vm_ops指向虚拟内存操作集合，创建文件映射的时候调用文件操作集合中的mmap方法（file-\u0026gt;f_op-\u0026gt;mmap）以注册虚拟内存操作集合。例如：假设文件属于EXT4文件系统，文件操作集合中的mmap方法是函数ext4_file_mmap，该函数把虚拟内存区域的成员vm_ops设置为ext4_file_vm_ops\n共享匿名映射的虚拟内存区域 （1）成员vm_file指向文件的一个打开实例（file）。 （2）成员vm_pgoff存放文件的以页为单位的偏移。 （3）成员vm_ops指向共享内存的虚拟内存操作集合shmem_vm_ops。\n私有匿名映射的虚拟内存区域 （1）页保护位（vm_area_struct.vm_page_prot）：描述虚拟内存区域的访问权限。内核定义了一个保护位映射数组，把VM_READ、VM_WRITE、VM_EXEC和VM_SHARED这4个标志转换成保护位组合 P代表私有（Private），S代表共享（Shared），后面的3个数字分别表示可读、可写和可执行，例如__P000表示私有、不可读、不可写和不可执行，__S111表示共享、可读、可写和可执行\n// mm/mmap.c pgprot_t protection_map[16] = { __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 }; pgprot_t vm_get_page_prot(unsigned long vm_flags) { return __pgprot(pgprot_val(protection_map[vm_flags \u0026amp; (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) | pgprot_val(arch_vm_get_page_prot(vm_flags))); } // include/linux/mman.h #ifndef arch_vm_get_page_prot #define arch_vm_get_page_prot(vm_flags) __pgprot(0) #endif 虚拟内存区域标志：结构体vm_area_struct的成员vm_flags存放虚拟内存区域的标志，头文件“include/linux/mm.h”定义了各种标志 VM_READ、VM_WRITE、VM_EXEC、VM_SHARED、VM_GROWSDOWN、VM_DONTEXPAND、VM_ACCOUNT、VM_NORESERVE、VM_HUGETLB、VM_ARCH_1、VM_ARCH_2、VM_HUGEPAGE、VM_MERGEABLE\n虚拟内存操作集合（vm_operations_struct）：定义了虚拟内存区域的各种操作方法\n// include/linux/mm.h struct vm_operations_struct { // 在创建虚拟内存区域时调用open方法，通常不使用，设置为空指针 void (*open)(struct vm_area_struct * area); // 在删除虚拟内存区域时调用close方法，通常不使用，设置为空指针 void (*close)(struct vm_area_struct * area); // 使用系统调用mremap移动虚拟内存区域时调用mremap方法 int (*mremap)(struct vm_area_struct * area); // 使用系统调用mremap移动虚拟内存区域时调用mremap方法 int (*fault)(struct vm_fault *vmf); // huge_fault方法针对使用透明巨型页的文件映射 int (*huge_fault)(struct vm_fault *vmf, enum page_entry_size pe_size); // 读文件映射的虚拟页时，如果没有映射到物理页，生成缺页异常 void (*map_pages)(struct vm_fault *vmf, pgoff_t start_pgoff, pgoff_t end_pgoff); /* 通知以前的只读页即将变成可写， * 如果返回一个错误，将会发送信号SIGBUS给进程*/ int (*page_mkwrite)(struct vm_fault *vmf); /* 使用VM_PFNMAP或者VM_MIXEDMAP时调用，功能和page_mkwrite相同*/ int (*pfn_mkwrite)(struct vm_fault *vmf); … } 2.链表和树 虚拟内存区域的链表和树 (1)双向链表，mm_struct.mmap指向第一个vm_area_struct实例 (2)红黑树，mm_struct.mm_rb指向红黑树的根 \\\n3.4.3 创建内存映射 C标准库封装了函数mmap用来创建内存映射\nasmlinkage long sys_mmap(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, off_t off); asmlinkage long sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, off_t off); ARM64架构只实现系统调用mmap\n系统调用sys_mmap执行流程 do_mmap的执行流程 待补充\n3.4.4 虚拟内存过量提交策略 虚拟内存过量提交，是指所有进程提交的虚拟内存的总和超过物理内存的容量，内存管理子系统支持3种虚拟内存过量 （1）OVERCOMMIT_GUESS(0)：猜测，估算可用内存的数量，因为没法准确计算可用内存的数量，所以说是猜测。 （2）OVERCOMMIT_ALWAYS(1)：总是允许过量提交。 （3）OVERCOMMIT_NEVER(2)：不允许过量提交。 /proc/sys/vm/overcommit_memory修改策略 在创建新的内存映射时，调用函数__vm_enough_memory根据虚拟内存过量提交策略判断内存是否足够\n3.4.5 删除内存映射 系统调用munmap用来删除内存映射，它有两个参数：起始地址和长度，mm/mmap.c中的函数do_munmap\n系统调用munmap执行流程 3.5 物理内存组织 3.5.1 体系结构 多处理器系统两种体系结构： (1)非一致内存访问(Non-Uniform Memory Access NUMA)：内存为多个内存节点多处理器系统 (2)对称多处理器(Symmetric Multi-Process SMP)：一直内存访问(UMA)\n3.5.2 内存模型 内存管理子系统支持3种内存模型 (1)平坦内存(Flat Memory)：内存物理地址空间是连续的 (2)不连续内存(Discontiguous Memory)：内存物理地址空间存在空洞 (3)系数内存(Sparse Memory)：内存物理地址空间存在空洞\n3.5.3 三级结构 内存管理子系统使用节点(node)、区域(zone)和页(page)三级结构描述物理内存。 \\\n1.内存节点 内存节点两种情况： （1）NUMA系统内存节点 （2）具有不连续内存的UMA系统 内存节点使用pglist_data结构体描述内存布局，内核定义宏NODE_DATA(nid)，获取节点的pglist_data实例。平坦内存模型，只有一个pglist_data实例contig_page_data\n内存节点的pglist_data实例 pglist_data结构主要成员：\n// include/linux/mmzone.h typedef struct pglist_data { struct zone node_zones[MAX_NR_ZONES]; /* 内存区域数组 */ struct zonelist node_zonelists[MAX_ZONELISTS]; /* 备用区域列表 */ int nr_zones; /* 该节点包含的内存区域数量 */ #ifdef CONFIG_FLAT_NODE_MEM_MAP /* 除了稀疏内存模型以外 */ struct page *node_mem_map; /* 页描述符数组 */ #ifdef CONFIG_PAGE_EXTENSION struct page_ext *node_page_ext; /* 页的扩展属性 */ #endif #endif … unsigned long node_start_pfn; /* 该节点的起始物理页号 */ unsigned long node_present_pages; /* 物理页总数 */ unsigned long node_spanned_pages; /* 物理页范围的总长度，包括空洞 */ int node_id; /* 节点标识符 */ … } pg_data_t; 2.内存区域 内核定义内存节点区域\n// include/linux/mmzone.h enum zone_type { #ifdef CONFIG_ZONE_DMA ZONE_DMA, // 直接内存访问区域 #endif #ifdef CONFIG_ZONE_DMA32 ZONE_DMA32, #endif // 内核虚拟地址和物理地址是线性映射的关系，即虚拟地址 =（物理地址 + 常量） ZONE_NORMAL, // 直接映射区域 #ifdef CONFIG_HIGHMEM ZONE_HIGHMEM, // 高端内存区域 #endif ZONE_MOVABLE, // 可移动区域 #ifdef CONFIG_ZONE_DEVICE ZONE_DEVICE, // 设备区域 #endif __MAX_NR_ZONES }; 每个内存区域用一个zone结构体描述\n// include/linux/mmzone.h struct zone { unsigned long watermark[NR_WMARK]; /* 页分配器使用的水线 */ … long lowmem_reserve[MAX_NR_ZONES]; /* 页分配器使用，当前区域保留多少页不能借给 高的区域类型 */ … struct pglist_data *zone_pgdat; /* 指向内存节点的pglist_data实例 */ struct per_cpu_pageset __percpu *pageset; /* 每处理器页集合 */ … unsigned long zone_start_pfn; /* 当前区域的起始物理页号 */ unsigned long managed_pages; /* 伙伴分配器管理的物理页的数量 */ unsigned long spanned_pages; /* 当前区域跨越的总页数，包括空洞 */ unsigned long present_pages; /* 当前区域存在的物理页的数量，不包括空洞 */ const char *name; /* 区域名称 */ … struct free_area free_area[MAX_ORDER]; /* 不同长度的空闲区域 */ … } 3.物理页 每个物理页对应一个page结构体，称为页描述符，内存节点的pglist_data实例的成员node_mem_map指向该内存节点包含的所有物理页的页描述符注册的数组。 结构体page成员flags布局 | [SECTION] | [NODE] | ZONE | [LAST_CPUPID] | \u0026hellip; | FLAGS | SECTION是稀疏内存模型中的段编号，NODE是节点编号，ZONE是区域类型，FLAGS是标志位 头文件include/linux/mm_types.h定义了page结构体\n// include/linux/mm.h // 得到物理页所属的内存节点的编号 static inline int page_to_nid(const struct page *page) { return (page-\u0026gt;flags \u0026gt;\u0026gt; NODES_PGSHIFT) \u0026amp; NODES_MASK; } // 得到物理页所属的内存区域的类型 static inline enum zone_type page_zonenum(const struct page *page) { return (page-\u0026gt;flags \u0026gt;\u0026gt; ZONES_PGSHIFT) \u0026amp; ZONES_MASK; } 3.6 引导内存分配器 在内核初始化的过程中需要分配内存，内核提供了临时的引导内存分配器，在页分配器和块分配器初始化完毕后，把空闲的物理页交给页分配器管理，丢弃引导内存分配器，开启配置宏CONFIG_NO_BOOTMEM，memblock就会取代bootmem。 3.6.1 bootmem分配器 3.6.2 memblock分配器 1.数据结构 memblock分配器数据结构\n// include/linux/memblock.h struct memblock { bool bottom_up; /* 表示分配内存的方式 是从下向上的方向？ */ phys_addr_t current_limit; // 可分配内存的最大物理地址 struct memblock_type memory; // 存类型（包括已分配的内存和未分配的内存） struct memblock_type reserved; // 预留类型（已分配的内存） #ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP struct memblock_type physmem; // 物理内存类型 #endif }; 内存块类型的数据结构\n// include/linux/memblock.h struct memblock_type { unsigned long cnt; /* 内存块区域数量 */ unsigned long max; /* 已分配数组的大小 */ phys_addr_t total_size; /* 内存块区域的总长度 所有区域的长度 */ struct memblock_region *regions; // 指向内存块区域数组 char *name; // 存块类型的名称 }; 内存块区域的数据结构\n// include/linux/memblock.h struct memblock_region { phys_addr_t base; // 起始物理地址 phys_addr_t size; // 长度 unsigned long flags; // 标志 MEMBLOCK_NONE或其他标志 #ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP int nid; // 节点编号 #endif }; /* memblock标志位的定义. */ enum { MEMBLOCK_NONE = 0x0, /* 无特殊要求 */ MEMBLOCK_HOTPLUG = 0x1, /* 可热插拔区域 */ MEMBLOCK_MIRROR = 0x2, /* 镜像区域 */ MEMBLOCK_NOMAP = 0x4, /* 不添加到内核直接映射 */ }; 2.初始化 源文件“mm/memblock.c”定义了全局变量memblock，把成员bottom_up初始化为假，表示从高地址向下分配。 ARM64内核初始化memblock分配器的过程是： （1）解析设备树二进制文件中的节点“/memory”，把所有物理内存范围添加到memblock. memory，具体过程参考3.6.3节。 （2）在函数arm64_memblock_init中初始化memblock。 arm64_memblock_init主要流程：\nstart_kernel() \u0026ndash;\u0026gt; setup_arch() \u0026ndash;\u0026gt; arm64_memblock_init()\n// arch/arm64/mm/init.c void __init arm64_memblock_init(void) { const s64 linear_region_size = -(s64)PAGE_OFFSET; // 解析设备树二进制文件中节点“/chosen”的属性“linux,usable-memory-range”， // 得到可用内存的范围，把超出这个范围的物理内存范围从memblock.memory中删除。 fdt_enforce_memory_region(); // 局变量memstart_addr记录内存的起始物理地址 memstart_addr = round_down(memblock_start_of_DRAM(), ARM64_MEMSTART_ALIGN); // 把线性映射区域不能覆盖的物理内存范围从memblock.memory中删除 memblock_remove(max_t(u64, memstart_addr + linear_region_size, __pa_symbol(_end)), ULLONG_MAX); if (memstart_addr + linear_region_size \u0026lt; memblock_end_of_DRAM()) { /* 确保memstart_addr严格对齐 */ memstart_addr = round_up(memblock_end_of_DRAM() - linear_region_size, ARM64_MEMSTART_ALIGN); memblock_remove(0, memstart_addr); } if (memory_limit != (phys_addr_t)ULLONG_MAX) { memblock_mem_limit_remove_map(memory_limit); memblock_add(__pa_symbol(_text), (u64)(_end - _text)); } … // 把内核镜像占用的物理内存范围添加到memblock.reserved memblock_reserve(__pa_symbol(_text), _end - _text); … // 从设备树二进制文件中的内存保留区域和节点“/reserved-memory” // 读取保留的物理内存范围，添加到memblock.reserved中 early_init_fdt_scan_reserved_mem(); … } 3.编程接口 memblock分配器接口\n// 添加新的内存块区域到memblock.memory中 memblock_add // 删除内存块区域 memblock_remove // 分配内存 memblock_alloc // 释放内存 memblock_free 4.算法 memblock分配器把所有内存添加到memblock.memory中，把分配出去的内存块添加到memblock.reserved中 函数memblock_alloc负责分配内存，主要为函数memblock_alloc_range_nid (1)memblock_find_in_range_node函数memblock_find_in_range_node (2)memblock_reserve函数把分配出去的内存块区域添加到memblock.reserved中 \\\n3.6.3 物理内存信息 内核初始化的过程中，引导内存分配器负责分配内存。ARM64架构使用扁平设备树（Flattened Device Tree，FDT）描述板卡的硬件信息。驱动开发者编写设备树源文件（Device Tree Source，DTS），存放在目录“arch/arm64/boot/dts”下，然后使用设备树编译器（Device Tree Compiler，DTC）把设备树源文件转换成设备树二进制文件（Device Tree Blob，DTB），接着把设备树二进制文件写到存储设备上。设备启动时，引导程序把设备树二进制文件从存储设备读到内存中，引导内核的时候把设备树二进制文件的起始地址传给内核，内核解析设备树二进制文件后得到硬件信息 \\\n设备树源文件.dts,描述物理内存布局\n/ { // “/”根节点 #address-cells = \u0026lt;2\u0026gt;; // 地址的单元数量 #size-cells = \u0026lt;2\u0026gt;; // 一个长度的单元数量 memory@80000000 { // 描述物理内存布局 device_type = \u0026#34;memory\u0026#34;; // 设备类型 // 物理内存范围 reg = \u0026lt;0x00000000 0x80000000 0 0x80000000\u0026gt;, \u0026lt;0x00000008 0x80000000 0 0x80000000\u0026gt;; }; }; 内核在初始化的时候调用函数early_init_dt_scan_nodes以解析设备树二进制文件，从而得到物理内存信息 \\\nstart_kernel() \u0026ndash;\u0026gt; setup_arch() \u0026ndash;\u0026gt; setup_machine_fdt() \u0026ndash;\u0026gt; early_init_dt_scan_nodes()\n// drivers/of/fdt.c void __init early_init_dt_scan_nodes(void) { … /* 初始化size-cells和address-cells信息 */ // early_init_dt_scan_root，解析根节点的属性“#address-cells”得到地址的单元数量， // 保存在全局变量dt_root_addr_cells中；解析根节点的属性“#size-cells”得到 // 长度的单元数量，保存在全局变量dt_root_size_cells中 of_scan_flat_dt(early_init_dt_scan_root, NULL); /* 调用函数early_init_dt_add_memory_arch设置内存 */ of_scan_flat_dt(early_init_dt_scan_memory, NULL); } early_init_dt_scan_memory解析memory节点\n// drivers/of/fdt.c int __init early_init_dt_scan_memory(unsigned long node, const char *uname, int depth, void *data) { // 解析节点的属性“device_type” const char *type = of_get_flat_dt_prop(node, \u0026#34;device_type\u0026#34;, NULL); const __be32 *reg, *endp; int l; … /* 只扫描 \u0026#34;memory\u0026#34; 节点 */ if (type == NULL) { /* 如果没有属性“device_type”，判断节点名称是不是“memory@0”*/ if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, \u0026#34;memory@0\u0026#34;) != 0) return 0; } else if (strcmp(type, \u0026#34;memory\u0026#34;) != 0) // 描述物理内存信息 return 0; reg = of_get_flat_dt_prop(node, \u0026#34;linux,usable-memory\u0026#34;, \u0026amp;l); if (reg == NULL) reg = of_get_flat_dt_prop(node, \u0026#34;reg\u0026#34;, \u0026amp;l); if (reg == NULL) return 0; endp = reg + (l / sizeof(__be32)); … while ((endp - reg) \u0026gt;= (dt_root_addr_cells + dt_root_size_cells)) { u64 base, size; base = dt_mem_next_cell(dt_root_addr_cells, \u0026amp;reg); size = dt_mem_next_cell(dt_root_size_cells, \u0026amp;reg); if (size == 0) continue; … early_init_dt_add_memory_arch(base, size); … } return 0; } 解析出每块内存的起始地址和大小后，调用函数early_init_dt_add_memory_arch\n// drivers/of/fdt.c void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size) { const u64 phys_offset = MIN_MEMBLOCK_ADDR; if (!PAGE_ALIGNED(base)) { if (size \u0026lt; PAGE_SIZE - (base \u0026amp; ~PAGE_MASK)) { pr_warn(\u0026#34;Ignoring memory block 0x%llx - 0x%llx\\n\u0026#34;, base, base + size); return; } size -= PAGE_SIZE - (base \u0026amp; ~PAGE_MASK); base = PAGE_ALIGN(base); } size \u0026amp;= PAGE_MASK; if (base \u0026gt; MAX_MEMBLOCK_ADDR) { pr_warning(\u0026#34;Ignoring memory block 0x%llx - 0x%llx\\n\u0026#34;, base, base + size); return; } if (base + size - 1 \u0026gt; MAX_MEMBLOCK_ADDR) { pr_warning(\u0026#34;Ignoring memory range 0x%llx - 0x%llx\\n\u0026#34;, ((u64)MAX_MEMBLOCK_ADDR) + 1, base + size); size = MAX_MEMBLOCK_ADDR - base + 1; } if (base + size \u0026lt; phys_offset) { pr_warning(\u0026#34;Ignoring memory block 0x%llx - 0x%llx\\n\u0026#34;, base, base + size); return; } if (base \u0026lt; phys_offset) { pr_warning(\u0026#34;Ignoring memory range 0x%llx - 0x%llx\\n\u0026#34;, base, phys_offset); size -= phys_offset - base; base = phys_offset; } // 把物理内存范围添加到memblock.memory memblock_add(base, size); } 3.7 伙伴分配器 内核初始化完毕后，使用页分配器管理物理页，当前使用的页分配器是伙伴分配器buddy allocato\n3.7.1 基本的伙伴分配器 连续的物理页称为页块（page block）。阶（order）是伙伴分配器的一个术语，是页的数量单位，2n个连续页称为n阶页块。满足以下条件的两个n阶页块称为伙伴（buddy） 伙伴分配器分配和释放物理页的数量单位是阶\n3.7.2 分区的伙伴分配器 1.数据结构 分区的伙伴分配器专注于某个内存节点的某个区域。内存区域的结构体成员free_area用来维护空闲页块，数组下标对应页块的阶数。结构体free_area的成员free_list是空闲页块的链表nr_free是空闲页块的数量。内存区域的结构体成员managed_pages是伙伴分配器管理的物理页的数量，不包括引导内存分配器分配的物理页\ninclude/linux/mmzone.h struct zone { … /* 不同长度的空闲区域 */ struct free_area free_area[MAX_ORDER]; // MAX_ORDER是最大阶数 … unsigned long managed_pages; … } ____cacheline_internodealigned_in_smp; struct free_area { struct list_head free_list[MIGRATE_TYPES]; unsigned long nr_free; }; // include/linux/mmzone.h /* 空闲内存管理-分区的伙伴分配器 */ #ifndef CONFIG_FORCE_MAX_ZONEORDER #define MAX_ORDER 11 #else #define MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER #endif 2．根据分配标志得到首选区域类型 3. 备用区域列表 4．区域水线 5．防止过度借用 3.7.3　根据可移动性分组 3.7.4　每处理器页集合 内核针对分配单页做了性能优化，为了减少处理器之间的锁竞争，在内存区域增加 1个每处理器页集合。\ninclude/linux/mmzone.h struct zone { … struct per_cpu_pageset __percpu *pageset; /* 在每个处理器上有一个页集合 */ … } ____cacheline_internodealigned_in_smp; struct per_cpu_pageset { struct per_cpu_pages pcp; … }; struct per_cpu_pages { int count; /* 链表里面页的数量 */ int high; /* 如果页的数量达到高水线，需要返还给伙伴分配器 */ int batch; /* 批量添加或删除的页数量 */ struct list_head lists[MIGRATE_PCPTYPES]; /* 每种迁移类型一个页链表 */ }; 3.7.5　分配页 1．分配接口 页分配器分配页接口\n// 求分配一个阶数为order的页块，返回一个page实例 alloc_pages(gfp_mask, order) // 在阶数为0情况下的简化形式，只分配一页 alloc_page(gfp_mask) // 只能从低端内存区域分配页，并且返回虚拟地址 __get_free_pages(gfp_mask, order) // 在阶数为0情况下的简化形式，只分配一页 __get_free_page(gfp_mask) // 参数gfp_mask设置了标志位__GFP_ZERO且阶数为0情况下的简化形式，只分配一页，并且用零初始化 get_zeroed_page(gfp_mask) 2．分配标志位 分配页的函数都带一个分配标志位参数，分配标志位分为以下5类 (1)区域修饰符\n(2)页移动性和位置提示\n(3)水线修饰符\n(4)回收修饰符\n(5)行动修饰符\n3．复合页 如果设置了标志位__GFP_COMP并且分配了一个阶数大于0的页块，页分配器会把页块组成复合页（compound page）。复合页最常见的用处是创建巨型页。 复合页的第一页叫首页（head page），其他页都叫尾页（tail page）\n复合页的结构 4．对高阶原子分配的优化处理 5．核心函数的实现 3.7.6　释放页 页分配器提供了以下释放页的接口 （1）void __free_pages(struct page *page, unsigned int order)，第一个参数是第一个物理页的page实例的地址，第二个参数是阶数 （2）void free_pages(unsigned long addr, unsigned int order)，第一个参数是第一个物理页的起始内核虚拟地址，第二个参数是阶数 \\\n3.8　块分配器 Linux内核提供了块分配器，处理小块内存分配问题，最早为SLAB分配器。大量物理内存的大型计算机上SLUB分配器，小内存的嵌入式设备上SLOB \\\n3.8.1 编程接口 3种块分配器提供了统一的编程接口，块分配器在初始化的时候创建了一些通用的内存缓存，从普通区域分配页的内存缓存的名称是kmalloc-\u0026lt;size\u0026gt;，DMA区域分配页的内存缓存的名称是dma-kmalloc-\u0026lt;size\u0026gt;，执行命令cat /proc/slabinfo可以看到这些通用的内存缓存 \\\n// 分配内存 void *kmalloc(size_t size, gfp_t flags); // 重新分配内存 void *krealloc(const void *p, size_t new_size, gfp_t flags); // 释放内存 void kfree(const void *objp); 创建专用的内存缓存\n// 创建内存缓存 struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void *)); // 从指定的内存缓存分配对象 void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags); // 释放对象 void kmem_cache_free(struct kmem_cache *cachep, void *objp); // 销毁内存缓存 void kmem_cache_destroy(struct kmem_cache *s); 3.8.2 SLAB分配器 1.数据结构 内存缓存的数据结构 （1）每个内存缓存对应一个kmem_cache实例 \\\n（2）每个内存节点对应一个kmem_cache_node实例\npage结构体的成员 1)flags设置标志位PG_slab，表示页属于SLAB分配器 2)s_mem存放slab第一个对象的地址 3)active表示已分配对象的数量 4)lru作为链表节点加入其中一条slab链表 5)slab_cache指向kmem_cache实例 6)freelist指向空闲对象链表 \\\n（3）kmem_cache实例的成员cpu_slab指向array_cache实例，\n2.空闲对象链表 每个slab需要一个空闲对象链表，从而把所有空闲对象链接起来，空闲对象链表是用数组实现的，page-\u0026gt;freelist指向空闲对象链表\n使用对象存放空闲对象链表-初始状态 使用对象存放空闲对象链表-分配最后一个空闲对象 空闲对象链表在slab外面 3.计算slab长度 函数calculate_slab_order负责计算slab长度，从0阶到kmalloc()函数支持的最大阶数（KMALLOC_MAX_ORDER）\n4.着色 5．每处理器数组缓存 内存缓存为每个处理器创建了一个数组缓存（结构体array_cache）。释放对象时，把对象存放到当前处理器对应的数组缓存中\n每处理器数组缓冲 6．对NUMA的支持 SLAB分配器支持NUMA 7．内存缓存合并 减少内存开销和增加对象的缓存热度，块分配器会合并相似的内存缓存\n8.回收内存 所有对象空闲的slab，没有立即释放，而是放在空闲slab链表中。只有内存节点上空闲对象的数量超过限制，才开始回收空闲slab，直到空闲对象的数量小于或等于限制 结构体kmem_cache_node的成员slabs_free是空闲slab链表的头节点，成员free_objects是空闲对象的数量，成员free_limit是空闲对象的数量限制 \\\n回收空闲slab 3.8.3　SLUB分配器 1．数据结构 SLUB分配器内存缓存的数据结构 2．空闲对象链表 空闲对象链表的初始状态 分配一个对象以后的空闲对象链表 3．计算slab长度 SLUB分配器在创建内存缓存的时候计算了两种slab长度：最优slab和最小slab\n4．每处理器slab缓存 SLUB分配器的每处理器slab缓存 5．对NUMA的支持 （1）内存缓存针对每个内存节点创建一个kmem_cache_node实例 （2）分配对象时，如果当前处理器的slab缓存是空的，需要重填当前处理器的slab缓存 \\\n6.回收内存 对于所有对象空闲的slab，如果内存节点的部分空闲slab的数量大于或等于最小部分空闲slab数量，那么直接释放，否则放在部分空闲slab链表的尾部\n7.调试 3.8.4　SLOB分配器 1．数据结构 SLOB分配器内存缓存的数据结构 2．空闲对象链表 空闲对象链表的初始状态 分配一个对象以后的空闲对象链表 3．分配对象 分配对象时，根据对象长度选择不同的策略\n3.9　不连续页分配器 3.9.1　编程接口 不连续页分配器提供了以下编程接口\n// vmalloc函数：分配不连续的物理页并且把物理页映射到连续的虚拟地址空间 void *vmalloc(unsigned long size); // vfree函数：释放vmalloc分配的物理页和虚拟地址空间 void vfree(const void *addr); // vmap函数：把已经分配的不连续物理页映射到连续的虚拟地址空间 // pages是page指针数组，count是page指针数组大小，flags标志位，prot页保护位 void *vmap(struct page **pages, unsigned int count, unsigned long flags, pgprot_t prot); // vunmap函数：释放使用vmap分配的虚拟地址空间 void vunmap(const void *addr); // kvmalloc函数：先尝试使用kmalloc分配内存块，如果失败，那么使用vmalloc函数分配不连续的物理页 void *kvmalloc(size_t size, gfp_t flags); // kvfree函数：如果内存块是使用vmalloc分配的，那么使用vfree释放，否则使用kfree释放 void kvfree(const void *addr); 3.9.2　数据结构 不连续页分配器的数据结构 使用vmap函数分配虚拟内存区域 3.9.3　技术原理 vmalloc虚拟地址空间的范围是[VMALLOC_START, VMALLOC_END)\n// arch/arm64/include/asm/pgtable.h #define VMALLOC_START (MODULES_END) #define VMALLOC_END (PAGE_OFFSET - PUD_SIZE - VMEMMAP_SIZE - SZ_64K) MODULES_END是内核模块区域的结束地址，PAGE_OFFSET是线性映射区域的起始地址，PUD_SIZE是一个页上层目录表项映射的地址空间长度，VMEMMAP_SIZE是vmemmap区域的长度。 vmalloc虚拟地址空间的起始地址等于内核模块区域的结束地址。 vmalloc虚拟地址空间的结束地址等于（线性映射区域的起始地址−一个页上层目录表项映射的地址空间长度−vmemmap区域的长度−64KB） 函数vmalloc的执行过程分为3步 （1）分配虚拟内存区域 分配vm_struct实例和vmap_area实例 （2） 分配物理页 vm_struct实例的成员nr_pages存放页数n；分配page指针数组 （3）在内核的页表中把虚拟页映射到物理页 内核的页表就是0号内核线程的页表。0号内核线程的进程描述符是全局变量init_task，成员active_mm指向全局变量init_mm，init_mm的成员pgd指向页全局目录swapper_pg_dir\n3.10　每处理器内存分配器 多处理器系统中，每处理器变量为每个处理器生成一个变量的副本\n3.10.1　编程接口 每处理器变量分为静态和动态两种\n1.静态每处理器变量 宏“DEFINE_PER_CPU(type, name)”定义普通的静态每处理器变量，使用宏“DECLARE_PER_CPU(type, name)”声明普通的静态每处理器变量\n// 宏“DEFINE_PER_CPU(type, name)”展开 // 静态每处理器变量存放在“.data..percpu” __attribute__((section(\u0026#34;.data..percpu\u0026#34;))) __typeof__(type) name 2．动态每处理器变量 为动态每处理器变量分配内存的函数\n// __alloc_percpu_gfp为动态每处理器变量分配内存 void __percpu *__alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp); // 宏alloc_percpu_gfp(type, gfp)是函数__alloc_percpu_gfp的简化形式 // 宏alloc_percpu_gfp(type, gfp)是函数__alloc_percpu_gfp的简化形式 void __percpu *__alloc_percpu(size_t size, size_t align); // free_percpu释放动态每处理器变量的内存 void free_percpu(void __percpu *__pdata); 3．访问每处理器变量 宏“this_cpu_ptr(ptr)”用来得到当前处理器的变量副本的地址，宏“get_cpu_var(var)”用来得到当前处理器的变量副本的值\n// 宏this_cpu_ptr(ptr)展开 unsigned long __ptr; __ptr = (unsigned long) (ptr); (typeof(ptr)) (__ptr + per_cpu_offset(raw_smp_processor_id())); 宏“per_cpu_ptr(ptr, cpu)”用来得到指定处理器的变量副本的地址，宏“per_cpu(var, cpu)”用来得到指定处理器的变量副本的值。 宏“get_cpu_ptr(var)”禁止内核抢占并且返回当前处理器的变量副本的地址，宏“put_cpu_ptr(var)”开启内核抢占，这两个宏成对使用 宏“get_cpu_var(var)”禁止内核抢占并且返回当前处理器的变量副本的值，宏“put_cpu_var(var)”开启内核抢占，这两个宏成对使用 \\\n3.10.2　技术原理 每处理器区域是按块（chunk）分配的 分配块的方式有两种: (1)分配块的方式有两种 (2)分配块的方式有两种 \\\n基于vmalloc区域的每处理器内存分配器 每个块对应一个pcpu_chunk实例\n基于内核内存的每处理器内存分配器 3.11　页表 3.11.1　统一的页表框架 页表用来把虚拟页映射到物理页，并且存放页的保护位，即访问权限 Linux 4.11版本以前，Linux内核把页表分为4级 (1)页全局目录(Page Global Directory PGD) (2)页上层目录(Page Upper DIrectory PUD) (3)页中间目录(Page Middle Directory PMD) (4)直接页表(Page Table PT) 4.11版本把页表扩展到五级，在页全局目录和页上层目录之间增加了页四级目录(Page 4th Directory，P4D) \\\n内核也有一个页表，0号内核线程的进程描述符init_task的成员active_mm指向内存描述符init_mm，内存描述符init_mm的成员pgd指向内核的页全局目录swapper_pg_dir 虚拟地址被分解为6个部分：页全局目录索引、页四级目录索引、页上层目录索引、页中间目录索引、直接页表索引和页内偏移 \\\n3.11.2　ARM64处理器的页表 ARM64处理器把页表称为转换表(translation table)，最多4级。ARM64处理器支持3 种页长度：4KB、16KB和64KB。 、 页长度是4KB：使用4级转换表，转换表和内核的页表术语的对应关系是：0级转换表对应页全局目录，1级转换表对应页上层目录，2级转换表对应页中间目录，3级转换表对应直接页表 \\\n3.12　页表缓存 处理器的内存管理单元（Memory Management Unit，MMU）负责把虚拟地址转换成物理地址。 TLB（Translation Lookaside Buffer）的高速缓存，TLB直译为转换后备缓冲区，意译为页表缓存，缓存最近使用过的页表项。两级页表缓存：第一级TLB分为指令TLB和数据TLB，好处是取指令和取数据可以并行执行；第二级TLB是统一TLB（Unified TLB），即指令和数据共用的TLB\n3.12.1　TLB表项格式 ARM64处理器的每条TLB表项不仅包含虚拟地址和物理地址，也包含属性：内存类型、缓存策略、访问权限、地址空间标识符（Address Space Identifier，ASID）和虚拟机标识符（Virtual Machine Identifier，VMID）。地址空间标识符区分不同进程的页表项，虚拟机标识符区分不同虚拟机的页表项 \\\n3.12.2　TLB管理 页表改变以后冲刷TLB的函数\n// 使所有TLB表项失效 void flush_tlb_all(void); // 使指定用户地址空间的某个范围的TLB表项失效 // 参数vma是虚拟内存区域，start是起始地址，end是结束地址（不包括） void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end); // 使指定用户地址空间里面的指定虚拟页的TLB表项失效 // 参数vma是虚拟内存区域，uaddr是一个虚拟页中的任意虚拟地址 void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr); // 使内核的某个虚拟地址范围的TLB表项失效 // 参数start是起始地址，end是结束地址（不包括） void flush_tlb_kernel_range(unsigned long start, unsigned long end); // 修改页表项以后把页表项设置到页表缓存 // 由软件管理页表缓存的处理器必须实现该函数，例如MIPS处理器 // ARM64处理器的内存管理单元可以访问内存中的页表，把页表项复制到页表缓存，所以ARM64架构的函数update_mmu_cache什么都不用做 void update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep); // 内核把进程从一个处理器迁移到另一个处理器以后，调用该函数以更新页表缓存或上下文特定信息 void tlb_migrate_finish(struct mm_struct *mm); ARM64架构没有提供写TLB的指令。 ARM64架构提供了一条TLB失效指令\nTLBI \u0026lt;type\u0026gt;\u0026lt;level\u0026gt;{IS} {, \u0026lt;Xt\u0026gt;} ARM64内核flush_tlb_all函数\n// arch/arm64/include/asm/tlbflush.h static inline void flush_tlb_all(void) {\t// dsb数据同步屏障 dsb(ishst); // ishst中的ish表示共享域是内部共享 __tlbi(vmalle1is); // 使所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效 dsb(ish); // ish表示数据同步屏障指令对所有核起作用 isb(); // 指令同步屏障 } // 宏展开 static inline void flush_tlb_all(void) { // dsb确保屏障前面的存储指令执行完 // ishst中的ish表示共享域是内部共享 // st表示存储（store），ishst表示数据同步屏障指令对所有核的存储指令起作用 asm volatile(\u0026#34;dsb ishst\u0026#34; : : : \u0026#34;memory\u0026#34;); // 使所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效 asm (\u0026#34;tlbi vmalle1is\u0026#34; : :); // 确保前面的TLB失效指令执行完。ish表示数据同步屏障指令对所有核起作用 asm volatile(\u0026#34;dsb ish\u0026#34; : : : \u0026#34;memory\u0026#34;); // isb是指令同步屏障,冲刷处理器的流水线，重新读取屏障指令后面的所有指令 asm volatile(\u0026#34;isb\u0026#34; : : : \u0026#34;memory\u0026#34;); } ARM64内核实现了函数local_flush_tlb_all，用来使当前核的所有TLB表项失效\n// arch/arm64/include/asm/tlbflush.h static inline void local_flush_tlb_all(void) { dsb(nshst); __tlbi(vmalle1); // 仅仅使当前核的TLB表项失效 dsb(nsh); // nsh是非共享,数据同步屏障指令仅仅在当前核起作用 isb(); } 3.12.3　地址空间标识符 ARM64处理器的页表缓存使用非全局(not global，nG)位区分内核和进程的页表项(nG位为0表示内核的页表项)，使用地址空间标识符(Address Space Identifier，ASID)区分不同进程的页表项 ARM64处理器的ASID长度8位或者16位，寄存器ID_AA64MMFR0_EL1段ASIDBits存放处理器支持的ASID长度。16位ASID使用寄存器TCR_EL1的AS(ASID Size)位控制实际使用的ASID长度，AS 0为8位ASID，AS 1为16位ASID 寄存器TCR_EL1的A1位决定使用哪个寄存器存放当前进程的ASID,寄存器TTBR0_EL1 用户0或TTBR1_EL1内核？存放当前进程ASID 内存描述符的成员context存放架构特定的内存管理上下文，数据类型是结构体mm_context_t，ARM64架构定义的结构体 // arch/arm64/include/asm/mmu.h typedef struct { atomic64_t id; // 成员id存放内核给进程分配的软件ASID … } mm_context_t; 全局变量asid_bits保存ASID长度，全局变量asid_generation的高56位保存全局ASID版本号，位图asid_map记录哪些ASID被分配 当全局ASID版本号加1时，每个处理器需要清空页表缓存，位图tlb_flush_pending保存需要清空页表缓存的处理器集合 // arch/arm64/mm/context.c static u32 asid_bits; static atomic64_t asid_generation; static unsigned long *asid_map; static DEFINE_PER_CPU(atomic64_t, active_asids); static DEFINE_PER_CPU(u64, reserved_asids); static cpumask_t tlb_flush_pending; 进程被调度时，函数check_and_switch_context负责检查是否需要给进程重新分配ASID __schedule() -\u0026gt; context_switch() -\u0026gt; switch_mm_irqs_off() -\u0026gt; switch_mm() -\u0026gt; check_and_switch_context()\n// arch/arm64/mm/context.c void check_and_switch_context(struct mm_struct *mm, unsigned int cpu) { unsigned long flags; u64 asid; asid = atomic64_read(\u0026amp;mm-\u0026gt;context.id); if (!((asid ^ atomic64_read(\u0026amp;asid_generation)) \u0026gt;\u0026gt; asid_bits) \u0026amp;\u0026amp; atomic64_xchg_relaxed(\u0026amp;per_cpu(active_asids, cpu), asid)) goto switch_mm_fastpath; raw_spin_lock_irqsave(\u0026amp;cpu_asid_lock, flags); asid = atomic64_read(\u0026amp;mm-\u0026gt;context.id); if ((asid ^ atomic64_read(\u0026amp;asid_generation)) \u0026gt;\u0026gt; asid_bits) { asid = new_context(mm, cpu); atomic64_set(\u0026amp;mm-\u0026gt;context.id, asid); } if (cpumask_test_and_clear_cpu(cpu, \u0026amp;tlb_flush_pending)) local_flush_tlb_all(); atomic64_set(\u0026amp;per_cpu(active_asids, cpu), asid); raw_spin_unlock_irqrestore(\u0026amp;cpu_asid_lock, flags); switch_mm_fastpath: if (!system_uses_ttbr0_pan()) cpu_switch_mm(mm-\u0026gt;pgd, mm); } 函数new_context负责分配ASID\n// arch/arm64/mm/context.c static u64 new_context(struct mm_struct *mm, unsigned int cpu) { static u32 cur_idx = 1; u64 asid = atomic64_read(\u0026amp;mm-\u0026gt;context.id); u64 generation = atomic64_read(\u0026amp;asid_generation); if (asid != 0) { u64 newasid = generation | (asid \u0026amp; ~ASID_MASK); if (check_update_reserved_asid(asid, newasid)) return newasid; asid \u0026amp;= ~ASID_MASK; if (!__test_and_set_bit(asid, asid_map)) return newasid; } asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, cur_idx); if (asid != NUM_USER_ASIDS) goto set_asid; generation = atomic64_add_return_relaxed(ASID_FIRST_VERSION, \u0026amp;asid_generation); flush_context(cpu); asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, 1); set_asid: __set_bit(asid, asid_map); cur_idx = asid; return asid | generation; } 函数flush_context负责重新初始化ASID分配状态\n// arch/arm64/mm/context.c static void flush_context(unsigned int cpu) { int i; u64 asid; bitmap_clear(asid_map, 0, NUM_USER_ASIDS); … smp_wmb(); for_each_possible_cpu(i) { asid = atomic64_xchg_relaxed(\u0026amp;per_cpu(active_asids, i), 0); if (asid == 0) asid = per_cpu(reserved_asids, i); __set_bit(asid \u0026amp; ~ASID_MASK, asid_map); per_cpu(reserved_asids, i) = asid; } cpumask_setall(\u0026amp;tlb_flush_pending); } 3.12.4　虚拟机标识符 虚拟机里面运行的客户操作系统的虚拟地址转换成物理地址分两个阶段： 第 1 阶段把虚拟地址转换成中间物理地址 第 2 阶段把中间物理地址转换成物理地址 第 1 阶段转换由客户操作系统的内核控制，和非虚拟化的转换过程相同。第 2 阶段转换由虚拟机监控器控制，虚拟机监控器为每个虚拟机维护一个转换表，分配一个虚拟机标识符(Virtual Machine Identifier，VMID)，寄存器VTTBR_EL2(虚拟化转换表基准寄存器，Virtualization Translation Table Base Register)存放当前虚拟机的阶段2转换表的物理地址\n3.13　巨型页 使用长度为2MB甚至更大的巨型页，可以大幅减少TLB未命中和缺页异常的数量，大幅提高应用程序的性能 (1)使用hugetlbfs伪文件系统实现巨型页 (2)透明巨型页 3.13.1　处理器对巨型页的支持 ARM64处理器支持巨型页的方式有两种 (1)通过块描述符支持 (2)通过页/块描述符的连续位支持 页长度为4KB时通过块描述符支持巨型页 页长度为4KB时通过页/块描述符的连续位支持巨型页 3.13.2　标准巨型页 编译内核时需要打开配置宏CONFIG_HUGETLBFS和CONFIG_HUGETLB_PAGE 文件“/proc/sys/vm/nr_hugepages”指定巨型页池中永久巨型页的数量 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 待补充 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n3.13.3　透明巨型页 (1)分配透明巨型页 函数handle_mm_fault是页错误异常处理程序的核心函数，如果触发异常的虚拟内存区域使用普通页或透明巨型页，把主要工作委托给函数__handle_mm_fault 透明巨型页的页错误异常处理 函数create_huge_pmd负责分配页中间目录级别的巨型页 3.14　页错误异常处理 虚拟页没有映射到物理页，或者没有访问权限，处理器将生成页错误异常 缺页异常,虚拟页没有映射到物理页 (1)访问用户栈的时候，超出了当前用户栈的范围，需要扩大用户栈 (2)进程申请虚拟内存区域的时候，通常没有分配物理页，进程第一次访问的时候触发页错误异常 (3)内存不足的时候，内核把进程的匿名页换出到交换区 (4)一个文件页被映射到进程的虚拟地址空间，内存不足的时候 (5)程序错误，访问没有分配给进程的虚拟内存区域 没有访问权限，两种情况 (1)写时复制(Copy on Write，CoW) 页错误异常处理程序成功地把虚拟页映射到物理页 (2)程序错误，发送段违法(SIGSEGV)信号以杀死进程 3.14.1　处理器架构特定部分 1.生成页错误异常 ARM64处理器在取指令或数据，需把虚拟地址转换成物理地址，分两种情况 (1)虚拟地址的高16位不是全1或全0，是非法地址，生成页错误异常 (2)虚拟地址的高16位是全1或全0，内存管理单元根据关键字{地址空间标识符，虚拟地址}查找TLB 寄存器TTBR1_EL1存放内核的页全局目录的物理地址，寄存器TTBR0_EL1存放进程的页全局目录的物理地址 命中了TLB表项，从TLB表项读取访问权限，检查访问权限，如果没有访问权限，生成页错误异常 没有命中TLB表项，内存管理单元将会查询内存中的页表，称为转换表遍历（translation table walk），分两种情况 （1）虚拟地址的高16位全部是1，是内核虚拟地址，查询内核的页表，从寄存器TTBR1_EL1取内核的页全局目录的物理地址 （2）虚拟地址的高16位全部是0，用户虚拟地址，查询进程的页表，从寄存器TTBR0_EL1取进程的页全局目录的物理地址 2.处理页错误异常 ARM64架构的内核异常向量表，起始地址是vectors（源文件arch/arm64/ kernel/entry.S），每个异常向量的长度是128字节，在Linux内核中每个异常向量只有一条指令：跳转到对应的处理程序。异常向量表的虚拟地址存放在异常级别1的向量基准地址寄存器(Vector Base Address Register for Exception Level 1，VBAR_EL1)中\nARM64处理器处理页错误异常 (1)异常类型是异常级别1生成的同步异常，异常向量的偏移是0x200，异常向量跳转到函数el1_sync (2)异常类型是64位用户程序在异常级别0生成的同步异常，异常向量的偏移是0x400，异常向量跳转到函数el0_sync (3)异常类型是32位用户程序在异常级别0生成的同步异常，异常向量的偏移是0x600，异常向量跳转到函数el0_sync_compat 函数el0_sync根据异常级别1的异常症状寄存器的异常类别字段处理 (1)异常类别是异常级别0生成的数据中止(data abort)，即在异常级别0访问数据时生成页错误异常，调用函数el0_da (2)异常类别是异常级别0生成的指令中止(instruction abort)，即在异常级别0取指令时生成页错误异常，调用函数el0_ia ARM64处理器，异常级别1的异常症状寄存器(ESR_EL1，Exception Syndrome Register for Exception Level 1)用来存放异常的症状信息 EC：异常类别(Exception Class)，指示引起异常的原因 ISS：指令特定症状 （1）do_mem_abort函数 do_mem_abort函数根据异常症状寄存器的指令特定症状字段的指令错误状态码，调用数组fault_info中处理函数 指令错误状态码和处理函数的对应关系\n指令错误状态码 说　明 处 理 函 数 4 0级转换错误 do_translation_fault 5 1级转换错误 do_translation_fault 6 2级转换错误 do_translation_fault 7 3级转换错误 do_page_fault 9 1级访问标志错误 do_page_fault 10 2级访问标志错误 do_page_fault 11 3级访问标志错误 do_page_fault 13 1级权限错误 do_page_fault 14 2级权限错误 do_page_fault 15 3级权限错误 do_page_fault 33 对齐错误 do_alignment_fault 其他 其他错误 do_bad （2）do_translation_fault函数 do_translation_fault处理在0级、1级或2级转换表中匹配的表项是无效描述符\n// arch/arm64/mm/fault.c // addr触发异常的虚拟地址 esr异常症状状态寄存器值 regs指向内核栈中保存的被打断的进程的寄存器集合 static int __kprobes do_translation_fault(unsigned long addr, unsigned int esr, struct pt_regs *regs) { if (addr \u0026lt; TASK_SIZE) return do_page_fault(addr, esr, regs); // 虚拟地址是用户虚拟地址 // 异常虚拟地址是内核虚拟地址或不规范地址 do_bad_area(addr, esr, regs); return 0; } do_bad_area\n// arch/arm64/mm/fault.c static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs) { struct task_struct *tsk = current; struct mm_struct *mm = tsk-\u0026gt;active_mm; const struct fault_info *inf; if (user_mode(regs)) { inf = esr_to_fault_info(esr); // 异常是在用户模式 __do_user_fault(tsk, addr, esr, inf-\u0026gt;sig, inf-\u0026gt;code, regs); // 发送信号以杀死进程 } else __do_kernel_fault(mm, addr, esr, regs); // 异常是在内核模式下生成 } （3）函数do_page_fault\n函数do_page_fault的执行流 // arch/arm64/mm/fault.c linux4.x static int __kprobes do_page_fault(unsigned long addr, unsigned int esr, struct pt_regs *regs) { struct task_struct *tsk; struct mm_struct *mm; int fault, sig, code; unsigned long vm_flags = VM_READ | VM_WRITE; unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE; … tsk = current; mm = tsk-\u0026gt;mm; // 禁止执行页错误异常处理程序，或者处于原子上下文，或者当前进程是内核线程 if (faulthandler_disabled() || !mm) goto no_context; if (user_mode(regs)) mm_flags |= FAULT_FLAG_USER; if (is_el0_instruction_abort(esr)) { vm_flags = VM_EXEC; } else if ((esr \u0026amp; ESR_ELx_WNR) \u0026amp;\u0026amp; !(esr \u0026amp; ESR_ELx_CM)) { vm_flags = VM_WRITE; mm_flags |= FAULT_FLAG_WRITE; } if (addr \u0026lt; USER_DS \u0026amp;\u0026amp; is_permission_fault(esr, regs, addr)) { /* 如果从异常级别0进入，regs-\u0026gt;orig_addr_limit可能是0 */ if (regs-\u0026gt;orig_addr_limit == KERNEL_DS) die(\u0026#34;Accessing user space memory with fs=KERNEL_DS\u0026#34;, regs, esr); if (is_el1_instruction_abort(esr)) die(\u0026#34;Attempting to execute userspace memory\u0026#34;, regs, esr); if (!search_exception_tables(regs-\u0026gt;pc)) die(\u0026#34;Accessing user space memory outside uaccess.h routines\u0026#34;, regs, esr); } if (!down_read_trylock(\u0026amp;mm-\u0026gt;mmap_sem)) { if (!user_mode(regs) \u0026amp;\u0026amp; !search_exception_tables(regs-\u0026gt;pc)) goto no_context; retry: down_read(\u0026amp;mm-\u0026gt;mmap_sem); } else { might_sleep(); … } fault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk); if ((fault \u0026amp; VM_FAULT_RETRY) \u0026amp;\u0026amp; fatal_signal_pending(current)) return 0; … if (mm_flags \u0026amp; FAULT_FLAG_ALLOW_RETRY) { if (fault \u0026amp; VM_FAULT_MAJOR) { tsk-\u0026gt;maj_flt++; … } else { tsk-\u0026gt;min_flt++; … } if (fault \u0026amp; VM_FAULT_RETRY) { mm_flags \u0026amp;= ~FAULT_FLAG_ALLOW_RETRY; mm_flags |= FAULT_FLAG_TRIED; goto retry; } } up_read(\u0026amp;mm-\u0026gt;mmap_sem); if (likely(!(fault \u0026amp; (VM_FAULT_ERROR | VM_FAULT_BADMAP | VM_FAULT_BADACCESS)))) return 0; if (!user_mode(regs)) goto no_context; if (fault \u0026amp; VM_FAULT_OOM) { pagefault_out_of_memory(); return 0; } if (fault \u0026amp; VM_FAULT_SIGBUS) { sig = SIGBUS; code = BUS_ADRERR; } else { sig = SIGSEGV; code = fault == VM_FAULT_BADACCESS ? SEGV_ACCERR : SEGV_MAPERR; } __do_user_fault(tsk, addr, esr, sig, code, regs); return 0; no_context: __do_kernel_fault(mm, addr, esr, regs); return 0; } 原子上下文：执行硬中断、执行软中断、禁止硬中断、禁止软中断和禁止内核抢占这五种情况不允许睡眠，称为原子上下文 函数__do_page_fault的执行流程 // arch/arm64/mm/fault.c static int __do_page_fault(struct mm_struct *mm, unsigned long addr, unsigned int mm_flags, unsigned long vm_flags, struct task_struct *tsk) { struct vm_area_struct *vma; int fault; vma = find_vma(mm, addr); fault = VM_FAULT_BADMAP; if (unlikely(!vma)) goto out; if (unlikely(vma-\u0026gt;vm_start \u0026gt; addr)) goto check_stack; good_area: if (!(vma-\u0026gt;vm_flags \u0026amp; vm_flags)) { fault = VM_FAULT_BADACCESS; goto out; } return handle_mm_fault(vma, addr \u0026amp; PAGE_MASK, mm_flags); check_stack: if (vma-\u0026gt;vm_flags \u0026amp; VM_GROWSDOWN \u0026amp;\u0026amp; !expand_stack(vma, addr)) goto good_area; out: return fault; } 3.14.2　用户空间页错误异常 函数handle_mm_fault处理用户空间的页错误异常，两种情况： (1)进程在用户模式下访问用户虚拟地址，生成页错误异常 (2)进程在内核模式下访问用户虚拟地址，生成页错误异常。进程通过系统调用进入内核模式，系统调用传入用户空间的缓冲区，进程在内核模式下访问用户空间的缓冲区 // mm/memory.c int handle_mm_fault(struct vm_area_struct *vma, unsigned long address, unsigned int flags) { … if (unlikely(is_vm_hugetlb_page(vma))) ret = hugetlb_fault(vma-\u0026gt;vm_mm, vma, address, flags); else ret = __handle_mm_fault(vma, address, flags); … } 巨型页函数hugetlb_fault，普通页__handle_mm_fault\n// mm/memory.c static int __handle_mm_fault(struct vm_area_struct *vma, unsigned long address, unsigned int flags) { struct vm_fault vmf = { .vma = vma, .address = address \u0026amp; PAGE_MASK, .flags = flags, .pgoff = linear_page_index(vma, address), .gfp_mask = __get_fault_gfp_mask(vma), }; struct mm_struct *mm = vma-\u0026gt;vm_mm; pgd_t *pgd; p4d_t *p4d; int ret; // 在页全局目录中查找虚拟地址对应的表项 pgd = pgd_offset(mm, address); p4d = p4d_alloc(mm, pgd, address); // 在页四级目录中查找虚拟地址对应的表项 if (!p4d) return VM_FAULT_OOM; // 在页上层目录中查找虚拟地址对应的表项 vmf.pud = pud_alloc(mm, p4d, address); if (!vmf.pud) return VM_FAULT_OOM; … // 在页中间目录中查找虚拟地址对应的表项 vmf.pmd = pmd_alloc(mm, vmf.pud, address); if (!vmf.pmd) return VM_FAULT_OOM; … // 到达直接页表 return handle_pte_fault(\u0026amp;vmf); } // mm/memory.c static int handle_pte_fault(struct vm_fault *vmf) { pte_t entry; // 直接页表中查找虚拟地址对应的表项 if (unlikely(pmd_none(*vmf-\u0026gt;pmd))) { vmf-\u0026gt;pte = NULL; } else { … vmf-\u0026gt;pte = pte_offset_map(vmf-\u0026gt;pmd, vmf-\u0026gt;address); vmf-\u0026gt;orig_pte = *vmf-\u0026gt;pte; barrier(); if (pte_none(vmf-\u0026gt;orig_pte)) { pte_unmap(vmf-\u0026gt;pte); vmf-\u0026gt;pte = NULL; } } // 页表项不存在 if (!vmf-\u0026gt;pte) { if (vma_is_anonymous(vmf-\u0026gt;vma)) return do_anonymous_page(vmf); else return do_fault(vmf); } // 页表项存在，但是页不在物理内存 if (!pte_present(vmf-\u0026gt;orig_pte)) return do_swap_page(vmf); … vmf-\u0026gt;ptl = pte_lockptr(vmf-\u0026gt;vma-\u0026gt;vm_mm, vmf-\u0026gt;pmd); // 获取页表锁的地址 spin_lock(vmf-\u0026gt;ptl); // 锁住页表 entry = vmf-\u0026gt;orig_pte; if (unlikely(!pte_same(*vmf-\u0026gt;pte, entry))) // 重新读取页表项的值 goto unlock; if (vmf-\u0026gt;flags \u0026amp; FAULT_FLAG_WRITE) { if (!pte_write(entry)) return do_wp_page(vmf); // 执行写时复制 entry = pte_mkdirty(entry); // 页表项有写权限 } entry = pte_mkyoung(entry); // 设置页表项的访问标志位 if (ptep_set_access_flags(vmf-\u0026gt;vma, vmf-\u0026gt;address, vmf-\u0026gt;pte, entry, vmf-\u0026gt;flags \u0026amp; FAULT_FLAG_WRITE)) { // 设置页表项 update_mmu_cache(vmf-\u0026gt;vma, vmf-\u0026gt;address, vmf-\u0026gt;pte); // 更新处理器的内存管理单元的页表缓存 } else { if (vmf-\u0026gt;flags \u0026amp; FAULT_FLAG_WRITE) flush_tlb_fix_spurious_fault(vmf-\u0026gt;vma, vmf-\u0026gt;address); } unlock: // 释放页表的锁 pte_unmap_unlock(vmf-\u0026gt;pte, vmf-\u0026gt;ptl); return 0; } 1．匿名页的缺页异常 函数do_anonymous_page处理私有匿名页的缺页异常\n// mm/memory.c static int do_anonymous_page(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u0026gt;vma; … struct page *page; pte_t entry; /* 没有“-\u0026gt;vm_ops”的文件映射？ */ if (vma-\u0026gt;vm_flags \u0026amp; VM_SHARED) return VM_FAULT_SIGBUS; // 直接页表不存在，分配页表 if (pte_alloc(vma-\u0026gt;vm_mm, vmf-\u0026gt;pmd, vmf-\u0026gt;address)) return VM_FAULT_OOM; … /* 如果是读操作，映射到零页 */ if (!(vmf-\u0026gt;flags \u0026amp; FAULT_FLAG_WRITE) \u0026amp;\u0026amp; !mm_forbids_zeropage(vma-\u0026gt;vm_mm)) { entry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf-\u0026gt;address), vma-\u0026gt;vm_page_prot)); vmf-\u0026gt;pte = pte_offset_map_lock(vma-\u0026gt;vm_mm, vmf-\u0026gt;pmd, vmf-\u0026gt;address, \u0026amp;vmf-\u0026gt;ptl); if (!pte_none(*vmf-\u0026gt;pte)) goto unlock; … goto setpte; } /* 分配我们自己的私有页 */ if (unlikely(anon_vma_prepare(vma))) goto oom; page = alloc_zeroed_user_highpage_movable(vma, vmf-\u0026gt;address); if (!page) goto oom; … __SetPageUptodate(page); entry = mk_pte(page, vma-\u0026gt;vm_page_prot); if (vma-\u0026gt;vm_flags \u0026amp; VM_WRITE) entry = pte_mkwrite(pte_mkdirty(entry)); vmf-\u0026gt;pte = pte_offset_map_lock(vma-\u0026gt;vm_mm, vmf-\u0026gt;pmd, vmf-\u0026gt;address, \u0026amp;vmf-\u0026gt;ptl); if (!pte_none(*vmf-\u0026gt;pte)) goto release; … inc_mm_counter_fast(vma-\u0026gt;vm_mm, MM_ANONPAGES); page_add_new_anon_rmap(page, vma, vmf-\u0026gt;address, false); … lru_cache_add_active_or_unevictable(page, vma); setpte: set_pte_at(vma-\u0026gt;vm_mm, vmf-\u0026gt;address, vmf-\u0026gt;pte, entry); /* 不需要从页表缓存删除页表项，因为以前虚拟页没有映射到物理页 */ update_mmu_cache(vma, vmf-\u0026gt;address, vmf-\u0026gt;pte); unlock: pte_unmap_unlock(vmf-\u0026gt;pte, vmf-\u0026gt;ptl); return 0; release: … put_page(page); goto unlock; oom_free_page: put_page(page); oom: return VM_FAULT_OOM; } 2．文件页的缺页异常 触发文件页的缺页异常: (1)启动程序时，第一次访问的时候触发文件页的缺页异常 (2)进程使用mmap创建文件映射，第一次访问的时候触发文件页的缺页异常 函数do_fault处理文件页和共享匿名页的缺页异常 // mm/memory.c static int do_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u0026gt;vma; int ret; /* 这个vm_area_struct结构体在执行mmap()的时候没有完全填充，或者缺少标志位VM_DONTEXPAND。 */ if (!vma-\u0026gt;vm_ops-\u0026gt;fault) ret = VM_FAULT_SIGBUS; else if (!(vmf-\u0026gt;flags \u0026amp; FAULT_FLAG_WRITE)) // 缺页异常是由读文件页触发 ret = do_read_fault(vmf); // 处理读文件页错误 else if (!(vma-\u0026gt;vm_flags \u0026amp; VM_SHARED)) // 缺页异常是由写私有文件页触发 ret = do_cow_fault(vmf); // 写私有文件页错误, 执行写时复制 else // 缺页异常是由写共享文件页触发 ret = do_shared_fault(vmf); // 处理写共享文件页错误 … return ret; } （1）处理读文件页错误 // mm/memory.c static int do_read_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u0026gt;vma; int ret = 0; // 全局变量fault_around_bytes控制总长度，默认值是64KB。如果页长度是4KB，就一次读取16页 if (vma-\u0026gt;vm_ops-\u0026gt;map_pages \u0026amp;\u0026amp; fault_around_bytes \u0026gt;\u0026gt; PAGE_SHIFT \u0026gt; 1) { ret = do_fault_around(vmf); if (ret) return ret; } // 文件页读到文件的页缓存中 ret = __do_fault(vmf); if (unlikely(ret \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) return ret; // 虚拟页映射到文件的页缓存中的物理页 ret |= finish_fault(vmf); unlock_page(vmf-\u0026gt;page); if (unlikely(ret \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) put_page(vmf-\u0026gt;page); return ret; } 函数finish_fault负责设置页表项，把主要工作委托给函数alloc_set_pte\n函数finish_fault的执行流程 // mm/memory.c int alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg, struct page *page) { struct vm_area_struct *vma = vmf-\u0026gt;vma; bool write = vmf-\u0026gt;flags \u0026amp; FAULT_FLAG_WRITE; pte_t entry; int ret; … if (!vmf-\u0026gt;pte) { // 直接页表不存在，分配直接页表 ret = pte_alloc_one_map(vmf); if (ret) return ret; } /* 锁住页表后重新检查 */ if (unlikely(!pte_none(*vmf-\u0026gt;pte))) return VM_FAULT_NOPAGE; // 直接页表不存在，那么分配直接页表 flush_icache_page(vma, page); entry = mk_pte(page, vma-\u0026gt;vm_page_prot); // 使用页帧号和访问权限生成页表项的值 if (write) // 写访问，设置页表项的脏标志位和写权限位 entry = maybe_mkwrite(pte_mkdirty(entry), vma); /* 写时复制的页 */ if (write \u0026amp;\u0026amp; !(vma-\u0026gt;vm_flags \u0026amp; VM_SHARED)) { inc_mm_counter_fast(vma-\u0026gt;vm_mm, MM_ANONPAGES); page_add_new_anon_rmap(page, vma, vmf-\u0026gt;address, false); … lru_cache_add_active_or_unevictable(page, vma); } else { inc_mm_counter_fast(vma-\u0026gt;vm_mm, mm_counter_file(page)); page_add_file_rmap(page, false); } set_pte_at(vma-\u0026gt;vm_mm, vmf-\u0026gt;address, vmf-\u0026gt;pte, entry); /* 不需要使无效：一个不存在的页不会被缓存 */ update_mmu_cache(vma, vmf-\u0026gt;address, vmf-\u0026gt;pte); return 0; } // mm/memory.c static int do_cow_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u0026gt;vma; int ret; if (unlikely(anon_vma_prepare(vma))) return VM_FAULT_OOM; // 关联一个anon_vma实例到虚拟内存区域 vmf-\u0026gt;cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-\u0026gt;address); if (!vmf-\u0026gt;cow_page) return VM_FAULT_OOM; … ret = __do_fault(vmf); // 把文件页读到文件的页缓存 if (unlikely(ret \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) goto uncharge_out; if (ret \u0026amp; VM_FAULT_DONE_COW) return ret; // 把文件的页缓存中物理页的数据复制到副本物理页 copy_user_highpage(vmf-\u0026gt;cow_page, vmf-\u0026gt;page, vmf-\u0026gt;address, vma); __SetPageUptodate(vmf-\u0026gt;cow_page); // 设置副本页描述符的标志位PG_uptodate，表示物理页包含有效的数据 // 设置页表项，把虚拟页映射到副本物理页 ret |= finish_fault(vmf); unlock_page(vmf-\u0026gt;page); put_page(vmf-\u0026gt;page); if (unlikely(ret \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) goto uncharge_out; return ret; uncharge_out: … put_page(vmf-\u0026gt;cow_page); return ret; } // mm/memory.c static int do_shared_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u0026gt;vma; int ret, tmp; // 把文件页读到文件的页缓存中 ret = __do_fault(vmf); if (unlikely(ret \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) return ret; if (vma-\u0026gt;vm_ops-\u0026gt;page_mkwrite) { unlock_page(vmf-\u0026gt;page); tmp = do_page_mkwrite(vmf); if (unlikely(!tmp || (tmp \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) { put_page(vmf-\u0026gt;page); return tmp; } } // 设置页表项，把虚拟页映射到文件的页缓存中的物理页 ret |= finish_fault(vmf); if (unlikely(ret \u0026amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) { unlock_page(vmf-\u0026gt;page); put_page(vmf-\u0026gt;page); return ret; } // 设置页的脏标志位，表示页的数据被修改 fault_dirty_shared_page(vma, vmf-\u0026gt;page); return ret; } 3．写时复制 两种情况会执行写时复制(Copy on Write，CoW) (1)进程分叉生成子进程的时候，为了避免复制物理页，子进程和父进程以只读方式共享所有私有的匿名页和文件页 (2)进程创建私有的文件映射，然后读访问，触发页错误异常 函数do_wp_page处理写时复制\n函数wp_page_copy执行写时复制\n// mm/memory.c static int wp_page_copy(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u0026gt;vma; struct mm_struct *mm = vma-\u0026gt;vm_mm; struct page *old_page = vmf-\u0026gt;page; struct page *new_page = NULL; pte_t entry; int page_copied = 0; const unsigned long mmun_start = vmf-\u0026gt;address \u0026amp; PAGE_MASK; const unsigned long mmun_end = mmun_start + PAGE_SIZE; struct mem_cgroup *memcg; // 关联一个anon_vma实例到虚拟内存区域 if (unlikely(anon_vma_prepare(vma))) goto oom; if (is_zero_pfn(pte_pfn(vmf-\u0026gt;orig_pte))) { // 是零页，分配一个物理页，然后用零初始化 new_page = alloc_zeroed_user_highpage_movable(vma,vmf-\u0026gt;address); if (!new_page) goto oom; } else { // 不是零页，分配一个物理页，然后把数据复制到新的物理页 new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-\u0026gt;address); if (!new_page) goto oom; cow_user_page(new_page, old_page, vmf-\u0026gt;address, vma); } … // 不是零页，那么分配一个物理页，然后把数据复制到新的物理页 __SetPageUptodate(new_page); // mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end); vmf-\u0026gt;pte = pte_offset_map_lock(mm, vmf-\u0026gt;pmd, vmf-\u0026gt;address, \u0026amp;vmf-\u0026gt;ptl); // 锁住页表 if (likely(pte_same(*vmf-\u0026gt;pte, vmf-\u0026gt;orig_pte))) { … flush_cache_page(vma, vmf-\u0026gt;address, pte_pfn(vmf-\u0026gt;orig_pte)); // 从缓存中冲刷页 // 使用新的物理页和访问权限生成页表项的值 entry = mk_pte(new_page, vma-\u0026gt;vm_page_prot); entry = maybe_mkwrite(pte_mkdirty(entry), vma); // 把页表项清除，并且冲刷页表缓存 ptep_clear_flush_notify(vma, vmf-\u0026gt;address, vmf-\u0026gt;pte); // 建立新物理页到虚拟页的反向映射 page_add_new_anon_rmap(new_page, vma, vmf-\u0026gt;address, false); … // 把物理页添加到活动LRU链表或不可回收LRU链表中，页回收算法需要从LRU链表中选择需要回收的物理页 lru_cache_add_active_or_unevictable(new_page, vma); // 修改页表项 set_pte_at_notify(mm, vmf-\u0026gt;address, vmf-\u0026gt;pte, entry); // 更新页表缓存 update_mmu_cache(vma, vmf-\u0026gt;address, vmf-\u0026gt;pte); if (old_page) { // 删除旧物理页到虚拟页的反向映射 page_remove_rmap(old_page, false); } /* 释放旧的物理页 */ new_page = old_page; page_copied = 1; } else { … } if (new_page) put_page(new_page); // 释放页表的锁 pte_unmap_unlock(vmf-\u0026gt;pte, vmf-\u0026gt;ptl); mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end); if (old_page) { if (page_copied \u0026amp;\u0026amp; (vma-\u0026gt;vm_flags \u0026amp; VM_LOCKED)) { lock_page(old_page); if (PageMlocked(old_page)) munlock_vma_page(old_page); unlock_page(old_page); } put_page(old_page); } return page_copied ? VM_FAULT_WRITE : 0; oom_free_new: put_page(new_page); oom: if (old_page) put_page(old_page); return VM_FAULT_OOM; } 3.14.3　内核模式页错误异常 内核使用线性映射区域的虚拟地址，在内存管理子系统初始化的时把虚拟地址映射到物理地址，运行过程中使用vmalloc()函数从vmalloc区域分配虚拟内存区域，vmalloc()函数会分配并且映射到物理页 有些系统调用会传入用户空间的缓冲区，内核必须使用头文件“uaccess.h”定义的专用函数访问用户空间的缓冲区，专用函数在异常表中添加了可能触发异常的指令地址和异常修正程序的地址。如果访问用户空间的缓冲区时生成页错误异常，页错误异常处理程序发现用户虚拟地址没有被分配给进程，就在异常表中查找指令地址对应的异常修正程序，如果找到了，使用异常修正程序修正异常，避免内核崩溃 在内核模式下执行时触发页错误异常，ARM64架构内核的处理流程，3种处理方式 (1)不允许内核执行用户空间治疗，内核模式执行用户态指令，内核崩溃 (2)内核模式下访问用户虚拟地址，先使用函数__do_page_fault处理，处理失败使用__do_kernel_fault处理 (3)其他情况 __do_kernel_fault处理 1.函数__do_kernel_fault 访问数据生成的异常，函数__do_kernel_fault尝试在异常表中查找异常修正程序 找到异常修正程序，把保存在内核栈中的异常链接寄存器(ELR_EL1，Exception Link Register for Exception Level 1)的值修改为异常修正程序的虚拟地址。当异常处理程序返回的时候，处理器把程序计数器设置成异常链接寄存器的值，执行异常修正程序 如果没有找到异常修正程序，内核崩溃 函数__do_kernel_fault\n// arch/arm64/mm/fault.c static void __do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int esr, struct pt_regs *regs) { const char *msg; // 如果异常是由访问数据生成的，那么在异常表中查找异常修复程序 if (!is_el1_instruction_abort(esr) \u0026amp;\u0026amp; fixup_exception(regs)) return; // 清除任何可能阻止在终端打印信息的自旋锁 bust_spinlocks(1); if (is_permission_fault(esr, regs, addr)) { if (esr \u0026amp; ESR_ELx_WNR) msg = \u0026#34;write to read-only memory\u0026#34;; else msg = \u0026#34;read from unreadable memory\u0026#34;; } else if (addr \u0026lt; PAGE_SIZE) { msg = \u0026#34;NULL pointer dereference\u0026#34;; } else { msg = \u0026#34;paging request\u0026#34;; } // 打印触发页错误异常的原因 pr_alert(\u0026#34;Unable to handle kernel %s at virtual address %08lx\\n\u0026#34;, msg, addr); // 打印页表信息 show_pte(mm, addr); die(\u0026#34;Oops\u0026#34;, regs, esr); // 调用函数die()以打印寄存器信息 bust_spinlocks(0); // 停止清除任何可能阻止打印信息的自旋锁 do_exit(SIGKILL); // 终止当前进程 } 函数fixup_exception根据指令地址在异常表中查找，然后把保存在内核栈中的异常链接寄存器的值修改为异常修正程序的虚拟地址\n// arch/arm64/mm/extable.c int fixup_exception(struct pt_regs *regs) { const struct exception_table_entry *fixup; fixup = search_exception_tables(instruction_pointer(regs)); if (fixup) regs-\u0026gt;pc = (unsigned long)\u0026amp;fixup-\u0026gt;fixup + fixup-\u0026gt;fixup; return fixup != NULL; } 异常表项中存储的指令地址是相对地址：fixup-\u0026gt;insn =（指令的虚拟地址 − \u0026amp;fixup-\u0026gt;insn） 异常表项中存储的异常修正程序的地址是相对地址：fixup-\u0026gt;fixup =（异常修正程序的虚拟地址 − \u0026amp;fixup-\u0026gt;fixup） regs-\u0026gt;pc是保存在内核栈中的异常链接寄存器的值 函数search_exception_tables根据指令地址在异常表中查找表项\n// kernel/extable.c const struct exception_table_entry *search_exception_tables(unsigned long addr) { const struct exception_table_entry *e; // 在内核的异常表中查找 e = search_extable(__start___ex_table, __stop___ex_table-1, addr); if (!e) // 在内核的异常表中没有找到，根据触发异常的指令的虚拟地址找到内核模块， e = search_module_extables(addr); // 在内核模块的异常表中查找 return e; } 2.异常表 进程在内核模式下运行的时候，访问用户虚拟地址时，应用程序通常是不可信任的，不能保证传入的用户虚拟地址是合法的，采取措施保护内核。使用异常表，每条表项有两个字段 (1)触发异常的指令的虚拟地址 (2)异常修正程序的起始虚拟地址 异常表项定义\n// arch/arm64/include/asm/extable.h struct exception_table_entry { int insn, fixup; }; 内核有一张异常表，全局变量__start___ex_table存放异常表的起始地址，__stop___ex_table存放异常表的结束地址 进程在内核模式下访问用户虚拟地址的时候，只允许使用头文件“uaccess.h”声明的函数，以函数get_user为例，函数get_user从用户空间读取C语言标准类型的数据，ARM64架构实现 // arch/arm64/include/asm/uaccess.h #define get_user(x, ptr) \\ ({ \\ __typeof__(*(ptr)) __user *__p = (ptr); \\ might_fault(); \\ access_ok(VERIFY_READ, __p, sizeof(*__p)) ? \\ __get_user((x), __p) : \\ ((x) = 0, -EFAULT); \\ }) 在64位内核中长整数的长度是8字节，把“__get_user((x), __p)”展开\nasm volatile( \\ \u0026#34;1: ldr %x1, [%2]\\n\u0026#34;, \\ \u0026#34;2:\\n\u0026#34; \\ \u0026#34; .section .fixup, \\\u0026#34;ax\\\u0026#34;\\n\u0026#34; \\ \u0026#34; .align 2\\n\u0026#34; \\ \u0026#34;3: mov %w0, %3\\n\u0026#34; \\ \u0026#34; mov %1, #0\\n\u0026#34; \\ \u0026#34; b 2b\\n\u0026#34; \\ \u0026#34; .previous\\n\u0026#34; \\ \u0026#34; .pushsection __ex_table, \\\u0026#34;a\\\u0026#34;\\n\u0026#34; \\ \u0026#34; .align 3\\n\u0026#34; \\ \u0026#34; .long (1b - .), (3b - .)\\n\u0026#34; \\ \u0026#34; .popsection\\n\u0026#34; : \u0026#34;+r\u0026#34; (err), \u0026#34;=\u0026amp;r\u0026#34; (x) \\ : \u0026#34;r\u0026#34; (__p), \u0026#34;i\u0026#34; (-EFAULT)) 链接脚本\n// arch/arm64/kernel/vmlinux.lds.S … . = ALIGN(SEGMENT_ALIGN); _etext = .; /* 代码段的结束地址 */ RO_DATA(PAGE_SIZE) /* 从这里到 */ EXCEPTION_TABLE(8) /* __init_begin将被标记为只读和不可执行 */ NOTES … // 宏EXCEPTION_TABLE的定义 // include/asm-generic/vmlinux.lds.h // 异常表 #define EXCEPTION_TABLE(align) \\ . = ALIGN(align); \\ __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) { \\ VMLINUX_SYMBOL(__start___ex_table) = .; \\ KEEP(*(__ex_table)) \\ VMLINUX_SYMBOL(__stop___ex_table) = .; \\ } 内核的全局变量__start___ex_table存放异常表节（__ex_table）的起始地址，__stop___ex_table存放异常表节的结束地址 3.15　反碎片技术 反碎片技术 (1)2.6.23版本引入了虚拟可移动区域 (2)3.5版本内存碎片整理技术 (3).6.24版本引入了根据可移动性分组的技术 (4).6.35版本引入了内存碎片整理技术 3.15.1　虚拟可移动区域 可移动区域(ZONE_MOVABLE)是一个伪内存区域：把物理内存分为两个区域，一个区域用于分配不可移动的页，另一个区域用于分配可移动的页\n3.15.2　内存碎片整理 内存碎片整理(memory compaction，意译为“内存碎片整理”)：从内存区域的底部扫描已分配的可移动页，从内存区域的顶部扫描空闲页，把底部的可移动页移到顶部的空闲页，在底部形成连续的空闲页 1.使用方法 内存碎片整理功能，必须开启配置文件“mm/Kconfig”定义的配置宏CONFIG_COMPACTION，默认开启\n3.16　页回收 申请分配页的时候，页分配器首先尝试使用低水线分配页。如果使用低水线分配失败，说明内存轻微不足，页分配器将会唤醒内存节点的页回收内核线程，异步回收页，然后尝试使用最低水线分配页。如果使用最低水线分配失败，说明内存严重不足，页分配器将会直接回收页 内核使用LRU（Least Recently Used，最近最少使用）算法选择最近最少使用的物理页\n3.16.1　数据结构 1．LRU链表 页回收算法使用LRU算法选择回收的页。每个内存节点的pglist_data实例有一个成员lruvec，称为LRU向量，LRU向量包含5条LRU链表 待补充\n3.16.2　发起页回收 申请分配页的时候，页分配器首先尝试使用低水线分配页。如果使用低水线分配失败，说明内存轻微不足，页分配器将会唤醒所有符合分配条件的内存节点的页回收线程，异步回收页，然后尝试使用最低水线分配页。如果分配失败，说明内存严重不足，页分配器将会直接回收页。如果直接回收页失败，那么判断是否应该重新尝试回收页 3.16.3　计算扫描的页数 3.16.4　收缩活动页链表 3.16.5　回收不活动页 3.16.6　页交换 3.16.7　回收slab缓存 3.17　内存耗尽杀手 当内存严重不足的时候，页分配器在多次尝试直接页回收失败以后，就会调用内存耗尽杀手（OOM killer，OOM是“Out of Memory”的缩写），选择进程杀死，释放内存\nflowchart LR __alloc_pages_showpath[Hard edge] --\u003e|Link text| __alloc_pages_may_oom(Round edge) __alloc_pages_may_oom --\u003e out_of_memeory{Decision} 3.17.1　使用方法 3.17.2　技术原理 3.18　内存资源控制器 控制组(cgroup)的内存资源控制器用来控制一组进程的内存使用量，启用内存资源控制器的控制组简称内存控制组（memcg）。控制组把各种资源控制器称为子系统，内存资源控制器也称为内存子系统\n3.18.1　使用方法 3.18.2　技术原理 3.19　处理器缓存 处理器和内存之间增加了缓存。缓存和内存的区别 (1)缓存是静态随机访问存储器(Static Random Access Memory，SRAM) (2)内存是动态随机访问存储器(Dynamic Random Access Memory，DRAM) 一级缓存分为一级指令缓存(i-cache，instruction cache)和一级数据数据(d-cache，data cache)。二级缓存是指令和数据共享的统一缓存(unified cache) 3.19.1　缓存结构 32KB四路组相连缓存(32KB 4-way set associative cache) 缓存的结构 缓存由多个容量相同的子缓存并联组成，每个子缓存称为路(Way)，四路表示4个子缓存并联\nARM64处理器的指令缓存有3种类型 (1)PIPT缓存 ： 物理地址生成索引和标签的缓存\n(2)VPIPT（VMID-aware PIPT）缓存 (3)VIPT：虚拟地址生成索引、从物理地址生成标签\n3.19.2　缓存策略 缓存分配有两种策略 (1)写分配(write allocation) (2)读分配(read allocation) 缓存更新有两种策略 (1)写回(write back) (2)写透(write-through) 3.19.3 缓存维护 3.ARM64处理器缓存维护 ARM64处理器支持3种缓存操作。 （1）使缓存行失效（invalidate）：清除缓存行的有效位。 （2）清理（clean）缓存行：首先把标记为脏的缓存行里面的数据写到下一级缓存或内存，然后清除缓存行的有效位。只适用于使用写回策略的数据缓存。 （3）清零（zero）：把缓存里面的一个内存块清零，不需要先从内存读数据到缓存中。只适用于数据缓存 3.19.4　SMP缓存一致性 原生的MESI协议有4种状态。MESI是4种状态的首字母缩写，缓存行的4种状态\n3.20 连续内存分配器 连续内存分配器（Contiguous Memory Allocator，CMA）:保留一块大的内存区域，当设备驱动不使用的时候，内核的其他模块可以使用\n3.21 userfaultfd userfaultfd（用户页错误文件描述符）用来拦截和处理用户空间的页错误异常，内核通过文件描述符将页错误异常的信息传递给用户空间，然后由用户空间决定要往虚拟页写入的数据。传统的页错误异常由内核独自处理，现在改为由内核和用户空间一起控制。 userfaultfd是为了解决QEMU/KVM虚拟机动态迁移的问题而出现的。所谓动态迁移，就是将虚拟机从一端迁移到另一端，而在迁移的过程中虚拟机能够继续提供服务，有两种实现方案\n3.22 内存错误检测工具KASAN 内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具，为发现“释放后使用”和“越界访问”这两类缺陷提供了快速和综合的解决方案 KASAN使用编译时插桩（compile-time instrumentation）检查每个内存访问\n第4章 中断、异常和系统调用 4.1 ARM64异常处理 4.1.1 异常级别 ARM64处理器4个异常级别：0~3\nARM64处理器的异常级别 虚拟机里面运行一个操作系统，运行虚拟机的操作系统称为宿主操作系统(host OS)，虚拟机里面的操作系统称为客户操作系统(guest OS) 开源虚拟机管理软件是QEMU，QEMU支持基于内核的虚拟机(Kernel-based Virtual Machine，KVM)。KVM直接在处理器上执行客户操作系统，虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要从异常级别1切换到异常级别2。 ARM64架构的安全扩展定义了两种安全状态：正常世界和安全世界。通过异常级别3的安全监控器切换\n4.1.2 异常分类 ARM64体系结构中，异常分为同步异常和异步异常 同步异常包括： (1)系统调用，异常级别0使用svc(Supervisor Call)指令陷入异常级别1，异常级别1使用hvc(Hypervisor Call)指令陷入异常级别2，异常级别2使用smc(Secure Monitor Call)指令陷入异常级别3 (2)数据中止，即访问数据时的页错误异常，无映射，无写权限 (3)指令中止，取指令时的页错误异常，无映射，无执行权限 (4)栈指针或指令地址没有对齐 (5)没有定义的指令 (6)调试异常 异步异常包括: (1)中断(normal priority interrupt，IRQ)，即普通优先级的中断。 (2)快速中断(fast interrupt FIQ)，高优先级中断 (3)系统错误(System Error SError)，硬件错误触发的异常 4.1.3 异常向量表 存储异常处理程序的内存位置称为异常向量，ARM64处理器的异常级别1、2和3，每个异常级别都有自己的异常向量表，异常向量表的起始虚拟地址存放在寄存器VBAR_ELn(向量基准地址寄存器，Vector Based Address Register)中 地址 异常类型 含义 VBAR_ELn + 0x000 同步异常 当前异常级别生成的异常，使用异常级别0的栈指针寄存器SP_EL0 + 0x080 中断 + 0x100 快速中断 + 0x180 系统错误 + 0x200 同步异常 当前异常级别生成的异常，使用当前异常级别的栈指针寄存器SP_ELn + 0x280 中断 + 0x300 快速中断 + 0x380 系统错误 + 0x400 同步异常 64位应用程序在异常级别（n−1）生成的异常 + 0x480 中断 + 0x500 快速中断 + 0x580 系统错误 + 0x600 同步异常 32位应用程序在异常级别（n−1）生成的异常 + 0x680 中断 + 0x700 快速中断 + 0x780 系统错误 ARM64架构内核定义的异常级别1的异常向量表 // ach/arm64/kernel/entry.S .align 11 ENTRY(vectors) ventry el1_sync_invalid // 异常级别1生成的同步异常，使用栈指针寄存器SP_EL0 ventry el1_irq_invalid // 异常级别1生成的中断，使用栈指针寄存器SP_EL0 ventry el1_fiq_invalid // 异常级别1生成的快速中断，使用栈指针寄存器SP_EL0 ventry el1_error_invalid // 异常级别1生成的系统错误，使用栈指针寄存器SP_EL0 ventry el1_sync // 异常级别1生成的同步异常，使用栈指针寄存器SP_EL1 ventry el1_irq // 异常级别1生成的中断，使用栈指针寄存器SP_EL1 ventry el1_fiq_invalid // 异常级别1生成的快速中断，使用栈指针寄存器SP_EL1 ventry el1_error_invalid // 异常级别1生成的系统错误，使用栈指针寄存器SP_EL1 ventry el0_sync // 64位应用程序在异常级别0生成的同步异常 ventry el0_irq // 64位应用程序在异常级别0生成的中断 ventry el0_fiq_invalid // 64位应用程序在异常级别0生成的快速中断 ventry el0_error_invalid// 64位应用程序在异常级别0生成的系统错误 #ifdef CONFIG_COMPAT /* 表示支持执行32位程序 */ ventry el0_sync_compat // 32位应用程序在异常级别0生成的同步异常 ventry el0_irq_compat // 32位应用程序在异常级别0生成的中断 ventry el0_fiq_invalid_compat // 32位应用程序在异常级别0生成的快速中断 ventry el0_error_invalid_compat// 32位应用程序在异常级别0生成的系统错误 #else ventry el0_sync_invalid // 32位应用程序在异常级别0生成的同步异常 ventry el0_irq_invalid // 32位应用程序在异常级别0生成的中断 ventry el0_fiq_invalid // 32位应用程序在异常级别0生成的快速中断 ventry el0_error_invalid// 32位应用程序在异常级别0生成的系统错误 #endif END(vectors) ventry是一个宏，参数是跳转标号，即异常处理程序的标号\n// arch/arm64/include/asm/assembler.h .macro ventry label .align 7 b \\label .endm // ventry el1_sync展开 .align 7 b el1_sync 启动过程中，0号处理器称为引导处理器，其他处理器称为从处理器。引导处理器在函数__primary_switched()中把寄存器VBAR_EL1设置为异常级别1的异常向量表的起始虚拟地址 _head() -\u0026gt; stext() -\u0026gt; __primary_switch() -\u0026gt; __primary_switched() // arch/arm64/kernel/head.S __primary_switched: … adr_l x8, vectors msr vbar_el1, x8 // 把寄存器VBAR_EL1设置为异常向量表的起始虚拟地址 isb … b start_kernel ENDPROC(__primary_switched) 从处理器在函数__secondary_switched()中把寄存器VBAR_EL1设置为异常级别1的异常向量表的起始虚拟地址\nsecondary_entry() -\u0026gt; secondary_startup() -\u0026gt; __secondary_switched() // arch/arm64/kernel/head.S __secondary_switched: adr_l x5, vectors msr vbar_el1, x5 isb … b secondary_start_kernel ENDPROC(__secondary_switched) 4.1.4 异常处理 处理器取出异常处理的时候，自动执行的操作 (1)把当前的处理器状态（Processor State，PSTATE）保存在寄存器SPSR_EL1（保存程序状态寄存器，Saved Program Status Register）中 (2)把返回地址保存在寄存器ELR_EL1（异常链接寄存器，Exception Link Register）中 系统调用，那么返回地址是系统调用指令后面的指令 除系统调用外的同步异常，那么返回地址是生成异常的指令 异步异常，那么返回地址是没有执行的第一条指令 (3)把处理器状态的DAIF这4个异常掩码位都设置为1，禁止这4种异常，D是调试掩码位（Debug mask bit），A是系统错误掩码位（SError mask bit），I是中断掩码位（IRQ mask bit），F是快速中断掩码位（FIQ mask bit） (4)同步异常或系统错误异常，把生成异常的原因保存在寄存器ESR_EL1（异常症状寄存器，Exception Syndrome Register）中 (5)同步异常，把错误地址保存在寄存器FAR_EL1（错误地址寄存器，Fault Address Register）中 (6)处理器处于用户模式（异常级别0），那么把异常级别提升到1 (7)根据向量基准地址寄存器VBAR_EL1、异常类型和生成异常的异常级别计算出异常向量的虚拟地址，执行异常向量 对于64位应用程序在用户模式（异常级别0）下生成的同步异常，入口是el0_sync\n// arch/arm64/kernel/entry.S el0_sync: kernel_entry 0 // 把所有通用寄存器的值保存在当前进程的内核栈 mrs x25, esr_el1 // 读异常症状寄存器 lsr x24, x25, #ESR_ELx_EC_SHIFT // 异常类别 cmp x24, #ESR_ELx_EC_SVC64 // 64位系统调用 b.eq el0_svc // 系统调用，调用函数el0_svc cmp x24, #ESR_ELx_EC_DABT_LOW // 异常级别0的数据中止 b.eq el0_da // 访问数据时的页错误异常，调用函数el0_da cmp x24, #ESR_ELx_EC_IABT_LOW // 异常级别0的指令中止 b.eq el0_ia // 取指令时的页错误异常，调用函数el0_ia cmp x24, #ESR_ELx_EC_FP_ASIMD // 访问浮点或者高级SIMD b.eq el0_fpsimd_acc // 访问浮点或高级SIMD，调用函数el0_fpsimd_acc cmp x24, #ESR_ELx_EC_FP_EXC64 // 浮点或者高级SIMD异常 b.eq el0_fpsimd_exc // 浮点或高级SIMD异常，调用函数el0_fpsimd_exc cmp x24, #ESR_ELx_EC_SYS64 // 可配置陷入 b.eq el0_sys // 可配置陷入，调用函数el0_sys cmp x24, #ESR_ELx_EC_SP_ALIGN // 栈对齐异常 b.eq el0_sp_pc cmp x24, #ESR_ELx_EC_PC_ALIGN // 指令地址对齐异常 b.eq el0_sp_pc cmp x24, #ESR_ELx_EC_UNKNOWN // 异常级别0的未知异常 b.eq el0_undef cmp x24, #ESR_ELx_EC_BREAKPT_LOW // 异常级别0的调试异常 b.ge el0_dbg b el0_inv 可配置陷入，调用函数el0_sys\n// arch/arm64/kernel/entry.S el1_sync: kernel_entry 1 mrs x1, esr_el1 // 读异常症状寄存器 lsr x24, x1, #ESR_ELx_EC_SHIFT // 异常类别 cmp x24, #ESR_ELx_EC_DABT_CUR // 异常级别1的数据中止 b.eq el1_da cmp x24, #ESR_ELx_EC_IABT_CUR // 异常级别1的指令中止 b.eq el1_ia cmp x24, #ESR_ELx_EC_SYS64 // 可配置陷入 b.eq el1_undef cmp x24, #ESR_ELx_EC_SP_ALIGN // 栈对齐异常 b.eq el1_sp_pc cmp x24, #ESR_ELx_EC_PC_ALIGN // 指令地址对齐异常 b.eq el1_sp_pc cmp x24, #ESR_ELx_EC_UNKNOWN // 异常级别1的未知异常 b.eq el1_undef cmp x24, #ESR_ELx_EC_BREAKPT_CUR // 异常级别1的调试异常 b.ge el1_dbg b el1_inv 以64位应用程序在用户模式（异常级别0）下访问数据时生成的页错误异常为例，处理函数是el0_da\n// arch/arm64/kernel/entry.S el0_da: mrs x26, far_el1 // 获取数据的虚拟地址，存放在寄存器x26 enable_dbg_and_irq // msr daifclr, #(8 | 2) 开启调试异常和中断 … clear_address_tag x0, x26 mov x1, x25 mov x2, sp bl do_mem_abort // 调用C语言函数 b ret_to_user 内核模式（异常级别1）下访问数据时生成的页错误异常为例说明，处理函数是el1_da\n// arch/arm64/kernel/entry.S el1_da: mrs x3, far_el1 enable_dbg tbnz x23, #7, 1f enable_irq 1: clear_address_tag x0, x3 mov x2, sp // 结构体 pt_regs bl do_mem_abort disable_irq kernel_exit 1 异常处理程序执行完的时候，调用kernel_exit返回。kernel_exit是一个宏，参数el是返回的异常级别，0表示返回异常级别0，1表示返回异常级别1\n// arch/arm64/kernel/entry.S .macro kernel_exit, el … ldp x21, x22, [sp, #S_PC] //加载保存的寄存器ELR_EL1和SPSR_EL1的值 … .if \\el == 0 /* 如果返回用户模式（异常级别0）*/ ldr x23, [sp, #S_SP] msr sp_el0, x23 /* 恢复异常级别0的栈指针寄存器 */ … .endif msr elr_el1, x21 msr spsr_el1, x22 ldp x0, x1, [sp, #16 * 0] ldp x2, x3, [sp, #16 * 1] ldp x4, x5, [sp, #16 * 2] ldp x6, x7, [sp, #16 * 3] ldp x8, x9, [sp, #16 * 4] ldp x10, x11, [sp, #16 * 5] ldp x12, x13, [sp, #16 * 6] ldp x14, x15, [sp, #16 * 7] ldp x16, x17, [sp, #16 * 8] ldp x18, x19, [sp, #16 * 9] ldp x20, x21, [sp, #16 * 10] ldp x22, x23, [sp, #16 * 11] ldp x24, x25, [sp, #16 * 12] ldp x26, x27, [sp, #16 * 13] ldp x28, x29, [sp, #16 * 14] ldr lr, [sp, #S_LR] add sp, sp, #S_FRAME_SIZE eret .endm 执行指令eret的时候，处理器自动使用寄存器SPSR_EL1保存的值恢复处理器状态，使用寄存器ELR_EL1保存的返回地址恢复程序计数器（Program Counter，PC）\n4.2 中断 中断是外围设备通知处理器的一种机制\n4.2.1　中断控制器 ARM标准的中断控制器，称为通用中断控制器（Generic Interrupt Controller，GIC） 软件 GIC v2控制器有两个主要的功能块 1）分发器（Distributor） 2）处理器接口（CPU Interface） 中断有以下4种类型:SGI、PPI、SPI、LPI SGI 软件生成的中断 0~15 PPI 私有外设中断 16~31 SPI 共享外设中断 32~1020 LPI 局部特点外设中断\n边沿触发、电平触发 中断有以下4种状态。 （1）Inactive：中断源没有发送中断。\n（2）Pending：中断源已经发送中断，等待处理器处理。\n（3）Active：处理器已经确认中断，正在处理。 （4）Active and pending：处理器正在处理中断，相同的中断源又发送了一个中断。 GIC v2控制器描述符\n// drivers/irqchip/irq-gic.c static struct irq_chip gic_chip = { .irq_mask = gic_mask_irq, .irq_unmask = gic_unmask_irq, .irq_eoi = gic_eoi_irq, .irq_set_type = gic_set_type, .irq_get_irqchip_state = gic_irq_get_irqchip_state, .irq_set_irqchip_state = gic_irq_set_irqchip_state, .flags = IRQCHIP_SET_TYPE_MASKED | IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND, }; 4.2.2　中断域 每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域 1．创建中断域 中断控制器的驱动程序使用分配函数irq_domain_add_*()创建和注册中断域，调用者给分配函数提供irq_domain_ops结构体，分配函数在执行成功的时候返回irq_domain的指针\n分配主要为函数__irq_domain_add()。函数__irq_domain_add()的执行过程是：分配一个irq_domain结构体，初始化成员，然后把中断域添加到全局链表irq_domain_list中 2．创建映射 向中断域添加硬件中断号到Linux中断号的映射，内核提供了函数irq_create_mapping\nunsigned int irq_create_mapping(struct irq_domain *domain, irq_hw_number_t hwirq); 3．查找映射 中断处理程序需要根据硬件中断号查找Linux中断号，内核提供了函数irq_find_mapping：\nunsigned int irq_find_mapping(struct irq_domain *domain, irq_hw_number_t hwirq); 输入参数是中断域和硬件中断号，返回Linux中断号\n4.2.3　中断控制器驱动初始化 ARM64架构使用扁平设备树（Flattened Device Tree，FDT）描述板卡的硬件信息。编写设备树源文件（Device Tree Source，DTS），存放在目录“arch/arm64/boot/dts”下，然后使用设备树编译器（Device Tree Compiler，DTC）把设备树源文件转换成设备树二进制文件（Device Tree Blob，DTB），最后把设备树二进制文件写到存储设备上\n1．设备树源文件 3.初始化 函数irqchip_init \u0026ndash;\u0026gt; of_irq_init \u0026ndash;\u0026gt; __irqchip_of_table start_kernel() -\u0026gt; init_IRQ() -\u0026gt; irqchip_init() -\u0026gt; of_irq_init() -\u0026gt; gic_of_init() -\u0026gt; __gic_init_bases() -\u0026gt; __irqchip_of_table() 4.2.4　Linux中断处理 向中断域添加硬件中断号到Linux中断号的映射时，内核分配一个Linux中断号和一个中断描述符irq_desc 中断描述符有两个层次的中断处理函数\n存储Linux中断号到中断描述符的映射关系 (1)中断编号是稀疏的（即不连续），那么使用基数树（radix tree）存储 (2)中断编号是连续的，那么使用数组存储\n// kernel/irq/irqdesc.c #ifdef CONFIG_SPARSE_IRQ static RADIX_TREE(irq_desc_tree, GFP_KERNEL); #else struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = { [0 ... NR_IRQS-1] = { .handle_irq = handle_bad_irq, .depth = 1, .lock = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-\u0026gt;lock), } }; #endif handle_irq() -\u0026gt; gic_irq_domain_map() // 硬件中断号小于32 -\u0026gt; handle_percpu_devid_irq() // 中断号大于或等于32 -\u0026gt; handle_fasteoi_irq() irq_create_mapping() -\u0026gt; irq_domain_associate() -\u0026gt; domain-\u0026gt;ops-\u0026gt;map() // drivers/irqchip/irq-gic.c static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw) { struct gic_chip_data *gic = d-\u0026gt;host_data; if (hw \u0026lt; 32) { irq_set_percpu_devid(irq); irq_domain_set_info(d, irq, hw, \u0026amp;gic-\u0026gt;chip, d-\u0026gt;host_data, handle_percpu_devid_irq, NULL, NULL); irq_set_status_flags(irq, IRQ_NOAUTOEN); } else { irq_domain_set_info(d, irq, hw, \u0026amp;gic-\u0026gt;chip, d-\u0026gt;host_data, handle_fasteoi_irq, NULL, NULL); irq_set_probe(irq); } return 0; } Linux中断处理流程 // arch/arm64/kernel/entry.S .align 6 el0_irq: kernel_entry 0 el0_irq_naked: enable_dbg … irq_handler … b ret_to_user ENDPROC(el0_irq) .macro irq_handler ldr_l x1, handle_arch_irq mov x0, sp irq_stack_entry blr x1 irq_stack_exit .endm 函数handle_irq_event，执行设备驱动程序注册的处理函数\n// handle_irq_event() -\u0026gt; handle_irq_event_percpu() -\u0026gt; __handle_irq_event_percpu() kernel/irq/handle.c irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags) { irqreturn_t retval = IRQ_NONE; unsigned int irq = desc-\u0026gt;irq_data.irq; struct irqaction *action; for_each_action_of_desc(desc, action) { irqreturn_t res; … res = action-\u0026gt;handler(irq, action-\u0026gt;dev_id); … switch (res) { case IRQ_WAKE_THREAD: … __irq_wake_thread(desc, action); /*继续往下走，把“action-\u0026gt;flags”作为生成随机数的一个因子 */ case IRQ_HANDLED: *flags |= action-\u0026gt;flags; break; default: break; } retval |= res; } return retval; } 4.2.5　中断线程化 内核提供的函数request_threaded_irq()用来注册线程化的中断\nint request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long flags, const char *name, void *dev); 每个中断处理描述符（irqaction）对应一个内核线程，成员thread指向内核线程的进程描述符，成员thread_fn指向线程处理函数\n// include/linux/interrupt.h struct irqaction { … irq_handler_t thread_fn; struct task_struct *thread; … } ____cacheline_internodealigned_in_smp; 中断处理线程是优先级为50、调度策略是SCHED_FIFO的实时内核线程，名称是“irq/”后面跟着Linux中断号，线程处理函数是irq_thread()\nrequest_threaded_irq() -\u0026gt; __setup_irq() -\u0026gt; setup_irq_thread() // kernel/irq/manage.c static int setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary) { struct task_struct *t; struct sched_param param = { .sched_priority = MAX_USER_RT_PRIO/2, }; if (!secondary) { t = kthread_create(irq_thread, new, \u0026#34;irq/%d-%s\u0026#34;, irq, new-\u0026gt;name); } else { t = kthread_create(irq_thread, new, \u0026#34;irq/%d-s-%s\u0026#34;, irq, new-\u0026gt;name); param.sched_priority -= 1; } … sched_setscheduler_nocheck(t, SCHED_FIFO, \u0026amp;param); … } handle_fasteoi_irq() -\u0026gt; handle_irq_event() -\u0026gt; handle_irq_event_percpu() -\u0026gt; __handle_irq_event_percpu() // kernel/irq/handle.c irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags) { irqreturn_t retval = IRQ_NONE; unsigned int irq = desc-\u0026gt;irq_data.irq; struct irqaction *action; for_each_action_of_desc(desc, action) { irqreturn_t res; … res = action-\u0026gt;handler(irq, action-\u0026gt;dev_id); … switch (res) { case IRQ_WAKE_THREAD: … __irq_wake_thread(desc, action); /*继续往下走，把“action-\u0026gt;flags”作为生成随机数的一个因子*/ case IRQ_HANDLED: *flags |= action-\u0026gt;flags; break; default: break; } retval |= res; } return retval; } 中断处理线程的处理函数是irq_thread()，调用函数irq_thread_fn()，然后函数irq_thread_fn()调用注册的线程处理函数\n// kernel/irq/manage.c static int irq_thread(void *data) { struct callback_head on_exit_work; struct irqaction *action = data; struct irq_desc *desc = irq_to_desc(action-\u0026gt;irq); irqreturn_t (*handler_fn)(struct irq_desc *desc, struct irqaction *action); if (force_irqthreads \u0026amp;\u0026amp; test_bit(IRQTF_FORCED_THREAD, \u0026amp;action-\u0026gt;thread_flags)) handler_fn = irq_forced_thread_fn; else handler_fn = irq_thread_fn; … while (!irq_wait_for_interrupt(action)) { irqreturn_t action_ret; … action_ret = handler_fn(desc, action); … } … return 0; } static irqreturn_t irq_thread_fn(struct irq_desc *desc, struct irqaction *action) { irqreturn_t ret; ret = action-\u0026gt;thread_fn(action-\u0026gt;irq, action-\u0026gt;dev_id); irq_finalize_oneshot(desc, action); return ret; } 4.2.6　禁止/开启中断 软件可以禁止中断，使处理器不响应所有中断请求，但是不可屏蔽中断（Non Maskable Interrupt，NMI）是个例外，接口： (1)local_irq_disable() (2)local_irq_save(flags) 先把中断状态保存在参数flags中，然后禁止中断 开启中断的接口 (1)local_irq_enable() (2)local_irq_restore(flags) 恢复本地处理器的中断状态 ARM64架构禁止中断的函数local_irq_disable()\nlocal_irq_disable() -\u0026gt; raw_local_irq_disable() -\u0026gt; arch_local_irq_disable() // arch/arm64/include/asm/irqflags.h // 中断掩码位设置成1 static inline void arch_local_irq_disable(void) { asm volatile( \u0026#34;msr daifset, #2 // arch_local_irq_disable\u0026#34; : : : \u0026#34;memory\u0026#34;); } ARM64架构开启中断的函数local_irq_enable()\nlocal_irq_enable() -\u0026gt; raw_local_irq_enable() -\u0026gt; arch_local_irq_enable() // arch/arm64/include/asm/irqflags.h // 中断掩码位设置成0 static inline void arch_local_irq_enable(void) { asm volatile( \u0026#34;msr daifclr, #2 // arch_local_irq_enable\u0026#34; : : : \u0026#34;memory\u0026#34;); } 4.2.7　禁止/开启单个中断 // 禁止单个中断的函数 void disable_irq(unsigned int irq); // 开启单个中断的函数 void enable_irq(unsigned int irq); 4.2.8　中断亲和性 设置中断亲和性，允许中断控制器把某个中断转发给哪些处理器，有两种配置方法 (1)写文件“/proc/irq/IRQ#/smp_affinity”，参数是位掩码 (2)文件“/proc/irq/IRQ#/smp_affinity_list”，参数是处理器列表 4.2.9　处理器间中断 多处理器系统中，一个处理器可以向其他处理器发送中断 处理处理器间中断的执行流程\n处理处理器间中断 4.3　中断下半部 中断处理程序分为两部分，上半部（top half，th）在关闭中断的情况下执行，只做对时间非常敏感、与硬件相关或者不能被其他中断打断的工作；下半部（bottom half，bh）在开启中断的情况下执行，可以被其他中断打断 上半部称为硬中断（hardirq），下半部有3种：软中断（softirq）、小任务（tasklet）和工作队列（workqueue） 4.3.1　软中断 内核定义了一张软中断向量表，每种软中断有一个唯一的编号，对应一个softirq_action实例，softirq_action实例的成员action是处理函数\n// kernel/softirq.c static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp; // include/linux/interrupt.h struct softirq_action { void (*action)(struct softirq_action *); }; 1．软中断的种类 内核定义了10种软中断\n// include/linux/interrupt.h enum { HI_SOFTIRQ=0, // 高优先级的小任务 TIMER_SOFTIRQ, // 定时器软中断 NET_TX_SOFTIRQ, // 网络栈发送报文的软中断 NET_RX_SOFTIRQ, // 网络栈接收报文的软中断 BLOCK_SOFTIRQ, // 块设备软中断 IRQ_POLL_SOFTIRQ, // 支持I/O轮询的块设备软中断 TASKLET_SOFTIRQ, // 低优先级的小任务 SCHED_SOFTIRQ, // 调度软中断 HRTIMER_SOFTIRQ, /* 没有使用，但是保留，因为有些工具依赖这个编号 */ RCU_SOFTIRQ, /* RCU软中断应该总是最后一个软中断 */ NR_SOFTIRQS }; 2．注册软中断的处理函数 open_softirq()用来注册软中断的处理函数，在软中断向量表中为指定的软中断编号设置处理函数\n// kernel/softirq.c void open_softirq(int nr, void (*action)(struct softirq_action *)) { softirq_vec[nr].action = action; } 3．触发软中断 函数raise_softirq用来触发软中断，参数是软中断编号。\nvoid raise_softirq(unsigned int nr); raise_softirq() -\u0026gt; raise_softirq_irqoff() -\u0026gt; __raise_softirq_irqoff() // kernel/softirq.c void __raise_softirq_irqoff(unsigned int nr) { or_softirq_pending(1UL \u0026lt;\u0026lt; nr); } // 宏or_softirq_pending展开 irq_stat[smp_processor_id()].__softirq_pending |= (1UL \u0026lt;\u0026lt; nr); 4.执行软中断 中断处理程序的后半部分，调用函数irq_exit()以退出中断上下文，处理软中断\n// kernel/softirq.c void irq_exit(void) { … preempt_count_sub(HARDIRQ_OFFSET); if (!in_interrupt() \u0026amp;\u0026amp; local_softirq_pending()) invoke_softirq(); … } // kernel/softirq.c static inline void invoke_softirq(void) { if (ksoftirqd_running()) return; if (!force_irqthreads) { __do_softirq(); } else { wakeup_softirqd(); } } 函数__do_softirq是执行软中断的核心函数\n// kernel/softirq.c #define MAX_SOFTIRQ_TIME msecs_to_jiffies(2) #define MAX_SOFTIRQ_RESTART 10 asmlinkage __visible void __softirq_entry __do_softirq(void) { unsigned long end = jiffies + MAX_SOFTIRQ_TIME; unsigned long old_flags = current-\u0026gt;flags; int max_restart = MAX_SOFTIRQ_RESTART; struct softirq_action *h; bool in_hardirq; __u32 pending; int softirq_bit; … pending = local_softirq_pending(); … __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET); … restart: set_softirq_pending(0); local_irq_enable(); h = softirq_vec; while ((softirq_bit = ffs(pending))) { … h += softirq_bit - 1; … h-\u0026gt;action(h); … h++; pending \u0026gt;\u0026gt;= softirq_bit; } … local_irq_disable(); pending = local_softirq_pending(); if (pending) { if (time_before(jiffies, end) \u0026amp;\u0026amp; !need_resched() \u0026amp;\u0026amp; --max_restart) goto restart; wakeup_softirqd(); } … __local_bh_enable(SOFTIRQ_OFFSET); … } 5．抢占计数器 进程的thread_info结构体有一个抢占计数器：int preempt_count，它用来表示当前进程能不能被抢占,可通过抢占计数器判断处在什么场景 // nclude/linux/preempt.h #define in_irq() (hardirq_count()) // 正在执行硬中断 #define in_softirq() (softirq_count()) // 禁止软中断和正在执行软中断 #define in_interrupt() (irq_count()) // 正在执行不可屏蔽中断 #define in_serving_softirq() (softirq_count() \u0026amp; SOFTIRQ_OFFSET) // 正在执行软中断 #define in_nmi() (preempt_count() \u0026amp; NMI_MASK) // 不可屏蔽中断场景 #define in_task() (!(preempt_count() \u0026amp; \\ (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET))) // 进程上下文 #define hardirq_count() (preempt_count() \u0026amp; HARDIRQ_MASK) #define softirq_count() (preempt_count() \u0026amp; SOFTIRQ_MASK) #define irq_count() (preempt_count() \u0026amp; (HARDIRQ_MASK | SOFTIRQ_MASK \\ | NMI_MASK)) 6．禁止/开启软中断 禁止软中断的函数是local_bh_disable()\ninclude/linux/bottom_half.h static inline void local_bh_disable(void) { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET); } static __always_inline void __local_bh_disable_ip(unsigned long ip, unsigned int cnt) { preempt_count_add(cnt); barrier(); } include/linux/preempt.h #define SOFTIRQ_DISABLE_OFFSET (2 * SOFTIRQ_OFFSET) // 开启软中断 local_bh_enable() 4.3.2 小任务 tasklet 小任务（tasklet）是基于软中断实现\n1.数据结构 // include/linux/interrupt.h struct tasklet_struct { struct tasklet_struct *next; unsigned long state; atomic_t count; void (*func)(unsigned long); unsigned long data; }; 2．编程接口 3．技术原理 4.3.3　工作队列 4.4　系统调用 系统调用是内核给用户程序提供的编程接口。用户程序调用系统调用，通常使用glibc库针对单个系统调用封装的函数。glibc库没有针对某个系统调用封装函数，用户程序可通用的封装函数syscall() #define _GNU_SOURCE #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; /* 定义 SYS_xxx */ long syscall(long number, ...); // number系统调用号 // 返回值 0成功，-1错误，错误号在errno 应用程序使用系统调用fork()创建子进程，有两种调用方法\nret = fork(); ret = syscall(SYS_fork); ARM64处理器提供的系统调用指令是svc (1)64位应用程序使用寄存器x8传递系统调用号 (2)寄存器x0～x6最多可以传递7个参数 (3)系统调用执行完的时候，使用寄存器x0存放返回值 4.4.1 定义系统调用 Linux内核使用宏SYSCALL_DEFINE定义系统调用，创建子进程的系统调用fork // kernel/fork.c SYSCALL_DEFINE0(fork) { #ifdef CONFIG_MMU return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0); #else /* 如果处理器没有内存管理单元，那么不支持 */ return -EINVAL; #endif } // SYSCALL_DEFINE0(fork) 展开 asmlinkage long sys_fork(void) // asmlinkage 表示C语言函数可以被汇编代码调用 ARM64架构定义的系统调用表sys_call_table\n// arch/arm64/kernel/sys.c #undef __SYSCALL #define __SYSCALL(nr, sym) [nr] = sym, void * const sys_call_table[__NR_syscalls] __aligned(4096) = { [0 ... __NR_syscalls - 1] = sys_ni_syscall, #include \u0026lt;asm/unistd.h\u0026gt; }; ARM64架构，头文件“asm/unistd.h”是“arch/arm64/include/asm/unistd.h”。\n// arch/arm64/include/asm/unistd.h #include \u0026lt;uapi/asm/unistd.h\u0026gt; // arch/arm64/include/uapi/asm/unistd.h #include \u0026lt;asm-generic/unistd.h\u0026gt; // include/asm-generic/unistd.h #include \u0026lt;uapi/asm-generic/unistd.h\u0026gt; // include/uapi/asm-generic/unistd.h #define __NR_io_setup 0 /* 系统调用号0 */ __SC_COMP(__NR_io_setup, sys_io_setup, compat_sys_io_setup) /* [0] = sys_io_setup, */ … #define __NR_fork 1079 /* 系统调用号1079 */ #ifdef CONFIG_MMU __SYSCALL(__NR_fork, sys_fork) /* [1079] = sys_fork, */ #else __SYSCALL(__NR_fork, sys_ni_syscall) #endif /* CONFIG_MMU */ #undef __NR_syscalls #define __NR_syscalls (__NR_fork+1) 4.4.2 执行系统调用 ARM64处理器把系统调用划分到同步异常，在异常级别1的异常向量表中，系统调用的入口，64位应用程序执行系统调用指令svc，系统调用入口 el0_sync\n// arch/arm64/kernel.c .align 6 el0_sync: kernel_entry 0 mrs x25, esr_el1 // 读异常症状寄存器 lsr x24, x25, #ESR_ELx_EC_SHIFT // 异常类别 cmp x24, #ESR_ELx_EC_SVC64 // 64位系统调用 b.eq el0_svc … el0_svc负责执行系统调用\n// arch/arm64/kernel.c /* * 这些是系统调用处理程序使用的寄存器， * 允许我们理论上最多传递7个参数给一个函数 – x0～x6 * * x7保留，用于32位模式的系统调用号 */ sc_nr .req x25 // 系统调用的数量 scno .req x26 // 系统调用号 stbl .req x27 // 系统调用表的地址 tsk .req x28 // 当前进程的thread_info结构体的地址 .align 6 el0_svc: adrp stbl, sys_call_table // 加载系统调用表的地址 uxtw scno, w8 // 寄存器w8里面的系统调用号 mov sc_nr, #__NR_syscalls el0_svc_naked: // 32位系统调用的入口 stp x0, scno, [sp, #S_ORIG_X0] // 保存原来的x0和系统调用号 enable_dbg_and_irq ct_user_exit 1 // ptrace跟踪系统调用，跳转到__sys_trace处理 ldr x16, [tsk, #TSK_TI_FLAGS] // 检查系统调用钩子 tst x16, #_TIF_SYSCALL_WORK b.ne __sys_trace cmp scno, sc_nr // 检查系统调用号是否超过上限 b.hs ni_sys ldr x16, [stbl, scno, lsl #3] // 系统调用表表项的地址 blr x16 // 调用sys_*函数 b ret_fast_syscall ni_sys: mov x0, sp bl do_ni_syscall b ret_fast_syscall ENDPROC(el0_svc) ret_fast_syscall从系统调用返回用户空间\n// arch/arm64/kernel.c ret_fast_syscall: disable_irq str x0, [sp, #S_X0] /* DEFINE(S_X0, offsetof(struct pt_regs, regs[0])); */ ldr x1, [tsk, #TSK_TI_FLAGS] and x2, x1, #_TIF_SYSCALL_WORK cbnz x2, ret_fast_syscall_trace and x2, x1, #_TIF_WORK_MASK cbnz x2, work_pending enable_step_tsk x1, x2 kernel_exit 0 ret_fast_syscall_trace: enable_irq // 开启中断 b __sys_trace_return_skipped // 我们已经保存了x0 work_pending: mov x0, sp // \u0026#39;regs\u0026#39; bl do_notify_resume #ifdef CONFIG_TRACE_IRQFLAGS bl trace_hardirqs_on // 在用户空间执行时开启中断 #endif ldr x1, [tsk, #TSK_TI_FLAGS] // 重新检查单步执行 b finish_ret_to_user ret_to_user: … finish_ret_to_user: enable_step_tsk x1, x2 kernel_exit 0 ENDPROC(ret_to_user) work_pending调用函数do_notify_resume\n// arch/arm64/kernel/signal.c asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int thread_flags) { … do { if (thread_flags \u0026amp; _TIF_NEED_RESCHED) { schedule(); } else { local_irq_enable(); if (thread_flags \u0026amp; _TIF_UPROBE) uprobe_notify_resume(regs); if (thread_flags \u0026amp; _TIF_SIGPENDING) do_signal(regs); if (thread_flags \u0026amp; _TIF_NOTIFY_RESUME) { clear_thread_flag(TIF_NOTIFY_RESUME); tracehook_notify_resume(regs); } if (thread_flags \u0026amp; _TIF_FOREIGN_FPSTATE) fpsimd_restore_current_state(); } local_irq_disable(); thread_flags = READ_ONCE(current_thread_info()-\u0026gt;flags); } while (thread_flags \u0026amp; _TIF_WORK_MASK); } 第5章 内核互斥技术 临界区的执行时间比较长或者可能睡眠互斥技术 (1)信号量 (2)读写信号量 (3)互斥锁 (4)实时互斥锁 临界区的执行时间很短，并且不会睡眠 互斥技术 (1)原子变量 (2)自旋锁 (3)读写锁 (4)顺序锁 进程互斥技术 (1)禁止内核抢占 (2)禁止软中断 (3)禁止硬中断 免使用锁的互斥技术 (1)每处理器变量 (2)每处理器计数器 (3)内存屏障 (4)读-复制更新(Read-Copy Update RCU) (5)可睡眠RCU 内核提供了死锁检测工具lockdep 5.1 信号量 信号量允许多个进程同时进入临界区，信号量的计数值设置为1，即二值信号量，这种信号量称为互斥信号量，适合保护比较长的临界区 内核使用的信号量定义\n// include/linux/semaphore.h struct semaphore { raw_spinlock_t lock; // 自旋锁，保护信号量其他成员 unsigned int count; // 计数值，允许多少个进程进入临界区 struct list_head wait_list; // 等待进入临界区进程链表 }; // 获取信号量 void down(struct semaphore *sem); int down_interruptible(struct semaphore *sem); int down_killable(struct semaphore *sem); int down_trylock(struct semaphore *sem); int down_timeout(struct semaphore *sem, long jiffies); // 释放信号量函数 void up(struct semaphore *sem); 5.2 读写信号量 读写信号量,适合在以读为主\n// include/linux/rwsem.h struct rw_semaphore { atomic_long_t count; struct list_head wait_list; raw_spinlock_t wait_lock; struct task_struct *owner; … }; 初始化，使用\n// 初始化静态读写信号量 DECLARE_RWSEM(name); // 运行时动态初始化读写信号量 init_rwsem(sem); // 申请读锁 void down_read(struct rw_semaphore *sem)； int down_read_trylock(struct rw_semaphore *sem)； // 释放读锁 void up_read(struct rw_semaphore *sem); // 申请写锁 void down_write(struct rw_semaphore *sem); int down_write_killable(struct rw_semaphore *sem); int down_write_trylock(struct rw_semaphore *sem); // 写锁降级为读锁 void downgrade_write(struct rw_semaphore *sem); // 释放写锁 void up_write(struct rw_semaphore *sem); 5.3 互斥锁 互斥锁只允许一个进程进入临界区，适合保护比较长的临界区\n// include/linux/mutex.h struct mutex { atomic_long_t owner; spinlock_t wait_lock; #ifdef CONFIG_MUTEX_SPIN_ON_OWNER struct optimistic_spin_queue osq; #endif struct list_head wait_list; … }; 使用互斥锁\n// 初始化静态互斥锁 DEFINE_MUTEX(mutexname); // 运行时动态初始化互斥锁 mutex_init(mutex); // 申请互斥锁 void mutex_lock(struct mutex *lock); int mutex_lock_interruptible(struct mutex *lock); int mutex_lock_killable(struct mutex *lock); int mutex_trylock(struct mutex *lock); // 释放互斥锁 void mutex_unlock(struct mutex *lock); 5.4 实时互斥锁 实时互斥锁是对互斥锁的改进，实现了优先级继承(priority inheritance)，解决了优先级反转(priority inversion)问题\n// include/linux/rtmutex.h struct rt_mutex { raw_spinlock_t wait_lock; struct rb_root waiters; struct rb_node *waiters_leftmost; struct task_struct *owner; … }; 初始化，使用\n// 初始化静态实时互斥锁 DEFINE_RT_MUTEX(mutexname); // 运行时动态初始化实时互斥锁 rt_mutex_init(mutex); // 申请实时互斥锁 void rt_mutex_lock(struct rt_mutex *lock); int rt_mutex_lock_interruptible(struct rt_mutex *lock); int rt_mutex_timed_lock(struct rt_mutex *lock, struct hrtimer_sleeper *timeout); int rt_mutex_trylock(struct rt_mutex *lock); // 释放实时互斥锁 void rt_mutex_unlock(struct rt_mutex *lock); 5.5 原子变量 原子变量用来实现对整数的互斥访问，通常用来实现计数器 内核定义了3种原子变量\n// 整数原子变量，数据类型是atomic_t // include/linux/types.h typedef struct { int counter; } atomic_t; // 长整数原子变量，数据类型是atomic_long_t // 64位整数原子变量，数据类型是atomic64_t 原子变量使用方法\n// 初始化静态原子变量 atomic_t \u0026lt;name\u0026gt; = ATOMINC_INIT(n); // 动态初始化原子变量 atomic_set(v, i); // 读取原子变量 atomic_read(v) // 原子变量加i，并返回 atomic_add_return(i, v) // 原子变量v加i atomic_add(i, v) // 原子变量加1 atomic_inc(v) // 原子变量v减i atomic_sub(i, v) // 原子变量减1 atomic_dec(v) ARM64处理器的原子变量实现 ARM64处理器原子变量指令支持 (1)独占加载指令ldxr (load Exclusive Register) (2)独占存储指令stxr (Store Exclusive Register) // 独占加载指令加载32位数据 ldxr \u0026lt;Wt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;{,#0}] // 独占存储指令存储32位数据 stxr \u0026lt;Ws\u0026gt;, \u0026lt;Wt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;{,#0}] // 原子加法指令stadd操作32位数据 stadd \u0026lt;Ws\u0026gt;, [\u0026lt;Xn|SP\u0026gt;] 函数atomic_add(i, v)实现\n// arch/arm64/include/asm/atomic_ll_sc.h static inline void atomic_add(int i, atomic_t *v) { unsigned long tmp; int result; asm volatile(\u0026#34;// atomic_add \\n\u0026#34; \\ \u0026#34; prfm pstl1strm, %2\\n\u0026#34; \\ \u0026#34;1: ldxr %w0, %2\\n\u0026#34; \\ \u0026#34; \u0026#34; add \u0026#34; %w0, %w0, %w3\\n\u0026#34; \\ \u0026#34; stxr %w1, %w0, %2\\n\u0026#34; \\ \u0026#34; cbnz %w1, 1b\u0026#34; \\ : \u0026#34;=\u0026amp;r\u0026#34; (result), \u0026#34;=\u0026amp;r\u0026#34; (tmp), \u0026#34;+Q\u0026#34; (v-\u0026gt;counter) \\ : \u0026#34;Ir\u0026#34; (i)); } 原子加法指令stadd实现的函数atomic_add(i, v)\n// arch/arm64/include/asm/atomic_lse.h static inline void atomic_add(int i, atomic_t *v) { register int w0 asm (\u0026#34;w0\u0026#34;) = i; register atomic_t *x1 asm (\u0026#34;x1\u0026#34;) = v; asm volatile(\u0026#34; stadd %w[i], %[v]\\n\u0026#34; \\ : [i] \u0026#34;+r\u0026#34; (w0), [v] \u0026#34;+Q\u0026#34; (v-\u0026gt;counter) \\ : \u0026#34;r\u0026#34; (x1) \\ : ); } 5.6 自旋锁 自旋锁用于处理器之间的互斥，适合保护很短的临界区，不允许在临界区睡眠\n// include/linux/spinlock_types.h typedef struct spinlock { union { struct raw_spinlock rlock; … }; } spinlock_t; typedef struct raw_spinlock { arch_spinlock_t raw_lock; … } raw_spinlock_t; Linux内核有一个实时内核分支（开启配置宏CONFIG_PREEMPT_RT）来支持硬实时特性，内核主线只支持软实时 数据类型arch_spinlock_t，ARM64架构的定义\n// arch/arm64/include/asm/spinlock_types.h typedef struct { #ifdef __AARCH64EB__ /* 大端字节序（高位存放在低地址） */ u16 next; u16 owner; #else /* 小端字节序（低位存放在低地址） */ u16 owner; u16 next; #endif } __aligned(4) arch_spinlock_t; 自旋锁使用\n// 初始化自旋锁 DEFINE_SPINLOCK(x); // 运行时初始化自旋锁 spin_lock_init(x); // 申请自旋锁 void spin_lock(spinlock_t *lock); void spin_lock_bh(spinlock_t *lock); void spin_lock_irq(spinlock_t *lock); spin_lock_irqsave(lock, flags); int spin_trylock(spinlock_t *lock); // 释放自旋锁 void spin_unlock(spinlock_t *lock); void spin_unlock_bh(spinlock_t *lock); void spin_unlock_irq(spinlock_t *lock); void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags); 原始自旋锁\n// 初始化原始自旋锁 DEFINE_RAW_SPINLOCK(x); // 运行时初始化原始自旋锁 raw_spin_lock_init (x); // 申请原始自旋锁 raw_spin_lock(lock) raw_spin_lock_bh(lock) raw_spin_lock_irq(lock) raw_spin_lock_irqsave(lock, flags) raw_spin_trylock(lock) // 释放原始自旋锁 raw_spin_unlock(lock) raw_spin_unlock_bh(lock) raw_spin_unlock_irq(lock) raw_spin_unlock_irqrestore(lock, flags) 函数spin_lock()负责申请自旋锁\n// spin_lock() -\u0026gt; raw_spin_lock() -\u0026gt; _raw_spin_lock() -\u0026gt; __raw_spin_lock() -\u0026gt; do_raw_spin_lock() -\u0026gt; arch_spin_lock() arch/arm64/include/asm/spinlock.h static inline void arch_spin_lock(arch_spinlock_t *lock) { unsigned int tmp; arch_spinlock_t lockval, newval; asm volatile( ARM64_LSE_ATOMIC_INSN( /* LL/SC */ \u0026#34; prfm pstl1strm, %3\\n\u0026#34; \u0026#34;1: ldaxr %w0, %3\\n\u0026#34; \u0026#34; add %w1, %w0, %w5\\n\u0026#34; \u0026#34; stxr %w2, %w1, %3\\n\u0026#34; \u0026#34; cbnz %w2, 1b\\n\u0026#34;, /* 大系统扩展的原子指令 */ \u0026#34; mov %w2, %w5\\n\u0026#34; \u0026#34; ldadda %w2, %w0, %3\\n\u0026#34; __nops(3) ) /* 我们得到锁了吗？*/ \u0026#34; eor %w1, %w0, %w0, ror #16\\n\u0026#34; \u0026#34; cbz %w1, 3f\\n\u0026#34; \u0026#34; sevl\\n\u0026#34; \u0026#34;2: wfe\\n\u0026#34; \u0026#34; ldaxrh %w2, %4\\n\u0026#34; \u0026#34; eor %w1, %w2, %w0, lsr #16\\n\u0026#34; \u0026#34; cbnz %w1, 2b\\n\u0026#34; /* 得到锁，临界区从这里开始*/ \u0026#34;3:\u0026#34; : \u0026#34;=\u0026amp;r\u0026#34; (lockval), \u0026#34;=\u0026amp;r\u0026#34; (newval), \u0026#34;=\u0026amp;r\u0026#34; (tmp), \u0026#34;+Q\u0026#34; (*lock) : \u0026#34;Q\u0026#34; (lock-\u0026gt;owner), \u0026#34;I\u0026#34; (1 \u0026lt;\u0026lt; TICKET_SHIFT) : \u0026#34;memory\u0026#34;); } 5.7 读写自旋锁 读写自旋锁(通常简称读写锁)是自旋锁的改进，区分读者和写者，允许多个读者同时进入临界区，读者和写者互斥，写者和写者互斥 // include/linux/rwlock_types.h typedef struct { arch_rwlock_t raw_lock; … } rwlock_t; // arch/arm64/include/asm/spinlock_types.h typedef struct { volatile unsigned int lock; } arch_rwlock_t; 5.8 顺序锁 顺序锁区分读者和写者\n5.8.1　完整版的顺序锁 顺序锁区分读者和写者\n// include/linux/seqlock.h typedef struct { struct seqcount seqcount; // 序列号 spinlock_t lock; // 自旋锁 } seqlock_t; 5.8.2　只提供序列号的顺序锁 5.9　禁止内核抢占 每个进程的thread_info结构体有一个抢占计数器：“int preempt_count”，其中第0～7位是抢占计数，第8～15位是软中断计数，第16～19位是硬中断计数，第20位是不可屏蔽中断计数 // 禁止内核抢占的编程接口 preempt_disable() // 开启内核抢占的编程接口 preempt_enable() 申请自旋锁的函数包含了禁止内核抢占\nspin_lock() -\u0026gt; raw_spin_lock() -\u0026gt; _raw_spin_lock() -\u0026gt; __raw_spin_lock() // include/linux/spinlock_api_smp.h static inline void __raw_spin_lock(raw_spinlock_t *lock) { preempt_disable(); … LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); } 释放自旋锁的函数包含了开启内核抢占\nspin_unlock() -\u0026gt; raw_spin_unlock() -\u0026gt; _raw_spin_unlock() -\u0026gt; __raw_spin_unlock() // include/linux/spinlock_api_smp.h static inline void __raw_spin_unlock(raw_spinlock_t *lock) { … do_raw_spin_unlock(lock); preempt_enable(); } 5.10　进程和软中断互斥 每个进程的thread_info结构体有一个抢占计数器“int preempt_count”，其中第8～15位是软中断计数 // 禁止软中断的接口 local_bh_disable() // 开启软中断的接口 local_bh_enable() 5.11　进程和硬中断互斥 进程和硬中断可能访问同一个对象，那么进程和硬中断需要互斥，进程需要禁止硬中断 // 禁止硬中断的接口 local_irq_disable() local_irq_save(flags) // 开启硬中断接口 local_irq_enable() local_irq_restore(flags) 5.12　每处理器变量 多处理器系统中，每处理器变量为每个处理器生成一个变量的副本 每处理器变量分为静态和动态两种 5.12.1　静态每处理器变量 5.12.2　动态每处理器变量 5.12.3　访问每处理器变量 5.13　每处理器计数器 原子变量作为计数器\n// include/linux/percpu_counter.h struct percpu_counter { raw_spinlock_t lock; s64 count; … s32 __percpu *counters; }; 5.14　内存屏障 内存屏障（memory barrier）是一种保证内存访问顺序的方法，解决内存访问乱序问题 (1) (2) (3) 内核支持3种内存屏障 (1)编译器屏障 (2)处理器内存屏障 (3)内存映射I/O (Memory Mapping I/O MMIO)写屏障 5.14.1　编译器屏障 编译器屏障\nbarrier(); /// GCC编译器定义的宏“barrier() // include/linux/compiler-gcc.h #define barrier() __asm__ __volatile__(\u0026#34;\u0026#34;: : :\u0026#34;memory\u0026#34;) 5.14.2　处理器内存屏障 处理器内存屏障用来解决处理器之间的内存访问乱序问题和处理器访问外围设备的乱序问题 内存屏障类型 强制性内存屏障 SMP内存屏障 通用内存屏障 mb() smp_mb() 写内存屏障 wmb() smp_wmb() 读内存屏障 rmb() smp_rmb() 数据依赖屏障 read_barrier_depends() smp_read_barrier_depends() 5.14.3 MMIO写屏障 // 内核为内存映射I/O写操作提供了一个特殊的屏障 mmiowb(); 5.14.4　隐含内存屏障 内核的有些函数隐含内存屏障 （1）获取和释放函数。 （2）中断禁止函数。 5.14.5　ARM64处理器内存屏障 ARM64处理器提供了3种内存屏障 (1)指令同步屏障(Instruction Synchronization Barrier ISB),指令是isb (2)数据内存屏障(Data Memory Barrier DMB)，指令是dmb (3)数据同步屏障(Data Synchronization Barrier DSb)，指令是dsb 5.15　RCU RCU(Read-Copy Update)读-复制更新 5.15.2　技术原理 5.16　可睡眠RCU 5.17　死锁检测工具lockdep 死锁有以下4种情况 1）进程重复申请同一个锁，称为AA死锁 2）进程申请自旋锁时没有禁止硬中断，进程获取自旋锁以后，硬中断抢占，申请同一个自旋锁 3）两个进程都要获取锁L1和L2，进程1持有锁L1，再去获取锁L2，如果这个时候进程2持有锁L2并且正在尝试获取锁L1，那么进程1和进程2就会死锁，称为AB-BA死锁 4）在一个处理器上进程1持有锁L1，再去获取锁L2，在另一个处理器上进程2持有锁L2，硬中断抢占进程2以后获取锁L1 5.17.1　使用方法 死锁检测工具lockdep的配置宏\n5.17.2　技术原理 第6章 文件系统 6.1　概述 Linux系统中，一切皆文件 Linux文件系统的架构 6.1.1　用户空间层面 应用程序可以直接使用内核提供的系统调用访问文件\n// 挂载文件系统 mount // 卸载目录下挂载的文件系统 umount // 打开文件 open // 关闭文件 close // 写文件 write // 设置文件偏移 lseek // 文件修改过的属性和数据立即写到存储设备 fsync glibc库封装的标准I/O流函数访问文件\n// 打开流 fopen // 关闭流 fclose // 读流 fread // 写流 fwrite // 设置文件偏移 fseek // 冲刷流 fflush 6.1.2　硬件层面 外部存储设备分为块设备、闪存和NVDIMM设备3类 闪存按存储结构分为NAND闪存和NOR闪存 6.1.3　内核空间层面 使不同的文件系统实现能够共存，内核实现了一个抽象层，称为虚拟文件系统(Virtual File System，VFS)，也称为虚拟文件系统切换(Virtual Filesystem Switch，VFS) 文件系统分为以下4种 (1)块设备文件系统，Linux原创文件系统：EXT2，EXT3和EXT4 (2)闪存文件系统，NAND闪存和NOR闪存，常用的闪存文件系统是JFFS2和UBIFS (3)内存文件系统，常见内存文件系统tmpfs (4)伪文件系统： 1）sockfs，套接字 2) proc 文件系统，挂载在目录 /proc 3) sysfs 把内核的设备信息导出到用户空间，挂载目录 /sys 4) hugetlbfs 实现标准巨型页 5) cgroup文件系统 控制组用来控制一组进程资源， 6) cgroup2文件系统 libnvdimm子系统提供对3种NVDIMM设备的支持：持久内存（persistent memory，PMEM）模式的NVDIMM设备，块设备（block，BLK）模式的NVDIMM设备，以及同时支持PMEM和BLK两种访问模式的NVDIMM设备 6.2　虚拟文件系统的数据结构 虚拟文件系统定义了一套统一的数据结构 (1)超级块。文件系统的第一块是超级块，结构体super_block (2)虚拟文件系统在内存中把目录组织为一棵树，挂载文件系统，虚拟文件系统就会创建一个挂载描述符：mount结构体，并且读取文件系统的超级块，在内存中创建超级块的一个副本 (3)每种文件系统的超级块的格式不同，向虚拟文件系统注册文件系统类型file_system_type (4)索引节点。结构体inode (5)目录项。目录项。 (6)进程打开一个文件，虚拟文件系统会创建文件的一个打开实例：file结构体 6.2.1 超级块 文件系统的第一块是超级块，描述文件系统的总体信息 // include/linux/fs.h struct super_block { struct list_head s_list; // 把所有超级块实例链接到全局链表super_blocks dev_t s_dev; // 存文件系统所在的块设备 unsigned char s_blocksize_bits; unsigned long s_blocksize; // 块长度 loff_t s_maxbytes; // 文件系统支持的最大文件长度 struct file_system_type *s_type; // 指向文件系统类型 const struct super_operations *s_op; // 指向超级块操作集合 … unsigned long s_flags; // 标志位 unsigned long s_iflags; /*内部 SB_I_* 标志 */ unsigned long s_magic; // 文件系统类型的魔幻数 struct dentry *s_root; // 指向根目录的结构体dentry … struct hlist_bl_head s_anon; struct list_head s_mounts; struct block_device *s_bdev; struct backing_dev_info *s_bdi; struct mtd_info *s_mtd; struct hlist_node s_instances; … void *s_fs_info; // 指向具体文件系统的私有信息 … }; 超级块操作集合的数据结构是结构体super_operations\n// include/linux/fs.h struct super_operations { struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, struct writeback_control *wbc); int (*drop_inode) (struct inode *); void (*evict_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); … int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*umount_begin) (struct super_block *); … }; 6.2.2　挂载描述符 每次挂载文件系统，虚拟文件系统就会创建一个挂载描述符：mount结构体 // fs/mount.h struct mount { struct hlist_node mnt_hash; struct mount *mnt_parent; // 指向父亲 struct dentry *mnt_mountpoint; // 指向作为挂载点的目录 struct vfsmount mnt; union { struct rcu_head mnt_rcu; struct llist_node mnt_llist; }; #ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; #else int mnt_count; int mnt_writers; #endif struct list_head mnt_mounts; struct list_head mnt_child; struct list_head mnt_instance; const char *mnt_devname; struct list_head mnt_list; … struct mnt_namespace *mnt_ns; struct mountpoint *mnt_mp; struct hlist_node mnt_mp_list; … } struct vfsmount { struct dentry *mnt_root; struct super_block *mnt_sb; int mnt_flags; }; 6.2.3　文件系统类型 每种文件系统需要向虚拟文件系统注册文件系统类型file_system_type，并且实现mount方法用来读取和解析超级块。结构体file_system_type // include/linux/fs.h struct file_system_type { const char *name; int fs_flags; #define FS_REQUIRES_DEV 1 #define FS_BINARY_MOUNTDATA 2 #define FS_HAS_SUBTYPE 4 #define FS_USERNS_MOUNT 8 #define FS_RENAME_DOES_D_MOVE 32768 struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); struct module *owner; struct file_system_type * next; struct hlist_head fs_supers; … }; 6.2.4　索引节点 文件系统中，每个文件对应一个索引节点，索引节点描述两类信息 (1)文件的数学，称为元数据(metadata) (2)文件数据的存储位置 当内核访问存储设备上的一个文件时，会在内存中创建索引节点的一个副本：结构体inode\n// include/linux/fs.h struct inode { umode_t i_mode; unsigned short i_opflags; kuid_t i_uid; kgid_t i_gid; unsigned int i_flags; #ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; struct posix_acl *i_default_acl; #endif const struct inode_operations *i_op; struct super_block *i_sb; struct address_space *i_mapping; … unsigned long i_ino; union { const unsigned int i_nlink; unsigned int __i_nlink; }; dev_t i_rdev; loff_t i_size; struct timespec i_atime; struct timespec i_mtime; struct timespec i_ctime; spinlock_t i_lock; unsigned short i_bytes; unsigned int i_blkbits; blkcnt_t i_blocks; … struct hlist_node i_hash; struct list_head i_io_list; … struct list_head i_lru; struct list_head i_sb_list; struct list_head i_wb_list; union { struct hlist_head i_dentry; struct rcu_head i_rcu; }; u64 i_version; atomic_t i_count; atomic_t i_dio_count; atomic_t i_writecount; #ifdef CONFIG_IMA atomic_t i_readcount; #endif const struct file_operations *i_fop; struct file_lock_context *i_flctx; struct address_space i_data; struct list_head i_devices; union { struct pipe_inode_info *i_pipe; struct block_device *i_bdev; struct cdev *i_cdev; char *i_link; unsigned i_dir_seq; }; … void *i_private; }; 文件几种类型： (1)普通文件 (2)目录，每个目录项存储一个子目录或文件的名称以及对应的索引节点号 (3)符号链接(软链接) (4)字符设备文件 (5)块设备文件 (6)命名管道 FIFO (7)套接字 socket 内核支持两种链接： (1)软链接 (2)硬链接 索引节点的成员i_op指向索引节点操作集合inode_operations，成员i_fop指向文件操作集合file_operations。两者的区别是：inode_operations用来操作目录和文件属性，file_operations用来访问文件的数据 索引节点操作集合的数据结构是结构体inode_operations\n// include/linux/fs.h struct inode_operations { // 在一个目录下查找文件 struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct inode *, int); struct posix_acl * (*get_acl)(struct inode *, int); int (*readlink) (struct dentry *, char __user *,int); int (*create) (struct inode *,struct dentry *, umode_t, bool); // 创建普通文件 int (*link) (struct dentry *,struct inode *,struct dentry *); // 创建硬链接 int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct inode *,struct dentry *,const char *); // 创建符号链接 int (*mkdir) (struct inode *,struct dentry *,umode_t); // 创建目录 int (*rmdir) (struct inode *,struct dentry *); // 删除目录 // 创建字符设备文件、块设备文件、命名管道和套接字 int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t); int (*rename) (struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*setattr) (struct dentry *, struct iattr *); // chmod调用设置文件属性 int (*getattr) (const struct path *, struct kstat *, u32, unsigned int); // stat读取文件属性 ssize_t (*listxattr) (struct dentry *, char *, size_t); // 列出文件的所有扩展属性 int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,u64 len); int (*update_time)(struct inode *, struct timespec *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode, int *opened); int (*tmpfile) (struct inode *, struct dentry *, umode_t); int (*set_acl)(struct inode *, struct posix_acl *, int); } ____cacheline_aligned; 6.2.5　目录项 内核访问存储设备上的一个目录项时，会在内存中创建目录项的一个副本：结构体dentry\n// include/linux/dcache.h struct dentry { /* RCU查找访问的字段 */ unsigned int d_flags; seqcount_t d_seq; struct hlist_bl_node d_hash; struct dentry *d_parent; struct qstr d_name; // 存储文件名称 struct inode *d_inode; // 指向文件的索引节点 unsigned char d_iname[DNAME_INLINE_LEN]; // 文件名称 /* 引用查找也访问下面的字段 */ struct lockref d_lockref; const struct dentry_operations *d_op; struct super_block *d_sb; unsigned long d_time; void *d_fsdata; union { struct list_head d_lru; wait_queue_head_t *d_wait; }; struct list_head d_child; struct list_head d_subdirs; /* * d_alias和d_rcu可以共享内存 */ union { struct hlist_node d_alias; struct hlist_bl_node d_in_lookup_hash; struct rcu_head d_rcu; } d_u; }; 目录项操作集合的数据结构是结构体dentry_operations\n// include/linux/dcache.h struct dentry_operations { int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_prune)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *, unsigned int); } ____cacheline_aligned; 6.2.6　文件的打开实例和打开文件表 进程打开一个文件，虚拟文件系统就会创建文件的一个打开实例：file结构体\n// include/linux/fs.h struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; const struct file_operations *f_op; spinlock_t f_lock; atomic_long_t f_count; unsigned int f_flags; fmode_t f_mode; struct mutex f_pos_lock; loff_t f_pos; struct fown_struct f_owner; const struct cred *f_cred; … void *private_data; … struct address_space *f_mapping; } __attribute__((aligned(4))); // f_path存储文件在目录树中的位置 struct path { struct vfsmount *mnt; struct dentry *dentry; }; 文件打开实例和索引节点关系 进程描述符有两个文件系统相关的成员：成员fs指向进程的文件系统信息结构体，主要是进程的根目录和当前工作目录；成员files指向打开文件表\n// include/linux/sched.h struct task_struct { … struct fs_struct *fs; struct files_struct *files; … }; // include/linux/fs_struct.h struct fs_struct { … // root存储进程的根目录 pwd进程当前工作目录 struct path root, pwd; }; 打开文件表称为文件描述符表，结构体files_struct是打开文件表的包装器 // include/linux/fdtable.h struct files_struct { atomic_t count; // 引用计数 … struct fdtable __rcu *fdt; // 指向打开文件表 struct fdtable fdtab; spinlock_t file_lock ____cacheline_aligned_in_smp; unsigned int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1]; unsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; fdt指向新的fdtable结构体，打开文件表的数据结构\n// include/linux/fdtable.h struct fdtable { unsigned int max_fds; struct file __rcu **fd; unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu; }; 6.3　注册文件系统类型 每种文件系统需要向虚拟文件系统注册文件系统类型file_system_type，实现mount方法用来读取和解析超级块 // register_filesystem用来注册文件系统类型 int register_filesystem(struct file_system_type *fs); // unregister_filesystem用来注销文件系统类型 int unregister_filesystem(struct file_system_type *fs); cat /proc/filesystems 查看已经注册的文件系统类型\n6.4　挂载文件系统 虚拟文件系统在内存中把目录组织为一棵树 glibc库封装了挂载文件系统的函数mount\nint mount(const char *dev_name, const char *dir_name, const char *type, unsigned long flags, const void *data); // 内核的系统调用oldumount int umount(const char *target); // 内核的系统调用umount int umount2(const char *target, int flags); 挂载描述符的数据结构 6.4.1　系统调用mount 系统调用mount用来挂载文件系统\n// fs/namespace.c SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name, char __user *, type, unsigned long, flags, void __user *, data) mount挂载的执行流程 6.4.2　绑定挂载 mount --bind olddir newdir mount --rbind olddir newdir 6.4.3　挂载命名空间 容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源，其中挂载命名空间用来隔离挂载点\n进程和挂载命名空间关系 两种方法创建新的挂载命名空间 (1)调用clone创建子进程，指定标准CLONE_NEWNS (2)调用unshare(CLONE_NEWNS)置不再和父进程共享挂载命名空间 1．标准的挂载命名空间 2．共享子树 共享子树提供了4种挂载类型。 共享挂载（shared mount） 从属挂载（slave mount） 私有挂载（private mount） 不可绑定挂载（unbindable mount） 6.4.4　挂载根文件系统 1．根文件系统rootfs 2．用户指定的根文件系统 6.5　打开文件 进程读写文件之前需要打开文件，得到文件描述符，然后通过文件描述符读写文件\n6.5.1 编程接口 内核两个打开文件的系统调用\nint open(const char *pathname, int flags, mode_t mode); int openat(int dirfd, const char *pathname, int flags, mode_t mode); 6.5.2　技术原理 系统调用open和openat都把主要工作委托给函数do_sys_open，open传入特殊的文件描述符AT_FDCWD\n// fs/open.c SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) { /* 如果是64位内核，强制设置标志位O_LARGEFILE，表示允许打开长度超过4GB的大文件。*/ if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(AT_FDCWD, filename, flags, mode); } SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode) { if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(dfd, filename, flags, mode); } include/uapi/linux/fcntl.h #define AT_FDCWD -100 1．分配文件描述符 函数get_unused_fd_flags负责分配文件描述符\n// fs/file.c int get_unused_fd_flags(unsigned flags) { return __alloc_fd(current-\u0026gt;files, 0, rlimit(RLIMIT_NOFILE), flags); } // fs/file.c int __alloc_fd(struct files_struct *files, unsigned start, unsigned end, unsigned flags) { unsigned int fd; int error; struct fdtable *fdt; spin_lock(\u0026amp;files-\u0026gt;file_lock); repeat: fdt = files_fdtable(files); fd = start; if (fd \u0026lt; files-\u0026gt;next_fd) fd = files-\u0026gt;next_fd; if (fd \u0026lt; fdt-\u0026gt;max_fds) fd = find_next_fd(fdt, fd); error = -EMFILE; if (fd \u0026gt;= end) goto out; error = expand_files(files, fd); if (error \u0026lt; 0) goto out; if (error) goto repeat; if (start \u0026lt;= files-\u0026gt;next_fd) files-\u0026gt;next_fd = fd + 1; __set_open_fd(fd, fdt); if (flags \u0026amp; O_CLOEXEC) __set_close_on_exec(fd, fdt); else __clear_close_on_exec(fd, fdt); error = fd; … out: spin_unlock(\u0026amp;files-\u0026gt;file_lock); return error; } 2．解析文件路径 do_filp_open解析文件路径并得到文件的索引节点，创建文件的一个打开实例，把打开实例关联到索引节点\n// fs/namei.c struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op) { struct nameidata nd; int flags = op-\u0026gt;lookup_flags; struct file *filp; set_nameidata(\u0026amp;nd, dfd, pathname); filp = path_openat(\u0026amp;nd, op, flags | LOOKUP_RCU); if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(\u0026amp;nd, op, flags); if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(\u0026amp;nd, op, flags | LOOKUP_REVAL); restore_nameidata(); return filp; } 结构体nameidata用来向解析函数传递参数，保存解析结果\n// fs/namei.c struct nameidata { struct path path; struct qstr last; struct path root; struct inode *inode; /* path.dentry.d_inode */ unsigned int flags; … unsigned depth; … struct saved { struct path link; struct delayed_call done; const char *name; unsigned seq; } *stack, internal[EMBEDDED_LEVELS]; struct filename *name; … int dfd; }; 函数do_filp_open三次调用函数path_openat以解析文件路径\n// fs/namei.c static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags) { const char *s; struct file *file; int opened = 0; int error; file = get_empty_filp(); if (IS_ERR(file)) return file; file-\u0026gt;f_flags = op-\u0026gt;open_flag; … s = path_init(nd, flags); if (IS_ERR(s)) { put_filp(file); return ERR_CAST(s); } while (!(error = link_path_walk(s, nd)) \u0026amp;\u0026amp; (error = do_last(nd, file, op, \u0026amp;opened)) \u0026gt; 0) { nd-\u0026gt;flags \u0026amp;= ～(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL); s = trailing_symlink(nd); if (IS_ERR(s)) { error = PTR_ERR(s); break; } } terminate_walk(nd); out2: … return file; } 函数link_path_walk负责解析文件路径\n函数walk_component负责解析文件路径的一个分量\ndo_last负责解析文件路径的最后一个分量，并且打开文件\n6.6　关闭文件 进程可以使用系统调用close关闭文件\nint close(int fd); 关闭文件的执行流程 延迟工作项delayed_fput_work的处理函数是flush_delayed_fput\n// fs/file_table.c void flush_delayed_fput(void) { delayed_fput(NULL); } static void delayed_fput(struct work_struct *unused) { struct llist_node *node = llist_del_all(\u0026amp;delayed_fput_list); struct llist_node *next; for (; node; node = next) { next = llist_next(node); __fput(llist_entry(node, struct file, f_u.fu_llist)); } } 遍历链表delayed_fput_list，针对每个file实例，调用函数__fput来加以释放,__fput负责释放file实例\n// fs/file_table.c static void __fput(struct file *file) { struct dentry *dentry = file-\u0026gt;f_path.dentry; struct vfsmount *mnt = file-\u0026gt;f_path.mnt; struct inode *inode = file-\u0026gt;f_inode; … fsnotify_close(file); // 通告关闭文件事件 eventpoll_release(file); // 监听文件系统的事件 locks_remove_file(file); // … if (file-\u0026gt;f_op-\u0026gt;release) // 释放文件锁 file-\u0026gt;f_op-\u0026gt;release(inode, file); … fops_put(file-\u0026gt;f_op); // 把文件操作集合结构体的引用计数减1 … // 解除file实例和目录项、挂载描述符以及索引节点的关联 file-\u0026gt;f_path.dentry = NULL; file-\u0026gt;f_path.mnt = NULL; file-\u0026gt;f_inode = NULL; file_free(file); // 释放file实例的内存 dput(dentry); // 释放目录项 mntput(mnt); // 释放挂载描述符 } 6.7　创建文件 6.7.1　使用方法 创建不同类型的文件，需要使用不同的命令 (1)普通文件：touch FILE (2)目录： mkdir DIR (3)符号链接：ln -s TRAGET LINK_NAME 或 ln \u0026ndash;symbolic TARGET LINK_NAME (4)符号或块设备： mknod NAME TYPE (5)命令管道：mkpipe NAME (6)硬链接: ln TARGET LINK_NAME 内核提供了下面这些创建文件的系统调用 (1)创建普通文件\nint creat(const char *pathname, mode_t mode); int open(const char *pathname, int flags, mode_t mode); int openat(int dirfd, const char *pathname, int flags, mode_t mode); (2)创建目录\nint mkdir(const char *pathname, mode_t mode); int mkdirat(int dirfd, const char *pathname, mode_t mode); (3)创建符号链接\nint symlink(const char *oldpath, const char *newpath); int symlikat(const char *oldpath, int newdirfd, const char *newpath); (4)mknod创建字符设备文件和块设备文件\nint mknod(const char *pathname, mode_t mode, dev_t dev); int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev); (5)link创建硬链接\nint link(const char *oldpath, const char *newpath); int linkat(int oldfd, const char *oldpath, int newfd, const char *newpath); glibc库封装了和上面的系统调用同名的库函数，封装创建命名管道的库函数\nint mkfifo(const char *pathname, mode_t mode); 6.7.2　技术原理 统调用open创建文件和打开文件，仅仅在函数do_last中存在差异。函数do_last负责解析文件路径的最后一个分量，并且打开文件 函数do_last创建文件的执行流程\n6.8　删除文件 6.8.1　使用方法 删除文件的命令 (1)删除任何类型的文件：unlink FILE (2)rm FILE，默认不删除目录, -r -R \u0026ndash;recutsive (3)删除目录 rmdir DIR 内核提供删除文件的系统调用 (1)unlink用来删除文件的名称，如果文件的硬链接计数变成0，并且没有进程打开这个文件，那么删除文件\nint unlink(const char *pathname); int unlinkat(int dirfd, const char *pathname, int flags); (2)删除目录\nint rmdir(const char *pahtname); 6.8.2　技术原理 删除文件需要从父目录的数据中删除文件对应的目录项，把文件的索引节点的硬链接计数减1（一个文件可以有多个名称，Linux把文件名称称为硬链接），如果索引节点的硬链接计数变成0，那么释放索引节点。因为各种文件系统类型的物理结构不同，所以需要提供索引节点操作集合的unlink方法 系统调用unlink和unlinkat主要工作给函数do_unlinkat\n// fs/namei.c SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag) { if ((flag \u0026amp; ～AT_REMOVEDIR) != 0) return -EINVAL; if (flag \u0026amp; AT_REMOVEDIR) return do_rmdir(dfd, pathname); return do_unlinkat(dfd, pathname); } SYSCALL_DEFINE1(unlink, const char __user *, pathname) { return do_unlinkat(AT_FDCWD, pathname); } do_unlinkat的执行流程\n删除文件的执行流程 6.9　设置文件权限 6.9.1 使用方法 设置文件权限的命令\nchmod [OPTION]... MODE[,MODE]... FILE... chmod [OPTION]... OCTAL-MODE FILE... 内核设置文件圈系统调用\nint chmod(const char *path, mode_t mode); int fchmod(int fd, mode_t mode); int fchmodat(int dfd, const char *filename, mode_t mode); 6.9.2　技术原理 修改文件权限需要修改文件的索引节点的文件模式字段，文件模式字段包含文件类型和访问权限。因为各种文件系统类型的索引节点不同，所以需要提供索引节点操作集合的setattr方法 系统调用chmod负责修改文件权限\n// fs/open.c SYSCALL_DEFINE2(chmod, const char __user *, filename, umode_t, mode) { return sys_fchmodat(AT_FDCWD, filename, mode); } // 系统调用chmod调用fchmodat // fs/open.c SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, umode_t, mode) { struct path path; int error; unsigned int lookup_flags = LOOKUP_FOLLOW; retry: error = user_path_at(dfd, filename, lookup_flags, \u0026amp;path); if (!error) { error = chmod_common(\u0026amp;path, mode); path_put(\u0026amp;path); if (retry_estale(error, lookup_flags)) { lookup_flags |= LOOKUP_REVAL; goto retry; } } return error; } 首先调用函数user_path_at解析文件路径，然后调用函数chmod_common修改文件权限\nchmod_common的执行流程 6.10 页缓存 文件的页缓存的数据结构\n6.10.1　地址空间 每个文件都有一个地址空间结构体address_space，用来建立数据缓存（在内存中为某种数据创建的缓存）和数据来源（即存储设备）之间的关联\n// include/linux/fs.h struct address_space { struct inode *host; // 指向索引节点 struct radix_tree_root page_tree; spinlock_t tree_lock; // 保护基数树 … const struct address_space_operations *a_ops; // 指向地址空间操作集合 … } __attribute__((aligned(sizeof(long)))); 地址空间操作集合address_space_operations\n// include/linux/fs.h struct address_space_operations { int (*writepage)(struct page *page, struct writeback_control *wbc); int (*readpage)(struct file *, struct page *); int (*writepages)(struct address_space *, struct writeback_control *); int (*set_page_dirty)(struct page *page); int (*readpages)(struct file *filp, struct address_space *mapping, struct list_head *pages, unsigned nr_pages); int (*write_begin)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata); int (*write_end)(struct file *, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata); … } 6.10.2　基数树 基数树（radix tree）是n叉树，内核为n提供了两种选择：16或64，默认64\n// include/linux/radix-tree.h #ifndef RADIX_TREE_MAP_SHIFT #define RADIX_TREE_MAP_SHIFT (CONFIG_BASE_SMALL ? 4 : 6) #endif #define RADIX_TREE_MAP_SIZE (1UL \u0026lt;\u0026lt; RADIX_TREE_MAP_SHIFT) init/kconfig config BASE_SMALL /* 表示使用小的内核数据结构，可以减少内存消耗。 */ int default 0 if BASE_FULL /* 如果开启BASE_FULL，那么默认关闭BASE_SMALL。 */ default 1 if !BASE_FULL config BASE_FULL /* 表示启用全尺寸的内核数据结构，默认启用。 */ default y bool \u0026#34;Enable full-sized data structures for core\u0026#34; if EXPERT 6.10.3　编程接口 页缓存的常用操作函数\n// 根据文件的页索引在页缓存中查找内存页 struct page *find_get_page(struct address_space *mapping, pgoff_t offset); // 据文件的页索引在页缓存中查找内存页，如果没有找到内存页， // 那么分配一个内存页，然后添加到页缓存中 struct page *find_or_create_page(struct address_space *mapping, pgoff_t offset, gfp_t gfp_mask) // 把一个内存页添加到页缓存和LRU链表中 int add_to_page_cache_lru(struct page *page, struct address_space *mapping, pgoff_t offset, gfp_t gfp_mask); // 从页缓存中删除一个内存页 void delete_from_page_cache(struct page *page); 6.11　读文件 6.11.1　编程接口 进程读文件的方式有3种 (1)调用内核提供的读文件的系统调用 (2)调用glibc库封装的读文件的标准I/O流函数 (3)创建基于文件的内存映射，把文件的一个区间映射到进程的虚拟地址空间，然后直接读内存 内核读文件的系统调用 (1)系统调用read从文件的当前偏移读文件\nssize_t read(int fd, void *buf, size_t count); (2)系统调用pread64从指定偏移开始读文件\nssize_t pread64(int fd, void *buf, size_t count, off_t offset); glibc库还封装了一个读文件的标准I/O流函数\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 6.11.2　技术原理 读文件系统调用是read\n// fs/read_write.c SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) 系统调用read的执行流程 EXT4文件系统文件操作集合的read_iter方法\n// const struct file_operations ext4_file_operations = { … .read_iter = ext4_file_read_iter, … }; 函数ext4_file_read_iter调用通用的读文件函数generic_file_read_iter\n6.12　写文件 6.12.1　编程接口 进程写文件的方式有3种 (1)调用内核提供的写文件的系统调用 (2)调用glibc库封装的写文件的标准I/O流函数 (3)创建基于文件的内存映射，把文件的一个区间映射到进程的虚拟地址空间，然后直接写内存 写文件的系统调用 (1)函数write从文件的当前偏移写文件，调用进程把要写入的数据存放在一个缓冲区\nssize_t write(int fd, const void *buf, size_t count); glibc库封装了一个写文件的标准I/O流函数\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 6.12.2　技术原理 写文件的主要步骤 (1)调用具体文件系统类型提供的文件操作集合的write或write_iter方法来写文件 (2)write或write_iter方法调用文件的地址空间操作集合的write_begin方法，在页缓存中查找页，如果页不存在，那么分配页；然后把数据从用户缓冲区复制到页缓存的页中；最后调用文件的地址空间操作集合的write_end方法 写文件系统调用是write\nfs/read_write.c SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count) EXT4文件系统提供了文件操作集合的write_iter方法\n// fs/ext4/file.c const struct file_operations ext4_file_operations = { … .write_iter = ext4_file_write_iter, … }; 函数ext4_file_write_iter调用通用的写文件函数__generic_file_write_iter\n6.13　文件回写 进程写文件时，内核的文件系统模块把数据写到文件的页缓存，没有立即写回到存储设备。文件系统模块会定期把脏页（即数据被修改过的文件页）写回到存储设备，进程也可以调用系统调用把脏页强制写回到存储设备 6.13.1　编程接口 内核提供了下面这些把文件同步到存储设备的系统调用 (1)sync把内存中所有修改过的文件元数据和文件数据写回到存储设备 void sync(void); (2)syncfs把文件描述符fd引用的文件所属的文件系统写回到存储设备\nint syncfs(int fd); (3)fsync把文件描述符fd引用的文件修改过的元数据和数据写回到存储设备\nint fsync(int fd); (4)fdatasync把文件描述符fd引用的文件修改过的数据写回到存储设备，还会把检索这些数据需要的元数据写回到存储设备\nint fdatasync(int fd); (5)Linux私有的系统调用sync_file_range把文件的一个区间修改过的数据写回到存储设备\nint sync_file_range(int fd, off64_t offset, off64_t nbytes, unsigned int flags); glibc库对系统调用封装库函数，封装了一个把数据从用户空间缓冲区写到内核的标准I/O流函数\nint fflush(FILE *stream); 6.13.2 技术原理 文件写回到存储设备的时机 (1)周期写回 (2)脏页的数量达到限制的时候，强制回写 (3)进程调用sync和syncfs等系统调用 1.数据结构 文件写回数据结构\n在挂载存储设备上的文件系统时，具体文件系统类型提供的mount方法从存储设备读取超级块，在内存中创建超级块的副本，把超级块关联到描述存储设备信息的结构体backing_dev_info\n// include/linux/backing-dev-defs.h struct backing_dev_info { struct list_head bdi_list; … struct bdi_writeback wb; … }; // include/linux/backing-dev-defs.h struct bdi_writeback { … struct list_head b_dirty; struct list_head b_io; … struct delayed_work dwork; … }; 内核创建了一个名为“writeback”的工作队列，专门负责把文件写回到存储设备，称为回写工作队列。全局变量bdi_wq指向回写工作队列\n// mm/backing-dev.c struct workqueue_struct *bdi_wq; static int __init default_bdi_init(void) { … bdi_wq = alloc_workqueue(\u0026#34;writeback\u0026#34;, WQ_MEM_RECLAIM | WQ_FREEZABLE | WQ_UNBOUND | WQ_SYSFS, 0); … } subsys_initcall(default_bdi_init); 修改文件的属性，以调用chmod修改文件的访问权限,ext4_setattr的执行过程\n系统调用write调用EXT4文件系统提供的文件操作集合的write_iter方法：函数ext4_file_write_iter\n函数wb_wakeup_delayed把回写控制块的延迟工作项添加到回写工作队列，超时是周期回写的时间间隔\n// mm/backing-dev.c void wb_wakeup_delayed(struct bdi_writeback *wb) { unsigned long timeout; timeout = msecs_to_jiffies(dirty_writeback_interval * 10); spin_lock_bh(\u0026amp;wb-\u0026gt;work_lock); if (test_bit(WB_registered, \u0026amp;wb-\u0026gt;state)) queue_delayed_work(bdi_wq, \u0026amp;wb-\u0026gt;dwork, timeout); spin_unlock_bh(\u0026amp;wb-\u0026gt;work_lock); } 2．周期回写 周期回写的时间间隔是5秒，通过/proc/sys/vm/dirty_writeback_centisecs配置\n// mm/page-writeback.c unsigned int dirty_writeback_interval = 5 * 100; /*厘秒*/ 一页保持为脏状态的最长时间是30秒，通过/proc/sys/vm/dirty_expire_centisecs\n// mm/page-writeback.c unsigned int dirty_expire_interval = 30 * 100; /*厘秒*/ 周期回写的执行流程\n3．强制回写 脏页的数量超过后台回写阈值时，默认的脏页比例是10，/proc/sys/vm/dirty_background_ratio，通过/proc/sys/vm/dirty_background_bytes修改脏页字节数\n// mm/page-writeback.c int dirty_background_ratio = 10; unsigned long dirty_background_bytes; 脏页的数量达到进程主动回写阈值后，默认的脏页比例是20，/proc/sys/vm/dirty_ratio修改脏页比例，/proc/sys/vm/dirty_bytes修改脏页字节数\n// mm/page-writeback.c int vm_dirty_ratio = 20; unsigned long vm_dirty_bytes; 调用函数balance_dirty_pages_ratelimited控制进程写文件时生成脏页的速度，如果脏页的数量超过（后台回写阈值 + 进程主动回写阈值）/2\n4.系统调用sync 执行命令sync，函数调用系统调用sync，把内存中所有修改过的文件属性和数据写回到存储设备\n// fs/sync.c SYSCALL_DEFINE0(sync) 6.14　DAX 内存的块设备，例如NVDIMM设备，不需要把文件从存储设备复制到页缓存。DAX(Direct Access，直接访问)绕过页缓存，直接访问存储设备，对于基于文件的内存映射，直接把存储设备映射到进程的虚拟地址空间\n6.14.1　使用方法 编译内核配置宏 CONFIG_DAX、CONFIG_FS_DAX\n6.14.2　技术原理 EXT4文件系统，文件操作集合的read_iter方法是函数ext4_file_read_iter，执行流程\nEXT4文件系统，文件操作集合的mmap方法是函数ext4_file_mmap\n// fs/ext4/file.c static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma) { struct inode *inode = file-\u0026gt;f_mapping-\u0026gt;host; … if (IS_DAX(file_inode(file))) { vma-\u0026gt;vm_ops = \u0026amp;ext4_dax_vm_ops; vma-\u0026gt;vm_flags |= VM_MIXEDMAP | VM_HUGEPAGE; } else { vma-\u0026gt;vm_ops = \u0026amp;ext4_file_vm_ops; } return 0; } static const struct vm_operations_struct ext4_dax_vm_ops = { .fault = ext4_dax_fault, .huge_fault = ext4_dax_huge_fault, .page_mkwrite = ext4_dax_fault, .pfn_mkwrite = ext4_dax_pfn_mkwrite, }; EXT4文件系统提供的fault方法是函数ext4_dax_fault\n6.15　常用的文件系统类型 机械硬盘和固态硬盘块设备常用的文件系统是EXT4和btrfs，闪存常用的文件系统是JFFS2和UBIFS 存储设备的容量比较小，可以使用只读的压缩文件系统squashfs，对程序和数据进行压缩。如果需要支持在文件系统中创建文件和写文件，可以使用overlay文件系统把可写的文件系统叠加在squashfs文件系统的上面\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","summary":"内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区","title":"Linux内核深度解析"},{"content":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉取更新代码 git pull # 推送 git push # 合并已push的commit git rebase -i HEAD~n # 强制更新覆盖本次 git fetch --all git reset --hard HEAD git pull # 强制推送 git push -u origin br_master --force # 回合代码 git rebase master # 回退已提交commit git reset --soft \u0026lt;commit-ID\u0026gt; # 忽略部分文件提交 git add filename # 放入本地栈 git stash -u -k git commit git push # 弹出本地栈 git stash pop git配置 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@163.com\u0026#34; git config --list user.name=xxx user.email=xxx@163.com # 生成秘钥 ssh-keygen -t rsa -C \u0026#39;xxx@163.com\u0026#39; # cd ~/.ssh 将 id_rsa.pub 添加道GitHub # 测试链接 ssh -T git@github.com # 设置默认编辑为vim git config --global core.editor \u0026#34;vim\u0026#34; 玩转WSL(6)之Git配置\ngit同时配置Gitee和Github\nGit设置换行符为LF\ngit使用小技巧 url.\n自动上传脚本 #!/usr/bin/env bash # Filename: deploy.sh # #### Action 1 #### echo -e \u0026#34; ===========Building web pages... [HTML]===============\u0026#34; # Build the project. #hugo --config ./config/_default/config.toml --gc --minify hugo -F --cleanDestinationDir #### Action 2 #### echo -e \u0026#34; ++++++++++++++++Upload the HUGO br_hugo site...++++++++++++++ \u0026#34; # ---------------------------------------------- # Add changes to git. git status git add . # Commit changes. msg=\u0026#34;Update $(date +\u0026#34;[%x %T]\u0026#34;)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin br_hugo # ---------------------------------------------- #### Action 3 #### echo -e \u0026#34; -----------Upload pages to master CODING... [HTML]---------- \u0026#34; # Go To Repository folder cd public # ---------------------------------------------- # Add changes to git. git status git add . # Commit changes. msg=\u0026#34;Update $(date +\u0026#34;[%x %T]\u0026#34;)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master # ---------------------------------------------- # Come Back up to the Project Root cd .. echo -e \u0026#34; ===========Upload Successful [HTML]=========== \u0026#34; ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/git/","summary":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉","title":"git"},{"content":"python logging # logging.yaml： version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #保留50个log文件 encoding: utf8 server_file_handler: class: logging.handlers.RotatingFileHandler level: INFO # 只在文件中记录INFO级别及以上的log formatter: upgrade filename: ./logs/server.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 loggers: server: level: DEBUG #允许打印DEBUG及以上log handlers: [server_file_handler] propagate: true #设为false则禁止将日志消息传递给父级记录器的处理程序中 root: level: DEBUG handlers: [console, all_file_handler] # logger.py # logging.py from fileinput import filename import os import time import yaml import logging.config import logging import datetime #import coloredlogs class Logger(): def __init__(self, log_name=\u0026#34;log.log\u0026#34;, log_path = \u0026#34;./logs\u0026#34;, default_path = \u0026#34;logging.yaml\u0026#34;, default_level = logging.INFO,env_key = \u0026#34;LOG_CFG\u0026#34;): self.log_name = log_name self.log_path = log_path #time_stamp = time. now = time.strftime(\u0026#39;%Y-%m-%d %H_%M_%S_\u0026#39;) # 文件的命令以及打开路径 log_filename = self.log_path + \u0026#34;/\u0026#34; + now + self.log_name with open(file=default_path, mode=\u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;)as file: logging_yaml = yaml.load(stream=file, Loader=yaml.FullLoader) logging_yaml[\u0026#39;handlers\u0026#39;][\u0026#39;all_file_handler\u0026#39;][\u0026#39;filename\u0026#39;] = log_filename print(\u0026#34;logging_yaml \u0026#34;,logging_yaml) handlers = logging_yaml[\u0026#39;handlers\u0026#39;] for key, value in handlers.items(): if \u0026#39;filename\u0026#39; in value: log_path = (os.path.split(value[\u0026#39;filename\u0026#39;])[0]) print(\u0026#34;log_path\u0026#34;) if not os.path.exists(log_path): os.makedirs(log_path) # 配置logging日志：主要从文件中读取handler的配置、formatter（格式化日志样式）、logger记录器的配置 logging.config.dictConfig(config=logging_yaml) ###设置完毕### # 获取根记录器：配置信息从yaml文件中获取 root = logging.getLogger() # 子记录器的名字与配置文件中loggers字段内的保持一致 server = logging.getLogger(\u0026#34;server\u0026#34;) print(\u0026#34;rootlogger:\u0026#34;, root.handlers) print(\u0026#34;serverlogger:\u0026#34;, server.handlers) print(\u0026#34;子记录器与根记录器的handler是否相同：\u0026#34;, root.handlers[0] == server.handlers[0]) if __name__ ==\u0026#39;__main__\u0026#39;: Logger() logging.info(\u0026#34;first log\u0026#34;) 参考链接：\nhttps://blog.csdn.net/weixin_43988680/article/details/123528294 https://zhuanlan.zhihu.com/p/425678081 https://blog.csdn.net/qq_35812205/article/details/126480417 https://blog.csdn.net/TracelessLe/article/details/108887001 c log zlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/logging/","summary":"python logging # logging.yaml： version: 1 disable_existing_loggers: False formatters: simple: format: \u0026#39;%(asctime)s %(levelname)s %(message)s\u0026#39; upgrade: format: \u0026#34;%(asctime)s -Loc %(filename)s -Pid %(process)d -%(name)s -%(levelname)s - %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout all_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: upgrade filename: ./logs/all_log.log maxBytes: 10485760 # 10MB backupCount: 50 #保留50个lo","title":"logging"},{"content":" LInux系统启动5个阶段： 内核引导 -\u0026gt; 运行init -\u0026gt; 系统初始化 -\u0026gt; 建立终端 -\u0026gt; 用户登录系统\n1.内核引导 机器上电后，BIOS开机自检，根据BIOS中设置的启动设备(通常为硬盘)启动 操作系统阶段硬件，首先读入/boot目录下内核文件 \\\ninit 进程是系统所有进程的起点，init 程序首先是需要读取配置文件 /etc/inittab。 许多程序需要开机启动。它们在Windows叫做\u0026quot;服务\u0026quot;（service），在Linux就叫做\u0026quot;守护进程\u0026quot;（daemon） init进程的一大任务，就是去运行这些开机启动的程序。 不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache， Linux允许为不同的场合，分配不同的开机启动程序，这就叫做\u0026quot;运行级别\u0026quot;（runlevel）。也就是说，启动时根据\u0026quot;运行级别\u0026quot;，确定要运行哪些程序 \\\nLinux系统有7个运行级别(runlevel)： 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 \\\n2.系统初始化 在init的配置文件中有这么一行：si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本 它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。 \\\n15:5wait:/etc/rc.d/rc 5 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下 而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数 /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行 而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行 这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。 至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\u0026quot;System Services\u0026quot;来自行设定 \\\nrc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。 init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端： \\\n从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。 同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份 \\\n3.用户登录系统 一般来说，用户的登录方式有三种： （1）命令行登录 （2）ssh登录 （3）图形界面登录 \\\n对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。 而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。 Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。 然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。 这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。 /etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制 \\\n参考链接 https://mp.weixin.qq.com/s?__biz=Mzg4OTgyNzQwMQ==\u0026amp;mid=2247484052\u0026amp;idx=1\u0026amp;sn=4b74f1134fcd2e9341173653d271bbd6\u0026amp;chksm=cfe4bbb2f89332a491e774cbcce98f8b7e9075d837bfa58dd0a9d5b151f72647dac8f0cae5e0\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=1231tifch9Iyv8wFwiPLT39I\u0026amp;sharer_sharetime=1672481021630\u0026amp;sharer_shareid=813a8c319563d8c50feefd77b191f183#rd ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/","summary":"LInux系统启动5个阶段： 内核引导 -\u0026gt; 运行init -\u0026gt; 系统初始化 -\u0026gt; 建立终端 -\u0026gt; 用户登录系统 1.内核引导 机器上电后，BIOS开机自检，根据BIOS","title":"linux系统启动"},{"content":"多年经验总结，写出最惊艳的 Markdown 高级用法\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/markown/","summary":"多年经验总结，写出最惊艳的 Markdown 高级用法","title":"Markdown"},{"content":"Lec18 OS organization 18.1 Monolithic kernel 宏内核：Linux，Unix 微内核：mac\n宏内核 微内核 优点 可移植\n虚拟地址空间\n共享资源\n通用性 缺点 Bug和安全漏洞 XV6编译 XV6代码三部分：kernel、user和mkfs QEMU https://blog.csdn.net/fangye945a/article/details/121962409\nsudo apt-get install ninja-build\nhttps://blog.csdn.net/Leo_h1104/article/details/115580753\nhttps://zhuanlan.zhihu.com/p/351865040\nhttps://zhuanlan.zhihu.com/p/466423677\ngdb make qemu echo set auto-load safe-path / \u0026gt; ~/.gdbinit gdb-multiarch\nlayout split\nb站课程：\nhttps://www.bilibili.com/video/BV19k4y1C7kA?p=2\u0026amp;spm_id_from=pageDriver\u0026amp;vd_source=6768732acbd0f78ac59230d2faa59a86 \\\n课程翻译: https://github.com/huihongxiao/MIT6.S081 https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/ \\\nhttps://pdos.csail.mit.edu/6.828/2020/schedule.html \\\nhttps://pdos.csail.mit.edu/6.828/2020/schedule.html \\\nMIT 6.S081 2020 操作系统 [中英文字幕]\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/mit-6.s081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"Lec18 OS organization 18.1 Monolithic kernel 宏内核：Linux，Unix 微内核：mac 宏内核 微内核 优点 可移植 虚拟地址空间 共享资源 通用性 缺点 Bug和安全漏洞 XV6编译 XV6代","title":"MIT 6.S081操作系统"},{"content":"第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内核态、虚拟机、安全态 PSTATE寄存器中NZCV标志：负零进溢 PSTATE寄存器DAIF异常掩码标志位 1.1 ARM简介 ARM体系结构是一种硬件规范，主要约定指令集、芯片内部体系结构 ARMv8体系结构处理器IP Cortex-A53、Cortex-A55、Cortex-A72、Cortex-A77 1.2 ARMv8体系结构基础知识 1.2.1 ARMv8体系结构 ARMv8是64位处理器指令集和体系结构 64位虚拟地址空间，32位仅支持4GB 31个64位宽通用寄存器 支持16KB和64Kb页面，降低TLB未命中率 异常处理模型EL0~EL3 加载-获取指令(Load-Acquire Instruction)，存储-释放指令(Store-Release Instruction) 1.2.2 ARMv8处理器内核 Cortex-A53 Cortex-A57 Cortex-A72 1.2.3 ARMv8体系结构基本概念 ARMv8体系结构基本概念和定义 处理机PE(Processing Element):处理器处理事务过程抽象 执行状态(execution state):处理器运行时环境，包括寄存器位宽、支持指令集、异常模型、内存管理以及编程模型 ARMv8两个执行状态\nAArch64：64位执行状态 31个通用寄存器 64位程序计数(PC)指针寄存器、栈指针(Stack Pointer SP)寄存器及异常链接寄存器(Exception Link Register ELR) A64指令集 ARMv8异常模型，4个异常等级，即EL0~EL3 64位内存模型 一组处理器状态(PSTATE)保存PE状态 AArch32: 32位执行状态 AArch64状态，部分系统寄存器在不同异常等级提供不同变种寄存器\n\u0026lt;register_name\u0026gt;_ELx // x: 0 1 2 3 1.2.4 A64指令集 ARMv8体系结构64位指令集：处理64位宽寄存器和数据并使用64位指针访问内存\n1.2.5 ARMv8处理器执行状态 AArch64状态异常等级(exception level)确定处理器当前运行的特权级别\nEL0：用户特权 EL1：系统特权，操作系统内核，系统使能虚拟化扩展，运行虚拟操作系统内核 EL2：运行虚拟化扩展的虚拟监控程序(hypervisor) EL3：运行安全世界中安全监控器(secure monitor) 1.2.6 ARMv8数据宽度 字节(byte)：8位 半字(halfword)：16位 字(word)：32位 双字(doubleword)：64位 四字(quadword)：128位 1.3 ARMv8寄存器 1.3.1 通用寄存器 AArch64执行状态支持31个64位通用寄存器，X0~X30寄存器，AArch32状态支持16个32位通用寄存器 AArch64状态下，X表示64位通用寄存器，W表示低32位的数据\n1.3.2 处理器状态 AArch64体系结构使用PSTATE寄存器表示当前处理器状态\n分　类 字　段 描　述 描　述 条件标志位 N 负数标志位。 在结果是有符号的二进制补码的情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0 Z 0标志位。如果结果为0，则Z=1；如果结果不为0，则Z=0 C 进位标志位。当发生无符号数溢出时，C=1。其他情况下，C=0 V 有符号数溢出标志位。\n　对于加/减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1；如果未发生溢出，则V=0。\n　对于其他指令，V通常不发生变化 执行状态控制 SS 软件单步。该位为1，说明在异常处理中使能了软件单步功能 IL 不合法的异常状态 nRW 当前执行状态 　0：处于AArch64状态 　1：处于AArch32状态 执行状态控制 EL 当前异常等级 　0：表示EL0\n　1：表示EL1\n　2：表示EL2\n　3：表示EL3 SP 选择SP寄存器。当运行在EL0时，处理器选择EL0的SP寄存器，即SP_EL0；当处理器运行在其他异常等级时，处理器可以选择使用SP_EL0或者对应的SP_ELn寄存器 异常掩码标志位 D 调试位。使能该位可以在异常处理过程中打开调试断点和软件单步等功能 A 用来屏蔽系统错误（SError） I 用来屏蔽IRQ F 用来屏蔽FIQ 访问权限 PAN 特权模式禁止访问（Privileged Access Never）位是ARMv8.1的扩展特性 　1：在EL1或者EL2访问属于EL0的虚拟地址时会触发一个访问权限错误 　0：不支持该功能，需要软件来模拟 UAO 用户访问覆盖标志位，是ARMv8.2的扩展特性 　1：当运行在EL1或者EL2时，没有特权的加载存储指令可以和有特权的加载存储指令一样访问内存，如LDTR指令\n　0：不支持该功能 1.3.3 特殊寄存器 ARMv8体系结构除31个通用寄存器外，还提供多个特殊寄存器\n1.零寄存器 ARMv8提供两个零寄存器(zero register)，寄存器内部全是0，WZR是32位零寄存器，XZR是64位零寄存器\n2.PC指针寄存器 PC指针寄存器用来存储当前运行指令的下一条指令地址，控制程序中指令的运行顺序，不可直接访问 3.SP寄存器 ARMv8体系结构支持4个异常等级，每个异常等级有专门SP寄存器：SP_EL0、SP_EL1、SP_EL2、SP_EL3 Linux内核使用SP_EL0存放进程中task_struct数据结构指针\n4.备份状态寄存器 运行异常处理程序时，处理器备份程序会保存备份程序状态寄存器(Savaed Program Status Register SPSR)里。当异常发生时，处理器会把PSTATE寄存器的值暂时保存到SPSR里，当异常处理完成并返回时，再把SPSR值恢复到PSTATE寄存器，SPSR字段：\n字　段 描　述 N 负数标志位 Z 零标志位 C 进位标志位 V 有符号数溢出标志位 DIT 与数据无关的指令时序（Data Independent Timing），ARMv8.4的扩展特性 UAO 用户访问覆盖标志位，ARMv8.2的扩展特性 PAN 特权模式禁止访问位，ARMv8.1的扩展特性 SS 表示是否使能软件单步功能。若该位为1，说明在异常处理中使能了软件单步功能 IL 不合法的异常状态 D 调试位。使能该位可以在异常处理过程中打开调试断点和软件单步等功能 A 用来屏蔽系统错误 I 用来屏蔽IRQ F 用来屏蔽FIQ M[4] 用来表示异常处理过程中处于哪个执行状态，若为0，表示AArch64状态 M[3:0] 异常模式 5. ELR ELR存放异常返回地址\n6.CurrentEL寄存器 该寄存器表示PSTATE寄存器中EL字段，保存异常等级，使用MRS指令读取当前异常等级\n7.DAIF寄存器 该寄存器表示PSTATE寄存器中[D、A、I、F]字段\n8.SPSel寄存器 寄存器表示PSTATE寄存器中SP字段，用于在SP_EL0和SP_ELn中选择SP寄存器\n9.PAN寄存器 PAN寄存器表示PSTATE寄存器中PAN字段，通过MSR和MRS指令设置PAN寄存器\n内核态访问用户态内存，主动调用内核接口，如copy_from_user()或copy_to_user() PAN寄存器值： 0：表示内核态可访问用户态内存 1：表示内核态访问用户态内存会触发访问权限异常 10.UAO寄存器 该寄存器表示PSTATE寄存器中UAO(User Access Override 用户访问覆盖)字段，MSR和MRS设置UAO寄存器，1表示EL1和EL2执行非特权指令效果和特权指令一样\n11.NZCV寄存器 PSTATE寄存器中{N, Z, C, V}\n1.3.4 系统寄存器 ARMv8体系结构7类系统寄存器 通用系统控制寄存器 调试寄存器 性能监控寄存器 活动监控寄存器 统计扩展寄存器 RAS寄存器 通用定时寄存器 系统寄存器支持不同的异常等级访问，Reg_ELx MSR和MRS指令访问系统寄存器 mrs x0, TTBR0_EL1 // 把TTBR0_EL1值复制到X0寄存器 msr TTBR0_El1, X0 // 把X0寄存器值复制到TTBR0_EL1 1.4 Cortex-A72处理器介绍 树莓派4B开发板，内置了4个Cortex-A72处理器内核 Cortex-A72处理器支持特性 采用ARMv8体系结构规范来设计，兼容ARMv8.0协议。\n超标量处理器设计，支持乱序执行的流水线。\n基于分支目标缓冲区(BTB)和全局..缓冲区(GHB)\n支持48个表项的全相连指令TLB，可以支持4 KB、64 KB以及1 MB大小的页面。\n支持32个表项的全相连数据TLB，可以支持4 KB、64 KB以及1 MB大小的页面。\n每个处理器内核支持4路组相连的L2 TLB。\n48 KB的L1指令高速缓存以及32 KB的L1数据高速缓存。\n可配置大小的L2高速缓存，可以配置为512 KB、1 MB、2 MB以及4 MB大小。\n基于AMBA4总线协议的ACE（AXI Coherency Extension）或者CHI（CoherentHubInterface）。\n支持PMUv3体系结构的性能监视单元。\n支持多处理器调试的CTI（Cross Trigger Interface）。\n支持GIC（可选）。\n支持多电源域（power domain）的电源管理。\n1.指令预取单元 指令预取单元从L1指令高速缓存中获取指令，每个周期向译码单元最多发送3条指令。支持动态和静态分支预测，指令预取单元功能：\nL1指令高速缓存是一个48 KB大小、3路组相连的高速缓存，每个缓存行的大小为64字节。 支持48个表项的全相连指令TLB，可以支持4 KB、64 KB以及1 MB大小的页面。 带有分支目标缓冲器的2级动态预测器，用于快速生成目标。 支持静态分支预测。 支持间接预测。 返回栈缓冲器。 2.指令译码单元 指令译码单元对A32、T32、A64指令集进行译码 指令译码单元执行寄存器重命名，消除写后写(WAW)和读后写(WAR)实现乱序执行 3.指令分派单元 指令分派单元控制译码后的指令何时被分派到执行管道及返回的结果何时终止，包括ARM核心通用寄存器、SIMD和浮点寄存器\n4.加载/存储单元 加载/存储单元(LSU)执行加载和存储指令，包括L1数据存储系统\n5.L1内存子系统 L1内存子系统包括指令内存系统和数据内存系统 L1指令内存系统包括如下特性 具有48 KB的指令高速缓存，3路组相连映射。 缓存行的大小为64字节。 支持物理索引物理标记（PIPT）。 高速缓存行的替换算法为LRU（Least Recently Used）算法。 L1数据内存系统包括如下特性 具有32 KB的数据高速缓存，两路组相连映射。 缓存行的大小为64字节。 支持物理索引物理标记。 对于普通内存，支持乱序发射、预测以及非阻塞的加载请求访问；对于设备内存，支持非预测以及非阻塞的加载请求访问。 高速缓存行的替换算法为LRU算法。 支持硬件预取。 6.MMU MMU实现虚拟地址到物理地址转换，AArch64支持4KB、16KB、64KB页面 MMU包括：\n48表项全相连的L1指令TLB 32表项全相连的L1数据TLB 4路组相连L2 TLB TLB支持8位或16位ASID，还支持VMID(虚拟化)\n7.L2内存子系统 L2内存子系统不仅负责处理每个处理器内核的L1指令和数据高速缓存未命中的情况，还通过ACE或者CHI连接到内存系统。其特性 可配置L2高速缓存的大小，大小可以是512 KB、1 MB、2 MB、4 MB。 缓存行大小为64字节。 支持物理索引物理标记。 具有16路组相连高速缓存。 缓存一致性监听控制单元（Snoop Control Unit，SCU）。 具有可配置的128位宽的ACE或者CHI。 具有可选的128位宽的ACP接口。 支持硬件预取。 1.5 ARMv9体系结构 ARMv9体系结构新加入的特性包括： 全新的可伸缩矢量扩展（Scalable Vector Extension version 2，SVE2）计算； 机密计算体系结构（Confidential Compute Architecture，CCA），基于硬件提供的安全环境来保护用户敏感数据； 分支记录缓冲区扩展（Branch Record Buffer Extension，BRBE），它以低成本的方式捕获控制路径历史的分支记录缓冲区； 内嵌跟踪扩展（Embedded Trace Extension，ETE）以及跟踪缓冲区扩展（Trace Buffer Extension，TRBE），用于增强对ARMv9处理器内核的调试和跟踪功能； 事务内存扩展（Transactional Memory Extension，TME） 第2章 搭建树莓派环境 2.1 树莓派 树莓派4B 博通BCM2711芯片 CPU内核：4核 A72 1.5GHz L1缓存： 32KB数据缓存，48KB指令缓存 L2缓存： 1MB GPU： VideoCoreV1核心，500MHz 内存： LPDDR4 两种地址模式：\n低地址模式 35位全地址模式 2.2 搭建树莓派环境 2.2.2 安装树莓派官方OS boot分区包括文件：\nbootcode.bin：引导程序 start4.elf：树莓派4B的GPU固件 start.elf： 树莓派3B的GPU固件 config.txt：配置文件 2.2.4 使用GDB和QEMU虚拟机调试BenOS 2.3 BenOS代码 2.4 QEMU虚拟机与ARM64 QEMU虚拟机与ARM64实验平台，书中Ubuntu20.04 1)安装工具\nsudo apt-get install qemu-system-arm libncurses5-dev gcc-aarch64-linux-gnu build-essential git bison flex libssl-dev # 查看ARM gcc版本 aarch64-linux-gnu-gcc -v 2)下载仓库\ngit clone git@github.com:figozhang/runninglinuxkernel_5.0.git 3)编译内核及创建文件系统 rootfs_arm64.tar.xz文件基于20.04系统的根文件系统创建\n# 编译内核 cd runninglinuxkernel_5.0 ./run_rlk_arm64.sh build_kernel # 编译文件系统 生成rootfs_arm64.ext4根文件系统 cd runninglinuxkernel_5.0 sudo ./run_rlk_arm64.sh build_rootfs 4)运行ARM64版本Linux系统\n./run_rlk_arm64.sh run # root 123 # 或 qemu-system-aarch64 -m 1024 -cpu max,sve=on,sev256=on -M virts 5)在线安装软件包 # 查看网络配置 ifconfig 6)主机和QEMU虚拟机共享文件 cp test.c runninglinuxkernel_5.0/kmodules/ # qemu cd /mnt ls 第3章 A64指令集I —— 加载与存储指令 A64指令特点 3.1 A64指令集介绍 ARMv8体系结构，A64指令集64位指令集，处理64位宽寄存器和数据，并使用64位指针访问内存，A64指令集指令宽度为32位 A64指集分类：\n内存加载和存储指令 多字节内存加载和存储指令 算数和移位指令 移位操作指令 位操作指令 条件操作指令 跳转指令 独占内存访问 内存屏障指令 异常处理指令 系统寄存器访问指令 3.2 A64指令编码 A64指令集指令宽度为32位，第24~28位识别指令分类\nop0字段值\nop0 字段值 说 明 0000x 保留 0010x 可伸缩矢量扩展(SVE)指令 100xx 数据处理指令(立即数) 101xx 分支处理指令、异常处理指令及系统寄存器访问指令 x1x0x 加载与存储指令 x101x 数据处理指令(基于寄存器) x111x 数据处理指令(浮点数与SIMD) 加载与存储指令分类 为什么指令编码宽度是32位？ A64指令集基于寄存器加载和存储体系结构设计，数据加载、存储及处理在通用寄存器中。ARM64一共31个通用寄存器X0~X30，因此在指令编码中使用5位宽，可索引32个通用寄存器 使用寄存器作为基地址，把SP(栈指针)寄存器当做第31个通用寄存器 用作源寄存器操作数时，把XZR当作第31个通用寄存器 3.3 加载与存储指令 ARMv8体系结构基于指令加载和存储体系结构，所有数据处理都通过通用寄存器完成，不能直接在内存中完成 常见内存加载指令是LDR指令，存储指令STR指令\nLDR 目标寄存器, \u0026lt;存储器地址\u0026gt; // 把存储地址中的数据加载到目标寄存器中 STR 源寄存器, \u0026lt;存储器地址\u0026gt; // 把源寄存器数据存储到存储器中 寻 址 模 式 说 明 基地址模式 [Xn] 基地址加偏移量模式 [Xn, #offset] 前变基模式 [Xn, #offset]! 后变基模式 [Xn] #offset PC相对地址模式 \u003c lable\u003e 3.3.1 基于基地址寻址模式 基地址模式寄存器值表示地址，基地址加偏移量模式基地址加上可正可负偏移 1.基地模式 指令以Xn寄存器值为内存地址，加载此内存地址内容到Xt寄存器\nLDR Xt, [Xn] 指令把Xt寄存器中内容存储到Xn寄存器的内存地址中\nSTR Xt, [Xn] ? 2.基地址加偏移量模式 指令把Xn寄存器值加偏移量(offset是8的倍数)，以相加的结果作为内存地址，加载此地址内容到Xt寄存器\n// 偏移量从指令编码imm12字段获取 0~32760B LDR Xt, [Xn, $offset] // 基地址加偏移量存储指令 STR Xt, [Xn, $offset] 3.基地址扩展模式 LDR \u0026lt;Xt\u0026gt;, {\u0026lt;Xn\u0026gt;, (\u0026lt;Xn\u0026gt;){, \u0026lt;extend\u0026gt; {\u0026lt;amount\u0026gt;}}} STR \u0026lt;Xt\u0026gt;, {\u0026lt;Xn\u0026gt;, (\u0026lt;Xn\u0026gt;){, \u0026lt;extend\u0026gt; {\u0026lt;amount\u0026gt;}}} 3.3.2 变基模式 两种变基模式\n前变基：先更新偏移量地址，后访问内存 后变基：先访问内存地址，后更新偏移量地址 // 前变基模式 LDR \u0026lt;Xt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;, #\u0026lt;simm\u0026gt;]! STR \u0026lt;Xt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;, #\u0026lt;simm\u0026gt;]! // 后变基模式 LDR \u0026lt;Xt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;], #\u0026lt;simm\u0026gt; STR \u0026lt;Xt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;], #\u0026lt;simm\u0026gt; 3.3.3 PC相对寻址模式 // LDR指令访问标签的地址 LDR \u0026lt;Xt\u0026gt;, \u0026lt;label\u0026gt; 3.3.4 LDR伪指令 // LDR伪指令 LDR Xt, =\u0026lt;label\u0026gt; // 把label标记的地址加载到Xt寄存器 Linux内核实现重定位伪代码\n// arch/arm64/kernel/head.S __primary_switch: adrp x1, init_pg_dir b1 __enable_mmu // 打开MMU ldr x8, =__primary_switched // 跳转 到链接地址，即内核空间虚拟地址 adrp x0, __PHYS_OFFSET // br x8 ENDPROC(__primary_switch) 3.4 加载与存储指令变种 3.4.1 不同位宽加载与存储指令 LDR、LDRSW、LDRB、LDRSB、LDRH、LDRSH、STRB、STRH\n3.4.2 不可扩展加载与存储指令 LDUR \u0026lt;Xt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;{, #\u0026lt;simm\u0026gt;}] STUR \u0026lt;Xt\u0026gt;, [\u0026lt;Xn|SP\u0026gt;{, #\u0026lt;simm\u0026gt;}] 不可扩展LDUR和STUR数据位宽变种\n3.4.3 多字节内存加载与存储指令 A64提供LDP和STP指令\n1.基地址偏移量模式 LDP \u0026lt;Xt1\u0026gt;, \u0026lt;Xt2\u0026gt;, [\u0026lt;Xn|SP\u0026gt;{, #\u0026lt;imm\u0026gt;}] STP \u0026lt;Xt1\u0026gt;, \u0026lt;Xt2\u0026gt;, [\u0026lt;Xn|SP\u0026gt;{, #\u0026lt;imm\u0026gt;}] 2.前变基模式 LDP \u0026lt;Xt1\u0026gt;, \u0026lt;Xt2\u0026gt;, [\u0026lt;Xn|SP\u0026gt;, #\u0026lt;imm\u0026gt;]! STP \u0026lt;Xt1\u0026gt;, \u0026lt;Xt2\u0026gt;, [\u0026lt;Xn|SP\u0026gt;, #\u0026lt;imm\u0026gt;]! 3.后变基模式 LDP \u0026lt;Xt1\u0026gt;, \u0026lt;Xt2\u0026gt;, [\u0026lt;Xn|SP\u0026gt;], #\u0026lt;imm\u0026gt; STP \u0026lt;Xt1\u0026gt;, \u0026lt;Xt2\u0026gt;, [\u0026lt;Xn|SP\u0026gt;], #\u0026lt;imm\u0026gt; 3.4.4 独占内存访问指令 ARMv8体系结构独占内存访问(exclusive memory access)指令，A64指令集LDXR指令尝试在内存总线中申请一个独占访问锁，然后访问一个内存地址。STXR会往LDXR指令申请独占访问内存地址中写入新内容。LDXR和STXR组合实现同步操作，如Linux内核自旋锁 ARMv8多字节多占内存访问指令，LDXP和STXP\n3.4.5 隐含加载-获取/存储-释放内存屏障原语 内存屏障原语LDAR和STAR\n3.4.6 非特权访问级别加载和存储指令 3.5 入栈和出栈 栈(stack)后进先出数据结构，保存：\n临时存储数据，如局部变量 参数：参数小于等于8个，用X0~X7通用寄存器传递，超过8个使用栈 栈从高地址向低地址扩展，栈指针(Stack Pointer SP)指向栈顶 // 栈向下扩展16字节 stp x29, x30, [sp, #-16] add sp, sp, #-8 // 释放8字节 add sp, sp, #8 ldp x29, x30, [sp], #16 3.6 MOV指令 MOV指令寄存器直接搬移和立即数搬移\n// 寄存器搬移 MOV \u0026lt;Xd|SP\u0026gt;, \u0026lt;Xn|SP\u0026gt; // 立即数搬移 MOV \u0026lt;Xd\u0026gt;, #\u0026lt;imm\u0026gt; MOVZ \u0026lt;Xd\u0026gt;, #\u0026lt;imm16\u0026gt;, LSL #\u0026lt;shift\u0026gt; ORR \u0026lt;Xd|SP\u0026gt;, XZR, #\u0026lt;imm\u0026gt; objdump指令查看MOV指令\naarch64-linux-gnu-objdump -s -d -M no-aliases test.o 第4章 A64指令集2 —— 算术与移位指令 N、Z、C、V 4个条件标志位作用 4.1 条件操作码 A64指令集在PSTATE寄存器中有4个条件标志位，N 负数、 Z 零、 C 进位、 V 溢出 4.2 加法和减肥指令 4.2.1 加法 add、adds、adc\n4.2.2 减法 SUB、SUBS\n4.3 CMP指令 A64指令集中 CMP指令内部调用SUBS指令\n// 立即数的CMP指令 CMP \u0026lt;Xn|SP\u0026gt;, #\u0026lt;imm\u0026gt;{, \u0026lt;shift\u0026gt;} // 上述等同于 SUBS XZR, \u0026lt;Xn|SP\u0026gt;, #\u0026lt;imm\u0026gt; {, \u0026lt;shift\u0026gt;} // 寄存器的CMP指令 CMP \u0026lt;Xn|SP\u0026gt;, \u0026lt;R\u0026gt;\u0026lt;m\u0026gt;{, \u0026lt;extend\u0026gt; {#\u0026lt;amount\u0026gt;}} // 移位操作的CMP指令 // CMP指令于添加操作后缀 4.4 条件表示位 4.5 移位指令 常见移位指令：\nLSL：逻辑左移，最高位丢弃，最低位补0 LSR：逻辑右移，最高位补0，最低位丢弃 ASR：算术右移，最低位丢弃，最高位按符号位扩展 ROR：循环右移，最低位移到最高位 4.6 位操作指令 两种与操作指令\nAND：按位与操作 ANDS：带条件标志位与操作，影响Z标志位 或操作指令\nORR EOR 异或 位清除操作\nBIC CLZ指令 计算为1的最高位前面有几个零\n4.7 位段操作指令 1.位段插入操作指令 BFI\n2.位段提取操作指令 UBFX\n第5章 A64指令集3 —— 比较指令与跳转指令 RET与ERET 5.1 比较指令 比较指令\nCMP CMN CSEL：条件选择指令 CSET：条件置位指令 CSINC：条件选择并增加指令 5.1.1 CMN指令 CMN指令将一个数与另一个数相反数进行比较\nCMN \u0026lt;Xn|SP\u0026gt;, #\u0026lt;imm\u0026gt;{, \u0026lt;shift\u0026gt;} CMN \u0026lt;XN|SP\u0026gt;, \u0026lt;R\u0026gt;\u0026lt;m\u0026gt;{, \u0026lt;extend\u0026gt; {#\u0026lt;amount\u0026gt;}} 5.1.2 CSEL指令 // cond为真，返回Xn，为假，返回Xm CSEL \u0026lt;Xd\u0026gt;, \u0026lt;Xn\u0026gt;, \u0026lt;Xm\u0026gt;, \u0026lt;cond\u0026gt; 5.1.3 CSET指令 // cond为真，Xd寄存器为1，否则为0 CSET \u0026lt;Xd\u0026gt;, \u0026lt;cond\u0026gt; 5.1.4 CSINC指令 // cond为真，返回Xn寄存器值，否则返回Xm寄存器值 CSINC \u0026lt;Xd\u0026gt;, \u0026lt;Xn\u0026gt;, \u0026lt;Xm\u0026gt;, \u0026lt;cond\u0026gt; 5.2 跳转与返回指令 5.2.1 跳转指令 指 令 描　述 B 跳转指令\nB Lable B.cond 有条件跳转指令\nB.cond Lable BL 带返回值跳转指令\nBL Lable BR 跳转到寄存器指定地址\nBR Xn BLR 跳转到寄存器指定地址\nBLR Xn 5.2.2 返回指令 A64两条返回指令： RET：用于子函数返回，返回地址保存在LR ERET：从当前的异常模式返回，把SPSR内容恢复到PSTATE寄存器中，从ELR中获取跳转地址并返回到该地址，ERET可实现处理器模式切换，如EL1到EL0 5.2.3 比较跳转指令 指 令 描　述 CBZ 比较并跳转指令\nCBZ Xt, Lable CBNZ 比较并跳转指令\nCBNZ Xt, Lable TBZ 测试位并跳转指令\nTBZ R\u003c t\u003e, #imm, lable TBNZ 测试并跳转指令\nTBNZ R\u003c t\u003e， #imm, lable 第6章 A64指令集 —— 其他重要指令 ADR/ADRP与伪指令LDR ADRP指令获取的是与 4KB 对齐的地址 6.1 PC相对地址加载指令 A64指令集PC相对地址加载指令——ADR和ADRP指令\n// ADR 加载当前PC值+-1MB范围内label地址到Xd寄存器 ADR \u0026lt;Xd\u0026gt;, \u0026lt;label\u0026gt; // ADRP 加载当前PC值一段范围内的label地址到Xd寄存器，与label地址按4Kb对齐 // 即偏移量位 -4Gb~4GB ADRP \u0026lt;Xd\u0026gt;, \u0026lt;label\u0026gt; 6.2 LDR与ADRP指令区别 树莓派上电复位后，固件(BOOTROM)把很想加载到0x80000地址处 LDR伪指令加载的是绝对地址，即程序编译是的链接地址。ADR/ADRP指令加载的是当前PC的相对地址(PC relative-address)，即当前PC值加上label的偏移量，理解位当前运行是label的物理地址 6.3 独占内存访问指令 ARMv8体系结构，A64指令集，LDXR指令尝试在内存总线中申请一个独占访问的锁，然后访问一个内存地址。STXR指令会往LDXR指令已经申请的独占访问内存地址宏写入新内容。 6.4 异常处理指令 指 令 描　述 SVC 系统调用指令\nSVC #imm HVC 虚拟化系统调用指令\nHVC #imm SMC 安全监控系统调用指令\nSMC #imm 6.5 系统寄存器访问指令 ARMv8体系结构MRS和MSR指令直接访问寄存器 指 令 描　述 MRS 读取系统寄存器的值到通用寄存器 MSR 更新系统寄存器的值 ARMv8体系结构7类系统寄存器 通用系统控制寄存器(System Control Register SCTLR) 调试寄存器 性能监控寄存器 活动监控寄存器 统计扩展寄存器 RAS寄存器 通用定时寄存器 特殊系统寄存器 描　述 CurrentEL 获取当前系统的异常等级 DAIF 获取和设置PSTATE寄存器中的DAIF掩码 NZCV 获取和设置PSTATE寄存器中的条件掩码 PAN 获取和设置PSTATE寄存器中的PAN掩码 SPSel 获取和设置当前寄存器的SP寄存器 UAO 获取和设置PSTATE寄存器中的UAO掩码 6.6 内存屏障指令 ARMv8体系结构是弱一致性内存模型，内存访问次序可能和程序预取顺序不一样\n指 令 描　述 DMB 数据存储屏障，确保在执行新的存储访问前所有存储器访问都已完成 DSB 数据同步屏障，确保在下一个指令执行前所有存储器访问都已完成 ISB 指令同步屏障，清空流水线，确保在执行新的指令前，之前所有指令都已完成 新的加载和存储指令\n指 令 描　述 LDAR 加载-获取(laod-acquire)指令 LDAR指令后面的读写内存指令必须在LDAR指令之前执行 STLR 存储-释放(store-release)指令 所有的加载和存储指令必须在STLR指令之前完成 第7章 A64指令集的陷阱 7.1 加载宏标签 ARMv8体系结构，在没有使能MMU情况下，访问内存地址变成访问设备类型的内存(device memory)。内存类型分为普通类型内存和设备类型内存 对设备类型内服访问发起不对齐访问，会触发对齐异常 系统MMU使能后，访问内存变成了访问普通类型内存，对普通类型内存发起一个不对齐访问，分为两种情况\n当SCTLR_ELx寄存器的A字段为1时，触发一个对齐异常 当SCTLR_ELx寄存器的A字段为0时，系统自动完成不对齐访问 7.2 加载字符串 7.3 读写寄存器导致树莓派死机 7.4 LDXR指令导致水平4B死机 7.5 在汇编中实现串口输出功能 7.6 纷享Linux5.0的启动汇编代码 Linux内核入口函数stext，在arch/arm64/kernel/haed.S汇编文件中实现。系统上电复位后，启动引导程序(bootloader)或BIOS初始化，最终跳转到Linux内核入口函数stext汇编函数，启动引导程序必要初始化，如内存设备初始化、磁盘设备初始化以及将内核镜像加载到运行地址，然后跳转到Linux内核入口。 内核汇编入口到C语言入口start_kernel()函数之间的汇编代码\n第8章 GNU汇编器 汇编器 符号 伪指令 kernel_ventry宏 汇编代码同汇编器生成目标代码，然后由连接器链接成可执行二进制程序 ARM64汇编器：1）ARM公司汇编器 2）GNU项目AS汇编器 aarch64-linux-gnu 汇编后文件Aarch64体系结构 8.1 编译流程与ELF文件 GCC编译流程： 1）预处理(pre-process)，GCC预处理器(cpp)，生成 *.i 文件 2）编译(compile)，C语言编译器(ccl)，对预处理文件进行词法、语法分析及语义分析 3）汇编(assemble)，汇编器(as)把汇编代码翻译成机器语言，并生成可重定位目标文件 4）链接(link)，连接器(ld)把所有生成可重定位目标文件以及用到的库文件综合成可执行二进制文件 gcc -E text.c -o text.i gcc -S text.i -o text.s as test.s -o test.o ld -o test test.o -lc ELF格式，待补充链接 ld --version 链接器在链接过程中对所有输入可重定位目标文件的符号表进行符号解析和重定位，每个符号在输出文件的相应段中得到一个确定的地址，最终生成一个符号表(symbol table) 8.2 汇编程序 # -o 输出二进制 -Map 输出符号表 -lc 链接libc库 ld test.o -o test -Map test.map -lc # 获取程序符号表 -s 显示符号表内容 readelf -s test 8.3 汇编语法 汇编代码注释 单行 # 或 // ，多行 /* */ 符号可表示地址、变量或函数 全局符号：使用global声明 本地符号：在本地汇编代码中引用 本地标签：供汇编器和程序员临时使用 8.4 常用伪指令 伪指令仅在汇编器编译期间起作用 .align 对齐伪指令 数据定义伪指令 函数相关伪指令 段相关伪指令 .section 伪指令 宏相关伪指令 8.5 AArch64依赖特性 AArch64特有命令行选项 第9章 链接器与链接脚本 链接器LD 链接脚本 加载地址、虚拟地址和链接地址 位置无关代码 重定位、Uboot重定位、打开MMU后重定位 9.1 链接器 链接器把目标文件(包括标准库函数目标文件)的代码段、数据段及符号表等内容按照某种格式(ELF)组合成一个可执行二进制文件 链接器使用链接脚本(Linker Script LS)语言，链接脚本把二进制文件.o，综合成可执行二进制文件 ld -o mytest test1.o test2.o -lc ld命令选项 9.3 链接脚本 链接器使用-T参数指定链接脚本，不指定使用内置链接脚本 9.2.1 链接程序 可执行程序由代码段、数据段、未初始化数据段。 Linux内置链接脚本是vmlinux.lds.S文件 SECTIONS { . = 0X10000; .text : { *{.text} } . = 0x8000000; .data : { *{.data} } .bss : { *{.bss} } } 9.2.2 设置入口点 ENTRY(symbol) 9.2.3 输出段和输入段包括段的名字、大小、可加载属性及可分配属性。可加载属性用于在运行是加载这些段内容到内存中，可分配属性用于在内存中预留一个区域，并不会加载这个区域内容 链接脚本关于段地址：加载地址和虚拟地址，加载地址是加载时段所在的地址，运行地址是虚拟地址是运行是所在的地址。通常两个地址相同的，不同情况是代码段被加载到ROM中，在程序启动是被复制到RAM中，即 ROM地址是加载地址，RAM地址是虚拟地址 9.2.7 常用内建函数 链接脚本语言包含内建函数 1.ABSOLUTE(exp) 2.ADDR(section) 3.ALIGN(align) 4.SIZEOF(section) 9.3 重定位 加载地址：存储代码的物理地址，GNU链接脚本里为LMA 运行地址：程序运行时地址，GNU链接脚本里为VMA 链接地址：在编译、链接时指定的地址，使用aarch64-linux-gnu-objdump工具进行反汇编时查看的就是链接地址 9.3.1 BenOS重定位 9.3.2 UBoot和Linux内核重定位 // linux5.0/arch/arm64/kernel/head.S __primary_switch; adrp\tx1, init_pg_dir bl\t__enable_mmu ldr x8, =__primary_switched adrp\tx0, __PHY_OFFSET br\tx8 第10章 GCC内嵌汇编代码 内嵌汇编代码关键字asm、volatile、inline及goto 内嵌汇编代码输出部分 = 和 + 内嵌汇编代码输出部分和输入部分的参数 内嵌汇编代码 # 和 ## 10.1 内嵌汇编代码基本用法 内嵌汇编代码两种形式： 基础内嵌汇编代码，不带参数 扩展内嵌汇编代码，可带输入/输出参数 10.1.1 基础内嵌汇编代码 asm { \u0026#34;汇编指令\u0026#34; } 10.1.2 扩展内嵌汇编代码 asm 修饰词( 指令部分 : 输出部分 : 输入部分 : 损坏部分) 常用修饰符: volatile：关闭GCC优化 inline：内联，GCC把汇编代码编译为尽可能短的代码 goto：跳转到C语言标签 10.1.3 内嵌汇编代码的修饰符和约束符 10.1.4 使用汇编符号名 10.1.5 内嵌汇编函数与宏结合 10.1.6 使用goto修饰符 第11章 异常处理 ARM64处理器，异常类型 ARM64处理器异常等级 同步异常和异步异常 ARM64处理器异常发生后CPU处理 LR和ELR返回地址 11.1 异常处理基本概念 ARMv8体系结构中，异常和中断都属于异常处理\n11.1.1 异常类型 1.中断 ARM64处理器中，中断请求分成普通中断请求(Interrupt Request IRQ)和快速中断请求(Fast Interrupt Request FIQ)\n2.中止 中止主要有指令中止(Instruction abort)和数据中止(data abort)两种，指访问内存地址发生错误(如缺页)，处理器内部的MMU捕获这些错误并且报告给处理器，指令中止是指当前处理器尝试执行某条指令时发生错误，数据中止指使用加载或存储指令读写外部存储单元发生错误 3.复位 复位(reset)，由CPU复位引脚产生复位信号，让CPU进入复位状态，并重新启动 4.系统调用 ARMv8体系结构提供3中软件尝试的异常和3种系统调用\nSVC指令：用户态程序请求操作系统内核的服务 HVC指令：客户操作系统(guest OS)请求虚拟机监控器(hypervisor)的服务 SMC指令：普通世界中的程序请求安全监控器(secure monitor) 11.1.2 异常等级 处理器两种运行模式：一种是特权模式，另一种是非特权模式，操作系统内核运行在特权模式 ARM64处理器支持4种特权模式，异常等级(Exception Level EL)：\nEL0 非特权模式，运行应用程序 EL1 特权模式，运行操作系统内核 EL2 运行虚拟化管理程序 EL3 运行安全世界的管理程序 11.1.3 同步异常和异步异常 异常分成同步异常和异步异常两种，同步异常是处理器执行某条指令而直接导致的异常，指令异常和数据异常为同步异常 中断称为异步异常 异步异常包括物理中断和虚拟中断：\n物理中断分为3种：SError、IRQ、FIQ 虚拟中断分为3种：VSError、vIRQ、vFIQ 11.2 异常处理与返回 11.2.1 异常入口 CPU内核感知异常发生，生成一个目标异常等级，CPU会做： 1）把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx中 2）把返回地址保存到对应目标异常等级的ELR_ELx中 3）把PSTATE寄存器中D、A、I、F标志位置为1，禁止中断 4）对于同步异常，分析异常原因，写入ESR_ELx 5）切换SP寄存器为目标异常等级的SP_ELx寄存器 6）从异常现场的异常等级切换到对应的目标异常等级，然后跳转到异常向量表 11.2.2 异常返回 操作系统系统处理完后，执行一条ERET指令从异常返回，指令执行如下操作： 1）从ELR_ELx中恢复PC指针 2）从SPSR_ELx中恢复PSTATE寄存器的状态 11.2.3 异常返回地址 两个寄存器存放不同返回地址： 1）X30寄存器(LR)，存放子函数的返回地址，函数完成调用RET指令返回父函数 2）ELR_ELx，存放异常返回地址，执行ERET指令返回异常现场 11.2.4 异常处理路由 异常处理路由指的是当异常发生时应该在哪个异常等级处理\n11.2.5 栈选择 ARMv8体系结构，每个异常等级都有对应的栈指针(SP)寄存器，通过SPSel寄存器配置SP，SPSel寄存器SP字段0，EL使用SP_EL0作为栈指针，1表示SP_ELx作为栈指针寄存器 栈必须16字节对齐\n11.2.6 异常处理的执行状态 11.2.7 异常返回的执行状态 SPSR决定ERET指令返回是不是切换执行模式\n11.3 异常向量表 11.3.1 ARMv8异常向量表 异常相关处理指令存储在内存中，存储位置为异常向量，ARM体系结构中，异常向量存储到一个异常向量表中\n地 址 异 常 类 型 描　述 + 0x000 同步 使用SP_EL0执行状态的当前异常等级 + 0x080 IRQ/vIRQ + 0x100 FIQ/vFIQ + 0x180 SError/vSError + 0x400 同步 在AArch64执行状态下的低异常等级 + 0x480 IRQ/vIRQ + 0x500 FIQ/vFIQ + 0x580 SError/vSError + 0x600 同步 在AArch32执行状态下的低异常等级 + 0x680 IRQ/vIRQ + 0x700 FIQ/vFIQ + 0x780 SError/vSError 11.3.2 Linux5.0 内核的异常向量表 Linux5.0 内核异常向量表在arch/arm64/kernel/entry.S\n\u0026lt;arch/arm64/kernel/entry.S\u0026gt; 11.3.3 VBAR_ELx ARMv8体系结构中VBAR_ELx寄存器来设置异常向量表地址 ARMv8体系结构异常向量表特点： 1）除EL0外，每个EL都有自己的异常向量表 2）异常向量表基地址设置到VBAR_ELx中 3）异常向量表起始地址必须以2KB字节对齐 4）每个表项存放32条指令，共128字节 11.4 异常现场 ARM64处理器异常现场，需要在栈空间保存： 1）PSTATE寄存器的值 2）PC值 3）SP值 4）X0~X30寄存器的值 这个栈空间指发生异常时进程的内核态的栈空间 11.5 同步异常 ARMv8体系结构中一个访问失效相关寄存器\u0026ndash;异常综合信息寄存器(Exception Syndrome Register ESR)\n11.5.1 异常类型 11.5.2 数据异常 第 12 章 中断处理 中断处理一般过程 中断现场 12.1 中断知识 12.1.1 中断引脚 ARM64处理器有两个中断相关引脚：nIRQ和nFIQ，ARM处理中断请求分为普通中断IRQ(Interrupt Request)和FIQ(Fast Interrupt Request) PSTATE寄存器两位中断相关，CPU内核的中断总开关： I： 屏蔽和打开IRQ F： 屏蔽和打开FIQ 12.1.2 中断控制器 ARM中断控制器GIC\n12.1.3 中断处理过程 中断处理过程： 1）CPU操作，把当前PC值保存到ELR中，把PSTATE寄存器值保存到SPSR中，然后跳转到异常向量表 2）在异常向量表中，CPU跳转到对应汇编处理函数，IRQ，中断发生在内核态，跳转到el1_irq，用户态，跳转到el0_irq汇编函数 3）汇编函数中保存中断现场 4）跳转到中断处理函数，如GIC驱动驱动读取中断号，跳转到设备中断处理程序 5）在设备中断处理程序里，处理中断 6）返回el1_irq或el0_irq汇编函数，恢复中断上下文 7）调用ERET指令完成中断返回，CPU把ELR值恢复到PC寄存器，把SPSR寄存器值恢复到PSTATE寄存器 8）CPU继续值中断现场下一条指令 12.2 树莓派4B中断控制器 树莓派4B支持两种中断控制器: 1）传统中断控制器，基于寄存器管理中断 2）GIC-400 12.3 ARM内核上通用定时器 Cortex-A72内核内置4个通用定时器：PS、PNS、HP、V\n12.4 中断现场 保存中断发生中断前现场，ARM64处理器在栈空间保存： 1）PSTATE寄存器的值 2）PC值 3）SP值 4）X0~X30寄存器的值 栈框数据结构(结构体ps_regs)来保存中断现场 12.4.1 保存中断现场 中断现场保存到当前进程的内核栈里: 1）栈框里的PSTATE保存发生中断时SPSR_EL1内容 2）栈框里的PC保存ELR_EL1 3）栈框里的SP保存栈定的位置 4）栈框里的regs[30]保存LR的值 5）栈框里的regs[0]~regs[29]分别保存X0~X30寄存器的值 12.4.2 恢复中断现场 中断返回时，从进程内核栈恢复中断现场到CPU\n第 13 章 GIC-V2 GIC-V2的SGI、PPI和SPI GIC-V2中断号分配 GIC-V2的SPI外设中断 12.1 GIC 12.2 中断状态、中断触发方式和硬件中断号 中断4种状态： 1）不活跃(inactive)状态：中断处于无效状态 2）等待(pending)状态：中断处于有效状态，但等待CPU响应该中断 3）活跃(active)状态：CPU已响应中断 4）活跃并等待(active and pending)状态：CPU正在响应中断，但该中断源又发送中断 中断触发方式：边沿触发与电平触发 中 断 类 型 中 断 号 范 围 软件触发中断 SGI 0~15 私有外设中断 PPI 16~31 共享外设中断 SPI 32~1019 13.3 GIC-V2 13.4 树莓派4B的GIC-400 第 14 章 内存管理 分段和分页机制 多级页表 内存管理单元(Memory Management Unit MMU) ARM64中TTBR0和TTBR1 两个转换页表基地址寄存器 ARM64处理器4级页表转换过程 ARMv8体系结构处理器两种内存属性：普通类型内存(normal memory)和设备类型内存(device memory) 打开MMU时需建立恒等映射 14.1 内存管理基础 内存分配三个问题： 1）进程地址空间保护 虚拟内存 2）内存使用率低 分页机制\n3）程序运行重定位 14.1.2 地址空间抽象 进程使用内存的3个地方： 1）进程本身，代码段、数据段存储程序数据 2）栈空间，程序运行时分配内存空间，保存函数调用关系、局部变量、函数参数及函数返回值 3）堆空间，程序运行时动态分配 地址转换：把进程请求的虚拟地址转换成物理地址 进程地址空间是对内存的抽象，使得虚拟化得到实现。进程地址空间、进程的CPU虚拟化及文件存储地址空间抽象，共同组成操作系统3个元素 14.1.3 分段机制 分段机制(segmentation)：把程序所需的内存空间的虚拟地址映射到某个物理空间 14.1.4 分页机制 分页机制引入虚拟存储器概念，分页机制核心思想：程序中一部分不使用的内存可以存放到交换磁盘，而程序正在使用的内存继续保留在物理内存中。 虚拟地址VA[31:0]分成两部分：一部分是虚拟页面内的偏移量，以4KB页为例，VA[11:0]是虚拟页面偏移量；另一部分用来寻找属于那个页，称为虚拟页帧号(Virtual Page Number VPN) 物理地址PA[11:0]表示物理页帧的偏移量，剩余部分表示物理页帧号(Physical Frame Number PFN)。MMU把虚拟页帧号转换成物理页帧号。处理器使用一张存储VPN到PFN映射关系，称为页表(Page Table PT)，页表每一项称为页表项(Page Table Entry PTE) 多级页表来减少页表占用的内存空间 TLB未命中时，处理器的MMU中的页表查询过程： 1）处理器根据虚拟地址判断使用TTBR0还是TTBR1，TTBR存放一级页表的基地址 2）处理器以虚拟地址Bit[31:20]作为索引，在一级页表中查找页表项，一级页表一共有4096个表项 3）一级页表的页表项存放二级页表的物理基地址 14.2 ARM64内存管理 ARM64处理器内核的MMU包括TLB和页表遍历单元(Table Waik Unit TWU)两个部件。TLB是高速缓存，缓存页表转换结果 进程地址空间分为内核空间(kernel space)和用户空间(user space) 在SMP系统中，每个处理器内置MMU和TLB硬件单元，CPU0和CPU1共享物理内存，页表存储在物理内存中。CPU1和CPU1的MMU和TLB共享一份页表，当一个CPU修改页表项时，使用BBM(Break-Before-Make)机制来保存其他CPU能访问正确和有效的TLB 14.2.1 页表 AArch64执行状态MMU支持一阶段页表转换，也支持虚拟化扩展中两阶段页表转换 一阶段页表转换指把虚拟地址(VA)翻译成物理地址(PA) 两阶段页表转换：阶段1，把虚拟地址翻译成中间物理地址(Intermdeiate Physical Address IPA)，阶段2，把IPA翻译成最终PA 14.2.2 页表映射 AArch64体系结构中，以48位地址总线位宽，VA划分位两个空间，每个256TB 1）低位虚拟地址空间高16位为0，使用TTBR0_ELx存储页表基地址，用户地址空间 2）高位虚拟地址空间高16位为1，使用TTBR1_ELx存放页表基地址，内核地址空间 TLB未命中时，处理器查询页表的过程 14.2.3 页表粒度 4KB、16KB、64KB\n14.2.4 两套页表 AArch64执行状态采用两套页表，整个虚拟地址空间分成3部分，下面是用户空间，中间非规范区域，上面是内核空间。 1）CPU访问用户空间地址(虚拟地址高16位为0)，MMU选择TTBR0_EL0指向页表， 2）CPU访问内核空间地址(虚拟地址高16位为1)，MMU选择TTBR1_EL1寄存器指向的页表\n14.2.5 页表项描述符 14.2.6 页表属性 1.共享性和缓存性 SH[1:0]字段 说 明 00 没有共享性 01 保留 10 外部共享 11 内部共享 2.访问权限 AP[1:0]字段 非特权模式(EL0) 特权模式(EL1、EL2及EL3) 00 不可读/不可写 可读/可写 01 可读/可写 可读/可写 10 不可读/不可写 只读 \u003c 11 只读 只读 3.执行权限 4.访问标志位 5.全局和进程持有TLB TLB表项分成全局和进程特有的 14.2.7 连续块表项 14.3 硬件管理访问位和脏位 ARMv8体系结构新增TTHM，支持由硬件管理访问位(Access Flag AF)和脏状态(dirty state) 14.4 地址转黄相关寄存器 地址转黄相关控制寄存器： 1）转黄控制寄存器(Translation Control Register TCR) 2）系统控制寄存器(Sytem Control Register SCTLR) 3）转换页表基地址寄存器(Translation Table Base Register TTBR) 14.4.1 TCR 14.4.2 SCTLR 14.4.3 TTBR TTBR存储页表的基地址，系统使用两段虚拟地址区域时，TTBR0_EL1指向低端虚拟地址区域，TTBR1_EL1指向高端虚拟地址区域。 ASID字段用来存储硬件ASID，BADDR字段存储页表基地址 14.5 内存属性 ARMv8体系结构处理器两个内存属性：普通类型内存和设备类型内存 14.5.1 普通类型内存 14.5.2 设备类型内存 14.6 BenOS里实现恒等映射 第 15 章 高速缓存 查询高速缓存过程 直接映射、全相连映射及组相连映射高速缓存 高速缓存组、路、高速缓存行，标记域 重名、同名问题 ARM64处理器 PoU和PoC 高速缓存工作原理、映射方式、虚拟高速缓存与物理高速缓存、重名和别名问题、高速缓存访问延时、高速缓存访问策略、共享属性、高速缓存维护指令\n15.1 高速缓存 数据在高速缓存中，称为高速缓存名字(cache bit)，数据不在高速缓存里，称为高速缓存未命中(cache miss) 高速缓存集成在处理内部的SRAM(Static Random Access Memory) 经典高速缓存系统方案 图\n15.2 高速缓存的访问延时 内存两种体系结构：一种是统一内存访问(Uniform Memroy Access UMA)体系结构，另一种是非统一内存访问(Non-Uniform Memory Access NUMA)体系结构 15.3 高速缓存工作原理 经典高速缓存体系结构(VIPT) 处理器访问存储器时会把虚拟地址同时传递给TLB和高速缓存，TLB存储虚拟地址到物理地址转换的小缓存，处理器先使用有效帧号(EPN)在TLB中查找最终实际页帧号(RPN) 高速缓存的基本结构 1）地址：处理器访问高速缓存时的地址编码，分成3部分：偏移量(offset)域、索引域和标记(tag)域 2）高速缓存行：高速缓存中最小访问单元，包含一小段主存储器中的数据 3）索引(index)：高速缓存地址编码部分，用于索引和查找地址在高速缓存的哪一组中 4）组(set)：由相同索引的高速缓存行组成 5）路(way)：在组相连的高速缓存中，高速缓存分成大小相同的几块 6）标记(tag)：判断高速缓存行缓存的数据的地址是否和处理器寻找的地址一致 7）偏移量(offset)：高速缓存行中的偏移量 15.4 高速缓存的映射方式 高速缓存映射方式：\n直接映射 全相连映射 组相连映射 15.4.1 直接映射 每个组只有一个高速缓存行时，高速缓存称为直接映射高速缓存\n15.4.2 全相连映射 主内存中只有一个地址与n个高速缓存行对应，称为全相连映射 15.4.3 组相连映射 15.5 虚拟高速缓存与物理高速缓存 15.5.1 物理虚拟缓存 处理器查询MMU和TLB并得到物理地址之后，使用物理地址查询高速缓存，称为物理高速缓存\n15.5.2 虚拟高速缓存 虚拟高速缓存：处理器使用虚拟地址寻找高速缓存\n15.5.3 VIPT和PIPT VIVT(Virtual Index Virtual Tag)：使用虚拟索引域和虚拟地址的标记域，虚拟高速缓存 PIPT(Physical Index Physical Tag)：使用物理索引域和物理地址标识域，物理高速缓存 VIPT(Virtual Index Physical Tag)：使用虚拟地址索引域和物理地址标记域 VIPT高速缓存工作方式\n15.6 重名和同名问题 15.6.1 重名问题 不同虚拟地址对应不同高速缓存行，但对应相同物理地址为重名问题 15.6.2 同名问题 同名问题：相同虚拟地址对应不同物理地址，出现在进程切换场景 解决方法在进程切换是先使用clean命令把脏的缓存行数据写回到内存，然后是所有高速缓存行失效，同事需要使TLB无效 重名问题是多个虚拟地址映射到同一个物理地址引发问题，同名问题是一个虚拟地址在进程切换等情况下映射不同物理地址引发问题 15.6.3 VIPT重名问题 VIPT中，使用虚拟地址索引域查找高速缓存组，可导致多个高速缓存组映射到同一物理地址\n15.7 高速缓存策略 处理器内核中，一套存储读写指令经过取值、译码、发射和执行等操作后，首先到达LSU(Load Store Unit)。LSU包括加载队列(load queue)和存储队列(store queue)。LSU是指令流水线中的一个执行部件，是处理器存储子系统顶层，是连续指令流水线和高速缓存一个支点 存储读写指令通过LSU后，到达一级缓存控制器，一级缓存控制器最先发起探测(probe)操作，对读操作，发起高速缓存读探测操作并带回数据，对写操作，发起写探测操作之前，准备号代谢高速缓存行。探测操作写返回是，将会带回数据。存储器写指令获得最终数据并进行提交操作之后，将整个数据写入。写入可采用直写(write throught)模式或回写(write back)模式 探测过程中，写操作没有找到对应高速缓存行，出现未命中(write miss)，否则为写命中(write hit)。对于写未命中处理器策略是写分配(write-allocate) 写命中时，真正写入两种模式：\n直写模式 回写模式 写未命中，两种策略：\n写分配(write-allocate)策略 不写分配(no write-allocate)策略 读操作，命中高速缓存，直接从高速缓存获取数据 读操作，未命中高速缓存两种策略\n读分配(read-allocate)策略 读直通(read-through)策略 高速缓存替换策略：随机法(random-policy)、先进先出(First in First out FIFO)法和最近最少使用(Least Recently Used LRU)法\n15.8 高速缓存的共享属性 15.8.1 共享属性 ARMv8体系结构下，普通内存为高速缓存设置可缓存的(shareability)和不可缓存的(non-shareability)两种属性。可设置高速缓存为内部共享(inner share)和外部共享(outer share)高速缓存 高速缓存4个共享域(share domain)：不可共享域、内部共享域、外部共享域及系统共享域\n15.8.2 PoU和PoC区别 ARMv8体系结构观察内存： 全局缓存一致性角度(Ponit of Coherency PoC)：系统中所有可发起内存访问的硬件单元都保证观察到某一个地址上的数据是一致的或相同的副本 处理器缓存一致性角度(Point of Unification PoU)：表示站在处理器角度看高速缓存的一致性问题。如指令高速缓存、数据高速缓存、TLB、MMU PoU两个观察点： 站在处理器角度 站在内部共享属性范围看 15.9 高速缓存的维护指令 ARM64指令集高速缓存管理指令，包括管理无效缓存和清理高速缓存指令 高速缓存管理三种情况：\n失效操作 清理操作 清零操作 15.10 高速缓存枚举 第 16 章 缓存一致性 缓存一致性 MESI协议 DMA和高速缓存一致性问题 自修改代码 16.1 缓存一致性 MESI协议对软件透明，是硬件实现的，但下列场景需要软件手工干预 驱动程序中使用DMA缓冲区造成数据高速缓存和内存中的数据不一致 自修改代码(Self-Modifying Code SMC)导致数据高速缓存和指令高速缓存不一致 修改页表到时不一致(TLB里保存的数据可能过时) 16.2 缓存一致性分类 16.2.1 ARM处理器缓存一致性 Cortex-15引入大小＆体系结构，大小核体系结构里两个CPU簇(cluster)，每个簇里有多个处理器，MESI协议保证多个处理器内核缓存一致性。CPU簇与簇之间一致性通过AMBA缓存一致性扩展协议控制器 16.2.2 缓存一致性分类 缓存一致性系统分成两大类：\n多喝间的缓存一致性 系统间缓存一致性 硬件实现MESI协议，在ARM芯片手册里，实现MESI协议的硬件单元为侦听控制单元(Snoop Control Unit SCU)，SCU保证CPU内核之间的缓存一致性 16.2.3 系统缓存一致性 在一个CPU簇里，每个CPU各自独立L1高速缓存，共享一个L2高速缓存，通过一个ACE硬件单元链接到缓存一致性控制器里。ACE(AXI Coherent Extension)是AMBA 4协议中定义 16.3 缓存一致性解决方案 解决缓存一致性问题，3种方案：\n关闭高速缓存 软件维护缓存一致性 硬件维护缓存一致性 16.3.1 关闭高速缓存 16.3.2 软件维护缓存一致性 软件在合适是清楚脏缓存行或使缓存行失效\n16.3.3 硬件维护缓存一致性 多核里失效一个MESI协议，失效一种总线侦听控制单元\n16.4 MESI协议 16.5 高速缓存伪共享 16.6 CCI和CCN缓存一致性控制器 处理器中通过高速缓存一致性协议失效，维护一个有限状态机(Finite State Machine FSM)，根据存储器读写的指令或总线上的传输内容，进行状态迁移和响应的高速缓存操作来维护高速缓存一致性，不需要软件 高速缓存一致性协议两达类别：一类监听协议(snooping protocol)，每个高速缓存都要被监听或监听其他高速缓存总线活动；另一类目录协议(directory protocol)用于全局统一管理高速缓存状态 MESI协议：修改(Modified M)、独占(Exclusive E)、共享(Shared S)和无效(Invalid I) 4个状态\n16.6.1 MESI协议 高速缓存行两个标志位——脏(dirty)和有效(valid)\n第 17 章 TLB管理 TLB TLB查询过程 TLB重名、同名问题 ASID机制 TLB维护指令后DSB内存屏障指令 BBM机制 操作系统切换页表是刷新TLB 把MMu的地址转换结果缓存到缓冲区TLB(Translation Lookaside Buffer)，称为快表 17.1 TLB基础知识 MMU内部，TLB项(TLB entry)数量较少，没项包含虚拟页帧号(VPN)、物理页帧号(PFN)及一些属性。 TLB类似高速缓存，支持直接映射方式、全相连映射方式及组相连映射方式。TLB大多采用组相连映射方式 组相连映射TLB，虚拟地址分成三部分，分别是标记域、索引域及页内偏移量 L1 TLB包括指令TLB和数据TLB，而L2 TLB是统一的TLB体系结构 全相连L1指令TLB包括48个表项，全相连L1数据TLb包括32个表项。4路组相连的L2 TLB包括1024个表项 属 性 描 述 VPN 虚拟地址页帧号 PFN 物理地址页帧号 V 有效位 nG 表示是否是全局TLB或进程持有的TLB D 脏位 AP 访问权限 ASID 进程地址空间ID(Address Space ID ASID) 17.2 TLB重名与同名问题 17.2.1 重名问题 高速缓存进程索引域和标识域是虚拟地址还是物理地址分为VIVT、PIPT及VIPT。TLB类似VIVT TLB和高速缓存内容不一样，高速缓存中存放的是数据，TLB缓存中存放的是VA到PA的映射关系\n17.2.2 同名问题 TLB和VIVT类型高速缓存一样，在进程切换是会发生同名问题，解决方法是在进程切换时使旧进程遗留下来的TLB失效 17.2 ASID TLB分成两种： 1）全局类型TLB 2）进程独有类型TLB ARM体系结构硬件解决方案，叫作进程地址空间(Address )\n17.4 TLB管理命令 ARMv8体系结构TLB管理命令刷新TLb，主要为失效操作，PTE被修改，先刷新对应的TLB项，再修改PTE TLB维护操作： 使所有TLB表项失效 使ASID对应某一个TLB项失效 使ASID对应的所有TLB项失效 使虚拟地址对应所有TLB项失效 17.4.1 TLB维护指令 # ARMv8体系结构TLBI指令 TLBI \u0026lt;type\u0026gt;\u0026lt;level\u0026gt;{IS} { \u0026lt;Xt\u0026gt;} TLBI R\u0026lt;type\u0026gt;\u0026lt;level\u0026gt;{IS} { \u0026lt;Xt\u0026gt;} 17.4.2 TLB广播 TLB维护指令具有广播功能，在指定的高速缓存共享域中发送广播\nvoid local_flush_tlb_all(void) { __tlbi(vmalle1); } void flush_tlb_all(void) { __tlbi(vmallelis); } 17.4.3 TLB维护指令执行次序 17.5 TLB案例 17.5.1 TLB在Linux内核中应用 待补充\n1.不采用KPTI方案 2.采用KPTI方案 copy_to_user()、copy_from_user()\n17.5.2 ASID在Linux内核中的应用 17.5.3 Linux内核中TLB维护操作 第 18 章 内存屏障指令 内存乱序 顺序一致性内存模型 处理器一致性内存模型 弱一致性内存模型 DMB和DSB指令 加载-获取屏障原语，存储-释放屏障原语 18.1 内存屏障指令产生 实际内存访问顺序和程序代码指定的访问顺序不一致，出现内存乱序访问，内存乱序访问提高了程序执行效率。内存乱序访问发生两个阶段： 1）编译时，编译器优化到时内存乱序访问 2）运行时，多个CPU交互引起内存乱序访问 编译时乱序访问通过barrier()函数规避\n#define barrier() __asm__ __volatile__ (\u0026#34;\u0026#34; ::: \u0026#34;memory\u0026#34;) 现代处理器，流水线、写缓存、高速缓存、超标量技术、乱序执行。 存储一致性问题，即系统中所有处理器所看到的对不同地址访问的次序问题\n18.1.1 顺序一致性内存模型 严格一致性(原子一致性)内存模型：使用一个全局时间比例部件决定存储器访问时序 顺序一致性(Sequential Consisitency SC)内存模型：每个处理器局部时间比例部件确定最新数据内存模型 18.1.2 处理器一直内存模型 处理器一致性内存模型是顺序一致性内存模型的弱化，放宽较早写操作与后续读操作次序要求，即放宽\u0026quot;写-\u0026gt;读\u0026quot;操作次序要求。处理器一致性模型允许一条加载指令从存储缓冲区(store buffer)读取一条还没执行的存储指令的值，此值还没写入高速缓存中。\n18.1.3 弱一致性内存模型 对内存访问分成： 1）共享访问 2）竞争访问 存储器访问指令分成数据访问指令和同步指令(内存屏障指令)两类，对应弱一致性内存模型 ARM64处理器实现弱一致性内存模型，使用内存屏障指令实现同步访问，内存屏障指令原则： 1）内存屏障指令后面的所有数据访问必须等待内存屏障zh8il执行完 2）多条内存屏障指令按顺序执行 ARM64体系结构处理器支持预测式操作： 1）从内存中预取数据或指令 2）预测指令预取 3）分支预测(branch prediction) 4）乱序数据加载 5）预测高速缓存行填充，LSU(加载存储单元)、存储缓冲区、无效队列及缓存 18.2 ARM64内存屏障指令 18.2.2 ARM64内存屏障指令 ARM64指令3条内存屏障指令 1）数据存储屏障(Data Memory Barrier DMB)指令 2）数据同步屏障(Data Synchronization Barrier DSB)指令 3）指令同步屏障(Instruction Synchronization Barrier ISB)指令 18.2.3 DMB指令 18.2.4 DSB指令 18.2.5 DMB指令与DSB指令参数 18.2.6 单方向内存屏障原语 18.2.7 ISB指令 18.3 第 19 章 使用内存屏障指令 存储缓冲区 无效队列 DMB、DSB、ISB指令 SMP内存屏障接口函数(如smp_rmb()) 19.1 存储缓冲区与写内存屏障指令 MESI协议基于总线侦听和传输协议，总线传输带宽与CPU间互联总线负载及CPU核数量有关 高速缓存中引入存储缓冲区(store buffer)，位于CPU和L1高速缓存中间 每个CPU内核有一个本地存储缓冲区，提高CPU连续写的性能。存储转发(store forwarding)，CPU加载(load)操作时，如果存储缓冲区存在数据副本，从存储缓冲区中读取数据 19.2 无效队列与读内存屏障指令 19.3 内存屏障指令总结 计算机体系结构角度，读内存屏障指令作用于无效队列，让无效队列中积压高速缓存行失效操作尽快执行玩才执行后面读操作。写内存屏障指令作用于存储缓冲区，让存储缓冲区中数据写入高速缓存行之后才进行后面写操作。读写内存屏障指令同时作用于使高速缓存行失效的队列和存储缓冲区。ARM64体系结构提供三条内存屏障指令，DMB和DSB指令能指定共享域范围 Linux内核提供域处理器体系结构无关内存屏障API函数 19.4 ARM64内存屏障指令区别 第 20 章 原子操作 原子操作 LL/SC机制 ARM64独占访问内存 CAS指令 WFE指令优化自旋锁 20.1 原子操作 ARM64处理器LDXR和STXR独占内存指令及原子内存访问操作指令 20.2 独占内存访问指令 ARMv8两种方式实现原子操作： 一、独占加载(Load-Exclusive)和独占存储(Store-Exclusive)指令，连接加载/条件存储(Load-Link/Store-Conditional LL/SC) 二、LSE指令 LS/SC用于并发与同步访问内存CPU指令 20.3 独占内存访问工作原理 20.4 原子内存访问操作指令 20.5 比较交换指令 20.6 WFE指令在自旋锁中的应用 第 21 章 操作系统相关 ARM64体系结构，子函数栈空间FP指向 操作系统0号进程 进程上下文切换 schedule()函数切换进程 调度器 switch_to()切换进程 21.1 C语言陷阱 21.2 函数调用标准 函数调用标准(Procedure Call Standar PCS) ARM64提现结构通用寄存器 21.3 栈布局 ARM64体系结构中，栈从高地址往低地址生长 ARM64体系结构函数栈布局： \\\n所有函数调用栈组成一个单链表 每个栈由两个地址构成链表 低地址存放：指向上一个栈帧(父函数栈帧)的栈基地址FP 高地址存放：当前函数返回地址，进入函数时LR值 处理器的FP和SP寄存器相同 函数返回时，ARM64处理器先把栈中P_LR值载入当前LR，然后执行RET指令 21.4 创建进程 21.4.1 进程控制块 task_struct数据结构描述一个进程控制块(Processing Control Block PCB)\n21.4.2 0号进程 21.4.3 do_fork函数 21.4.4 进程上下文切换 21.4.5 新进程第一次运行 21.5 简易进程调度器 21.5.1 扩展进程控制块 21.5.2 就绪队列run_queue 21.5.3 调度队列类 21.5.4 调度器实现 21.5.5 自愿调度 21.5.6 抢占调度 21.6 系统调用 处理器运行模式地址空间分成两部分：一部分内核空间，对应ARM64体系结构中的EL1；另一部分用户空间，对应EL0 ARM64体系结构系统调用SVC，应用程序通过SVC指令自陷到操作系统内核中，即陷入EL1\n21.6.1 系统调用介绍 21.6.2 用户态调用SVC指令 21.6.3 内核对系统调用的处理 21.6.4 系统调用表 21.7 系统启动 第 22 章 浮点运算与NEON指令 SISD和SIMD指令 ARM64体系结构矢量数据 浮点运算指令与NEON指令 22.1 数据模型 22.2 浮点运算 22.3 NEON指令 第 23 章 可伸缩矢量计算和优化 23.1 SVE指令 参考文档 ARM Architecture Reference Manual Supplement®ARMv8.1, for ARMv8-A architecture profile\nARM Cortex -A Series®®Version: 1.0 Programmer’s Guide for ARMv8-A\nARM® Cortex®-A72 MPCore Processor Revision: r0p3 Technical Reference Manual\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/arm64%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/","summary":"第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内","title":"ARM64体系结构编程与实践"},{"content":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxcommand/","summary":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown","title":"LinuxCommand"},{"content":" openbenchmark\nopenssl speed openssl speed --multi 1 openssl speed --multi 1 aes-128-cbc # 编译 https://www.jianshu.com/p/499c4603cfd5\nhttps://blog.csdn.net/CHYabc123456hh/article/details/125794350\nperf sudo apt install linux-tools-common sudo apt install linux-tools-generic sudo apt install linux-cloud-tools-generic perf --version https://blog.csdn.net/qq_44158431/article/details/125199825\nhttps://www.cnblogs.com/limstorm/p/16334539.html\nhttps://weishu.me/2022/06/12/eBPF-on-Android/\nhttps://www.cnxct.com/ecapture-news-android/\nhttps://ebpf.io/applications/\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/benchmark/","summary":"openbenchmark openssl speed openssl speed --multi 1 openssl speed --multi 1 aes-128-cbc # 编译 https://www.jianshu.com/p/499c4603cfd5 https://blog.csdn.net/CHYabc123456hh/article/details/125794350 perf sudo apt install linux-tools-common sudo apt install linux-tools-generic sudo apt install linux-cloud-tools-generic perf --version https://blog.csdn.net/qq_44158431/article/details/125199825 https://www.cnblogs.com/limstorm/p/16334539.html https://weishu.me/2022/06/12/eBPF-on-Android/ https://www.cnxct.com/ecapture-news-android/ https://ebpf.io/applications/","title":"benchmark"},{"content":"[toc]\n深入理解计算机系统 第1章 计算机系统 hello world程序分析 hello.c编译\n编译系统：预处理器cpp、编译器ccl、汇编器as和链接器ld\n计算机系统硬件组成：总线，I/O设备，主存，处理器 CPU 在指令的要求下执行操作：加载、存储、操作和跳转\nhello程序加载 从键盘上读取 hello 命令,从磁盘加载可执行文件到主存,将输出字符串从存储器写到显示器\n高速缓存存储器cache：L1 L2 L3(SRAM) 存储设备层次结构 操作系统有两个基本功能： （1)防止硬件被失控的应用程序滥用 （2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备 操作系统通过几个基本的抽象概念：进程、虚拟内存和文件 Posix 标准：Unix系统调用的C语言接口、shell 程序和工具、线程及网络编程 进程：操作系统对一个正在运行的程序的一种抽象，操作系统实现进程交错执行的机制称为上下文切换 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括 PC 和寄存器文件的当前值，以及主存的内容 系统调用会将控制权传递给操作系统 从一个进程到另一个进程的转换是由操作系统内核(kernel)管理的。内核是操作系统代码常驻主存的部分 读写文件，执行一条系统调用(system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序 内核不是一个独立的进程。是系统管理全部进程所用代码和数据结构的集合 线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据 虚拟内存 程序代码和数据，堆，共享库，栈，内核虚拟内存， 文件 I/O 设备是文件\n系统之间网络通信\nAmdahl定律\n对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度\n并发和并行 三个层次：\n线程级并发 指令级并行 单指令、多数据并行 计算机系统中抽象 程序结构和执行 处理器和存储子系统，基本数据结构，指令操作，编译器翻译\n第2章 信息的表示和处理 2.1 信息表示 十六进制 x是2的非负整数n次幂时，x=2”，我们可以很容易地将 x 写成十六进制形式，只要记住 X 的二进制表示就是1后面跟n个0， 2^9 = 512 0x200\n字节序 低有效字节在最前面的方式，称为小端法 最高有效字节在最前面的方式，称为大端法 x01234567 大端01 23 45 67 小端 67 45 23 01 \\\n位运算与逻辑运算 位运算\u0026amp;与 |或 ~非 异或 \\ 逻辑运算：\u0026amp;\u0026amp;与 ||或 !非 无符号，补码，浮点数\n移位运算 算数右移和逻辑右移\n2.2 整数表示 有符号数和无符号数 补码计算公式 C 库中的文件\u0026lt;limits.h\u0026gt;定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。常量 INT_MAX、INT_MIN 和UINT_MAX, stdint.h 中uintl6_t，int32_t定义指定位数类型。\n#define INT_MAX 2147483647 #define INT.MIN (-INT_MAX 1) 2.3 整数运算 计算机执行的 “整数” 运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出\n2.4 浮点数 浮点表示通过将数字编码为: x*2〃的形式来近似地表示实数\n第3章 程序的机器级表示 计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、 读写存储设备上的数据，以及利用网络通信\n3.1 机器码 指令集体系结构或指令集架构(Instruction Set Architecture,ISA)定义机器级程序的格式和行为，定义了处理器状态、指令的格式，已经每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址，内存模型看做一个大字节数组。 处理器状态： \\ 程序计数器(PC x86-64中%rip)给出将要执行的下一条指令在内存中的地址 整数寄存器文件包含16个命名的位置,分别存储64位的值. 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息. 一组向量寄存器可存放一个或多个整数或浮点数值. # -S 产生汇编代码 生成 .s 文件 gcc -Og -S mstore.c # -c 编译并汇编 产生 .o 文件 gcc -Og -c mstore.c # 反汇编 objdump -d mstore.o x86-64指令长度从1到15字节不等. 反汇编器基于机器代码文件中的字节序列确定汇编代码 objdump ？ 汇编代码中以 以.开头的行都是指导汇编器和链接器工作的伪指令 C语言中嵌入汇编代码: 1)独立汇编文件,用汇编器和链接器把它和C语言代码合并. 2)使用GCC的内联汇编特性,用asm伪指令在C程序中包含汇编代码 数据传送指令四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)\n3.2 处理器访问 x86-64的中央处理器(CPU)包含一组16个存储64位值的通用目的寄存器。%r开头，%rax-%rbp 栈指针%rsp，用来指明运行时栈的结束位置\n复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0。\n3.2.1 指令操作和类型 指令操作数：指令操作使用的源数据值，以及放置结果的目的位置。操作数三种类型：立即数(immediate)、寄存器(register)和内存引用。\n数据传送指令\nMOV类：movb，movw，movl和movq 源操作数类型：立即数，寄存器值和内存中的值，目的操作数：指定位置，寄存器，内存地址，x86-64中源操作数和目的操作数不能同为内存地址。\nMOVZ类指令把目的中剩余资金填充位0 MOVS类指令通过符号扩展来填充，把源操作数高位进行复制。 cltq指令：总以寄存器%eax作为源，%rax作为符号扩展结果的目的 *指针引用，\u0026amp;取址\n3.2.2 压入和弹出栈数据 pushq操作把数据压入栈中，popq指令弹出数据；栈向下增长，栈顶元素在低地址，栈指针%rsp保存栈顶元素地址。 3.3 算术和逻辑操作 加法指令ADD类：addb、addw、addl和addq 四组操作：加载有效地址、一元操作、二元操作和移位 leaq 将有效地址写入到目的操作数。 \\ 一元操作：只有一个操作数，即是源又是目的。 二元操作：第二个操作数既是源又是目的。 移位操作：先给出移位量，然后第二项给出的是要移位的数。算术和逻辑右移。移位量是个立即数，或者但自己寄存器%c1中。左移：SAL和SHL；右移：SAR和SHR \\\n特殊算数操作 3.4 控制指令 两种基本条件行为：测试数据值，然后根据曹氏结果来改变控制流或数据流。\n3.4.1 条件码(condition code)寄存器 CF：进位标志 ZF：零标志 SF：符号标志 OF：溢出标志 两类设置条件码指令：\nCMP指令：根据两个操作数之差来设置条件码 TEST指令：与AND(\u0026amp;)指令一样，但仅设置条件码 访问条件码：1)条件码的某种组合SET指令 2)条件跳转 3)条件传送数据\n跳转指令jump\njmp无条件跳转指令：直接跳转和间接跳转 # 用寄存器%rax中的值作为跳转目标 jmp *%rax # 以%rax中的值作为读地址，从内存中读取跳转目标 jmp *(%rax) 当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令 的地址，而不是跳转指令本身的地址 为什么基于**条件数据传送(条件赋值)**的代码会比基于条件控制转移的代码性能要好？\n分支预测是条件表达式50%的正确率，x86-64分支预测错误惩罚19个时钟周期。 无论测试数据是什么，编译出使用条件传送代码所需的时间8个时钟周期。控制流不依赖于数据，处理器更容易保持流水线是满的。 条件传送指令 3.4.2 循环 条件测试和跳转组合实现循环\ndo-while循环 loop: bogy-statement t = text-expr; if (t) goto loop while 循环 goto test; loop: body-statement test: t = text-expr; if (t) goto loop; t = text-expr if (!t) got done; do body-statement while(test-expr); done for循环 init-expr; got test; loop: body-statement update-expr; test: t = test-expr; if (t) goto loop; init-expr; t = test-expr; if (!t) goto done; loop: body-statement update-epxr; t = test-expr; if (t) goto loop; done 3.4.2 switch语句 switch(开关)语句可以根据一个整数索引值进行多重分支（multiway branching)。使用**跳转表(jump table)**数据结构使得实现更加高效,跳转表是一个数组，表项i是一个代码段的地址。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关 .rodata（只读数据，Read-Only Data)的目标代码文件的 段中\n3.5 过程 过程：函数，方法，子例程，处理函数。 过程切换：传递控制，传递数据，分配和释放内存 \\\n运行时栈 栈向低地址方向增长，栈指针%rsp指向栈顶元素。pushq和popq指令将数据压栈和出栈。运行栈划分成栈帧，被调函数返回地址属于调用函数栈帧。\n转移控制 将程序计数器(PC)设置为转移目的代码起始位置。 call Q调用过程 call指令，指明被调用过程起始的指令地址,直接调用的目标是标号,间接调用的目标是*后面跟一个操作数指示符.call将返回地址压入栈中,并跳转到函数的第一条指令.\n数据传送 大部分数据传送通过寄存器实现,返回值通过%rax寄存器. x86-64中通过寄存器最多传递6个整型参数,超出部分通过栈传递,栈顶数据大小都向8的倍数对齐。ARMv8通过寄存器最多可传递8个参数。 栈上局部存储：超出寄存器数量，局部变量地址\u0026amp;，局部变量数组或结构 寄存器中的局部存储空间：寄存器组，寄存器%rbx、%rbp和%r12-%r15为被调用者保存寄存器。被调用这必须保存这些寄存器值，不改变值或入栈返回前恢复。其他寄存器由调用者保存。 每次函数调用由字节私有的状态信息（保存的返回值位置和被调用这保存寄存器的值）存储空间。 递归过程与普通调用一致\n3.6 数组分配与访问 数组声明：T A[N] x86-64内存引用指令可简化数组访问\n# E[i] E地址在寄存器%rdx中，i值在寄存器%rcx中 x + 4i movl (%rdx, %rcx, 4), %eax 指针运算 单操作符\u0026amp;和*可产生指针和间接引用指针 嵌套数组(多维数组) 定长数组 #define N 1 变长数组 malloc \\\n3.7 结构struct和联合union struct 指向结构的指针就是结构第一个字节的地址,结构信息每个字段（field)的字节偏移\nunion 联合能够规避c语言的类型系统，允许以多种类型引用一个对象\n数据对齐 x86-64数据类型对齐 # 保证起始地址是8的倍数 .align 8 3.8 机器级程序中控制和数据结合 指针 指针类型，指针值，指针创建\u0026amp;，指针间接引用*，数组与指针，指针强制类型转换，函数指针(*f)()\nGDB\ngdb prog 内存越界引用和缓冲区溢出 数组越界访问 字符串长度超过分配的数组空间 \\ 防止缓冲区溢出：栈随机化，栈破坏检测，限制可执行代码区域，变长栈帧 \\\n3.9 浮点代码 MMX-SSE-SSE2-AVX-AVX2 AVX浮点体系16个YMM寄存器%ymm0-%ymm15,256bit(32字节) 浮点传送和转换 浮点运算 x86-64 机器代码 控制结构（比如条件、循环和开关语句）生成的基本指令模式 括栈分配、寄存器使用惯例和参数传递 数据结构（如结构、联合和数组）的分配和访问方式 整数和浮点数算术运算的指令 代码安全漏洞（例如缓冲区溢出）\n第4章 处理器体系结构 处理器支持的指令和指令的字节级编码称为指令集体系结构(Instruction-Set Architecture ISA) HCL(Hardware Control Language硬件控制语言)\n4.1 Y86-64指令集 Y86-64 指令\nmovq指令分成4中：irmovq,rrmovq,mrmovq和rmmovq;i立即数，r寄存器，m内存 整数操作指令4个：addq,subq,andq和xorq;可设置条件吗ZF(零)，SF(符号)和OF(溢出) 跳转指令7条：jmp、 jle、 jl、 je、 jne、 jge 和 jg 6个条件传送指令: cmovle、cmovl、cmove、 cmovne、 cmovge 和 cmovg。 call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回 pushq 和 popq 指令实现了人栈和出栈 halt 指令停止指令的执行 CISC(复杂指令集)和RISC(精简指令集) RISC寻址方式简单:机制和便宜了寻址，只能对寄存器操作数进行算数和逻辑运算，内存引用仅有load和store\n状态码Stat，程序执行的总体状态 以.开头的词是汇编器伪指令(assembler directives)，它们告诉汇 编器调整地址，以便在那儿产生代码或查入一些数据。 \\\npush %rsp指令行为：1)压人％rsp 的原始值，2)压人减去 8 的红印的值\n4.2 逻辑设计和硬件控制语言HCL 逻辑门 与 或 非 逻辑门组成组合电路 \\\n存储器和时钟 两类存储设备：时钟寄存器(寄存器)和随记访问存储器(内存) 处理器随机访问存储器来存储程序数据 SEQ(\u0026ldquo;se-quential\u0026rdquo; 顺序的）的处理器\n操作阶段：\n取值fetch:从内存读取指令字节，地址为程序计数器（PC)的值,从指令中取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令功能）。 译码decode: 译码阶段从寄存器文件读人最多两个操作数 执行execute: 执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针 访存memory: 访存阶段可以将数据写人内存，或者从内存读出数据 写回: 最多可以写两个结果到寄存器文件 更新PC: 将 PC 设置成下一条指令的地址。 SEQ引进结构\n控制处理器中活动的时序原则：从不回读，\n取指阶段 译码和写回阶段 执行阶段 访存阶段 更新PC阶段 流水线 吞吐量：每秒千兆条指令（GIPS) 各个阶段之间放上流水线寄存器（pipeline register) 现代处理器采用了很深的(15 或更多的阶段)流水线 \\\n带反馈流水线系统 指令执行顺序相关：\n数据相关 控制相关 SEQ+ PIPE 预测下一个 PC 猜测分支方向并根据猜测开始取指的技术称为分支预测，预测 PC 的新值为 valG \\\n流水线冒险 相关有两种形式： \\\n1)数据相关，下一条指令会用到这一条指令计算出的结果； 2)控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时冒险也可以分为两类：数据冒险(data hazard)和控制冒险(control hazard)\n对于Y86-64 来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器\n异常处理 Y86-64 包括三种不同的内部产生的异常：l)halt 指令，2)有非法指令和功能码组合的指令，3)取指或数据读写试图访问一个非法地址导致异常的指令称为异常指令(excepting instruction)\nPIPE 各阶段的实现 PC 选择和取指阶段 译码和写回阶段 执行阶段 访存阶段\nCPI(Cycles Per Instruction, 每指令周期数）\n第四章流水部分还需要继续阅读 基本的组合和时序逻辑元素 流水线 五阶段处理器流水线\n第5章 优化程序性能 高性能程序： 1)数据结构与算法选择 2)编译器能够优化 3)计算分解，并行化\n5.1 优化编译器 GCC 编译选项 -Og -O1 -O2 -O3 两个指针可能指向同一个内存位置的情况称为内存别 名使用(memory aliasing) 包含函数调用的代码可以用一个称为 内联函数替换(inline substitution, 或 者简称\u0026quot;内联（inlining)\u0026quot;)的过程进行优化 \\\n程序性能表示 CPE每元素的周期数（Cycles Per Element, CPE) \\\n消除循环的低效率:循环条件判断中使用数值，而不是表达式 减少过程调用：将调用移出循环 消除不必要的内存引用：把中间结果存在临时变量中，最后在赋给引用地址 \\\n5.2 现代处理器 指令并行 两种下界描述了程序的最大性能:延迟界限(latency bound)和吞吐量界限(throughpu bound) 超标量：每个时钟周期执行多个操作 乱序：指令的顺序不一定与机器级程序中的顺序一致 处理器设计两个主要部分：指令控制单元(ICU)和执行单元(EU) 分支预测(branch prediction):处理器会猜测是否选择分支，还预测分支的目的地址 投机执行（speculative execution)冒险？ 处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码 Intel Core i7 Haswell 有 8 个功能单元: 0 整数运算、浮点乘、整数和浮点数除法、分支 1 整数运算、浮点加、整数乘、浮点乘 2 加载、地址计算 3 加载、地址计算 4 存储 5 整数运算 6 整数运算、分支 7 存储、地址计算 \\\n任何对程序寄存器的更新都只会在指令退役时才会发生 控制操作数在执行单元间传送的最常见的机制称为寄存器重命名(register renaming)：值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来， 重命名表只包含关于有未进行写操作的寄存器条目。 \\\n运算性能：\n延迟：完成运算所需总时间 发射时间：两个联系同类型运算直接最小时间周期数 容量：能够执行该元素的功能单元的数量 数据流(data-flow)，关键路径(critical path)\n循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。编译器GCC优化等级-O3\n5.3 提高并行性 一个可结合和可交换的合并运算来说，比如说整数加法或乘法，可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能 ;浮点乘法和加法不是可结合的 重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。 极大化对向量元素加或者乘的函数性能 制约程序性能的一些限制因素：寄存器溢出，并行度p超过寄存器数量；分支预测和预测错误处罚\n5.4 内存性能 加载的性能：对两个加载单元而言，其每个时钟周期只能启动一条加载操作，所以 CPE 不可能小于 0.50 存储的性能：每个周期开始一条新的存储\n5.5 性能提高技术 1）高级设计：为问题选择适当的算法和数据结构 2）编码原则：消除连续的函数调用；消除不必要的内存引用 3）低级优化：展开循环；使用多个累积变量和重新结合等，提高指令并行；功能性的风格重写条件操作 \\\n基准数据（benchmark data} Unix 系统提供了一个剖析程序 GPROF Linux 系统上 VALGRIND� 循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器 提供的指令级并行 减少程序需要做的工作的变换 指令级并行度的变换 现代乱序处理器是如何工作的\n第6章 存储器层次结构 存储器层次结构 局部性（locality) 存储技术棗 SRAM 存储器、DRAM 存储器、ROM 存储器以及旋转的和固态的硬盘\n6.1 随机访问存储器 随机访问存储器（Random-Access Memory, RAM)分为两类：静态的和动态的。静态RAM(SRAM)比动态 RAM(DRAM)更快，SRAM 用来作为高速缓存存储器，可在CPU芯片上，也可在片下。 SRAM每个位存储在一个双稳态的（bistable)存储器单元 DRAM 将每个位存储为对一个电容的充电 行地址i称为 RAS(Row Access Strobe, 行访问选通脉冲）请求。列地址j称为 CAS(Cÿlumn Access Strobe, 列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引脚 双倍数据速率同步 DRAM(Double Data-Rate Synchronous DRAM, DDR SDRAM) SRAM和DRAM都是易失的,ROM非易失的 只读存储器（Read-Only Memory, ROM) 可擦写 可编程 ROM(Erasable Programmable ROM, EPROM) 闪存（flash memory)是一类非易失性存储器，基于 EEPROM\n总线事务(bus transaction)。读事务（read transaction)从主存传送数据到CPU写事务（write transaction)从CPU传送数据到主存。 地址、数据和控制总线\nIO总线：PCI、PCIE、USB\nCPU 使用一种称为内存映射 I/O(memory-mapped I/O)的技术来向 I/O 设备发射命令。内存映射 I/O 的系统中，地址空间中有一块地址是为与 I/O 设备通信保留的。每个这样的地址称为一个 I/O 端口（I/O port)，当一个设备连接到总线时，它与一个或多个端口相关联(或它被映射到一个或多个端口） 直接内存访问(Direct Memory Access DMA)\n固态硬盘 读SSD比写要快\n6.2 局部性 局部性原理（principle of locality)：倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身 时间局部性（temporal locality) 和空间局部性（spatiallocality) \\\n时间局部性的程序中，被引用过一次的内存位置很可能在不远 的将来再被多次引用 空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置 数据引用的局部性，取指令的局部性 局部性原则：重复引用相同变量；步长为々的引用模式的程序，步长越小，空间局部性越好；取指令来说，循环有好的时间和空间局部性\n6.3 存储层次结构 存储器层次结构 高速缓存cache\n存储器被划分成连续的数据对象组块（chunk), 称为块（block)。 数据总是以块大小为传送单元（transfer unit)在第k层和第;k+1 层之间来回复制的 缓存命中和缓存不命中(cache miss) 替换策略：最近最少被使用（LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块 缓存不命中的种类\n强制性不命中（compulsory miss)或冷不命中（cold miss)：空的缓存有时被称为冷缓存（cold cache) 冲突不命中（conflict miss)：限制性的放置策略会引起一种不命中 容量不命中（capacity miss)：工作集的大小超过缓存的大小 高速缓存被组织成一个有 S=2^s个高速缓存组（cache set)的数组。每个组包含 £个高速缓存行（cache line)， 每个行是由一个 B =2^b 字节的数据块(block)组成的，一个有效位（valid bit)指明这个行是否包含有意义的信息，还有 t=m-(b+s)个标记位（tag bit)(是当前块的内存地址的位的一个子集》s 它们唯一地标识存储在 这个高速缓存行中的块。 高速缓存的结构可以用元组（S,E,B,m)来描述\n高速缓存请求名字，抽取被请求子过程：1)组选择 2)行匹配 3)字抽取\n组相联高速缓存： 1\u0026lt;E\u0026lt;C/B 称为E路组相联高速缓存 组相连替换最不常使用(Least-Frequently-Used,LFU)策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最 少使用(Least-Recently-Used LRU)策略会替换最后一次访问时间最久远的那一行。\n全相联高速缓存： 包含所有高速缓存行的组（即 E=C/B)组成 写的问题：直写，写回，写分配 i-cache和d-cache 高速缓存性能指标：不命中率(miss rate)，命中率(hit rate)，命中时间(hit time)，不命中出发(miss penalty) 块：固定大小，cache与主存之间传送 行：cache的一个存储单元？ 组：一个或者多个含的集合 编写高速缓存友好代码：对局部变量反复引用；步长为1的引用模式\n高速缓存与程序性能一个程序从存储系统中读数据的速率称为读呑吐量(read throughput) 或者有时称为读带宽(read bandwidth) 利用时间局部性，使得频繁使用的字从 L1 中取出，还要利用空.间局部性，使得尽可能多的字从一个L1 高速缓存行中访问到\n存储器层次结构对程序编写指导：\n注意力集中在内循环上 按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大 从存睹器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大 基本存储技术包括随机存储器(RAM)、非易失性存储器（ROM)和磁盘。RAM 有两种基本类型。静态RAM(SRAM)快一些，用做 CPU 芯片上的髙速缓存，也可以用做芯片下的高速缓存；动态 RAM(DRAM)慢一点，用做主存和图形帧缓冲区；在关电的时候,ROM 也能保持它们的信息； 随机存取存储器（RAM)和只读存储器(ROM) 及磁盘和固态硬盘 时间局部性和空间局部性来提高应用程序的性能\n在系统上运行程序 第7章 链接 链接可以执行于编译时,也可以在源代码翻译成机器代码时；也可以执行于加载时(dynamorio中的链接在执行时)，即程序被加载器加载到内存并执行时；也可以执行与运行时。静态链接和加载时的共享库动态链接，运行时共享库动态链接\n# 编译 gcc -Og -o prog main.c sum.c # 预处理 cpp [可选] main.c main.i # 编译 ccl main.i -Og [可选] -o main.s # 汇编 \u0026gt;\u0026gt;可重定位目标文件 as [] -o main.o main.s # 链接 \u0026gt;\u0026gt;可执行目标文件 ld -o prog [] main.o sum.o # 执行 ./prog 7.1 静态链接 链接器生成可执行文件两个过程：\n符号解析 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 目标文件三种形式：\n可重定位目标文件：包含二进制代码和数据 可执行目标文件：包含二进制代码和数据，可直接复制到内存并执行 共享目标文件：特殊可重定位目标文件，可在加载或运行时被动态地加载进内存并链接 Unix a.out格式，windows可移植可执行(PE)格式，linux 可执行可链接格式(ELF) 可重定位目标文件 ELF头(ELF header)以一个16字节的序列开始,描述生成该文件的系统的字的大小和字节顺序;帮助链接器语法分析和解释目标文件的信息，包括ELF头大小、目标文件类型(可重定位、可执行或共享的)、机器类型、节头部表的文件便宜，节头部表中条目的大小和数量。 夹在 ELF 头和节头部表之间的都是节 ELF可重定位目标文件包含的节：\n.text : 编译程序的机器代码 .rodata: 只读数据，格式串和开关语句的跳转表 .data: 已初始化的全局和静态 C 变量 .bss : 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .rel.text: 一个.text 节中位置的列表 .rel.data： 被模块引用或定义的所有全局变量的重定位信息 .debug：调试符号表，其条目是程序中定义的局部变量和类型定义 .line： 调试符号表，其条目是程序中定义的局部变量和类型定义 LINE .strtab: 字符串表 符号表：全局符号，外部符号和局部符号 符号表是由汇编器构造的，使用编译器输出到汇编语言.s 文件中的符号。.symtab节中包含ELF符号表。 有三个特殊的伪节（pseudosection), 它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号；UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配位置的未初始化的数据目标 符号解析：连接器解析符号\n编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，Linux 链接器来处理多重定义的符号名规则 编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library) 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以过在命令行上指定单独的文件名字来使用这些在库中定义的函数\n# 创建静态库 gcc -c addvec.c multvec.c # AR工具 ar rcs libvector.a addvex.op multvec.o # 使用静态库，包含头文件 gcc -c main2.c gcc -static -o prog2c main2.o ./libvector.a # 等价 gcc -c main2.c gcc --static -o prog2c main2.o -L. -lvector 7.2 重定位 重定位由两步组成： 重定位节和符号定义：合并节为聚合节，为聚会节赋运行时内存地址，为符号赋地址 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址 重定位条目 汇编时汇编器不知道外部函数或全局变量的位置，未知目标引用即为重定位条目，代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中 ELF 定义了 32 种不同的重定位类型,两种最基本的 重定货类型：\nR_X86_64_PC32 重定位一个使用32位PC相对地址的引用 R_X86_64_32 重定位一个使用32位绝对地址的引用 重定位PC相对引用 重定位绝对引用\n7.3 可执行目标文件 ELF 头描述文件的总体格式。它还包括程序的入口点（entry point), 也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和.data 节与可重定位目标文件中的节是相似的，init 节定义了一个小函数，叫做_init， 程序的初始化代码会调用它 可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系\n加载可执行目标文件\n./prog shell 认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。linux程序可通过调用execve函数来调用加载器，加载器加可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。\n在 Linux X86-64系统中，代码段总是从地址 0x400加0 处开始，后面是数据段,运行时堆在数据段之后，通过调用 malloc 库往上增长。后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址(2^48 —1)开始，向较小内存地址增长。栈上的区域，从地址 2^48 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分\n加载器运行时在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。加载器跳转到程序的入口点，即_start函数的地址，这个函数是在系统目标文件 Ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核 父进程创建一个fork子进程，子进程通过execve系统调用启动加载器，加载器删除子进程现有的 虚拟内存段，并创建一组新的代码、数 据、堆和栈段。\n7.4 动态链接共享库 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking), 是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在 Linux 系统中通常用 .so后缀来表示,windows中用DLL\n# -fpic 编译器生成与位置无关代码 gcc -shared -fpic -o libvector.so addvec.c multvec.c 动态链接器通过执行重定位完成链接任务 Linux 系统动态链接器接口\n#include\u0026lt;dlfcn.h\u0026gt; void *dlopen(const char *filename, int flag); // dlsym 函数的输人是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字,如果该符号存在，就返回符号的地址，否则返回 NULL void *dlsym(void *handle, char *symbol); int dlclose(void *handle); const char *dlerror(void); 可加载而无需重定位的代码称为位置无关代码(PIC) 数据段与代码段的距离总是保持不变,数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT) 延迟绑定(lazy binding), 将过程地址的绑定推迟到第一次调用该过程时。过程链接表(Procedure Linkage Table, PLT)\nLinux 链接器支持库打桩(library interpositioning), 允许截获对共享库函数的调用，取而代之执行自己的代码。打桩可以发生在编译时、链接时或当程序被加载和执行的运行时\n# 编译时打桩 gcc -DCOMPILETIME -c mymalloc.c gcc -I. -o intc int.c mymalloc.o # 链接时打桩 gcc -DLINKTIME -c mymallo.c gcc -c int.c gcc -Wl, --wrap, malloc -Wl, --wrap, free -o initl int.o mymalloc.o # 运行时打桩 gcc -DRUNTIME -shared -fpic ~o mymalloc.so mymalloc.c -ldl 处理目标文件的工具,GNUbinutils 包\nAR 创建静态库，查人、删除、列出和提取成员 STRINGS 列出一个目标文件中所有可打印的字符串。 STRIP 从目标文件中删除符号表信息 NM 列出目标文件的符号表中定义的符号 SIZE 列出目标文件中节的名字和大小 READELF 显示目标文件的完整结构，ELF头信息 OBJDUMP 所有二进制工具，反汇编 LDD 可执行文件在运行时所需要的共享库 静态和动态链接, 可重定位的、可执行的和共享的 可重定位的和可执行的目标文件、符号解析、重定位、静态库、 共享目标库、 位置无关代码，以及库打桩 链接器的两个主要任务是符号解析和重定位 链接器生成的目标文件是与一些像加载、虚拟内存和内存映射 加载器将可执行文件的内容映射到内存，并运行这个程序\n第8章 异常控制流ECF 8.1 异常 ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制 应用程序与操作系统交换通过陷阱(trap)或系统(system call)的ECF形式 异常处理通过非本地跳转响应错误，C通过setjmp和longjmph函数 状态变化称为事件(event),处理器检测到事件发生，通过异常表(存储异常号)的跳转表，进行间接过程调用，跳转到操作系统子程序(异常处理程序(exception handler))。异常表的起始地地址放在叫做异常表基址寄存器(exception table base register)的特殊CPU寄存器 异常不同于调用：调用返回地址压入栈，异常返回地址位当前指令或下一条指令；额外压入处理器状态到栈；如控制转移到内核，则压入内核栈；异常程序运行在内核模式 异常分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort) 陷阱用在用户程序和内核之间的系统调用，用户程序向内核请求服务，如读文件(read)、创建进程(fork)、加载程序(execve)和终止进程(exit)等，syscall n 指令 故障示例缺页异常 linux/x85-64异常 C程序用 syscall 函数可以直接调用任何系统调用，通常通过包装函数(系统级函数)使用 寄存 %rax 包含系统调用号,寄存器%rdi，%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。 8.2 进程 进程一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文(context)中 PC值的序列叫逻辑控制流，一个逻辑流在时间上与另一个流重叠，称为并发流，并发运行 并发多个流并发执行；多任务进程轮流运行；时间片\n进程私有地址空间\n代码段总是从地址 0x400000 开始,地址空间顶部保留给内核(操作系统常驻内存的部分)\n处理器通常是用某个控制寄存器中的一个模式位(mode bit)来确定用户模式和内核模式 linux系统提供 /proc 文件系统，允许用户模式进程访问内核数据结构的内容\n上下文切换(context swtich):通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构\n内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling), 是由内核中称为调度器(scheduler)的代码处理的\n系统调用错误处理Unix 系统级函数遇到错误时,返回-1，设置全局整数变量errno\n8.3 进程控制 获取进程ID\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; pid_t getpid(void); pit_t getppid(void); 进程三种状态\n运行：在 CPU 上执行；或等待被执行且最终会被内核调度 停止：进程的执行被挂起（suspended), 且不会被调度。收到SIGSTOP、SIGTSTP、SIGYTTIN或SIGTTOU信号，进程停止，直到收到SIGCONT信号，再次运行 终止：进程会因为三种原因终止：1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用 exit 函数 #include \u0026lt;stdlib.h\u0026gt; // 以status退出状态终止进程 void exit(int status) #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 创建进程 调用一次返回两次在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0 pid_t fork(void); 回收子进程；内核将子进程的退出状态传递给父进程;如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父.init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; // waitpid 函数来等待它的子进程终止或者停止 pid_t waitpid(pid_t pid, int *statusp, int options); options 设置为常量 WNOHANG、WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为\n#include\u0026lt;unistd.h\u0026gt; // 进程休眠secs秒 unsigned int sleep(unsigned int secs); // 让调用函数休眠 int pause(void); // 加载并运行一个新程序 和fork的区别 ？ int execve(const char *filename, const char *argv[], const char *envp[]); main函数有3个参数：1）argc argv[]数组中非空指针数量 2)argv 指向argv[]数组第一个条目 3) envp 指向envp[]数组中第一个条目\n#include \u0026lt;stdlib.h\u0026gt; char *getenv(const char *name); int setenv(const char *name, const char *newvalue, int overwrite); void unsetenv(const char *name); 8.4 信号 发送信号 每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp函数返回当前进程的进程组 ID:\n#include\u0026lt;unistd.h\u0026gt; pid_t getpgrp(void); // 改变进程所属进程组 int setpgid(pid_t pid, pid_t pgid); /bin/kill 程序向另外i的进程发送任意信号\n# 15213 进程组 /bin/kill -9 -15213 #include\u0026lt;sys/typed.h\u0026gt; #include\u0026lt;signal.h\u0026gt; //调用 kill 函数发送信号给其他进程 int kill(pid_t pid, int sig); #include\u0026lt;unistd.h\u0026gt; // 调用 alarm 函数向它自己发送 SIGALRM 信号 unsigned int alarm(unsigned int secs); 接收信号\n#include\u0026lt;signale.h\u0026gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); Linux 提供阻塞信号的隐式和显式的机制：\n隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。 显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。\n#include\u0026lt;signal.h\u0026gt; int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signum); int sigdelset(sigset_t *set, int signum); int sigismember(const sigset_t *set, int signum); 信号处理程序中产生输出唯一安全的方法是使用 write 函数, printf和spirintf是不安全的\n8.5 非本地跳转 C 语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump)，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列\n#include\u0026lt;setjmp.h\u0026gt; // setjmp 函数在 env 缓冲区中保存当前调用环境 int setjmp(jmp_buf env); int sigsetjmp(sigjmp_buf env, int savesigs); // longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化的 setjmp 调用的返回 void longjmp(jmp_buf env, int retval); void siglongjmp(sigjmp_buf env, int retval); 操作进程工具：\nstrace 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹 ps 列出当前系统中的进程 top 打印出关于当前进程资源使用的信息 pmap 显示进程的内存映射 /proc 虚拟文件系统，输出大量内核数据结构的内容 如：cat /proc/loadavg 异常控制流 系统所有层次的异常控制流 底层的硬件异常和中断 四种异常：中断、陷阱、故障和终止 在操作系统层，内核用 ECF 提供进程的基本概念。 并发进程的上下文切换 进程的基本概念 通过 Linux 系统调用来使用多个进程\n第9章 虚拟内存 虚拟内存提供了三个重要的能力:1)主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域; 2)为每个进程提供了一致的地址空间; 3)保护了每个进程的地址空间不被其他进程破坏 虚拟内存如何工作;使用和管理虚拟内存\n物理地址(PA)和虚拟地址(VA) MMU内存管理单元：地址翻译\n9.1 虚拟内存作为缓存工具 虚拟页面三个状态：未分配的；缓存的；位缓存的 DRAM缓存 页表(page table)，页表将虚拟页映射到物理页；页表是页表条目(Page Table Entry PTE)的数组\n页命中 缺页 DRAM缓存不命中，缺页异常\n磁盘和内存之间传送也叫做交换或页面调度；按需页面调度策略:直到不命中才换入页面\n分配页面 VP分配过程是在磁盘上创建空间并更新PTE，指向磁盘上新创建的页面 局部性保证了程序趋于较小的活动页面上\n9.2 虚拟内存作为内存管理工具 进程页表独立\n简化链接：进程内存映射采用相同的基本格式，linux64中代码段总是从虚拟地址0x400000开始 简化加载：.text和.data节linux加载器分配虚拟页，标记位无效的，加载不从磁盘复制数据，内存映射(memory mapping)：将一组连续虚拟也映射到任意一个文件中的任意位置表示 linux系统调用mmap，应用程序可做内存映射。 简化共享： 简化内存分配：页表方式可分配不连续物理空间 9.3 虚拟内存作为内存保护工具 PTE三个许可标志位：\nSUP 进程是否必须运行在内核(超级用户)模式下才能访问该页 READ 位和 WRITE 位控制对页面的读和写访问 9.4 地址翻译 TLB加速地址翻译： MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器(Translation Lookaside Buffer, TLB) TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块 多级页表 Core i7内存系统\nLinux 虚拟内存系统 内核为系统中的每个进程维护一个单独的任务结构(源代码中的 task_StrUCt),任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行目标文件的 名字，以及程序计数器) Linux 缺页异常处理 MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序\n9.5 内存映射 Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)\nfork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID, 给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的副本\n删除已存在的用户区域、映射私有区域、映射共享区域、设置程序计数器(PC)\nmmap 函数的用户级内存映射\n#include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/mman.h\u0026gt; // Linux 进程使用 mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); // munmap 函数删除虚拟内存的区域 // munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域 int munmap(void *start, size_t length); 9.6 动态内存分配 mmap 和 munmap 函数来创建和删除虚拟内存的区域，C语言使用动态内存分配器，动态内存分配器维护着一个进程的虚拟内存区 域，称为堆(heap),每个进程，内核维护着一个变量 brk(读break) 它指向堆的顶部。\n显示分配器：c语言malloc free；C++中new和delete 隐式分配器：垃圾收集器GC，Java #include\u0026lt;stdio.h\u0026gt; // malloc 函数从堆中分配块 void *malloc(size_t size); void free(void *ptr); // malloc 可通过使用 mmap 和 munmap 函数，显式地分配和释放堆内存，或者还可以使用 sbrk 函数 #include\u0026lt;unistd.h\u0026gt; void *sbrk(intptr_t incr); 动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小\n管理和操纵虚拟内存 存储分配操作，标准库的 malloc 和 free 操作 存储泄漏和非法指针引用等内存引用错误\n程序间的交互和通信 第10章 系统级 I/O 10.1 输入/输出(I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程 Unix I/O和标准I/O Unix I/O：打开文件、改变单位文件位置、读写文件和关闭文件。 Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准输出(描述符为 1)和标准错误(描述符为 2) Linux 文件: 普通文件、目录、套接字\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/sttat.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; // flags O_RDONYL 只读 O_WRONLY 只写 O_RDWR 可读可写 int open(char *filename, int flags, mode_t mode); #include \u0026lt;unistd.h\u0026gt; // 关闭文件 int close(int fd) #include\u0026lt;unistd.h\u0026gt; // 读写文件 ssize_t read(int fd, void *buf, size_t n); ssize_t write(int fd, const void *buf, size_t n); RIO健壮读写包 https://blog.csdn.net/df12138/article/details/122272107\n读取文件元数据\n#include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/stat.h\u0026gt; int stat(const char *filename, struct stat *buf); int fstat(int fd, struct stat *buf); 读取目录内容\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;dirent.h\u0026gt; DIR *opendir(const char *name); struct dirent *readdir(DIR *dirp); int closedir(DIR *dirp); 共享文件\n描述符表：每个进程有独立描述符表 文件表：所有进程共享 v-node表：所有进程共享 10.2 I/O 重定向 linux\u0026gt; ls \u0026gt; foo.txt #include\u0026lt;unistd.h\u0026gt; int dup2(int oldfd, int newfd); 10.3 标准I/O C语言libc库提供了打开和关闭文件的函数(fopen 和 fclose)、读和写字节的函数(fread 和 fwrite)、读和写字符串的函数(fgets 和 fputs)以及复杂的格式化的 I/O 函数(scanf 和 printf) 标准 I/O 库将一个打开的文件模型化为一个流,一个流就是一个指向 FILE 类型的结构的指针,有三个打开的流 stdin、stdout和 stderr分别对应于标准输人、标准输出和标准错误\nUnix VO 的基本概念 文件和描述符 共享文件，1/O重定向 访问文件的元数据 C 的标准 I/O 库 Linux 内核使用三个相关的数据结构来表示打开的文件 描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项，每个进程都有它自己单独的描述符表，而所有的进程共享同一个打开文件表和 v-node 表 第11章 网络编程 11.1 客户端-服务器 客户端-服务器(CS)模型中的基本操作是事务(transaction) 网络是一种I/O设备， 局域网(LAN)、以太网 IP地址是32位无符号整数\n// IP address struct struc in_addr { uint32_t s_addr; } // 网络字节序是大端字节序 #include\u0026lt;arpa/int.h\u0026gt; uint32_t htonl(unit32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint_16_t netshort); 11.2 因特网 域名 DNS域名集合和 IP 地址集合之间的映射\nnslookup localhost hostname nslookup cs.mit.edu 因特网客户端和服务器通过在连接上发送和接收字节流来通信,客户端套接字地址中的端口是由内核自动分配的 文件/etc/services 包含机器提供的知名名字和知名端口之间的映射 套接字对(socket pair) :—个连接是由它两端的套接字地址唯一确定\n(cliaddr:cliport, servaddr:servport) 11.3 套接字接口 套接字接口(socket interface)是一组函数，和 Unix I/O 函数结合起来，用以创建网络应用 套接字地址结构\nstruct sockaddr_int { uint16_t sin_family; // Protocol family (always AF_INET) uint16_t sin_port; // Port number in network byte order struct in_addr sin_addr; // IP address in network byte order unsigned char sin_zero[8]；// Pad to sizeof(struct sockaddr) } struct sockaddr { uint16_t sa_famliy; // Protocol family char sa_data[14]; // Address data } #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; int socket(int domain, int type, int protocol); int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen); int bind(int sockfd const struct sockaddr *addr, socklen_t addrlen); int listen(int sockfd, int backlog); int accept(int listenfd, struct sockaddr *addr, int *addrlen); getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构 getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串\n11.3 Web服务器 HTTP、HTML\nTINY Web 服务器\n网络是 I/O 设备 客户端-服务器模型 第12章 并发编程 逻辑控制流在时间上重叠称为并发。使用应用级并发的应用程序称为并发程序(concurrent program)。现代操作系统提供 了三种基本的构造并发程序：\n进程：每个逻辑控制流都是一个进程，由内核来调度和维护。进 程有独立的虚拟地址空间。进程间通信(interprocess communication IPC) I/O 多路复用:逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态 线程：线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度 12.1 基于进程的并发编程 创建进程fork、exec和waitpid。并发服务器的法，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。 进程模型：共享文件表，不共享用户地址空间。独立的地址空间使得显式的 IPC(进程间通信)机制。Unix IPC同一台主机上其他进程进行通信的技术，包括管道、先进先出(FIFO)、系统 V 共享内存，以及系统 V 信号量(semaphore)\n12.2 基于I/O多路复用的并发编程 I/O 多路复用(I/O multiplexing)技术,基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序\n#include \u0026lt;sys/select,h\u0026gt; int select(int n, fd_set *fdset, NULL, NULL, NULL); FD_ZERO(fd_set *fdset); /* Clear all bits in fdset */ FD_CLR(int fd, fd.set *fdset); /* Clear bit fd in fdset */ FD_SET(int fd, fd_set *fdset); /* Turn on bit fd in fdset */ FD_ISSET(int fd, fd_set *fdset); /* Is bit fd in fdset on? */ I/O 多路复用可以用做并发事件驱动(event-driven)程序的基础，在事件驱动程序中，某些事件会导致流向前推进。将逻辑流模型化为状态机。一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移是将状态和输人事件映射到状态。每个转移是将一个（输人状态，输人事件）对映 射到一个输出状态。\n12.3 基于线程的并发编程 第一种方法中，为每个流使用单独的进程。内核会自动调度每个进程，而每个进程有它自己的私有地址空间，使得流共享数据很困难。第二种方法中，创建自己的逻辑流，并利用 I/O 多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间 第三种方法：线程(thread)就是运行在进程上下文中的逻辑流.一个进程里同时运行多个线程的程序。线程由内核自动调度。每个线程都有它自己的线程上下文(thread context), 包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。\n每个进程开始生命周期时都是单一线程，这个线程称为主线程(main thread)在某一时刻，主线程创建一个对等线程(peer thread)。线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止\nPosix 线程(Pthreads)是在 C 程序中处理线程的一个标准接口。\n#include\u0026lt;pthread.h\u0026gt; // 创建线程 typedef void *(func)(void*) int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg); // 获线程 ID pthread_t pthread_self(void); // 终止线程 void pthread_exit(void *thread_return); // 终止当前线程 int pthread_cancel(pthread_t tid); // 回收终止线程资源 int pthread_join(pthread_t tid, void **thread_return); // 分离线程 int pthread_detach(pthread_t tid); // 初始化线程 pthread_once_t once_control = PTHREAD_ONCE_INIT; int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); 12.4 多线程程序中的共享变量 线程共享相同的程序变量。一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。寄存器是从不共享的，而虚拟内存总是共享的。 多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：全局变量、本地自动变量、本地静态变量。 用信号量同步线程:信号量 s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V:\n12.5 并发问题 线程安全：函数被称为线程安全的(thread-safe), 当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果\n三种编写并发程序的基本机制（进程、 1/()多路复用和线程） 用 P、 V 信号量操作来实现同步、线程安全和可重人、竞争条件以及死锁等的基本原则\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e[toc]\u003c/p\u003e\n\u003ch1 id=\"深入理解计算机系统\"\u003e深入理解计算机系统\u003c/h1\u003e\n\u003ch2 id=\"第1章-计算机系统\"\u003e第1章 计算机系统\u003c/h2\u003e","title":"深入理解计算机系统"},{"content":"1.cmake简述 CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\nCMake工程简单例子\ncmake_minimum_required(VERSION 3.12) project(myproj) find_package(Poco REQUIRED COMPONENTS Net Util) add_executable(MyExe) target_source(MyExe PRIVATE \u0026#34;main.cpp\u0026#34;) target_link_library(MyExe PRIVATE Poco::Net PocoUtil) target_complie_definition(MyExe PRIVATE std_cxx_14) 2.Target 和围绕 Target 的配置 C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为target，创建命令分别是add_library()和add_executable()。其中链接库的类型又分为很多种，最常用的就是SHARED以及STATIC，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。 指定target的源文件：\ntarget_source(MyLib PRVIATE \u0026#34;main.cpp\u0026#34; \u0026#34;func.cpp\u0026#34;) PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值\n较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) 命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：\ntarget_source(MyLib PRIVATE ${SRCS}) 配置target时通常还需要指定头文件目录：\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/) 编译时需要的语言特性：\ntarget_compile_features(MyLib PRIVATE std_cxx_14) 编译时的宏定义：\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3) 参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra) 3.Build Specification 和 Usage Requirement C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库 CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。\n一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：\ntarget_compile_features(MyLib PRIVATE cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：\ntarget_compile_features(MyLib PUBLIC cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) 当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可\narget_compile_features(MyLib INTERFACE cxx_std_14) Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，\n4.寻找和使用链接库 C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。 在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。\n4.1 通过 Config file 找到依赖 Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement\nCMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。\n4.2 通过 Find file 找到依赖 对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。\nCMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。 库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake) ${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。 通过 CMake 的find_library和find_path两个命令就可以完成任务：\nfind_library(MPI_LIBRARY NAMES mpi HINTS \u0026#34;${CMAKE_PREFIX_PATH}/lib\u0026#34; ${MPI_LIB_PATH} # 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值 ) find_path(MPI_INCLUDE_DIR NAMES mpi.h PATHS \u0026#34;${CMAKE_PREFIX_PATH}/include\u0026#34; ${MPI_INCLUDE_PATH} # 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值 ) 4.3.find_package 的处理 find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：\n# 要求大版本号为2的SFML库的graphic模块 find_package(SFML 2 COMPONENTS graphics REQUIRED) # SFML提供的target名字为sfml-graphics target_link_libraries(MyEXE PRIVATE sfml-graphics) 5.使用 CMake 来编译 CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：\ncmake --build . 使用\u0026ndash;buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。 对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：\ncmake --build . --config Release CPM 使用CPM管理CMake C++工程中的外部依赖库\n参考链接: cmake https://ukabuer.me/blog/more-modern-cmake/ Makefile ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/cmake/","summary":"\u003ch2 id=\"1cmake简述\"\u003e1.cmake简述\u003c/h2\u003e\n\u003cp\u003e CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\u003c/p\u003e","title":"cmake"},{"content":"一.简单句子分析 英语句子= 主干+修饰成分 分析句子结构: 一个中心 + 两个要点 一个中心: 动词. 句子必须右动词 两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者. 句子的核心是主谓结构\nn个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。\n英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.\n{% pullquote mindmap mindmap-md %}\n英文句子 简单句 主 + 谓 主 + 谓 + 宾 主 + 谓 + 宾 + 宾补 主 + 谓 + 间宾 + 直宾 主 + 系 + 表 复合句 名词性从句 主语从句 宾语从句 同位语从句 表语从句 定语从句 状语从句 时间状语从句 地点状语从句 条件状语从句 结果状语从句 让步状语从句 目的状语从句 特殊句式 强调句 虚拟语气 倒装句 类型 陈述句 祈使句 感叹句 疑问句 {% endpullquote %}\n英语语法从整体上来讲是通过五部分来组成 1、简单句 2、并列句、复合句 3、三大从句 4、特殊句式 5、类型\n补语 补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。 修饰成分 介词短语 从句 非谓语动词 时间状语 论主语的补语，而后将宾语的补语作为一种变形来讨论\n1.1 S + V （主+谓） 句子不可或缺的两部分. 名词/代词/不定式/动名词 + 动词 谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.\n1.2 S + V + C （主+系+表） 主语 +系动词 +表语\n表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。\n系动词包括：\na. be 动词，am, is, are, was, were;\nb. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);\nc. 表变化：become(成为), grow, turn(转变为), go, get, fall;\nd. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).\nappear 显得像是 prove 证实为 become 成为 make 作为\n1.3 S + V + O （主+谓+宾） 主语+谓语+宾语\n谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。\n1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)） 谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。 e.g.,\ngive sb sth = give sth to sb\ntell sb sth = tell sth to sb\n1.5 S + V + O + C（主+谓+宾+宾补） 此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。 主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。\nThere be 句型\nThere be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分\n1.主语：句子所陈述的对象。 2.谓语：主语发出的动作。一般是有动作意义的动词。 3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。 4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。 5. 表语：紧跟系动词后面的成分。 6. 定语：修饰名词或代词的成分。 7. 状语： 修饰形容词、副词、动词或句子的成分。 8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。\n参考链接: https://liam.page/2014/06/21/basic-sentence-and-the-complement/ https://www.zhihu.com/question/30030877/answer/768501967\n参考数据 《语法俱乐部》\n复杂句:从简单句演化而来\n简单句没有什么句序的调整，所以翻译起来基本没有什么难度。\n英语中的修饰成分，分定语和状语两种情况。 英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)\n二、并列句、复合句 简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：\n并列句：简单句+并列词+简单句\n并列词一般有：and / or / but / so /while / yet / for / however\n1）：表示并列：and, not only\u0026hellip;but also\u0026hellip; , neither\u0026hellip;nor\u0026hellip;\nHer father is a doctor and her mother is a teacher .\n2）：表示选择：or, or else, otherwise, either\u0026hellip;or\u0026hellip;\nHurry or you won\u0026rsquo;t make the train.\n3）：表示对比、转折: but, while , yet , however , never ,\nI like tea while she likes coffee .\n4）：表示原因：for\nI am thirsty , for it is hot .\n复合句：简单句+从属连词+简单句\n从属连词有：that / wether/ if\n复合句其实就是我们常说的三大从句，\n三.三大从句 1、名词性从句\n当名词性从句作为句子的不同成分时，又被称呼为不同的名字。\n当作为主语时，称为主语从句。\n当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：\n主语从句 What she said is wrong .\n宾语从句 I said that she was wrong.\n表语从句 The fact is that he doesn’t really try.\n同位语从句 The news that he will come back is ture.\n记住一点，不管什么从句，你把它当成一个”长一点的名词”。\n那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。\n同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。\n2、定语从句\n修饰限定名词，汉语中“的”前面的内容。\n关系代词引导的定语从句\n1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.\n2. whom指人，在定语从句中充当宾语，常可省略。\nMr. Ling is just the boy whom I want to see\n3. which指物，在定语从句中做主语或者宾语，做宾语时可省略\nThis is the pen (which) he bought yesterday.\n4. that指人时，相当于who 或者whom；指物时，相当于which。\n5. whose通常指人，也可指物，在定语从句中做定语。\n指的是谁的。Do you like the book whose cover is yellow?\n关系副词引导的定语从句\nwhen where why\n3、状语从句\n修饰动作的发生的时间、地点、原因、方式\n九大状语从句\n1、时间状语从句\n常用引导词：when, as, while, as soon as, before, after, since , till, until\n特殊引导词：the minute, the moment, the second, every time, the day，the instant,\nI was fat when I was a child.\n2、地点状语从句\n常用引导词：where\n特殊引导词：wherever, anywhere, everywhere\nKeep it where you can see it.\n3、原因状语从句\n常用引导词：because, since, as, for\n特殊引导词：seeing that, now that, in that, considering that, given that.\nMy friends dislike me because I’m beautiful .\n4、目的状语从句\n常用引导词：so that, in order that\n特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that\nstudy hard so that you can pass the exam.\n5、结果状语从句\n常用引导词：so … that, so… that, such … that,\n特殊引导词：such that, to the degree that, to the extent that, to such a degree that,\nHe got up so early that he caught the first bus.\n6、条件状语从句\n常用引导词：if, unless,\n特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that\nIf you ask him, he will help you.\n7、方式状语从句\n常用引导词：as, as if, how\n特殊引导词：the way\nThink as i think\n8、比较状语从句\n常用引导词：as(同级比较), than(不同程度的比较)\n特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B\nThe house is three times as big as ours.\n9、让步状语从句\n常用引导词：though, although, even if, even though\n特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\nThough I believe it, yet I must consider.\n四.特殊句式 1、强调句\nIt is （名词 / 介宾）指的是被强调的内容that （\u0026hellip;\u0026hellip;..）\nIt was she whom we are talking about.\n2、倒装句\n正常句序 ：主谓宾\n倒装句序 ：谓主宾\nwe can win only through hard work .\nonly through hard work can we win .\n3、虚拟语气，假设不可能发生的事情\n1、对过去情况的虚拟\n从句用 had done\n主句用 would could might should have done\n2、对现在情况的虚拟\n从句用 did , was变成were\n主句用 would could might should do\n3、对将来情况虚拟\n从句用 did ，was 变成 were，should do,were to do\n主句用 would could might should do\n五.类型 陈述句\ni like English very much . 我非常喜欢英语。\n疑问句\nis this your key ? 这是你的钥匙吗？\n祈使句\n一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。\nmind you head 小心碰头！\n第二种祈使句以let开头\nLet\u0026rsquo;s have another try\n感叹句\nwhat a brave girl ! 真是个勇敢的女孩子\nhttps://zhuanlan.zhihu.com/p/400448345\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%B8%80/","summary":"\u003ch2 id=\"一简单句子分析\"\u003e一.简单句子分析\u003c/h2\u003e\n\u003cp\u003e \u003cstrong\u003e英语句子= 主干+修饰成分\u003c/strong\u003e\n 分析句子结构:\n  一个中心 + 两个要点\n  一个中心: 动词. 句子必须右动词\n  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.\n  \u003cstrong\u003e句子的核心是主谓结构\u003c/strong\u003e\u003c/p\u003e","title":"英语语法一"},{"content":"ptrace ptrace使用简介 android的ptrace详细分析 【Android 逆向】ptrace 函数 ( C 标准库 ptrace 函数简介 | ptrace 函数真实作用 )\nTermux Android手机命令行中断\nhttps://termux.dev/en/ https://github.com/termux/termux-app\nIDA\n010 Editor\nspeedscope\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/android/","summary":"ptrace ptrace使用简介 android的ptrace详细分析 【Android 逆向】ptrace 函数 ( C 标准库 ptrace 函数简介 | ptrace 函数真实作用 ) Termux An","title":"Android"},{"content":"hugo运行 hugo -F --cleanDestinationDir # 本地预览 hugo server 参考链接：\nhttps://www.sulvblog.cn/\nhttps://www.jianshu.com/p/fa95c0c1fdab\nhttps://lishensuo.github.io/\nhttps://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612\nhttps://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38\nhttps://blog.csdn.net/qq_45975757/article/details/108923612\nmongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.6.7\u0026#34;} 托管 为了提高访问速度托管在gitee上，迁移完成后将会同时托管到github中。 通过不同分支保存源码和静态网页内容，用br_hugo管理源码，master分支管理public 域名申请中\u0026hellip;，个人域名审批流程真麻烦\nhexo # 清理缓存 hexo clean # 生成网页 hexo g # 启动本地服务端口 hexo s # 发布到github hexo d # 强制推送备份源码分支 git push -f origin backup GitHub Pages + Hexo使用及配置 github上创建一个 username.github.io 的工程，username 必须为github的用户名\n参考链接 https://www.jianshu.com/p/f82c76b90336\nhttps://www.jianshu.com/p/5d0b31032d55\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\nhttps://theme-next.org/\nhttps://hexo.io/zh-cn/docs/\nhttps://www.jianshu.com/p/3a05351a37dc\nhttps://www.zhyong.cn/posts/ca02/\nhttp://theme-next.iissnan.com/\nhttps://liam.page/\nhttps://liam.page/en/\n装饰 Hexo博客添加helper-live2d动态模型插件 https://blog.csdn.net/qq_30930805/article/details/\nemojiall 图标可嵌入博客中 https://www.emojiall.com/zh-hans/sub-categories/A15\n图床 vscode + PicGo + github\n# 快捷方式 # 上传剪贴板中的图片到服务器。 ctrl + alt + u # 打开文件浏览器选择图片上传。 ctrl + alt + e 参考链接： https://blog.csdn.net/qq_44314954/article/details/122951033 https://blog.csdn.net/qq_44314954/article/details/122951033 https://www.jianshu.com/p/868b3a2028f8 https://zhuanlan.zhihu.com/p/131584831\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/blog/","summary":"hugo运行 hugo -F --cleanDestinationDir # 本地预览 hugo server 参考链接： https://www.sulvblog.cn/ https://www.jianshu.com/p/fa95c0c1fdab https://lishensuo.github.io/ https://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612 https://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38 https://blog.csdn.net/qq_45975757/article/details/108923612 mongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#3","title":"hexo-\u003ehugo迁移"},{"content":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接： ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334\n安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239\n性能显示 bpytop 装X神器\nsudo apt-get install bpytop sudo snap install bpyto https://blog.csdn.net/ll837448792/article/details/123103212\nubuntu 显示 https://ubuntuqa.com/article/8837.html\nhttps://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html\nUbunut 22.04 LTS 版本 GNU/Linux核心\nGCC 11.2.0 binutils 2.38 glibc 2.35 编译工具链\nPython 3.10.4 Perl 5.34.0 LLVM 14 golang 1.18 rustc 1.58 OpenJDK Ruby 3.0 systemd 249.11 OpenSSL 3.0 虚拟化\nqemu 6.2.0 libvirt 8.0.0 virt-manager 4.0.0 Linux包管理 snap flameshot截图工具 # 快捷方式 # 个人习惯设置为 alt + AQ # -c 保存到粘贴板， -p 保存到路径 flameshot gui -c -p \u0026lt;path\u0026gt; https://www.cnblogs.com/kendoziyu/p/how_to_screenshot_in_ubuntu2004.html ubuntu/linux系统知识（14）ubuntu 搜狗输入法不见了，重启方法\nfree wget -O clash.gz https://github.com/Dreamacro/clash/releases/download/v1.11.8/clash-linux-amd64-v1.11.8.gz wget -O clash.gz https://github.com/Dreamacro/clash/releases/download/v1.12.0/clash-linux-amd64-v1.12.0.gz curl -LJO -o clash.gz https://github.com/Dreamacro/clash/releases/download/v1.12.0/clash-linux-amd64-v1.12.0.gz gzip -f clash.gz -d sudo chmod +x clash ./clash wget -U \u0026ldquo;Mozilla/6.0\u0026rdquo; -O ~/.config/clash/config.yaml\nwget -U \u0026#34;Mozilla/6.0\u0026#34; -O ~/.config/clash/config.yaml https://to.runba.cyou/link/HR6FLUV7z8k7lNyx?clash=1 https://github.com/esrrhs/pingtunnel/tree/delete\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxtool/","summary":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接： ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334 安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239 性能显示 bpytop 装X神器 sudo apt-get install bpytop sudo snap install bpyto","title":"linuxTool"},{"content":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # shift + : 低行模式 wq # 保存退出 w! # 保存 !q # 放弃退出 gg # 回到文件首部 GG # 到文件尾部 / # 查找 p # 粘贴 x # 删除光标所在字符 nx # 删除光标所在处后n个字符 d # 删除一行 D # 删除光标到行尾 dG # 删除光标到文件尾 u # 撤销 yy # 复制当前行 dd # 剪切当前行 %s/old/new # 替换old字符为new 史上最全的vim快捷键 Vim使用笔记 Windows使用Vim 在Windows系统中，安装git后已经存在vim，找到vim.exe所在目录，添加到环境变量path中即可。 Windows下载 Vim安装 参考博客：在Windows下安装和使用vim PowerVim PowerVim快捷键 ;n # 打开文件目录树显示在屏幕左侧 ;m # 打开当前函数和变量目录树显示在屏幕右侧 ;w # 保存文件 ;u # 向上翻半屏 ;d # 向下翻半屏 ;1 # 光标快速移动到行首 ;2 # 光标快速移动到行末 ;a # 快速切换.h和cpp文件，写C++的时候很方便 ;e # 打开一个新文件 ;z # 切回shell交互命令，输入fg在切回vim，非常实用 ;s # 水平分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;v # 竖直分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;fw # 查找项目内关键字 ;ff # 查找项目内文件名 ;gt # 跳转到变量或者函数定义的地方，前提是安装ctags，并且在在PowerVim输入 ;tg命令 Jump to the definition of the keyword where the cursor is located, but make sure you have make ctags ;gr # 跳回，对应着;gt ;tg # 对当前目录打ctag ;y # 保存当前选中的目录到系统剪切板，前提是vim支持系统剪切板的寄存器 dsfa;w ;h/l/k/j # 光标向左右上下窗口移动，特别是打开多个窗口。使用这个快捷键组合非常实用 ;gg # 按顺序光标跳转各个窗口 # Shortcuts without ; e # 快速删除光标所在的词 tabc # 关闭当前tab，可以用:tabnew来打开一个新的tab Close tab, of course you should :tabnew a file first. F1 # 编译C++代码，自己写的C++例子的时候一键编译。前提手动在当前目录建一个bin文件夹，这是用来存放编译产生的执行文件 gc # 快速注释选中的块（是visual模式下选中的块） gcc # 快速当前行 { # 光标向上移动一个代码块s } # 光标向下移动一个代码块 PowerVim安装及配置 【VIM】PowerVim安装及使用\nPowerVim - 使Vim更加强大易用\n安装PowerVim 问题解决过程记录\nctags ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vim/","summary":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # shift + : 低行模式 wq # 保存退出 w! # 保存 !q # 放弃退出 gg # 回到文件首部 GG #","title":"vim"},{"content":"CMD命令 # 查询本机IP ipconfig # 向对方电脑发送消息 msg /server 192.168.1.100 * 消息 # 查看本机用户信息 net user # 查看共享资源 net share # 查看网站IP nsloopup www.baidu.com # 查看WiFi配置文件 netsh wlan show # 管道符，输出到文件 | 1.txt # windows 工具软件 Snipaste 截图软件 支持自定义设置快捷键 Download\nZoomIt 屏幕缩放、标记、录制 展示小工具 whois 居然可以在Windows使用 Download\nSysinternals 工具集 Download\neveryting 快速查找文件 Download\n7zip 开源压缩软件 Download\nWiztree 磁盘文件占用 Download\nWindows Terminal 取代传统cmd显示，可集成PowerShell， 登录wsl， 未来Windows将设置为默认终端 微软商店\ncmder 同事推荐，值得探索，Windows命令行工具 \\ Download github 配置 \\\nPowerShell 一款shell，支持Windows、linux、mac，推荐Windows结合 Windows Terminal使用, 使Windows像Linux终端一样爽 Download\nwinget search Microsoft.PowerShell winget install Microsoft.PowerShell 参考链接：\nWindows Powershell和Windows Terminal的区别\n安装和设置 Windows 终端\nwsl+windows terminal 美化教程\nQ-Dir 多窗口资源管理器 Download\nFileZilla 多协议文件传送，支持FTP、SFTP，包含Client和Server，支持Windows、Linux、mac Download\n终端连接程序 secureCRT 需要破解 https://blog.csdn.net/qq_39052513/article/details/104692026\ngeek windows卸载工具，清理注册表，删除缓存文件，开箱即用 Download\nWindows包管理 Scoop Scoop 是 Windows 的命令行安装程序，是一个强大的包管理工具\n项目地址\n使用教程\nChocolatey choro Windows软件管理工具Chocolatey的安装和使用\nwinget 官方推出 谁用Windows 终端安装程序？ 我！\n# 使用 WinGet 安装一遍 winget install postman winget search postman # 卸载，再用 Scoop 安装一遍 scoop install postman vcpkg C/C++ 库管理工具，跨平台 Get started with vcpkg\ncget https://cget.readthedocs.io/en/latest/# \\\n开源库集成器Vcpkg全教程\nWSL 安装ubuntu20.04 安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe\n卸载wsl wslconfig /l # 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令 wslconfig /u Ubuntu 参考链接：WSL系列操作：安装，卸载\n设置wsl # 更改默认root用户登录 ubuntu1804.exe config --default-user root # 更改默认登陆目录 # list 中 Ubuntu-20.04 条目中添加 \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu-20.04\u0026#34; # 以管理员权限运行cmd # 停止 net stop LxssManager # 启动 net start LxssManager l rustdesk 远程开源软件，跨平台 https://github.com/rustdesk/rustdesk\nditto 粘贴板工具 https://ditto-cp.sourceforge.io/ https://github.com/sabrogden/Ditto\nbleachbit https://github.com/bleachbit/bleachbit https://www.bleachbit.org/\nqbittorrent https://github.com/qbittorrent/qBittorrent\nimagine gui 跨平台PNG和JPEG优化GUI工具 https://github.com/meowtec/Imagine\ncreentogif 动图捕获软件 录制屏幕上的指定区域 https://www.screentogif.com/\ngrammarly https://www.grammarly.com/\nPowerToys 功能多样工具集 https://github.com/microsoft/PowerToys\nWox http://www.wox.one/ https://github.com/Wox-launcher/Wox WOX 软件高效使用\nZetero https://www.zotero.org/ https://github.com/zotero/zotero Zotero 简明介绍 Zotero+TeraCloud同步应用\npotplayer https://iptv-org.github.io/iptv/index.m3u\nmaya 三维建模软件 Online 线上思维导图 https://gitmind.cn/app/template\n在线文档转换 https://www.aconvert.com/cn/\n开源软件下载网站 https://www.fosshub.com/#\n、\n剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键\nchrome插件 油猴\nwindows输入英文中间有间隙 进入了全角模式，选择半角即可\nReact Router http://react-guide.github.io/react-router-cn/index.html\nyoutube 下载 https://www.ganbey.com/youtube-download-3774\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/windowssoftware/","summary":"CMD命令 # 查询本机IP ipconfig # 向对方电脑发送消息 msg /server 192.168.1.100 * 消息 # 查看本机用户信息 net user # 查看共享资源 net share # 查看网站IP nsloopup www.baidu.com # 查看WiFi配置文件 netsh","title":"WindowsSoftware"},{"content":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04\nWindows\n镜像烧录工具 软碟通UltraISO 写入镜像，树莓派刷镜像\nVentoy 官方网站 Ventoy支持多个ISO镜像，开源，支持Linux和Windows ventoy详细使用教程 制作完启动盘，将ISO复制到U盘即可\nWinPE 支持多镜像 支持多镜像\n安装系统 小米 F2设置boot密码，重启F12安装Ubuntu\nThinkpad 1.关闭bitlocker 2.f1进入bios关闭security boot 3.f12进入boot，选择启动U盘\nQ 什么功能Windows上有，在Linux没有又没有替代方法？ ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","summary":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04 Windows 镜像烧录工具 软碟通UltraISO 写入镜像，树莓派刷镜像 Ventoy 官方网站 Ventoy支持多个ISO镜像，开源，支持","title":"系统安装"},{"content":" 上海疫情之逃离酒店 \u0026ndash; 2022.11.02\n","permalink":"https://liuz0123.gitee.io/zain/posts/life/life/","summary":"上海疫情之逃离酒店 \u0026ndash; 2022.11.02","title":"Life"},{"content":" 无间道-3 往往是事情改变人，而不是人改变事情\n在云端\n世界如此之大，无数人来了又走，奔波操劳 世界又如此之小，任何两点一日可达\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/movie/movie/","summary":"无间道-3 往往是事情改变人，而不是人改变事情 在云端 世界如此之大，无数人来了又走，奔波操劳 世界又如此之小，任何两点一日可达","title":"Movie"},{"content":" QMD\n已停止服务，等待开源 2022.11.01 《如愿》-王菲 天后依然\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/music/music/","summary":"QMD 已停止服务，等待开源 2022.11.01 《如愿》-王菲 天后依然","title":"Music"},{"content":"软件故事 1946年 ENIAC\n批处理系统 硬件发展-》 分时系统 机器语言\u0026ndash;纸带 汇编语言\u0026ndash; 指令 操作 Fortran语言 - 第一种高级计算机语言 COBOL 语言 BASIC\n卡耐基 \u0026ndash; 人工智能\nIBM 701 704(Fortran商用) IBM OS/360\n存储时计算机\nUnix c 语言\n欧洲计算机技术： linux 芬兰 万维网 瑞典\nAPPLE II Macish\n微软 收购DOS\nwindows BASIC\n鼠标、 显示器\nC++\nJava Java与互联网\n阿帕奇 IBM linux\n硅谷百年 硅谷 斯坦福、伯克利、圣何塞大学\n特曼\n真空管、晶体管、集成电路 仙童半导体 - 八叛徒 英特尔、AMD、英伟达\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/computerbook/","summary":"\u003ch2 id=\"软件故事\"\u003e软件故事\u003c/h2\u003e\n\u003cp\u003e1946年 ENIAC\u003c/p\u003e\n\u003cp\u003e批处理系统\n硬件发展-》 分时系统\n机器语言\u0026ndash;纸带\n汇编语言\u0026ndash; 指令 操作\nFortran语言 - 第一种高级计算机语言\nCOBOL 语言\nBASIC\u003c/p\u003e","title":"computerbook"},{"content":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使\n《局外人》 加缪 个人主义，无知是最大的邪恶 《culture evolution》 文化的演进 ronald inglehart教授 什么原因猝发个人主义\n《结构性思维》\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/readingplan/","summary":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使 《局外人》 加缪 个人主义，无知是最大的邪恶 《cultur","title":"Reading Plan"},{"content":"豆豆三部曲 《背叛》 《遥远的救世主》 《天幕红尘》\n在细雨中呼唤 余华 普通农村少年以旁观者角度叙述自己的童年少年成长，世间人都处于一辆时光列车中，其中遇到的人和事，不管他们是好的还是坏的，未来的未知都无可逃避，唯一能做好的就是：好好活着，珍惜眼前的一切，做最好的自己。\n死亡不是失去生命，只是走出了时间\n通往奴役之路 如果我们仅仅只是一部无人性的机器中的一个齿轮，这也许不是好事情；但如果我们再也无法脱离它，被束缚在为我们选定的那些上级的身边，那么情况就不知道要糟糕多少倍。当每个人意识到他的命运的不满，就会同他的这种意识一起成长。\n简单的逻辑学 小毕的故事 简短的剧本，电影丰富人物真实性 一颗种子，但却不必发芽\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/read/","summary":"豆豆三部曲 《背叛》 《遥远的救世主》 《天幕红尘》 在细雨中呼唤 余华 普通农村少年以旁观者角度叙述自己的童年少年成长，世间人都处于一辆时光列车中，其","title":"读书"},{"content":" 有意思网站wikihow https://zh.wikihow.com/%E9%A6%96%E9%A1%B5 https://www.wikihow.com/Main-Page \\\n窥探社会的三个层次，技术、制度、文化，逐层递进，技术是表象，推动社会运动的动力；制度是社会的组织方式，制度是主义吗？什么样的制度能够让社会持续演进？文化是根本，很多表象最终都会有文化属性的影子，我们是几千年文化，这些文化中又有多少不适合今天的社会，或者有多少是口中的文化，行动的矮子。 \u0026mdash;《遥远的\u0026hellip;.》 2022.11.12\n众生、群像\n点上一支烟，飘然远去，不亦快哉\n越是珍爱的东西，越快离他远去，非要立定成佛，或纠结某种痛苦都是同一种执念。\n第一个信号-中原-可防可治疗 2022.11.01\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/","summary":"有意思网站wikihow https://zh.wikihow.com/%E9%A6%96%E9%A1%B5 https://www.wikihow.com/Main-Page \\ 窥探社会的三个层次，技术、制度、文化，逐层递进，技术是表象，推动社会运动的动力；制度是社会的组织方式，制度是主","title":"闲言碎语"},{"content":"DynamoRIO官方 https://dynamorio.org/ https://github.com/DynamoRIO/dynamorio\ngit clone https://github.com/DynamoRIO/dynamorio.git --recursive 编译 注意wsl中需要root用户编译 https://dynamorio.org/page_building.html # Android 编译配置 mkdir build cd build cmake \\ -DCMAKE_TOOLCHAIN_FILE=../dynamorio/make/toolchain-android=arm64.cmake \\ -DANDROID_TOOLCHAIN=/home/zain/tool/android-ndk-r21e/toolchains \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../ ../dynamorio /home/zain/tool/android-ndk-r21e/toolchains -DANDROID_TOOLCHAIN=/android_toolchain_using \\ # AArch64 树莓派 编译配置 mkdir build cd build cmake \\ -DCMAKE_TOOLCHAIN_FILE=../dynamorio/make/toolchain-arm32.cmake \\ -DANDROID_TOOLCHAIN=/home/zain/tool/raspbian_complier/arm-bcm2708/arm-linux-gnueabihf/bin \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio cmake \\ -DCMAKE_TOOLCHAIN_FILE=../dynamorio/make/toolchain-aarch64_raspbian_armv8.cmake \\ -DANDROID_TOOLCHAIN=/home/zain/tool/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio /home/zain/tool/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin -DCMAKE_TOOLCHAIN_FILE=../dynamorio/make/toolchain-aarch64_raspbian.cmake \\ ../dynamorio /home/zain/tool/android-ndk-r21e/toolchains -DANDROID_TOOLCHAIN=/android_toolchain_using \\ # x64 编译配置 cd dynamorio mkdir build cd build cmake \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio/ # 编译 make -j12 # 使用 # 帮助 ./bin64/drrun --help # 参数 -c 指定client so # libbbbuf ./bin64/drrun -c ./api/bin/libbbbuf.so -- ls client libbbbuf.so 学习链接 DynamoRIO进阶指南 https://blog.csdn.net/oShuangYue12/article/details/109780166 DynamoRIO的入门指南（Ubuntu） https://blog.csdn.net/ts_forever/article/details/124614200 aarch64-linux-gnu 交叉编译 libpcap\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/dynamorio/","summary":"DynamoRIO官方 https://dynamorio.org/ https://github.com/DynamoRIO/dynamorio git clone https://github.com/DynamoRIO/dynamorio.git --recursive 编译 注意wsl中需要root用户编译 https://dynamorio.org/page_building.html # Android 编译配置 mkdir build cd build cmake \\ -DCMAKE_TOOLCHAIN_FILE=../dynamorio/make/toolchain-android=arm64.cmake \\ -DANDROID_TOOLCHAIN=/home/zain/tool/android-ndk-r21e/toolchains \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../ ../dynamorio /home/zain/tool/android-ndk-r21e/toolchains -DANDROID_TOOLCHAIN=/android_toolchain_using \\ # AArch64 树","title":"DynamoRIO"},{"content":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？\nLinux内核代码下载 Linux kernel官网 https://www.kernel.org/\n解压 linux-5.19.10.tar.xz\ntar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035\nlinux内核线上阅读 linux、u-boot、qemu、glibc、llvm、grub https://elixir.bootlin.com/ https://www.kernel.org/doc/html/latest/\nU-boot # 下载源代码 git clone https://source.denx.de/u-boot/u-boot.git # 或 git clone https://github.com/u-boot/u-boot # 切换分支 git checkout v2020.10 官网 https://www.denx.de/wiki/U-Boot/ 代码网站 https://source.denx.de/u-boot 什么是U-Boot以及如何下载U-Boot源码 https://blog.csdn.net/zhuguanlin121/article/details/119008893 gdb 《100个gdb小技巧》 https://leetcode-cn.com/circle/article/7mxorv\nkbuild Kbuild: the Linux Kernel Build System Kernel Build System¶ https://www.zhihu.com/question/47039391/answer/2287806626\nELF 开源库 lief\n参考链接： https://blog.csdn.net/GrayOnDream/article/details/124564129\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linuxreadtool/","summary":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？ Linux内核代码下载 Linux kernel官网 https://www.kernel.org/ 解压 linux-5.19.10.tar.xz tar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035 linux内核线上阅读 li","title":"Linux Read Tool"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/tech/tech/","summary":"","title":"Tech"},{"content":"\rZain\u0026#39;s Blog\r一个记录技术、阅文、生活的博客\r两年后，再次回到如水般沉静，酿的淡而又淡的酒\n做一个终生不与女人吵架的男人有那么难吗？😇 👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego\n","permalink":"https://liuz0123.gitee.io/zain/links/","summary":"Zain\u0026#39;s Blog 一个记录技术、阅文、生活的博客 两年后，再次回到如水般沉静，酿的淡而又淡的酒 做一个终生不与女人吵架的男人有那么难吗？😇 👉 越过长城，走向世界","title":"🤝闲言俗语"},{"content":"\n英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 思考、觉悟、成长、沉静，时而逗比，时而安静，明心见性 👉Hugo博客交流群\r787018782\n","permalink":"https://liuz0123.gitee.io/zain/about/","summary":"英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 思考、觉悟、成长、沉静，时","title":"🙋🏻‍♂️关于"},{"content":"COVID-19 与流感：相似之处和不同之处 2019 冠状病毒病（冠状病毒）与流感有许多相似之处和不同之处。请查看相关注意事项，了解如何保护自己免受这些疾病的侵害。\n来自妙佑医疗国际员工\n在 COVID-19 疫情期间，您可能听说过 2019 冠状病毒病（COVID-19）与流感（流行性感冒）类似。COVID-19 和流感都是由病毒引起的传染性呼吸道疾病。它们有一些共同的症状。但如果进行更深入的比较，便会发现它们会对人体产生不同的影响。此外，由于流感存在的时间较长，医生对如何治疗和预防此类疾病已有较为深入的了解，但对 COVID-19 却还有待进一步了解。 COVID-19 和流行性感冒有何相似之处？\nCOVID-19 和流行性感冒如何传播 引起 COVID-19 和流行性感冒的病毒的传播方式相似。它们都可以在密切接触的人（6 英尺或 2 米之内）之间传播。这些病毒会通过谈话、打喷嚏或咳嗽时释放的呼吸道飞沫或气溶胶传播。这些飞沫可能落入附近某个人的口鼻内，或者被吸入。如果一个人触摸了带有这些病毒的表面，然后再触摸自己的口鼻或眼睛，也会导致病毒传播。\nCOVID-19 和流行性感冒的症状 COVID-19 和流行性感冒有许多相同的体征和症状，包括：\n发热 咳嗽 气短或呼吸困难 疲倦 咽喉疼痛 流鼻涕或鼻塞 肌肉痛 头痛 恶心或呕吐，但这在儿童中比在成人中更为常见 这两种疾病的体征和症状都是从无症状、轻度症状到重度症状不等。由于 COVID-19 和流行性感冒的症状相似，仅根据您的症状很难诊断您患的是哪种疾病。您可以通过检测来确定自己患的是 COVID-19 还是流行性感冒。您也可能同时患上这两种疾病。\nCOVID-19 和流行性感冒的并发症 COVID-19 和流行性感冒都可导致严重的并发症，例如：\n感染性肺炎 急性呼吸窘迫综合征 器官衰竭 心脏病发作 心脏或脑部发炎 卒中 死亡 许多流行性感冒患者或 COVID-19 轻症患者通过在家休息和多喝水就可以恢复健康。但是有些流行性感冒或 COVID-19 患者会表现为重症，需要住院治疗。\nCOVID-19 和流感有何区别？ COVID-19 和流感有几个不同之处，包括病因、并发症和治疗方法。COVID-19 与流感的传播方式也不同，此外，严重程度、部分症状和预防疫苗也存在差异。\nCOVID-19 和流感的病因 COVID-19 和流感有几个不同之处。COVID-19 和流感由不同的病毒引起。COVID-19 由一种名为 SARS-CoV-2 的新型冠状病毒引起，而流感则是由甲型和乙型流感病毒引起。\nCOVID-19 和流感的症状 COVID-19 和流感症状的出现时间不同，症状本身也存在一定差异。COVID-19 的症状一般在感染后 2 到 14 天出现。流感的症状通常在感染后约 1 至 4 天出现。\nCOVID-19 和流感的传播和严重程度 COVID-19 似乎比流感更具传染性，传播速度也更快。若患上 COVID-19，您可能会丧失味觉或嗅觉。与流感相比，COVID-19 导致重症（如肺损伤）的概率更高。COVID-19 的死亡率也高于流感。\n据美国疾病控制与预防中心（CDC）报告，截至目前，美国已有超过 3800 万人感染了 COVID-19。2020 年和 2021 年间，美国已有超过 630,000 人死于 COVID-19。\n相比之下，在 2019 年至 2020 年美国流感季，约有 3800 万人感染流感，约有 22,000 人死于流感。\nCOVID-19 和流感的并发症 COVID-19 可引起不同于流感的并发症，如血栓和儿童多系统炎症综合征。\nCOVID-19 和流感的治疗方法 另一个区别是流感可以用抗病毒药物来治疗。目前，只有一种抗病毒药物（瑞德西韦）获批用于治疗 COVID-19。研究人员正在评估许多治疗 COVID-19 的药物和疗法。有些药物可能有助于缓解 COVID-19 的病情。\nCOVID-19 和流感的预防 您可以每年接种一次流感疫苗来帮助降低患流感的风险。流感疫苗还可以降低流感的严重程度和出现严重并发症的风险。每年的流感疫苗都可以帮助您抵抗三种或四种预计在当年流感季最为常见的流感病毒。该疫苗可以通过注射或鼻喷雾接种。\n接种流感疫苗无法预防 COVID-19。部分研究表明，接种流感疫苗或许能降低感染 COVID-19 的风险。研究还表明，接种流感疫苗并不会增加您患 COVID-19 或其他呼吸道感染的风险。\n美国食品药品管理局（FDA）已授予部分 COVID-19 疫苗在美国紧急使用的许可，且有一种疫苗已获批准。疫苗可以防止您感染 COVID-19 病毒，或在您已经感染 COVID-19 病毒的情况下，防止您的病情加重。接种 COVID-19 疫苗还可让您做许多因疫情而无法做的事，例如无需佩戴口罩或保持安全社交距离，但法律法规要求的情况除外。\nCOVID-19 对今年的流感季有怎样的影响？ 北美的流感季通常发生在 10 月至 5 月之间。在流感季期间，引起COVID-19 和流感的病毒可能同时在您的社区传播。如果发生这种情况，人们可能患上其中一种或同时患上这两种疾病。\n检测可以确定您可能感染了哪种病毒，并且有助于指导医生进行适当的治疗。同一时间可能会有许多因这两种病毒而身患重病的人需要住院，从而可能导致医院爆满。接种 COVID-19 疫苗或流感疫苗可以帮助减少导致这些疾病的病毒传播。\n妙佑医疗国际一分钟：为何这个季节流感疫苗接种尤其重要\n如何避免感染 COVID-19 和流感？ 接种 COVID-19 疫苗和流感疫苗。您还可以遵循几项标准预防措施，就能采取同样的步骤降低感染引发 COVID-19、流感和其他呼吸道感染的病毒的风险。实际上，一些研究发现，保持社交距离和戴口罩等措施可能有助于缩短流感季的持续时间，并减少 2019-2020 流感季受累人数。\n如果您未接种 COVID-19 疫苗，您可以采取多项措施来降低感染风险。预防措施可能包括：\n避免参加大型活动和群众集会 避免与家人以外的任何人密切接触（6 英尺或 2 米以内），尤其是您较容易患重病的情况下 经常用肥皂和水洗手至少 20 秒，或使用酒精含量至少 60% 的含酒精洗手液清洁双手 在存在 COVID-19 高传播风险（例如人员密集的活动或大型集会）的室内公共场所和室外，请佩戴口罩。进一步的 COVID-19 口罩佩戴指南取决于您是已完全接种疫苗还是尚未接种疫苗。 咳嗽或打喷嚏时用肘部或纸巾遮掩口鼻 避免触摸眼睛和口鼻 每天清洁和消毒频繁接触的表面，如门把手、电灯开关、电子设备和柜台 采取这些预防措施可以帮助您保持健康，降低因 COVID-19 或流感而患病的风险。\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/covid_cmp_./","summary":"COVID-19 与流感：相似之处和不同之处 2019 冠状病毒病（冠状病毒）与流感有许多相似之处和不同之处。请查看相关注意事项，了解如何保护自己免受这些疾病的侵害。","title":""}]