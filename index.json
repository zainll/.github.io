[{"content":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF http://gen.lib.rus.ec/ https://libgen.li/ https://libgen.gs/ https://sci-hub.41610.org/library-genesis https://libgen.rs/search.php?\u0026amp;req=KVM\u0026amp;phrase=1\u0026amp;view=simple\u0026amp;column=def\u0026amp;sort=year\u0026amp;sortmode=DESC https://libgen.rs/ zlibrary PDF https://zh.u1lib.org/ https://en.ru1lib.org/ FreeTechBooks 计算机科学类 http://www.freetechbooks.com/ https://www.freetechbooks.com/ 古登宝计划 http://www.gutenberg.org/ Planet eBook 国内可访问 https://www.planetebook.com/ 布克书屋 https://iao.su/3064/comment-page-1 https://www.bukebook.cn yudu https://express.yudu.com/ kindle 社区 书伴 https://bookfere.com/post/4.html 参考链接： http://www.360doc.com/content/20/0219/14/5008209_893150066.shtml http://www.sohu.com/a/215001801_490529\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/ebookwebsite/","summary":"kindle资源 幸福的味道 https://ebook2.lorefree.com/ https://lorefree.com/ http://www.ireadweek.com/ 公众号Sobook https://sobooks.cc/ 小书屋 www.mebook.cc \\ 子午书简 https://5kindle.com/ 已废弃 http://shuxiangjia.cn/?cate=2 目录 SooHub 2022.09.13已打不开 https://www.soohub.com/ finelybook http://finelybook.com/ 好读 http://haodoo.net/ 长城之外 Library Genesis mobi\u0026amp;PDF","title":"电子书网站"},{"content":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉取更新代码 git pull # 推送 git push # 合并已push的commit git rebase -i HEAD~n # 强制更新覆盖本次 git fetch --all git reset --hard HEAD git pull # 强制推送 git push -u origin br_master --force # 回合代码 git rebase master git配置 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@163.com\u0026#34; git config --list user.name=xxx user.email=xxx@163.com # 生成秘钥 ssh-keygen -t rsa -C \u0026#39;xxx@163.com\u0026#39; # cd ~/.ssh 将 id_rsa.pub 添加道GitHub # 测试链接 ssh -T git@github.com # 设置默认编辑为vim git config --global core.editor \u0026#34;vim\u0026#34; 玩转WSL(6)之Git配置\ngit同时配置Gitee和Github\nGit设置换行符为LF\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/git/","summary":"git操作 # 下载代码，ssh或https 一种方式出错换用另一种 git clone # 创建分支 git checkout -b br_master # 提交 git status git add . git commit # 合并到前一个commit git commit --amend # 拉","title":"git"},{"content":"python logging # logging.yaml： version: 1 disable_existing_loggers: true formatters: standard: format: \u0026#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#34; error: format: \u0026#34;%(levelname)s \u0026lt;PID %(process)d:%(processName)s\u0026gt; %(name)s.%(funcName)s(): %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: standard stream: ext://sys.stdout info_file_handler: class: logging.handlers.RotatingFileHandler level: INFO formatter: standard filename: /tmp/info.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 error_file_handler: class: logging.handlers.RotatingFileHandler level: ERROR formatter: error filename: /tmp/errors.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 debug_file_handler: class: logging.handlers.RotatingFileHandler level: DEBUG formatter: standard filename: /tmp/debug.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 critical_file_handler: class: logging.handlers.RotatingFileHandler level: CRITICAL formatter: standard filename: /tmp/critical.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 warn_file_handler: class: logging.handlers.RotatingFileHandler level: WARN formatter: standard filename: /tmp/warn.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 root: level: NOTSET handlers: [console] propogate: yes loggers: \u0026lt;module\u0026gt;: level: INFO handlers: [console, info_file_handler, error_file_handler, critical_file_handler, debug_file_handler, warn_file_handler] propogate: no \u0026lt;module.x\u0026gt;: level: DEBUG handlers: [info_file_handler, error_file_handler, critical_file_handler, debug_file_handler, warn_file_handler] propogate: yes # logging.py import os import yaml import logging.config import logging import coloredlogs def setup_logging(default_path=\u0026#39;logging.yaml\u0026#39;, default_level=logging.INFO, env_key=\u0026#39;LOG_CFG\u0026#39;): \u0026#34;\u0026#34;\u0026#34; | **@author:** Prathyush SP | Logging Setup \u0026#34;\u0026#34;\u0026#34; path = default_path value = os.getenv(env_key, None) if value: path = value if os.path.exists(path): with open(path, \u0026#39;rt\u0026#39;) as f: try: config = yaml.safe_load(f.read()) logging.config.dictConfig(config) coloredlogs.install() except Exception as e: print(e) print(\u0026#39;Error in Logging Configuration. Using default configs\u0026#39;) logging.basicConfig(level=default_level) coloredlogs.install(level=default_level) else: logging.basicConfig(level=default_level) coloredlogs.install(level=default_level) print(\u0026#39;Failed to load configuration file. Using default configs\u0026#39;) 参考链接：\nhttps://blog.csdn.net/weixin_43988680/article/details/123528294 https://zhuanlan.zhihu.com/p/425678081 c log zlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/logging/","summary":"python logging # logging.yaml： version: 1 disable_existing_loggers: true formatters: standard: format: \u0026#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#34; error: format: \u0026#34;%(levelname)s \u0026lt;PID %(process)d:%(processName)s\u0026gt; %(name)s.%(funcName)s(): %(message)s\u0026#34; handlers: console: class: logging.StreamHandler level: DEBUG formatter: standard stream: ext://sys.stdout info_file_handler: class: logging.handlers.RotatingFileHandler level: INFO formatter: standard filename: /tmp/info.log maxBytes: 10485760 # 10MB backupCount: 20 encoding: utf8 error_file_handler: class: logging.handlers.RotatingFileHandler level: ERROR formatter:","title":"logging"},{"content":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxcommand/","summary":"查看大小 # 查看系统目录大小 df -lh # 查看当前目录下文件大小 du -h --max-depth=1 权限 chmod chown","title":"LinuxCommand"},{"content":"[toc]\n深入理解计算机系统 第1章 计算机系统 hello world程序分析 hello.c编译\n编译系统：预处理器cpp、编译器ccl、汇编器as和链接器ld\n计算机系统硬件组成：总线，I/O设备，主存，处理器 CPU 在指令的要求下执行操作：加载、存储、操作和跳转\nhello程序加载 从键盘上读取 hello 命令,从磁盘加载可执行文件到主存,将输出字符串从存储器写到显示器\n高速缓存存储器cache：L1 L2 L3(SRAM) 存储设备层次结构 操作系统有两个基本功能：（1)防止硬件被失控的应用程序滥用；（2 )向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备 操作系统通过几个基本的抽象概念：进程、虚拟内存和文件 Posix 标准：Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程\n进程：操作系统对一个正在运行的程序的一种抽象，操作系统实现进程交错执行的机制称为上下文切换\n操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括 PC 和寄存器文件的当前值，以及主存的内容\n系统调用会将控制权传递给操作系统\n从一个进程到另一个进程的转换是由操作系统内核（kernel )管理的。内核是操作系统代码常驻主存的部分\n读写文件，执行一条系统调用（system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序\n内核不是一个独立的进程。是系统管理全部进程所用代码和数据结构的集合\n线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据\n虚拟内存 程序代码和数据，堆，共享库，栈，内核虚拟内存，\n文件 I/O 设备是文件\n系统之间网络通信\nAmdahl定律\n对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度\n并发和并行 三个层次：\n线程级并发 指令级并行 单指令、多数据并行 计算机系统中抽象 程序结构和执行 处理器和存储子系统，基本数据结构，指令操作，编译器翻译\n第2章 信息的表示和处理 2.1 信息表示 十六进制 x是2的非负整数n次幂时，x=2”，我们可以很容易地将 x 写成十六进制形式，只要记住 X 的二进制表示就是1后面跟n个0， 2^9 = 512 0x200\n字节序 低有效字节在最前面的方式，称为小端法 最高有效字节在最前面的方式，称为大端法 x01234567 大端01 23 45 67 小端 67 45 23 01\n位运算与逻辑运算 位运算\u0026amp;与 |或 ~非 异或 逻辑运算：\u0026amp;\u0026amp;与 ||或 !非 无符号，补码，浮点数\n移位运算 算数右移和逻辑右移\n2.2 整数表示 有符号数和无符号数 补码计算公式 C 库中的文件\u0026lt;limits.h\u0026gt;定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。常量 INT_MAX、INT_MIN 和UINT_MAX, stdint.h 中uintl6_t，int32_t定义指定位数类型。\n#define INT_MAX 2147483647 #define INT.MIN (-INT_MAX 1) 2.3 整数运算 计算机执行的 “整数” 运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出\n2.4 浮点数 浮点表示通过将数字编码为: x*2〃的形式来近似地表示实数\n第3章 程序的机器级表示 计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、 读写存储设备上的数据，以及利用网络通信\n3.1 机器码 指令集体系结构或指令集架构(Instruction Set Architecture,ISA)定义机器级程序的格式和行为，定义了处理器状态、指令的格式，已经每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址，内存模型看做一个大字节数组。\n处理器状态：\n程序计数器(PC x86-64中%rip)给出将要执行的下一条指令在内存中的地址 整数寄存器文件包含16个命名的位置,分别存储64位的值. 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息. 一组向量寄存器可存放一个或多个整数或浮点数值. # -S 产生汇编代码 生成 .s 文件 gcc -Og -S mstore.c # -c 编译并汇编 产生 .o 文件 gcc -Og -c mstore.c # 反汇编 objdump -d mstore.o x86-64指令长度从1到15字节不等. 反汇编器基于机器代码文件中的字节序列确定汇编代码 汇编代码中以 以.开头的行都是指导汇编器和链接器工作的伪指令 C语言中嵌入汇编代码:1)独立汇编文件,用汇编器和链接器把它和C语言代码合并.2)使用GCC的内联汇编特性,用asm伪指令在C程序中包含汇编代码 数据传送指令四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)\n3.2 处理器访问 x86-64的中央处理器(CPU)包含一组16个存储64位值的通用目的寄存器。%r开头，%rax-%rbp 栈指针%rsp，用来指明运行时栈的结束位置\n复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0。\n3.2.1 指令操作和类型 指令操作数：指令操作使用的源数据值，以及放置结果的目的位置。操作数三种类型：立即数(immediate)、寄存器(register)和内存引用。\n数据传送指令\nMOV类：movb，movw，movl和movq 源操作数类型：立即数，寄存器值和内存中的值，目的操作数：指定位置，寄存器，内存地址，x86-64中源操作数和目的操作数不能同为内存地址。\nMOVZ类指令把目的中剩余资金填充位0 MOVS类指令通过符号扩展来填充，把源操作数高位进行复制。 cltq指令：总以寄存器%eax作为源，%rax作为符号扩展结果的目的 *指针简介引用，\u0026amp;取址\n3.2.2 压入和弹出栈数据 pushq操作把数据压入栈中，popq指令弹出数据；栈向下增长，栈顶元素在低地址，栈指针%rsp保存栈顶元素地址。 3.3 算术和逻辑操作 加法指令ADD类：addb、addw、addl和addq 四组操作：加载有效地址、一元操作、二元操作和移位 leaq 将有效地址写入到目的操作数。 一元操作：只有一个操作数，即是源又是目的。 二元操作：第二个操作数既是源又是目的。 移位操作：先给出移位量，然后第二项给出的是要移位的数。算术和逻辑右移。移位量是个立即数，或者但自己寄存器%c1中。左移：SAL和SHL；右移：SAR和SHR\n特殊算数操作 3.4 控制指令 两种基本条件行为：测试数据值，然后根据曹氏结果来改变控制流或数据流。\n3.4.1 条件码(condition code)寄存器 CF：进位标志 ZF：零标志 SF：符号标志 OF：溢出标志 两类设置条件码指令：\nCMP指令：根据两个操作数之差来设置条件码 TEST指令：与AND(\u0026amp;)指令一样，但仅设置条件码 访问条件码：1)条件码的某种组合SET指令 2)条件跳转 3)条件传送数据\n跳转指令jump\njmp无条件跳转指令：直接跳转和间接跳转 # 用寄存器%rax中的值作为跳转目标 jmp *%rax # 以%rax中的值作为读地址，从内存中读取跳转目标 jmp *(%rax) 当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令 的地址，而不是跳转指令本身的地址\n为什么基于条件数据传送(条件赋值)的代码会比基于条件控制转移的代码性能要好？\n分支预测是条件表达式50%的正确率，x86-64分支预测错误惩罚19个时钟周期。 无论测试数据是什么，编译出使用条件传送代码所需的时间8个时钟周期。控制流不依赖于数据，处理器更容易保持流水线是满的。 条件传送指令 3.4.2 循环 条件测试和跳转组合实现循环\ndo-while循环 loop: bogy-statement t = text-expr; if (t) goto loop while 循环 goto test; loop: body-statement test: t = text-expr; if (t) goto loop; t = text-expr if (!t) got done; do body-statement while(test-expr); done for循环 init-expr; got test; loop: body-statement update-expr; test: t = test-expr; if (t) goto loop; init-expr; t = test-expr; if (!t) goto done; loop: body-statement update-epxr; t = test-expr; if (t) goto loop; done 3.4.2 switch语句 switch(开关)语句可以根据一个整数索引值进行多重分支（multiway branching)。使用跳转表(jump table)数据结构使得实现更加高效,跳转表是一个数组，表项i是一个代码段的地址。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关 .rodata（只读数据，Read-Only Data)的目标代码文件的 段中\n3.5 过程 过程：函数，方法，子例程，处理函数。 过程切换：传递控制，传递数据，分配和释放内存\n运行时栈 栈向低地址方向增长，栈指针%rsp指向栈顶元素。pushq和popq指令将数据压栈和出栈。运行栈划分成栈帧，被调函数返回地址属于调用函数栈帧。\n转移控制 将程序计数器(PC)设置为转移目的代码起始位置。 call Q调用过程 call指令，指明被调用过程起始的指令地址,直接调用的目标是标号,间接调用的目标是*后面跟一个操作数指示符.call将返回地址压入栈中,并跳转到函数的第一条指令.\n数据传送 大部分数据传送通过寄存器实现,返回值通过%rax寄存器. x86-64中通过寄存器最多传递6个整型参数,超出部分通过栈传递,栈顶数据大小都向8的倍数对齐。ARMv8通过寄存器最多可传递8个参数。 栈上局部存储：超出寄存器数量，局部变量地址\u0026amp;，局部变量数组或结构 寄存器中的局部存储空间：寄存器组，寄存器%rbx、%rbp和%r12-%r15为被调用者保存寄存器。被调用这必须保存这些寄存器值，不改变值或入栈返回前恢复。其他寄存器由调用者保存。 每次函数调用由字节私有的状态信息（保存的返回值位置和被调用这保存寄存器的值）存储空间。 递归过程与普通调用一致\n3.6 数组分配与访问 数组声明：T A[N] x86-64内存引用指令可简化数组访问\n# E[i] E地址在寄存器%rdx中，i值在寄存器%rcx中 x + 4i movl (%rdx, %rcx, 4), %eax 指针运算 单操作符\u0026amp;和*可产生指针和间接引用指针 嵌套数组(多维数组) 定长数组 #define N 1 变长数组 malloc\n3.7 结构struct和联合union struct 指向结构的指针就是结构第一个字节的地址,结构信息每个字段（field)的字节偏移\nunion 联合能够规避c语言的类型系统，允许以多种类型引用一个对象\n数据对齐 x86-64数据类型对齐 # 保证起始地址是8的倍数 .align 8 3.8机器级程序中控制和数据结合 指针 指针类型，指针值，指针创建\u0026amp;，指针间接引用*，数组与指针，指针强制类型转换，函数指针(*f)()\nGDB\ngdb prog 内存越界引用和缓冲区溢出 数组越界访问 字符串长度超过分配的数组空间 防止缓冲区溢出：栈随机化，栈破坏检测，限制可执行代码区域，变长栈帧\n3.9 浮点代码 MMX-SSE-SSE2-AVX-AVX2 AVX浮点体系16个YMM寄存器%ymm0-%ymm15,256bit(32字节) 浮点传送和转换 浮点运算 x86-64 机器代码 控制结构（比如条件、循环和开关语句）生成的基本指令模式 括栈分配、寄存器使用惯例和参数传递 数据结构（如结构、联合和数组）的分配和访问方式 整数和浮点数算术运算的指令 代码安全漏洞（例如缓冲区溢出）\n第4章 处理器体系结构 处理器支持的指令和指令的字节级编码称为指令集体系结构(Instruction-Set Architecture ISA) HCL(Hardware Control Language硬件控制语言)\n4.1 Y86-64指令集 Y86-64 指令\nmovq指令分成4中：irmovq,rrmovq,mrmovq和rmmovq;i立即数，r寄存器，m内存 整数操作指令4个：addq,subq,andq和xorq;可设置条件吗ZF(零)，SF(符号)和OF(溢出) 跳转指令7条：jmp、 jle、 jl、 je、 jne、 jge 和 jg 6个条件传送指令: cmovle、cmovl、cmove、 cmovne、 cmovge 和 cmovg。 call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回 pushq 和 popq 指令实现了人栈和出栈 halt 指令停止指令的执行 CISC(复杂指令集)和RISC(精简指令集) RISC寻址方式简单:机制和便宜了寻址，只能对寄存器操作数进行算数和逻辑运算，内存引用仅有load和store\n状态码Stat，程序执行的总体状态 以.开头的词是汇编器伪指令（assembler directives)，它们告诉汇 编器调整地址，以便在那儿产生代码或cha人一些数据。\npush %rsp指令行为：1)压人％rsp 的原始值，2)压人减去 8 的红印的值\n4.2 逻辑设计和硬件控制语言HCL 逻辑门 与 或 非 逻辑门组成组合电路\n存储器和时钟 两类存储设备：时钟寄存器(寄存器)和随记访问存储器(内存) 处理器随机访问存储器来存储程序数据 SEQ(\u0026ldquo;se-quential\u0026rdquo; 顺序的）的处理器\n操作阶段：\n取值fetch:从内存读取指令字节，地址为程序计数器（PC)的值,从指令中取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令功能）。 译码decode: 译码阶段从寄存器文件读人最多两个操作数 执行execute: 执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针 访存memory: 访存阶段可以将数据写人内存，或者从内存读出数据 写回: 最多可以写两个结果到寄存器文件 更新PC: 将 PC 设置成下一条指令的地址。 SEQ引进结构\n控制处理器中活动的时序原则：从不回读，\n取指阶段 译码和写回阶段 执行阶段 访存阶段 更新PC阶段 流水线 吞吐量：每秒千兆条指令（GIPS)\n各个阶段之间放上流水线寄存器（pipeline register) 现代处理器采用了很深的(15 或更多的阶段)流水线\n带反馈流水线系统 指令执行顺序相关：\n数据相关 控制相关 SEQ+ PIPE 预测下一个 PC\n猜测分支方向并根据猜测开始取指的技术称为分支预测，预测 PC 的新值为 valG\n流水线冒险 相关有两种形式：1)数据相关，下一条指令会用到这一条指令计算出的结果；2)控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时 冒险也可以分为两类：数据冒险（data hazard)和控制冒险(control hazard)\n对于Y86-64 来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器\n异常处理 Y86-64 包括三种不同的内部产生的异常：l)halt 指令，2)有非法指令和功能码组合的指令，3)取指或数据读写试图访问一个非法地址 导致异常的指令称为异常指令（excepting instruction)\nPIPE 各阶段的实现 PC 选择和取指阶段 译码和写回阶段 执行阶段 访存阶段\nCPI(Cycles Per Instruction, 每指令周期数）\n第四章流水部分还需要继续阅读 基本的组合和时序逻辑元素 流水线 五阶段处理器流水线\n第5章 优化程序性能 高性能程序：1)数据结构与算法选择 2)编译器能够优化 3)计算分解，并行化\n5.1 优化编译器 GCC 编译选项 -Og -O1 -O2 -O3 两个指针可能指向同一个内存位置的情况称为内存别 名使用（memory aliasing) 包含函数调用的代码可以用一个称为 内联函数替换（inline substitution, 或 者简称\u0026quot;内联（inlining)\u0026quot;）的过程进行优化\n程序性能表示 CPE每元素的周期数（Cycles Per Element, CPE)\n消除循环的低效率:循环条件判断中使用数值，而不是表达式 减少过程调用：将调用移出循环 消除不必要的内存引用：把中间结果存在临时变量中，最后在赋给引用地址\n5.2 现代处理器 指令并行 两种下界描述了程序的最大性能:延迟界限(latency bound)和吞吐量界限(throughpu bound) 超标量：每个时钟周期执行多个操作 乱序：指令的顺序不一定与机器级程序中的顺序一致 处理器设计两个主要部分：指令控制单元(ICU)和执行单元(EU) 分支预测(branch prediction):处理器会猜测是否选择分支，还预测分支的目的地址 投机执行（speculative execution)冒险？ 处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码 Intel Core i7 Haswell 有 8 个功能单元: 0 整数运算、浮点乘、整数和浮点数除法、分支 1 整数运算、浮点加、整数乘、浮点乘 2 加载、地址计算 3 加载、地址计算 4 存储 5 整数运算 6 整数运算、分支 7 存储、地址计算\n任何对程序寄存器的更新都只会在指令退役时才会发生 控制操作数在执行单元间传送的最常见的机制称为寄存器重命名（register renaming)：值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来， 重命名表只包含关于有未进行写操作的寄存器条目。\n运算性能：\n延迟：完成运算所需总时间 发射时间：两个联系同类型运算直接最小时间周期数 容量：能够执行该元素的功能单元的数量 数据流(data-flow)，关键路径(critical path)\n循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。编译器GCC优化等级-O3\n5.3 提高并行性 对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能 浮点乘法和加法不是可结合的\n重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。\n极大化对向量元素加或者乘的函数性能\n制约程序性能的一些限制因素：寄存器溢出，并行度p超过寄存器数量；分支预测和预测错误处罚\n5.4 内存性能 加载的性能：对两个加载单元而言，其每个时钟周期只能启动一条加载操作，所以 CPE 不可能小于 0.50 存储的性能：每个周期开始一条新的存储\n5.5 性能提高技术 1）高级设计：为问题选择适当的算法和数据结构 2）编码原则：消除连续的函数调用；消除不必要的内存引用 3）低级优化：展开循环；使用多个累积变量和重新结合等，提高指令并行；功能性的风格重写条件操作\n基准数据（benchmark data} Unix 系统提供了一个剖析程序 GPROF Linux 系统上 VALGRIND� 循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器 提供的指令级并行 减少程序需要做的工作的变换 指令级并行度的变换 现代乱序处理器是如何工作的\n第6章 存储器层次结构 存储器层次结构 局部性（locality) 存储技术棗 SRAM 存储器、DRAM 存储器、ROM 存储器以及旋转的和固态的硬盘\n6.1 随机访问存储器 随机访问存储器（Random-Access Memory, RAM)分为两类：静态的和动态的。静态AM(SRAM)比动态 RAM(DRAM)更快，SRAM 用来作为高速缓存存储器，可在CPU芯片上，也可在片下。 SRAM每个位存储在一个双稳态的（bistable)存储器单元 DRAM 将每个位存储为对一个电容的充电 行地址i称为 RAS(Row Access Strobe, 行访问选通脉冲）请求。列地址j称为 CAS(Cÿlumn Access Strobe, 列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引脚 双倍数据速率同步 DRAM(Double Data-Rate Synchronous DRAM, DDR SDRAM) SRAM和DRAM都是易失的,ROM非易失的 只读存储器（Read-Only Memory, ROM) 可擦写 可编程 ROM(Erasable Programmable ROM, EPROM) 闪存（flash memory)是一类非易失性存储器，基于 EEPROM\n总线事务(bus transaction)。读事务（read transaction)从主存传送数据到CPU写事务（write transaction)从CPU传送数据到主存。 地址、数据和控制总线\nIO总线：PCI、PCIE、USB\nCPU 使用一种称为内存映射 I/O(memory-mapped I/O)的技术来向 I/O 设备发射命令。内存映射 I/O 的系统中，地址空间中有一块地址是为与 I/O 设备通信保留的。每个这样的地址称为一个 I/O 端口（I/O port)，当一个设备连接到总线时，它与一个或多个端口相关联(或它被映射到一个或多个端口） 直接内存访问(Direct Memory Access DMA)\n固态硬盘 读SSD比写要快\n6.2 局部性 局部性原理（principle of locality)：倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身 时间局部性（temporal locality) 和空间局部性（spatial locality) 时间局部性的程序中，被引用过一次的内存位置很可能在不远 的将来再被多次引用 空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置 数据引用的局部性，取指令的局部性 局部性原则：重复引用相同变量；步长为々的引用模式的程序，步长越小，空间局部性越好；取指令来说，循环有好的时间和空间局部性\n6.3 存储层次结构 存储器层次结构 高速缓存cache 存储器被划分成连续的数据对象组块（chunk), 称为块（block)。 数据总是以块大小为传送单元（transfer unit)在第k层和第;k+1 层之间来回复制的 缓存命中和缓存不命中(cache miss) 替换策略：最近最少被使用（LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块 缓存不命中的种类\n强制性不命中（compulsory miss)或冷不命中（cold miss)：空的缓存有时被称为冷缓存（cold cache) 冲突不命中（conflict miss)：限制性的放置策略会引起一种不命中 容量不命中（capacity miss)：工作集的大小超过缓存的大小 高速缓存被组织成一个有 S=2^s个高速缓存组（cache set)的数组。每个组包含 £个高速缓存行（cache line)， 每个行是由一个 B =2^b 字节的数据块(block)组成的，一个有效位（valid bit)指明这个行是否包含有意义的信息，还有 t=m-(b+s)个标记位（tag bit)(是当前块的内存地址的位的一个子集》s 它们唯一地标识存储在 这个高速缓存行中的块。 高速缓存的结构可以用元组（S,E,B,m)来描述\n高速缓存请求名字，抽取被请求子过程：1)组选择 2)行匹配 3)字抽取\n组相联高速缓存： 1\u0026lt;E\u0026lt;C/B 称为E路组相联高速缓存 组相连替换最不常使用(Least-Frequently-Used,LFU)策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最 少使用(Least-Recently-Used LRU)策略会替换最后一次访问时间最久远的那一行。\n全相联高速缓存： 包含所有高速缓存行的组（即 E=C/B)组成 写的问题：直写，写回，写分配 i-cache和d-cache 高速缓存性能指标：不命中率(miss rate)，命中率(hit rate)，命中时间(hit time)，不命中出发(miss penalty) 块：固定大小，cache与主存之间传送 行：cache的一个存储单元？ 组：一个或者多个含的集合 编写高速缓存友好代码：对局部变量反复引用；步长为1的引用模式\n高速缓存与程序性能一个程序从存储系统中读数据的速率称为读呑吐量(read throughput) 或者有时称为读带宽(read bandwidth) 利用时间局部性，使得频繁使用的字从 L1 中取出，还要利用空.间局部性，使得尽可能多的字从一个L1 高速缓存行中访问到\n存储器层次结构对程序编写指导：\n注意力集中在内循环上 按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大 从存睹器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大 基本存储技术包括随机存储器(RAM)、非易失性存储器（ROM)和磁盘。RAM 有两种基本类型。静态RAM(SRAM)快一些，用做 CPU 芯片上的髙速缓存，也可以用做芯片下的高速缓存；动态 RAM(DRAM)慢一点，用做主存和图形帧缓冲区；在关电的时候,ROM 也能保持它们的信息； 随机存取存储器（RAM)和只读存储器(ROM) 及磁盘和固态硬盘 时间局部性和空间局部性来提高应用程序的性能\n在系统上运行程序 第7章 链接 链接可以执行于编译时,也可以在源代码翻译成机器代码时；也可以执行于加载时(dynamorio中的链接在执行时)，即程序被加载器加载到内存并执行时；也可以执行与运行时。静态链接和加载时的共享库动态链接，运行时共享库动态链接\n# 编译 gcc -Og -o prog main.c sum.c # 预处理 cpp [可选] main.c main.i # 编译 ccl main.i -Og [可选] -o main.s # 汇编 \u0026gt;\u0026gt;可重定位目标文件 as [] -o main.o main.s # 链接 \u0026gt;\u0026gt;可执行目标文件 ld -o prog [] main.o sum.o # 执行 ./prog 7.1 静态链接 链接器生成可执行文件两个过程：\n符号解析 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 目标文件三种形式：\n可重定位目标文件：包含二进制代码和数据 可执行目标文件：包含二进制代码和数据，可直接复制到内存并执行 共享目标文件：特殊可重定位目标文件，可在加载或运行时被动态地加载进内存并链接 Unix a.out格式，windows可移植可执行(PE)格式，linux 可执行可链接格式(ELF) 可重定位目标文件 ELF头(ELF header)以一个16字节的序列开始,描述生成该文件的系统的字的大小和字节顺序;帮助链接器语法分析和解释目标文件的信息，包括ELF头大小、目标文件类型(可重定位、可执行或共享的)、机器类型、节头部表的文件便宜，节头部表中条目的大小和数量。 夹在 ELF 头和节头部表之间的都是节 ELF可重定位目标文件包含的节：\n.text : 编译程序的机器代码 .rodata: 只读数据，格式串和开关语句的跳转表 .data: 已初始化的全局和静态 C 变量 .bss : 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .rel.text: 一个.text 节中位置的列表 .rel.data： 被模块引用或定义的所有全局变量的重定位信息 .debug：调试符号表，其条目是程序中定义的局部变量和类型定义 .line： 调试符号表，其条目是程序中定义的局部变量和类型定义 LINE .strtab: 字符串表 符号表：全局符号，外部符号和局部符号 符号表是由汇编器构造的，使用编译器输出到汇编语言.s 文件中的符号。.symtab节中包含ELF符号表。 有三个特殊的伪节（pseudosection), 它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号；UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配位置的未初始化的数据目标 符号解析：连接器解析符号\n编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，Linux 链接器来处理多重定义的符号名规则 编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library) 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以过在命令行上指定单独的文件名字来使用这些在库中定义的函数\n# 创建静态库 gcc -c addvec.c multvec.c # AR工具 ar rcs libvector.a addvex.op multvec.o # 使用静态库，包含头文件 gcc -c main2.c gcc -static -o prog2c main2.o ./libvector.a # 等价 gcc -c main2.c gcc --static -o prog2c main2.o -L. -lvector 7.2 重定位 重定位由两步组成： 重定位节和符号定义：合并节为聚合节，为聚会节赋运行时内存地址，为符号赋地址 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址 重定位条目 汇编时汇编器不知道外部函数或全局变量的位置，未知目标引用即为重定位条目，代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中 ELF 定义了 32 种不同的重定位类型,两种最基本的 重定货类型：\nR_X86_64_PC32 重定位一个使用32位PC相对地址的引用 R_X86_64_32 重定位一个使用32位绝对地址的引用 重定位PC相对引用 重定位绝对引用\n7.3 可执行目标文件 ELF 头描述文件的总体格式。它还包括程序的入口点（entry point), 也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和.data 节与可重定位目标文件中的节是相似的，init 节定义了一个小函数，叫做_init， 程序的初始化代码会调用它 可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系\n加载可执行目标文件\n./prog shell 认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。linux程序可通过调用execve函数来调用加载器，加载器加可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。\n在 Linux X86-64系统中，代码段总是从地址 0x400加0 处开始，后面是数据段,运行时堆在数据段之后，通过调用 malloc 库往上增长。后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址(2^48 —1)开始，向较小内存地址增长。栈上的区域，从地址 2^48 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分\n加载器运行时在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。加载器跳转到程序的入口点，即_start函数的地址，这个函数是在系统目标文件 Ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核 父进程创建一个fork子进程，子进程通过execve系统调用启动加载器，加载器删除子进程现有的 虚拟内存段，并创建一组新的代码、数 据、堆和栈段。\n7.4 动态链接共享库 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking), 是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在 Linux 系统中通常用 .so后缀来表示,windows中用DLL\n# -fpic 编译器生成与位置无关代码 gcc -shared -fpic -o libvector.so addvec.c multvec.c 动态链接器通过执行重定位完成链接任务 Linux 系统动态链接器接口\n#include\u0026lt;dlfcn.h\u0026gt; void *dlopen(const char *filename, int flag); // dlsym 函数的输人是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字,如果该符号存在，就返回符号的地址，否则返回 NULL void *dlsym(void *handle, char *symbol); int dlclose(void *handle); const char *dlerror(void); 可加载而无需重定位的代码称为位置无关代码(PIC) 数据段与代码段的距离总是保持不变,数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT) 延迟绑定(lazy binding), 将过程地址的绑定推迟到第一次调用该过程时。过程链接表(Procedure Linkage Table, PLT)\nLinux 链接器支持库打桩(library interpositioning), 允许截获对共享库函数的调用，取而代之执行自己的代码。打桩可以发生在编译时、链接时或当程序被加载和执行的运行时\n# 编译时打桩 gcc -DCOMPILETIME -c mymalloc.c gcc -I. -o intc int.c mymalloc.o # 链接时打桩 gcc -DLINKTIME -c mymallo.c gcc -c int.c gcc -Wl, --wrap, malloc -Wl, --wrap, free -o initl int.o mymalloc.o # 运行时打桩 gcc -DRUNTIME -shared -fpic ~o mymalloc.so mymalloc.c -ldl 处理目标文件的工具,GNUbinutils 包\nAR 创建静态库，cha人、删除、列出和提取成员 STRINGS 列出一个目标文件中所有可打印的字符串。 STRIP 从目标文件中删除符号表信息 NM 列出目标文件的符号表中定义的符号 SIZE 列出目标文件中节的名字和大小 READELF 显示目标文件的完整结构，ELF头信息 OBJDUMP 所有二进制工具，反汇编 LDD 可执行文件在运行时所需要的共享库 静态和动态链接, 可重定位的、可执行的和共享的 可重定位的和可执行的目标文件、符号解析、重定位、静态库、 共享目标库、 位置无关代码，以及库打桩 链接器的两个主要任务是符号解析和重定位 链接器生成的目标文件是与一些像加载、虚拟内存和内存映射 加载器将可执行文件的内容映射到内存，并运行这个程序\n第8章 异常控制流ECF 8.1 异常 ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制 应用程序与操作系统交换通过陷阱(trap)或系统(system call)的ECF形式 异常处理通过非本地跳转响应错误，C通过setjmp和longjmph函数 状态变化称为事件(event),处理器检测到事件发生，通过异常表(存储异常号)的跳转表，进行间接过程调用，跳转到操作系统子程序(异常处理程序(exception handler))。异常表的起始地地址放在叫做异常表基址寄存器(exception table base register)的特殊CPU寄存器 异常不同于调用：调用返回地址压入栈，异常返回地址位当前指令或下一条指令；额外压入处理器状态到栈；如控制转移到内核，则压入内核栈；异常程序运行在内核模式 异常分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort) 陷阱用在用户程序和内核之间的系统调用，用户程序向内核请求服务，如读文件(read)、创建进程(fork)、加载程序(execve)和终止进程(exit)等，syscall n 指令 故障示例缺页异常 linux/x85-64异常 C程序用 syscall 函数可以直接调用任何系统调用，通常通过包装函数(系统级函数)使用 寄存 %rax 包含系统调用号,寄存器%rdi，%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。 8.2 进程 进程一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文(context)中 PC值的序列叫逻辑控制流，一个逻辑流在时间上与另一个流重叠，称为并发流，并发运行 并发多个流并发执行；多任务进程轮流运行；时间片\n进程私有地址空间\n代码段总是从地址 0x400000 开始,地址空间顶部保留给内核(操作系统常驻内存的部分)\n处理器通常是用某个控制寄存器中的一个模式位(mode bit)来确定用户模式和内核模式 linux系统提供 /proc 文件系统，允许用户模式进程访问内核数据结构的内容\n上下文切换(context swtich):通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构\n内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling), 是由内核中称为调度器(scheduler)的代码处理的\n系统调用错误处理Unix 系统级函数遇到错误时,返回-1，设置全局整数变量errno\n8.3 进程控制 获取进程ID\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; pid_t getpid(void); pit_t getppid(void); 进程三种状态\n运行：在 CPU 上执行；或等待被执行且最终会被内核调度 停止：进程的执行被挂起（suspended), 且不会被调度。收到SIGSTOP、SIGTSTP、SIGYTTIN或SIGTTOU信号，进程停止，直到收到SIGCONT信号，再次运行 终止：进程会因为三种原因终止：1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用 exit 函数 #include \u0026lt;stdlib.h\u0026gt; // 以status退出状态终止进程 void exit(int status) #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 创建进程 调用一次返回两次在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0 pid_t fork(void); 回收子进程；内核将子进程的退出状态传递给父进程;如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父.init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; // waitpid 函数来等待它的子进程终止或者停止 pid_t waitpid(pid_t pid, int *statusp, int options); options 设置为常量 WNOHANG、WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为\n#include\u0026lt;unistd.h\u0026gt; // 进程休眠secs秒 unsigned int sleep(unsigned int secs); // 让调用函数休眠 int pause(void); // 加载并运行一个新程序 和fork的区别 ？ int execve(const char *filename, const char *argv[], const char *envp[]); main函数有3个参数：1）argc argv[]数组中非空指针数量 2)argv 指向argv[]数组第一个条目 3) envp 指向envp[]数组中第一个条目\n#include \u0026lt;stdlib.h\u0026gt; char *getenv(const char *name); int setenv(const char *name, const char *newvalue, int overwrite); void unsetenv(const char *name); 8.4 信号 发送信号 每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp函数返回当前进程的进程组 ID:\n#include\u0026lt;unistd.h\u0026gt; pid_t getpgrp(void); // 改变进程所属进程组 int setpgid(pid_t pid, pid_t pgid); /bin/kill 程序向另外i的进程发送任意信号\n# 15213 进程组 /bin/kill -9 -15213 #include\u0026lt;sys/typed.h\u0026gt; #include\u0026lt;signal.h\u0026gt; //调用 kill 函数发送信号给其他进程 int kill(pid_t pid, int sig); #include\u0026lt;unistd.h\u0026gt; // 调用 alarm 函数向它自己发送 SIGALRM 信号 unsigned int alarm(unsigned int secs); 接收信号\n#include\u0026lt;signale.h\u0026gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); Linux 提供阻塞信号的隐式和显式的机制：\n隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。 显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。\n#include\u0026lt;signal.h\u0026gt; int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signum); int sigdelset(sigset_t *set, int signum); int sigismember(const sigset_t *set, int signum); 信号处理程序中产生输出唯一安全的方法是使用 write 函数, printf和spirintf是不安全的\n8.5 非本地跳转 C 语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump)，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列\n#include\u0026lt;setjmp.h\u0026gt; // setjmp 函数在 env 缓冲区中保存当前调用环境 int setjmp(jmp_buf env); int sigsetjmp(sigjmp_buf env, int savesigs); // longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化的 setjmp 调用的返回 void longjmp(jmp_buf env, int retval); void siglongjmp(sigjmp_buf env, int retval); 操作进程工具：\nstrace 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹 ps 列出当前系统中的进程 top 打印出关于当前进程资源使用的信息 pmap 显示进程的内存映射 /proc 虚拟文件系统，输出大量内核数据结构的内容 如：cat /proc/loadavg 异常控制流 系统所有层次的异常控制流 底层的硬件异常和中断 四种异常：中断、陷阱、故障和终止 在操作系统层，内核用 ECF 提供进程的基本概念。 并发进程的上下文切换 进程的基本概念 通过 Linux 系统调用来使用多个进程\n第9章 虚拟内存 虚拟内存提供了三个重要的能力:1)主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域; 2)为每个进程提供了一致的地址空间; 3)保护了每个进程的地址空间不被其他进程破坏 虚拟内存如何工作;使用和管理虚拟内存\n物理地址(PA)和虚拟地址(VA) MMU内存管理单元：地址翻译\n9.1 虚拟内存作为缓存工具 虚拟页面三个状态：未分配的；缓存的；位缓存的 DRAM缓存 页表(page table)，页表将虚拟页映射到物理页；页表是页表条目(Page Table Entry PTE)的数组\n页命中 缺页 DRAM缓存不命中，缺页异常\n磁盘和内存之间传送也叫做交换或页面调度；按需页面调度策略:直到不命中才换入页面\n分配页面 VP分配过程是在磁盘上创建空间并更新PTE，指向磁盘上新创建的页面 局部性保证了程序趋于较小的活动页面上\n9.2 虚拟内存作为内存管理工具 进程页表独立\n简化链接：进程内存映射采用相同的基本格式，linux64中代码段总是从虚拟地址0x400000开始 简化加载：.text和.data节linux加载器分配虚拟页，标记位无效的，加载不从磁盘复制数据，内存映射(memory mapping)：将一组连续虚拟也映射到任意一个文件中的任意位置表示 linux系统调用mmap，应用程序可做内存映射。 简化共享： 简化内存分配：页表方式可分配不连续物理空间 9.3 虚拟内存作为内存保护工具 PTE三个许可标志位：\nSUP 进程是否必须运行在内核(超级用户)模式下才能访问该页 READ 位和 WRITE 位控制对页面的读和写访问 9.4 地址翻译 TLB加速地址翻译： MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器(Translation Lookaside Buffer, TLB) TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块 多级页表 Core i7内存系统\nLinux 虚拟内存系统 内核为系统中的每个进程维护一个单独的任务结构(源代码中的 task_StrUCt),任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行目标文件的 名字，以及程序计数器) Linux 缺页异常处理 MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序\n9.5 内存映射 Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)\nfork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID, 给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的副本\n删除已存在的用户区域、映射私有区域、映射共享区域、设置程序计数器(PC)\nmmap 函数的用户级内存映射\n#include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/mman.h\u0026gt; // Linux 进程使用 mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中 void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); // munmap 函数删除虚拟内存的区域 // munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域 int munmap(void *start, size_t length); 9.6 动态内存分配 mmap 和 munmap 函数来创建和删除虚拟内存的区域，C语言使用动态内存分配器，动态内存分配器维护着一个进程的虚拟内存区 域，称为堆(heap),每个进程，内核维护着一个变量 brk(读break) 它指向堆的顶部。\n显示分配器：c语言malloc free；C++中new和delete 隐式分配器：垃圾收集器GC，Java #include\u0026lt;stdio.h\u0026gt; // malloc 函数从堆中分配块 void *malloc(size_t size); void free(void *ptr); // malloc 可通过使用 mmap 和 munmap 函数，显式地分配和释放堆内存，或者还可以使用 sbrk 函数 #include\u0026lt;unistd.h\u0026gt; void *sbrk(intptr_t incr); 动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小\n管理和操纵虚拟内存 存储分配操作，标准库的 malloc 和 free 操作 存储泄漏和非法指针引用等内存引用错误\n程序间的交互和通信 第10章 系统级 1/() 10.1 输入/输出(I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程 Unix I/O和标准I/O Unix I/O：打开文件、改变单位文件位置、读写文件和关闭文件。 Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准输出(描述符为 1)和标准错误(描述符为 2) Linux 文件: 普通文件、目录、套接字\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/sttat.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; // flags O_RDONYL 只读 O_WRONLY 只写 O_RDWR 可读可写 int open(char *filename, int flags, mode_t mode); #include \u0026lt;unistd.h\u0026gt; // 关闭文件 int close(int fd) #include\u0026lt;unistd.h\u0026gt; // 读写文件 ssize_t read(int fd, void *buf, size_t n); ssize_t write(int fd, const void *buf, size_t n); RIO健壮读写包 https://blog.csdn.net/df12138/article/details/122272107\n读取文件元数据\n#include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/stat.h\u0026gt; int stat(const char *filename, struct stat *buf); int fstat(int fd, struct stat *buf); 读取目录内容\n#include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;dirent.h\u0026gt; DIR *opendir(const char *name); struct dirent *readdir(DIR *dirp); int closedir(DIR *dirp); 共享文件\n描述符表：每个进程有独立描述符表 文件表：所有进程共享 v-node表：所有进程共享 10.2 I/O 重定向 linux\u0026gt; ls \u0026gt; foo.txt #include\u0026lt;unistd.h\u0026gt; int dup2(int oldfd, int newfd); 10.3 标准I/O C语言libc库提供了打开和关闭文件的函数(fopen 和 fclose)、读和写字节的函数(fread 和 fwrite)、读和写字符串的函数(fgets 和 fputs)以及复杂的格式化的 I/O 函数(scanf 和 printf) 标准 I/O 库将一个打开的文件模型化为一个流,一个流就是一个指向 FILE 类型的结构的指针,有三个打开的流 stdin、stdout和 stderr分别对应于标准输人、标准输出和标准错误\nUnix VO 的基本概念 文件和描述符 共享文件，1/O重定向 访问文件的元数据 C 的标准 I/O 库 Linux 内核使用三个相关的数据结构来表示打开的文件 描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项，每个进程都有它自己单独的描述符表，而所有的进程共享同一个打开文件表和 v-node 表 第11章 网络编程 11.1 客户端-服务器 客户端-服务器(CS)模型中的基本操作是事务(transaction) 网络是一种I/O设备， 局域网(LAN)、以太网 IP地址是32位无符号整数\n// IP address struct struc in_addr { uint32_t s_addr; } // 网络字节序是大端字节序 #include\u0026lt;arpa/int.h\u0026gt; uint32_t htonl(unit32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint_16_t netshort); 11.2 因特网 域名 DNS域名集合和 IP 地址集合之间的映射\nnslookup localhost hostname nslookup cs.mit.edu 因特网客户端和服务器通过在连接上发送和接收字节流来通信,客户端套接字地址中的端口是由内核自动分配的 文件/etc/services 包含机器提供的知名名字和知名端口之间的映射 套接字对(socket pair) :—个连接是由它两端的套接字地址唯一确定\n(cliaddr:cliport, servaddr:servport) 11.3 套接字接口 套接字接口(socket interface)是一组函数，和 Unix I/O 函数结合起来，用以创建网络应用 套接字地址结构\nstruct sockaddr_int { uint16_t sin_family; // Protocol family (always AF_INET) uint16_t sin_port; // Port number in network byte order struct in_addr sin_addr; // IP address in network byte order unsigned char sin_zero[8]；// Pad to sizeof(struct sockaddr) } struct sockaddr { uint16_t sa_famliy; // Protocol family char sa_data[14]; // Address data } #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; int socket(int domain, int type, int protocol); int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen); int bind(int sockfd const struct sockaddr *addr, socklen_t addrlen); int listen(int sockfd, int backlog); int accept(int listenfd, struct sockaddr *addr, int *addrlen); getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构 getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串\n11.3 Web服务器 HTTP、HTML\nTINY Web 服务器\n网络是 I/O 设备 客户端-服务器模型 第12章 并发编程 逻辑控制流在时间上重叠称为并发。使用应用级并发的应用程序称为并发程序(concurrent program)。现代操作系统提供 了三种基本的构造并发程序：\n进程：每个逻辑控制流都是一个进程，由内核来调度和维护。进 程有独立的虚拟地址空间。进程间通信(interprocess communication IPC) I/O 多路复用:逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态 线程：线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度 12.1 基于进程的并发编程 创建进程fork、exec和waitpid。并发服务器的法，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。 进程模型：共享文件表，不共享用户地址空间。独立的地址空间使得显式的 IPC(进程间通信)机制。Unix IPC同一台主机上其他进程进行通信的技术，包括管道、先进先出(FIFO)、系统 V 共享内存，以及系统 V 信号量(semaphore)\n12.2 基于I/O多路复用的并发编程 I/O 多路复用(I/O multiplexing)技术,基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序\n#include \u0026lt;sys/select,h\u0026gt; int select(int n, fd_set *fdset, NULL, NULL, NULL); FD_ZERO(fd_set *fdset); /* Clear all bits in fdset */ FD_CLR(int fd, fd.set *fdset); /* Clear bit fd in fdset */ FD_SET(int fd, fd_set *fdset); /* Turn on bit fd in fdset */ FD_ISSET(int fd, fd_set *fdset); /* Is bit fd in fdset on? */ I/O 多路复用可以用做并发事件驱动(event-driven)程序的基础，在事件驱动程序中，某些事件会导致流向前推进。将逻辑流模型化为状态机。一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移是将状态和输人事件映射到状态。每个转移是将一个（输人状态，输人事件）对映 射到一个输出状态。\n12.3 基于线程的并发编程 第一种方法中，为每个流使用单独的进程。内核会自动调度每个进程，而每个进程有它自己的私有地址空间，使得流共享数据很困难。第二种方法中，创建自己的逻辑流，并利用 I/O 多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间 第三种方法：线程(thread)就是运行在进程上下文中的逻辑流.一个进程里同时运行多个线程的程序。线程由内核自动调度。每个线程都有它自己的线程上下文(thread context), 包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。\n每个进程开始生命周期时都是单一线程，这个线程称为主线程(main thread)在某一时刻，主线程创建一个对等线程(peer thread)。线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止\nPosix 线程(Pthreads)是在 C 程序中处理线程的一个标准接口。\n#include\u0026lt;pthread.h\u0026gt; // 创建线程 typedef void *(func)(void*) int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg); // 获线程 ID pthread_t pthread_self(void); // 终止线程 void pthread_exit(void *thread_return); // 终止当前线程 int pthread_cancel(pthread_t tid); // 回收终止线程资源 int pthread_join(pthread_t tid, void **thread_return); // 分离线程 int pthread_detach(pthread_t tid); // 初始化线程 pthread_once_t once_control = PTHREAD_ONCE_INIT; int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); 12.4 多线程程序中的共享变量 线程共享相同的程序变量。一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。寄存器是从不共享的，而虚拟内存总是共享的。 多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：全局变量、本地自动变量、本地静态变量。 用信号量同步线程:信号量 s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V:\n12.5 并发问题 线程安全：函数被称为线程安全的(thread-safe), 当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果\n三种编写并发程序的基本机制（进程、 1/()多路复用和线程） 用 P、 V 信号量操作来实现同步、线程安全和可重人、竞争条件以及死锁等的基本原则\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e[toc]\u003c/p\u003e\n\u003ch1 id=\"深入理解计算机系统\"\u003e深入理解计算机系统\u003c/h1\u003e\n\u003ch2 id=\"第1章-计算机系统\"\u003e第1章 计算机系统\u003c/h2\u003e","title":"深入理解计算机系统"},{"content":"1.cmake简述 CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\nCMake工程简单例子\ncmake_minimum_required(VERSION 3.12) project(myproj) find_package(Poco REQUIRED COMPONENTS Net Util) add_executable(MyExe) target_source(MyExe PRIVATE \u0026#34;main.cpp\u0026#34;) target_link_library(MyExe PRIVATE Poco::Net PocoUtil) target_complie_definition(MyExe PRIVATE std_cxx_14) 2.Target 和围绕 Target 的配置 C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为target，创建命令分别是add_library()和add_executable()。其中链接库的类型又分为很多种，最常用的就是SHARED以及STATIC，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。 指定target的源文件：\ntarget_source(MyLib PRVIATE \u0026#34;main.cpp\u0026#34; \u0026#34;func.cpp\u0026#34;) PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值\n较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp) 命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：\ntarget_source(MyLib PRIVATE ${SRCS}) 配置target时通常还需要指定头文件目录：\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/) 编译时需要的语言特性：\ntarget_compile_features(MyLib PRIVATE std_cxx_14) 编译时的宏定义：\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3) 参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra) 3.Build Specification 和 Usage Requirement C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库 CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。\n一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：\ntarget_compile_features(MyLib PRIVATE cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：\ntarget_compile_features(MyLib PUBLIC cxx_std_14) target_link_libraries(MyLib PRIVATE Boost::Format) 当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可\narget_compile_features(MyLib INTERFACE cxx_std_14) Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，\n4.寻找和使用链接库 C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。 在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。\n4.1 通过 Config file 找到依赖 Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement\nCMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。\n4.2 通过 Find file 找到依赖 对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。\nCMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。 库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake) ${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。 通过 CMake 的find_library和find_path两个命令就可以完成任务：\nfind_library(MPI_LIBRARY NAMES mpi HINTS \u0026#34;${CMAKE_PREFIX_PATH}/lib\u0026#34; ${MPI_LIB_PATH} # 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值 ) find_path(MPI_INCLUDE_DIR NAMES mpi.h PATHS \u0026#34;${CMAKE_PREFIX_PATH}/include\u0026#34; ${MPI_INCLUDE_PATH} # 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值 ) 4.3.find_package 的处理 find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：\n# 要求大版本号为2的SFML库的graphic模块 find_package(SFML 2 COMPONENTS graphics REQUIRED) # SFML提供的target名字为sfml-graphics target_link_libraries(MyEXE PRIVATE sfml-graphics) 5.使用 CMake 来编译 CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：\ncmake --build . 使用\u0026ndash;buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。 对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：\ncmake --build . --config Release 参考链接: cmake https://ukabuer.me/blog/more-modern-cmake/ Makefile ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/cmake/","summary":"\u003ch2 id=\"1cmake简述\"\u003e1.cmake简述\u003c/h2\u003e\n\u003cp\u003e CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\u003c/p\u003e","title":"cmake"},{"content":"一.简单句子分析 英语句子= 主干+修饰成分 分析句子结构: 一个中心 + 两个要点 一个中心: 动词. 句子必须右动词 两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者. 句子的核心是主谓结构\nn个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。\n英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.\n{% pullquote mindmap mindmap-md %}\n英文句子 简单句 主 + 谓 主 + 谓 + 宾 主 + 谓 + 宾 + 宾补 主 + 谓 + 间宾 + 直宾 主 + 系 + 表 复合句 名词性从句 主语从句 宾语从句 同位语从句 表语从句 定语从句 状语从句 时间状语从句 地点状语从句 条件状语从句 结果状语从句 让步状语从句 目的状语从句 特殊句式 强调句 虚拟语气 倒装句 类型 陈述句 祈使句 感叹句 疑问句 {% endpullquote %}\n英语语法从整体上来讲是通过五部分来组成 1、简单句 2、并列句、复合句 3、三大从句 4、特殊句式 5、类型\n补语 补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。 修饰成分 介词短语 从句 非谓语动词 时间状语 论主语的补语，而后将宾语的补语作为一种变形来讨论\n1.1 S + V （主+谓） 句子不可或缺的两部分. 名词/代词/不定式/动名词 + 动词 谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.\n1.2 S + V + C （主+系+表） 主语 +系动词 +表语\n表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。\n系动词包括：\na. be 动词，am, is, are, was, were;\nb. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);\nc. 表变化：become(成为), grow, turn(转变为), go, get, fall;\nd. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).\nappear 显得像是 prove 证实为 become 成为 make 作为\n1.3 S + V + O （主+谓+宾） 主语+谓语+宾语\n谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。\n1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)） 谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。 e.g.,\ngive sb sth = give sth to sb\ntell sb sth = tell sth to sb\n1.5 S + V + O + C（主+谓+宾+宾补） 此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。 主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。\nThere be 句型\nThere be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分\n1.主语：句子所陈述的对象。 2.谓语：主语发出的动作。一般是有动作意义的动词。 3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。 4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。 5. 表语：紧跟系动词后面的成分。 6. 定语：修饰名词或代词的成分。 7. 状语： 修饰形容词、副词、动词或句子的成分。 8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。\n参考链接: https://liam.page/2014/06/21/basic-sentence-and-the-complement/ https://www.zhihu.com/question/30030877/answer/768501967\n参考数据 《语法俱乐部》\n复杂句:从简单句演化而来\n简单句没有什么句序的调整，所以翻译起来基本没有什么难度。\n英语中的修饰成分，分定语和状语两种情况。 英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)\n二、并列句、复合句 简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：\n并列句：简单句+并列词+简单句\n并列词一般有：and / or / but / so /while / yet / for / however\n1）：表示并列：and, not only\u0026hellip;but also\u0026hellip; , neither\u0026hellip;nor\u0026hellip;\nHer father is a doctor and her mother is a teacher .\n2）：表示选择：or, or else, otherwise, either\u0026hellip;or\u0026hellip;\nHurry or you won\u0026rsquo;t make the train.\n3）：表示对比、转折: but, while , yet , however , never ,\nI like tea while she likes coffee .\n4）：表示原因：for\nI am thirsty , for it is hot .\n复合句：简单句+从属连词+简单句\n从属连词有：that / wether/ if\n复合句其实就是我们常说的三大从句，\n三.三大从句 1、名词性从句\n当名词性从句作为句子的不同成分时，又被称呼为不同的名字。\n当作为主语时，称为主语从句。\n当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：\n主语从句 What she said is wrong .\n宾语从句 I said that she was wrong.\n表语从句 The fact is that he doesn’t really try.\n同位语从句 The news that he will come back is ture.\n记住一点，不管什么从句，你把它当成一个”长一点的名词”。\n那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。\n同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。\n2、定语从句\n修饰限定名词，汉语中“的”前面的内容。\n关系代词引导的定语从句\n1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.\n2. whom指人，在定语从句中充当宾语，常可省略。\nMr. Ling is just the boy whom I want to see\n3. which指物，在定语从句中做主语或者宾语，做宾语时可省略\nThis is the pen (which) he bought yesterday.\n4. that指人时，相当于who 或者whom；指物时，相当于which。\n5. whose通常指人，也可指物，在定语从句中做定语。\n指的是谁的。Do you like the book whose cover is yellow?\n关系副词引导的定语从句\nwhen where why\n3、状语从句\n修饰动作的发生的时间、地点、原因、方式\n九大状语从句\n1、时间状语从句\n常用引导词：when, as, while, as soon as, before, after, since , till, until\n特殊引导词：the minute, the moment, the second, every time, the day，the instant,\nI was fat when I was a child.\n2、地点状语从句\n常用引导词：where\n特殊引导词：wherever, anywhere, everywhere\nKeep it where you can see it.\n3、原因状语从句\n常用引导词：because, since, as, for\n特殊引导词：seeing that, now that, in that, considering that, given that.\nMy friends dislike me because I’m beautiful .\n4、目的状语从句\n常用引导词：so that, in order that\n特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that\nstudy hard so that you can pass the exam.\n5、结果状语从句\n常用引导词：so … that, so… that, such … that,\n特殊引导词：such that, to the degree that, to the extent that, to such a degree that,\nHe got up so early that he caught the first bus.\n6、条件状语从句\n常用引导词：if, unless,\n特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that\nIf you ask him, he will help you.\n7、方式状语从句\n常用引导词：as, as if, how\n特殊引导词：the way\nThink as i think\n8、比较状语从句\n常用引导词：as(同级比较), than(不同程度的比较)\n特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B\nThe house is three times as big as ours.\n9、让步状语从句\n常用引导词：though, although, even if, even though\n特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\nThough I believe it, yet I must consider.\n四.特殊句式 1、强调句\nIt is （名词 / 介宾）指的是被强调的内容that （\u0026hellip;\u0026hellip;..）\nIt was she whom we are talking about.\n2、倒装句\n正常句序 ：主谓宾\n倒装句序 ：谓主宾\nwe can win only through hard work .\nonly through hard work can we win .\n3、虚拟语气，假设不可能发生的事情\n1、对过去情况的虚拟\n从句用 had done\n主句用 would could might should have done\n2、对现在情况的虚拟\n从句用 did , was变成were\n主句用 would could might should do\n3、对将来情况虚拟\n从句用 did ，was 变成 were，should do,were to do\n主句用 would could might should do\n五.类型 陈述句\ni like English very much . 我非常喜欢英语。\n疑问句\nis this your key ? 这是你的钥匙吗？\n祈使句\n一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。\nmind you head 小心碰头！\n第二种祈使句以let开头\nLet\u0026rsquo;s have another try\n感叹句\nwhat a brave girl ! 真是个勇敢的女孩子\nhttps://zhuanlan.zhihu.com/p/400448345\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%B8%80/","summary":"\u003ch2 id=\"一简单句子分析\"\u003e一.简单句子分析\u003c/h2\u003e\n\u003cp\u003e \u003cstrong\u003e英语句子= 主干+修饰成分\u003c/strong\u003e\n 分析句子结构:\n  一个中心 + 两个要点\n  一个中心: 动词. 句子必须右动词\n  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.\n  \u003cstrong\u003e句子的核心是主谓结构\u003c/strong\u003e\u003c/p\u003e","title":"英语语法一"},{"content":"hugo运行 hugo -F --cleanDestinationDir 参考链接：\nhttps://www.sulvblog.cn/\nhttps://www.jianshu.com/p/fa95c0c1fdab\nhttps://lishensuo.github.io/\nhttps://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612\nhttps://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38\nhttps://blog.csdn.net/qq_45975757/article/details/108923612\nmongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.6.7\u0026#34;} hexo # 清理缓存 hexo clean # 生成网页 hexo g # 启动本地服务端口 hexo s # 发布到github hexo d # 强制推送备份源码分支 git push -f origin backup GitHub Pages + Hexo使用及配置 github上创建一个 username.github.io 的工程，username 必须为github的用户名\n参考链接 https://www.jianshu.com/p/f82c76b90336\nhttps://www.jianshu.com/p/5d0b31032d55\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\nhttps://theme-next.org/\nhttps://hexo.io/zh-cn/docs/\nhttps://www.jianshu.com/p/3a05351a37dc\nhttps://www.zhyong.cn/posts/ca02/\nhttp://theme-next.iissnan.com/\nhttps://liam.page/\nhttps://liam.page/en/\nHexo博客添加helper-live2d动态模型插件 https://blog.csdn.net/qq_30930805/article/details/ ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/blog/","summary":"hugo运行 hugo -F --cleanDestinationDir 参考链接： https://www.sulvblog.cn/ https://www.jianshu.com/p/fa95c0c1fdab https://lishensuo.github.io/ https://freeze.org.cn/page/7/#main https://blog.csdn.net/qq_45975757/article/details/108923612 https://luckyu.com.cn/index.html?_sw-precache=b052c2fa6d5b2f1a059fb72907f20d38 https://blog.csdn.net/qq_45975757/article/details/108923612 mongodb+srv://twikoo:zhuang738191@cluster0.dzagnuh.mongodb.net/?retryWrites=true\u0026amp;w=majority {\u0026#34;code\u0026#34;:100,\u0026#34;message\u0026#34;:\u0026#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2 完成前端的配置\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34","title":"hexo-\u003ehugo迁移"},{"content":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接：ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334\n安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239\nubuntu 显示 https://ubuntuqa.com/article/8837.html\nhttps://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html\nUbunut 22.04 LTS 版本 GNU/Linux核心\nGCC 11.2.0 binutils 2.38 glibc 2.35 编译工具链\nPython 3.10.4 Perl 5.34.0 LLVM 14 golang 1.18 rustc 1.58 OpenJDK Ruby 3.0 systemd 249.11 OpenSSL 3.0 虚拟化\nqemu 6.2.0 libvirt 8.0.0 virt-manager 4.0.0 # 查看当前目录大小 du -h --max-depth=1 flameshot截图工具 # 快捷方式 flameshot gui https://www.cnblogs.com/kendoziyu/p/how_to_screenshot_in_ubuntu2004.html ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/linuxtool/","summary":"ubuntu 换源 # 备份 cp /etc/apt/sources.list /etc/apt/sources.list.20211013 lsb_release -c lsb_release -a # sudo apt-get update sudo apt-get upgrade 参考链接：ubuntu20.04更改国内镜像源 https://blog.csdn.net/qq_48490728/article/details/124944114 https://blog.csdn.net/weixin_44916154/article/details/124581334 安装搜狗输入法 https://blog.csdn.net/Mr_Sudo/article/details/124874239 ubuntu 显示 https://ubuntuqa.com/article/8837.html https://www.csdn.net/tags/MtTaAgzsNjg5MTk4LWJsb2cO0O0O.html Ubunut 22.04 LTS 版本 GNU/Lin","title":"linuxTool"},{"content":"WSL 安装ubuntu20.04 安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe\n卸载wsl wslconfig /l # 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令 wslconfig /u Ubuntu 参考链接：WSL系列操作：安装，卸载\n设置wsl # 更改默认root用户登录 ubuntu1804.exe config --default-user root # 更改默认登陆目录 # list 中 Ubuntu-20.04 条目中添加 \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu-20.04\u0026#34; # 以管理员权限运行cmd # 停止 net stop LxssManager # 启动 net start LxssManager PowerShell winget search Microsoft.PowerShell winget install Microsoft.PowerShell 参考链接：\nWindows Powershell和Windows Terminal的区别\n安装和设置 Windows 终端\nwindows 包管理工具 winget 官方推出 # 使用 WinGet 安装一遍 winget install postman winget search postman # 卸载，再用 Scoop 安装一遍 scoop install postman choro vcpkg Get started with vcpkg\ncget https://cget.readthedocs.io/en/latest/#\n开源库集成器Vcpkg全教程\nScoop 图床 https://blog.csdn.net/qq_44314954/article/details/122951033\nvscode vscode 上传图片 # 上传剪贴板中的图片到服务器。 ctrl + alt + u # 打开文件浏览器选择图片上传。 ctrl + alt + e https://www.jianshu.com/p/868b3a2028f8 https://zhuanlan.zhihu.com/p/131584831 ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/tool/","summary":"WSL 安装ubuntu20.04 安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe 卸","title":"tool"},{"content":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # 保存退出 wq # 放弃退出 !q # 回到文件首部 gg # 到文件尾部 GG 史上最全的vim快捷键 Vim使用笔记 Windows使用Vim 在Windows系统中，安装git后已经存在vim，找到vim.exe所在目录，添加到环境变量path中即可。 Windows下载 Vim安装 参考博客：在Windows下安装和使用vim PowerVim PowerVim快捷键 ;n # 打开文件目录树显示在屏幕左侧 ;m # 打开当前函数和变量目录树显示在屏幕右侧 ;w # 保存文件 ;u # 向上翻半屏 ;d # 向下翻半屏 ;1 # 光标快速移动到行首 ;2 # 光标快速移动到行末 ;a # 快速切换.h和cpp文件，写C++的时候很方便 ;e # 打开一个新文件 ;z # 切回shell交互命令，输入fg在切回vim，非常实用 ;s # 水平分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;v # 竖直分屏，并打开文件目录选取想打开的文件，如果想新建文件，;e 就好 ;fw # 查找项目内关键字 ;ff # 查找项目内文件名 ;gt # 跳转到变量或者函数定义的地方，前提是安装ctags，并且在在PowerVim输入 ;tg命令 Jump to the definition of the keyword where the cursor is located, but make sure you have make ctags ;gr # 跳回，对应着;gt ;tg # 对当前目录打ctag ;y # 保存当前选中的目录到系统剪切板，前提是vim支持系统剪切板的寄存器 dsfa;w ;h/l/k/j # 光标向左右上下窗口移动，特别是打开多个窗口。使用这个快捷键组合非常实用 ;gg # 按顺序光标跳转各个窗口 # Shortcuts without ; e # 快速删除光标所在的词 tabc # 关闭当前tab，可以用:tabnew来打开一个新的tab Close tab, of course you should :tabnew a file first. F1 # 编译C++代码，自己写的C++例子的时候一键编译。前提手动在当前目录建一个bin文件夹，这是用来存放编译产生的执行文件 gc # 快速注释选中的块（是visual模式下选中的块） gcc # 快速当前行 { # 光标向上移动一个代码块s } # 光标向下移动一个代码块 PowerVim安装及配置 【VIM】PowerVim安装及使用\nPowerVim - 使Vim更加强大易用\n安装PowerVim 问题解决过程记录\nctags ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/vim/","summary":"Vim vim快捷方式 # 编辑模式 i a o # i 进入编辑模式 # 退出ESC 返回命令模式 # 保存退出 wq # 放弃退出 !q # 回到文件首部 gg # 到文件尾部 GG 史上最全的vi","title":"vim"},{"content":"windows 工具软件 Snipaste 截图软件 Sysinternals 支持自定义设置快捷键 Download ZoomIt 屏幕缩放、标记、录制 Sysinternals Download Sysinternals 工具集 Download everyting 快速查找文件 Download 7zip 开源压缩软件 Download Wiztree 磁盘文件占用 Download Windows Terminal \\ 取代传统cmd显示，可集成PowerShell， 登录wsl， 未来Windows将设置为默认终端 微软商店 PowerShell 一款shell，支持Windows、linux、mac，推荐Windows结合 Windows Terminal使用, 使Windows像Linux终端一样爽 Download Q-Dir 多窗口资源管理器 Download \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;未整理部分\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nrustdesk 远程开源软件\nmaya\nimagine\nscreentogif\nditto\nbleachbit\nqbittorrent\ngrammarly\npotplayer https://iptv-org.github.io/iptv/index.m3u\n剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键\n线上思维导图 https://gitmind.cn/app/template 在线文档转换 https://www.aconvert.com/cn/ 开源软件下载网站 https://www.fosshub.com/#\nwindows ternial 添加 git base 到ternial chrome插件 油猴\nwindows输入英文中间有间隙 进入了全角模式，选择半角即可\nReact Router http://react-guide.github.io/react-router-cn/index.html\nyoutube 下载 https://www.ganbey.com/youtube-download-3774\nzlog https://blog.csdn.net/twd_1991/article/details/80481920\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\ngdb https://leetcode-cn.com/circle/article/7mxorv\n","permalink":"https://liuz0123.gitee.io/zain/posts/blog/windowssoftware/","summary":"windows 工具软件 Snipaste 截图软件 Sysinternals 支持自定义设置快捷键 Download ZoomIt 屏幕缩放、标记、录制 Sysinternals Download Sysinternals 工具集 Download everyting 快速查找文件 Download 7zip 开源压缩软件 Download Wiztree 磁盘文件占用 Download Windows Terminal \\ 取代传","title":"WindowsSoftware"},{"content":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04\nWindows\n镜像烧录工具 软碟通UltraISO Ventoy 官方网站 Ventoy支持多个ISO镜像，开源，支持Linux和Windows ventoy详细使用教程 将ISO复制到U盘\nWinPE 支持多镜像 安装系统 小米 F2设置boot密码，重启F12安装Ubuntu\nQ\u0026amp;A 什么功能Windows上有，在Linux没有又没有替代方法 ","permalink":"https://liuz0123.gitee.io/zain/posts/blog/system/","summary":"启动U盘制作 下载镜像 Ubuntu 镜像 Ubuntu 20.04\u0026amp;22.04 Windows 镜像烧录工具 软碟通UltraISO Ventoy 官方网站 Ventoy支持多个ISO镜像，开源，支持Linux和Windo","title":"系统安装"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/movie/movie/","summary":"","title":"Movie"},{"content":" QMD ##《如愿》-王菲 天后依然\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/music/music/","summary":"QMD ##《如愿》-王菲 天后依然","title":"Music"},{"content":"软件故事 1946年 ENIAC\n批处理系统 硬件发展-》 分时系统 机器语言\u0026ndash;纸带 汇编语言\u0026ndash; 指令 操作 Fortran语言 - 第一种高级计算机语言 COBOL 语言 BASIC\n卡耐基 \u0026ndash; 人工智能\nIBM 701 704(Fortran商用) IBM OS/360\n存储时计算机\nUnix c 语言\n欧洲计算机技术： linux 芬兰 万维网 瑞典\nAPPLE II Macish\n微软 收购DOS\nwindows BASIC\n鼠标、 显示器\nC++\nJava Java与互联网\n阿帕奇 IBM linux\n硅谷百年 硅谷 斯坦福、伯克利、圣何塞大学\n特曼\n真空管、晶体管、集成电路 仙童半导体 - 八叛徒 英特尔、AMD、英伟达\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/computerbook/","summary":"\u003ch2 id=\"软件故事\"\u003e软件故事\u003c/h2\u003e\n\u003cp\u003e1946年 ENIAC\u003c/p\u003e\n\u003cp\u003e批处理系统\n硬件发展-》 分时系统\n机器语言\u0026ndash;纸带\n汇编语言\u0026ndash; 指令 操作\nFortran语言 - 第一种高级计算机语言\nCOBOL 语言\nBASIC\u003c/p\u003e","title":"computerbook"},{"content":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使\n《局外人》 加缪 个人主义，无知是最大的邪恶 《culture evolution》 文化的演进 ronald inglehart教授 什么原因猝发个人主义\n《结构性思维》\n","permalink":"https://liuz0123.gitee.io/zain/posts/read/read/readingplan/","summary":"《Lesson from the Edge》 来自边缘的教训\u0026ndash;约瓦诺维奇 前USA驻乌克兰大使 《局外人》 加缪 个人主义，无知是最大的邪恶 《cultur","title":"Reading Plan"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/read/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/","summary":"","title":"闲言碎语"},{"content":"编译 注意wsl中需要root用户编译 https://dynamorio.org/page_building.html cmake \\ -DCMAKE_TOOLCHAIN_FILE=/mnt/e/code/dynamorio/make/toolchain-android=arm64.cmake \\ -DANDROID_TOOLCHAIN=/android_toolchain_using \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio cmake \\ -DDR_COPY_TO_DEVICE=OFF \\ -DCMAKE_BUILD_TYPE=Debug \\ -DBUILD_TESTS=OFF \\ -DBUILD_SAMPLES=ON \\ -DBUILD_CLIENTS=ON \\ ../dynamorio 学习链接 DynamoRIO进阶指南 https://blog.csdn.net/oShuangYue12/article/details/109780166 ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/dynamorio/","summary":"\u003ch2 id=\"编译\"\u003e编译\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e注意wsl中需要root用户编译\n\u003ca href=\"https://dynamorio.org/page_building.html\"\u003ehttps://dynamorio.org/page_building.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_TOOLCHAIN_FILE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/mnt/e/code/dynamorio/make/toolchain-android\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003earm64.cmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DANDROID_TOOLCHAIN\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/android_toolchain_using \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecmake \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DDR_COPY_TO_DEVICE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DCMAKE_BUILD_TYPE\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eDebug \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_TESTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eOFF \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_SAMPLES\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e-DBUILD_CLIENTS\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eON \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e../dynamorio\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"DynamoRIO"},{"content":" 参考博客： https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA 总结 leetcode基础题目 1.两数之和 思路：两层循环\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){ *returnSize = 0; int* res = (int *)malloc(sizeof(int) * 2); for (int i = 0; i \u0026lt; numsSize; i++) { int tmp = target - nums[i]; for (int j = i + 1; j \u0026lt; numsSize; j++) { if (nums[j] == tmp) { res[0] = i; res[1] = j; *returnSize = 2; } } } return res; } 2.两数相加 思路：两个链表，判断链表是否为空，求和不为空链表节点，第一次添加到头节点，之后添加到尾节点，最后判断进位\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) { struct ListNode* head = NULL; struct ListNode* tail = NULL; int carry = 0; while (l1 || l2) { int n1 = l1 ? l1-\u0026gt;val : 0; int n2 = l2 ? l2-\u0026gt;val : 0; int sum = n1 + n2 + carry; if (!head) { head = tail = malloc(sizeof(struct ListNode)); tail-\u0026gt;val = sum % 10; tail-\u0026gt;next= NULL; } else { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = sum % 10; tail = tail-\u0026gt;next; tail-\u0026gt;next = NULL; } carry = sum / 10; if (l1) { l1 = l1-\u0026gt;next; } if (l2) { l2 = l2-\u0026gt;next; } } if (carry \u0026gt; 0) { tail-\u0026gt;next = malloc(sizeof(struct ListNode)); tail-\u0026gt;next-\u0026gt;val = carry; tail-\u0026gt;next-\u0026gt;next = NULL; } return head; } 3. 无重复字符的最长子串 双指针，前后快慢指针，table表标记字符是否出现过，fast标记，slow去除标记，求 fast-slow 最大值\nint lengthOfLongestSubstring(char * s){ int slow = 0; int fast = 0; int len = strlen(s); int table[256] = {0}; int maxLen = 0; // fast从0开始 while (fast \u0026lt; len) { if (table[s[fast]] == 0) { table[s[fast]] = 1; fast++; //} else if (table[s[right]] == 1) { } else { table[s[slow]] = 0; slow++; } maxLen = fmax(maxLen, fast - slow); } return maxLen; } 4. 寻找两个正序数组的中位数 思路：每个数组各自索引，判断大小移动索引，最后判断是奇数还是偶数\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){ int numSize = nums1Size + nums2Size; int* res = (int *)malloc(sizeof(int) * numSize); int half = numSize / 2 + 1; int p1 = 0; int p2 = 0; for (int i = 0; i \u0026lt; half; i++) { int n; if (p1 \u0026lt; nums1Size \u0026amp;\u0026amp; p2 \u0026lt; nums2Size) { n = nums1[p1] \u0026lt; nums2[p2] ? nums1[p1++] : nums2[p2++]; } else if (p1 \u0026lt; nums1Size) { n = nums1[p1++]; } else if (p2 \u0026lt; nums2Size) { n = nums2[p2++]; } res[i] = n; } if (numSize % 2 == 0) { return (res[half - 1] + res[half - 2]) / 2.0; } else { return res[half-1]; } } 6. 字形变换 ","permalink":"https://liuz0123.gitee.io/zain/posts/tech/leetcode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/","summary":"参考博客： https://programmercarl.com/ https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA 总结 leetcode基础题目 1.两数之和 思路：两层循环 int* twoSum(int* nums, int numsSize, int target, int* returnSize){ *returnSize = 0; int* res = (int *)malloc(sizeof(int) * 2); for (int i = 0; i \u0026lt; numsSize; i++) { int tmp = target - nums[i]; for","title":"leetcode基础题目"},{"content":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？\nLinux内核代码下载 Linux kernel官网 https://www.kernel.org/\n解压 linux-5.19.10.tar.xz\ntar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035\ngdb 《100个gdb小技巧》\nkbuild Kbuild: the Linux Kernel Build System Kernel Build System¶\nhttps://www.zhihu.com/question/47039391/answer/2287806626\nELF 开源库 lief\n参考链接： https://blog.csdn.net/GrayOnDream/article/details/124564129\n","permalink":"https://liuz0123.gitee.io/zain/posts/tech/linuxreadtool/","summary":"Linux Kernel阅读工具 需要多久才能看完linux内核源码？ Linux内核代码下载 Linux kernel官网 https://www.kernel.org/ 解压 linux-5.19.10.tar.xz tar -xvf linux-5.19.10.tar.xz https://blog.csdn.net/m0_49328056/article/details/121669035 gdb 《100个gdb小技巧》","title":"Linux Read Tool"},{"content":"","permalink":"https://liuz0123.gitee.io/zain/posts/tech/tech/","summary":"","title":"Tech"},{"content":"\rZain\u0026#39;s Blog\r一个记录技术、阅文、生活的博客\r👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego\n","permalink":"https://liuz0123.gitee.io/zain/links/","summary":"Zain\u0026#39;s Blog 一个记录技术、阅文、生活的博客 👉 越过长城，走向世界 Across the Great Wall we can reach every corner in the world \u0026ndash; 1987.09.14 Chromego","title":"🤝闲言俗语"},{"content":"\n英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 名称： Zain\u0026rsquo;s Blog 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 👉Hugo博客交流群\r787018782\n","permalink":"https://liuz0123.gitee.io/zain/about/","summary":"英文名: zain Lz 职业: 程序员 运动: 跑步、篮球、爬山 名称： Zain\u0026rsquo;s Blog 网址： https://liuz0123.gitee.io/zain 图标： https://liuz0123.gitee.io/zain/img/Q.gif 描述： 一个记录技术、阅读、生活自用博客, hexo To hugo 迁移中 👉Hugo博客交","title":"🙋🏻‍♂️关于"}]