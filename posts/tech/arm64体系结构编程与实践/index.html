<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ARM64体系结构编程与实践 | zain&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内">
<meta name="author" content="
&nbsp;Zain">
<link rel="canonical" href="https://liuz0123.gitee.io/zain/posts/tech/arm64%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/">
<link crossorigin="anonymous" href="/zain/assets/css/stylesheet.6bbe4903eaf247f5c3db656a51fd7b09d982ab42029edfdc123f359e2748dc03.css" integrity="sha256-a75JA&#43;ryR/XD22VqUf17CdmCq0ICnt/cEj81nidI3AM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/zain/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="apple-touch-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="mask-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="ARM64体系结构编程与实践" />
<meta property="og:description" content="第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liuz0123.gitee.io/zain/posts/tech/arm64%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-12T00:21:58&#43;08:00" />
<meta property="article:modified_time" content="2022-07-12T00:21:58&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ARM64体系结构编程与实践"/>
<meta name="twitter:description" content="第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://liuz0123.gitee.io/zain/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "ARM64体系结构编程与实践",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/arm64%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ARM64体系结构编程与实践",
  "name": "ARM64体系结构编程与实践",
  "description": "第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内",
  "keywords": [
    ""
  ],
  "articleBody": "第1章 ARM64体系结构基础 ARMv8体系结构处理器包含31个通用寄存器 AArch64执行状态包含·4个异常等级，EL0~EL3，用户态、内核态、虚拟机、安全态 PSTATE寄存器中NZCV标志：负零进溢 PSTATE寄存器DAIF异常掩码标志位 1.1 ARM简介 ARM体系结构是一种硬件规范，主要约定指令集、芯片内部体系结构 ARMv8体系结构处理器IP Cortex-A53、Cortex-A55、Cortex-A72、Cortex-A77 1.2 ARMv8体系结构基础知识 1.2.1 ARMv8体系结构 ARMv8是64位处理器指令集和体系结构 64位虚拟地址空间，32位仅支持4GB 31个64位宽通用寄存器 支持16KB和64Kb页面，降低TLB未命中率 异常处理模型EL0~EL3 加载-获取指令(Load-Acquire Instruction)，存储-释放指令(Store-Release Instruction) 1.2.2 ARMv8处理器内核 Cortex-A53 Cortex-A57 Cortex-A72 1.2.3 ARMv8体系结构基本概念 ARMv8体系结构基本概念和定义 处理机PE(Processing Element):处理器处理事务过程抽象 执行状态(execution state):处理器运行时环境，包括寄存器位宽、支持指令集、异常模型、内存管理以及编程模型 ARMv8两个执行状态\nAArch64：64位执行状态 31个通用寄存器 64位程序计数(PC)指针寄存器、栈指针(Stack Pointer SP)寄存器及异常链接寄存器(Exception Link Register ELR) A64指令集 ARMv8异常模型，4个异常等级，即EL0~EL3 64位内存模型 一组处理器状态(PSTATE)保存PE状态 AArch32: 32位执行状态 AArch64状态，部分系统寄存器在不同异常等级提供不同变种寄存器\n\u003cregister_name\u003e_ELx // x: 0 1 2 3 1.2.4 A64指令集 ARMv8体系结构64位指令集：处理64位宽寄存器和数据并使用64位指针访问内存\n1.2.5 ARMv8处理器执行状态 AArch64状态异常等级(exception level)确定处理器当前运行的特权级别\nEL0：用户特权 EL1：系统特权，操作系统内核，系统使能虚拟化扩展，运行虚拟操作系统内核 EL2：运行虚拟化扩展的虚拟监控程序(hypervisor) EL3：运行安全世界中安全监控器(secure monitor) 1.2.6 ARMv8数据宽度 字节(byte)：8位 半字(halfword)：16位 字(word)：32位 双字(doubleword)：64位 四字(quadword)：128位 1.3 ARMv8寄存器 1.3.1 通用寄存器 AArch64执行状态支持31个64位通用寄存器，X0~X30寄存器，AArch32状态支持16个32位通用寄存器 AArch64状态下，X表示64位通用寄存器，W表示低32位的数据\n1.3.2 处理器状态 AArch64体系结构使用PSTATE寄存器表示当前处理器状态\n分　类 字　段 描　述 描　述 条件标志位 N 负数标志位。 在结果是有符号的二进制补码的情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0 Z 0标志位。如果结果为0，则Z=1；如果结果不为0，则Z=0 C 进位标志位。当发生无符号数溢出时，C=1。其他情况下，C=0 V 有符号数溢出标志位。\n　对于加/减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1；如果未发生溢出，则V=0。\n　对于其他指令，V通常不发生变化 执行状态控制 SS 软件单步。该位为1，说明在异常处理中使能了软件单步功能 IL 不合法的异常状态 nRW 当前执行状态 　0：处于AArch64状态 　1：处于AArch32状态 执行状态控制 EL 当前异常等级 　0：表示EL0\n　1：表示EL1\n　2：表示EL2\n　3：表示EL3 SP 选择SP寄存器。当运行在EL0时，处理器选择EL0的SP寄存器，即SP_EL0；当处理器运行在其他异常等级时，处理器可以选择使用SP_EL0或者对应的SP_ELn寄存器 异常掩码标志位 D 调试位。使能该位可以在异常处理过程中打开调试断点和软件单步等功能 A 用来屏蔽系统错误（SError） I 用来屏蔽IRQ F 用来屏蔽FIQ 访问权限 PAN 特权模式禁止访问（Privileged Access Never）位是ARMv8.1的扩展特性 　1：在EL1或者EL2访问属于EL0的虚拟地址时会触发一个访问权限错误 　0：不支持该功能，需要软件来模拟 UAO 用户访问覆盖标志位，是ARMv8.2的扩展特性 　1：当运行在EL1或者EL2时，没有特权的加载存储指令可以和有特权的加载存储指令一样访问内存，如LDTR指令\n　0：不支持该功能 1.3.3 特殊寄存器 ARMv8体系结构除31个通用寄存器外，还提供多个特殊寄存器\n1.零寄存器 ARMv8提供两个零寄存器(zero register)，寄存器内部全是0，WZR是32位零寄存器，XZR是64位零寄存器\n2.PC指针寄存器 PC指针寄存器用来存储当前运行指令的下一条指令地址，控制程序中指令的运行顺序，不可直接访问 3.SP寄存器 ARMv8体系结构支持4个异常等级，每个异常等级有专门SP寄存器：SP_EL0、SP_EL1、SP_EL2、SP_EL3 Linux内核使用SP_EL0存放进程中task_struct数据结构指针\n4.备份状态寄存器 运行异常处理程序时，处理器备份程序会保存备份程序状态寄存器(Savaed Program Status Register SPSR)里。当异常发生时，处理器会把PSTATE寄存器的值暂时保存到SPSR里，当异常处理完成并返回时，再把SPSR值恢复到PSTATE寄存器，SPSR字段：\n字　段 描　述 N 负数标志位 Z 零标志位 C 进位标志位 V 有符号数溢出标志位 DIT 与数据无关的指令时序（Data Independent Timing），ARMv8.4的扩展特性 UAO 用户访问覆盖标志位，ARMv8.2的扩展特性 PAN 特权模式禁止访问位，ARMv8.1的扩展特性 SS 表示是否使能软件单步功能。若该位为1，说明在异常处理中使能了软件单步功能 IL 不合法的异常状态 D 调试位。使能该位可以在异常处理过程中打开调试断点和软件单步等功能 A 用来屏蔽系统错误 I 用来屏蔽IRQ F 用来屏蔽FIQ M[4] 用来表示异常处理过程中处于哪个执行状态，若为0，表示AArch64状态 M[3:0] 异常模式 5. ELR ELR存放异常返回地址\n6.CurrentEL寄存器 该寄存器表示PSTATE寄存器中EL字段，保存异常等级，使用MRS指令读取当前异常等级\n7.DAIF寄存器 该寄存器表示PSTATE寄存器中[D、A、I、F]字段\n8.SPSel寄存器 寄存器表示PSTATE寄存器中SP字段，用于在SP_EL0和SP_ELn中选择SP寄存器\n9.PAN寄存器 PAN寄存器表示PSTATE寄存器中PAN字段，通过MSR和MRS指令设置PAN寄存器\n内核态访问用户态内存，主动调用内核接口，如copy_from_user()或copy_to_user() PAN寄存器值： 0：表示内核态可访问用户态内存 1：表示内核态访问用户态内存会触发访问权限异常 10.UAO寄存器 该寄存器表示PSTATE寄存器中UAO(User Access Override 用户访问覆盖)字段，MSR和MRS设置UAO寄存器，1表示EL1和EL2执行非特权指令效果和特权指令一样\n11.NZCV寄存器 PSTATE寄存器中{N, Z, C, V}\n1.3.4 系统寄存器 ARMv8体系结构7类系统寄存器 通用系统控制寄存器 调试寄存器 性能监控寄存器 活动监控寄存器 统计扩展寄存器 RAS寄存器 通用定时寄存器 系统寄存器支持不同的异常等级访问，Reg_ELx MSR和MRS指令访问系统寄存器 mrs x0, TTBR0_EL1 // 把TTBR0_EL1值复制到X0寄存器 msr TTBR0_El1, X0 // 把X0寄存器值复制到TTBR0_EL1 1.4 Cortex-A72处理器介绍 树莓派4B开发板，内置了4个Cortex-A72处理器内核 Cortex-A72处理器支持特性 采用ARMv8体系结构规范来设计，兼容ARMv8.0协议。\n超标量处理器设计，支持乱序执行的流水线。\n基于分支目标缓冲区(BTB)和全局..缓冲区(GHB)\n支持48个表项的全相连指令TLB，可以支持4 KB、64 KB以及1 MB大小的页面。\n支持32个表项的全相连数据TLB，可以支持4 KB、64 KB以及1 MB大小的页面。\n每个处理器内核支持4路组相连的L2 TLB。\n48 KB的L1指令高速缓存以及32 KB的L1数据高速缓存。\n可配置大小的L2高速缓存，可以配置为512 KB、1 MB、2 MB以及4 MB大小。\n基于AMBA4总线协议的ACE（AXI Coherency Extension）或者CHI（CoherentHubInterface）。\n支持PMUv3体系结构的性能监视单元。\n支持多处理器调试的CTI（Cross Trigger Interface）。\n支持GIC（可选）。\n支持多电源域（power domain）的电源管理。\n1.指令预取单元 指令预取单元从L1指令高速缓存中获取指令，每个周期向译码单元最多发送3条指令。支持动态和静态分支预测，指令预取单元功能：\nL1指令高速缓存是一个48 KB大小、3路组相连的高速缓存，每个缓存行的大小为64字节。 支持48个表项的全相连指令TLB，可以支持4 KB、64 KB以及1 MB大小的页面。 带有分支目标缓冲器的2级动态预测器，用于快速生成目标。 支持静态分支预测。 支持间接预测。 返回栈缓冲器。 2.指令译码单元 指令译码单元对A32、T32、A64指令集进行译码 指令译码单元执行寄存器重命名，消除写后写(WAW)和读后写(WAR)实现乱序执行 3.指令分派单元 指令分派单元控制译码后的指令何时被分派到执行管道及返回的结果何时终止，包括ARM核心通用寄存器、SIMD和浮点寄存器\n4.加载/存储单元 加载/存储单元(LSU)执行加载和存储指令，包括L1数据存储系统\n5.L1内存子系统 L1内存子系统包括指令内存系统和数据内存系统 L1指令内存系统包括如下特性 具有48 KB的指令高速缓存，3路组相连映射。 缓存行的大小为64字节。 支持物理索引物理标记（PIPT）。 高速缓存行的替换算法为LRU（Least Recently Used）算法。 L1数据内存系统包括如下特性 具有32 KB的数据高速缓存，两路组相连映射。 缓存行的大小为64字节。 支持物理索引物理标记。 对于普通内存，支持乱序发射、预测以及非阻塞的加载请求访问；对于设备内存，支持非预测以及非阻塞的加载请求访问。 高速缓存行的替换算法为LRU算法。 支持硬件预取。 6.MMU MMU实现虚拟地址到物理地址转换，AArch64支持4KB、16KB、64KB页面 MMMU包括：\n48表项全相连的L1指令TLB 32表项全相连的L1数据TLB 4路组相连L2 TLB TLB支持8位或16位ASID，还支持VMID(虚拟化)\n7.L2内存子系统 L2内存子系统不仅负责处理每个处理器内核的L1指令和数据高速缓存未命中的情况，还通过ACE或者CHI连接到内存系统。其特性 可配置L2高速缓存的大小，大小可以是512 KB、1 MB、2 MB、4 MB。 缓存行大小为64字节。 支持物理索引物理标记。 具有16路组相连高速缓存。 缓存一致性监听控制单元（Snoop Control Unit，SCU）。 具有可配置的128位宽的ACE或者CHI。 具有可选的128位宽的ACP接口。 支持硬件预取。 1.5 ARMv9体系结构 ARMv9体系结构新加入的特性包括： 全新的可伸缩矢量扩展（Scalable Vector Extension version 2，SVE2）计算； 机密计算体系结构（Confidential Compute Architecture，CCA），基于硬件提供的安全环境来保护用户敏感数据； 分支记录缓冲区扩展（Branch Record Buffer Extension，BRBE），它以低成本的方式捕获控制路径历史的分支记录缓冲区； 内嵌跟踪扩展（Embedded Trace Extension，ETE）以及跟踪缓冲区扩展（Trace Buffer Extension，TRBE），用于增强对ARMv9处理器内核的调试和跟踪功能； 事务内存扩展（Transactional Memory Extension，TME） 第2章 搭建树莓派环境 2.1 树莓派 树莓派4B 博通BCM2711芯片 CPU内核：4核 A72 1.5GHz L1缓存： 32KB数据缓存，48KB指令缓存 L2缓存： 1MB GPU： VideoCoreV1核心，500MHz 内存： LPDDR4 两种地址模式：\n低地址模式 35位全地址模式 2.2 搭建树莓派环境 2.2.2 安装树莓派官方OS boot分区包括文件：\nbootcode.bin：引导程序 start4.elf：树莓派4B的GPU固件 start.elf： 树莓派3B的GPU固件 config.txt：配置文件 2.2.4 使用GDB和QEMU虚拟机调试BenOS 2.3 BenOS代码 2.4 QEMU虚拟机与ARM64 QEMU虚拟机与ARM64实验平台，书中Ubuntu20.04 1)安装工具\nsudo apt-get install qemu-system-arm libncurses5-dev gcc-aarch64-linux-gnu build-essential git bison flex libssl-dev # 查看ARM gcc版本 aarch64-linux-gnu-gcc -v 2)下载仓库\ngit clone git@github.com:figozhang/runninglinuxkernel_5.0.git 3)编译内核及创建文件系统 rootfs_arm64.tar.xz文件基于20.04系统的根文件系统创建\n# 编译内核 cd runninglinuxkernel_5.0 ./run_rlk_arm64.sh build_kernel # 编译文件系统 生成rootfs_arm64.ext4根文件系统 cd runninglinuxkernel_5.0 sudo ./run_rlk_arm64.sh build_rootfs 4)运行ARM64版本Linux系统\n./run_rlk_arm64.sh run # root 123 # 或 qemu-system-aarch64 -m 1024 -cpu max,sve=on,sev256=on -M virts 5)在线安装软件包 # 查看网络配置 ifconfig 6)主机和QEMU虚拟机共享文件 cp test.c runninglinuxkernel_5.0/kmodules/ # qemu cd /mnt ls 第3章 A64指令集I —— 加载与存储指令 A64指令特点 3.1 A64指令集介绍 ARMv8体系结构，A64指令集64位指令集，处理64位宽寄存器和数据，并使用64位指针访问内存，A64指令集指令宽度为32位 A64指集分类：\n内存加载和存储指令 多字节内存加载和存储指令 算数和移位指令 移位操作指令 位操作指令 条件操作指令 跳转指令 独占内存访问 内存屏障指令 异常处理指令 系统寄存器访问指令 3.2 A64指令编码 A64指令集指令宽度为32位，第24~28位识别指令分类\nop0字段值\nop0 字段值 说 明 0000x 保留 0010x 可伸缩矢量扩展(SVE)指令 100xx 数据处理指令(立即数) 101xx 分支处理指令、异常处理指令及系统寄存器访问指令 x1x0x 加载与存储指令 x101x 数据处理指令(基于寄存器) x111x 数据处理指令(浮点数与SIMD) 加载与存储指令分类 为什么指令编码宽度是32位？ A64指令集基于寄存器加载和存储体系结构设计，数据加载、存储及处理在通用寄存器中。ARM64一共31个通用寄存器X0~X30，因此在指令编码中使用5位宽，可索引32个通用寄存器 使用寄存器作为基地址，把SP(栈指针)寄存器当做第31个通用寄存器 用作源寄存器操作数时，把XZR当作第31个通用寄存器 3.3 加载与存储指令 ARMv8体系结构基于指令加载和存储体系结构，所有数据处理都通过通用寄存器完成，不能直接在内存中完成 常见内存加载指令是LDR指令，存储指令STR指令\nLDR 目标寄存器, \u003c存储器地址\u003e // 把存储地址中的数据加载到目标寄存器中 STR 源寄存器, \u003c存储器地址\u003e // 把源寄存器数据存储到存储器中 寻 址 模 式 说 明 基地址模式 [Xn] 基地址加偏移量模式 [Xn, #offset] 前变基模式 [Xn, #offset]! 后变基模式 [Xn] #offset PC相对地址模式 \u003c lable\u003e 3.3.1 基于基地址寻址模式 基地址模式寄存器值表示地址，基地址加偏移量模式基地址加上可正可负偏移 1.基地模式 指令以Xn寄存器值为内存地址，加载此内存地址内容到Xt寄存器\nLDR Xt, [Xn] 指令把Xt寄存器中内容存储到Xn寄存器的内存地址中\nSTR Xt, [Xn] ? 2.基地址加偏移量模式 指令把Xn寄存器值加偏移量(offset是8的倍数)，以相加的结果作为内存地址，加载此地址内容到Xt寄存器\n// 偏移量从指令编码imm12字段获取 0~32760B LDR Xt, [Xn, $offset] // 基地址加偏移量存储指令 STR Xt, [Xn, $offset] 3.基地址扩展模式 LDR \u003cXt\u003e, {\u003cXn\u003e, (\u003cXn\u003e){, \u003cextend\u003e {\u003camount\u003e}}} STR \u003cXt\u003e, {\u003cXn\u003e, (\u003cXn\u003e){, \u003cextend\u003e {\u003camount\u003e}}} 3.3.2 变基模式 两种变基模式\n前变基：先更新偏移量地址，后访问内存 后变基：先访问内存地址，后更新偏移量地址 // 前变基模式 LDR \u003cXt\u003e, [\u003cXn|SP\u003e, #\u003csimm\u003e]! STR \u003cXt\u003e, [\u003cXn|SP\u003e, #\u003csimm\u003e]! // 后变基模式 LDR \u003cXt\u003e, [\u003cXn|SP\u003e], #\u003csimm\u003e STR \u003cXt\u003e, [\u003cXn|SP\u003e], #\u003csimm\u003e 3.3.3 PC相对寻址模式 // LDR指令访问标签的地址 LDR \u003cXt\u003e, \u003clabel\u003e 3.3.4 LDR伪指令 // LDR伪指令 LDR Xt, =\u003clabel\u003e // 把label标记的地址加载到Xt寄存器 Linux内核实现重定位伪代码\n// arch/arm64/kernel/head.S __primary_switch: adrp x1, init_pg_dir b1 __enable_mmu // 打开MMU ldr x8, =__primary_switched // 跳转 到链接地址，即内核空间虚拟地址 adrp x0, __PHYS_OFFSET // br x8 ENDPROC(__primary_switch) 3.4 加载与存储指令变种 3.4.1 不同位宽加载与存储指令 LDR、LDRSW、LDRB、LDRSB、LDRH、LDRSH、STRB、STRH\n3.4.2 不可扩展加载与存储指令 LDUR \u003cXt\u003e, [\u003cXn|SP\u003e{, #\u003csimm\u003e}] STUR \u003cXt\u003e, [\u003cXn|SP\u003e{, #\u003csimm\u003e}] 不可扩展LDUR和STUR数据位宽变种\n3.4.3 多字节内存加载与存储指令 A64提供LDP和STP指令\n1.基地址偏移量模式 LDP \u003cXt1\u003e, \u003cXt2\u003e, [\u003cXn|SP\u003e{, #\u003cimm\u003e}] STP \u003cXt1\u003e, \u003cXt2\u003e, [\u003cXn|SP\u003e{, #\u003cimm\u003e}] 2.前变基模式 LDP \u003cXt1\u003e, \u003cXt2\u003e, [\u003cXn|SP\u003e, #\u003cimm\u003e]! STP \u003cXt1\u003e, \u003cXt2\u003e, [\u003cXn|SP\u003e, #\u003cimm\u003e]! 3.后变基模式 LDP \u003cXt1\u003e, \u003cXt2\u003e, [\u003cXn|SP\u003e], #\u003cimm\u003e STP \u003cXt1\u003e, \u003cXt2\u003e, [\u003cXn|SP\u003e], #\u003cimm\u003e 3.4.4 独占内存访问指令 ARMv8体系结构独占内存访问(exclusive memory access)指令，A64指令集LDXR指令尝试在内存总线中申请一个独占访问锁，然后访问一个内存地址。STXR会往LDXR指令申请独占访问内存地址中写入新内容。LDXR和STXR组合实现同步操作，如Linux内核自旋锁 ARMv8多字节多占内存访问指令，LDXP和STXP\n3.4.5 隐含加-获取/存储-释放内存屏障原语 内存屏障原语LDAR和STAR\n3.4.6 非特权访问级别加载和存储指令 3.5 入栈和出栈 栈(stack)后进先出数据结构，保存：\n临时存储数据，如局部变量 参数：参数小于等于8个，用X0~X7通用寄存器传递，超过8个使用栈 栈从高地址向低地址扩展，栈指针(Stack Pointer SP)指向栈顶 // 栈向下扩展16字节 stp x29, x30, [sp, #-16] add sp, sp, #-8 // 释放8字节 add sp, sp, #8 ldp x29, x30, [sp], #16 3.6 MOV指令 MOV指令寄存器直接搬移和立即数搬移\n// 寄存器搬移 MOV \u003cXd|SP\u003e, \u003cXn|SP\u003e // 立即数搬移 MOV \u003cXd\u003e, #\u003cimm\u003e MOVZ \u003cXd\u003e, #\u003cimm16\u003e, LSL #\u003cshift\u003e ORR \u003cXd|SP\u003e, XZR, #\u003cimm\u003e objdump指令查看MOV指令\naarch64-linux-gnu-objdump -s -d -M no-aliases test.o 第4章 A64指令集2 —— 算术与移位指令 N、Z、C、V 4个条件标志位作用 4.1 条件操作码 A64指令集在PSTATE寄存器中有4个条件标志位，N 负数、 Z 零、 C 进位、 V 溢出 4.2 加法和减肥指令 4.2.1 加法 add、adds、adc\n4.2.2 减法 SUB、SUBS\n4.3 CMP指令 A64指令集中 CMP指令内部调用SUBS指令\n// 立即数的CMP指令 CMP \u003cXn|SP\u003e, #\u003cimm\u003e{, \u003cshift\u003e} // 上述等同于 SUBS XZR, \u003cXn|SP\u003e, #\u003cimm\u003e {, \u003cshift\u003e} // 寄存器的CMP指令 CMP \u003cXn|SP\u003e, \u003cR\u003e\u003cm\u003e{, \u003cextend\u003e {#\u003camount\u003e}} // 移位操作的CMP指令 // CMP指令于添加操作后缀 4.4 条件表示位 4.5 移位指令 常见移位指令：\nLSL：逻辑左移，最高位丢弃，最低位补0 LSR：逻辑右移，最高位补0，最低位丢弃 ASR：算术右移，最低位丢弃，最高位按符号位扩展 ROR：循环右移，最低位移到最高位 4.6 位操作指令 两种与操作指令\nAND：按位与操作 ANDS：带条件标志位与操作，影响Z标志位 或操作指令\nORR EOR 异或 位清除操作\nBIC CLZ指令 计算为1的最高位前面有几个零\n4.7 位段操作指令 1.位段插入操作指令 BFI\n2.位段提取操作指令 UBFX\n第5章 A64指令集3 —— 比较指令与跳转指令 RET与ERET 5.1 比较指令 比较指令\nCMP CMN CSEL：条件选择指令 CSET：条件置位指令 CSINC：条件选择并增加指令 5.1.1 CMN指令 CMN指令将一个数与另一个数相反数进行比较\nCMN \u003cXn|SP\u003e, #\u003cimm\u003e{, \u003cshift\u003e} CMN \u003cXN|SP\u003e, \u003cR\u003e\u003cm\u003e{, \u003cextend\u003e {#\u003camount\u003e}} 5.1.2 CSEL指令 // cond为真，返回Xn，为假，返回Xm CSEL \u003cXd\u003e, \u003cXn\u003e, \u003cXm\u003e, \u003ccond\u003e 5.1.3 CSET指令 // cond为真，Xd寄存器为1，否则为0 CSET \u003cXd\u003e, \u003ccond\u003e 5.1.4 CSINC指令 // cond为真，返回Xn寄存器值，否则返回Xm寄存器值 CSINC \u003cXd\u003e, \u003cXn\u003e, \u003cXm\u003e, \u003ccond\u003e 5.2 跳转与返回指令 5.2.1 跳转指令 指 令 描　述 B 跳转指令\nB Lable B.cond 有条件跳转指令\nB.cond Lable BL 带返回值跳转指令\nBL Lable BR 跳转到寄存器指定地址\nBR Xn BLR 跳转到寄存器指定地址\nBLR Xn 5.2.2 返回指令 A64两条返回指令： RET：用于子函数返回，返回地址保存在LR ERET：从当前的异常模式返回，把SPSR内容恢复到PSTATE寄存器中，从ELR中获取跳转地址并返回到该地址，ERET可实现处理器模式切换，如EL1到EL0 5.2.3 比较跳转指令 指 令 描　述 CBZ 比较并跳转指令\nCBZ Xt, Lable CBNZ 比较并跳转指令\nCBNZ Xt, Lable TBZ 测试位并跳转指令\nTBZ R\u003c t\u003e, #imm, lable TBNZ 测试并跳转指令\nTBNZ R\u003c t\u003e， #imm, lable 第6章 A64指令集 —— 其他重要指令 ADR/ADRP与伪指令LDR ADRP指令获取的是与 4KB 对齐的地址 6.1 PC相对地址加载指令 A64指令集PC相对地址加载指令——ADR和ADRP指令\n// ADR 加载当前PC值+-1MB范围内label地址到Xd寄存器 ADR \u003cXd\u003e, \u003clabel\u003e // ADRP 加载当前PC值一段范围内的label地址到Xd寄存器，与label地址按4Kb对齐 // 即偏移量位 -4Gb~4GB ADRP \u003cXd\u003e, \u003clabel\u003e 6.2 LDR与ADRP指令区别 树莓派上电复位后，固件(BOOTROM)把很想加载到0x80000地址处 LDR伪指令加载的是绝对地址，即程序编译是的链接地址。ADR/ADRP指令加载的是当前PC的相对地址(PC relative-address)，即当前PC值加上label的偏移量，理解位当前运行是label的物理地址 6.3 独占内存访问指令 ARMv8体系结构，A64指令集，LDXR指令尝试在内存总线中申请一个独占访问的锁，然后访问一个内存地址。STXR指令会往LDXR指令已经申请的独占访问内存地址宏写入新内容。 6.4 异常处理指令 指 令 描　述 SVC 系统调用指令\nSVC #imm HVC 虚拟化系统调用指令\nHVC #imm SMC 安全监控系统调用指令\nSMC #imm 6.5 系统寄存器访问指令 ARMv8体系结构MRS和MSR指令直接访问寄存器 指 令 描　述 MRS 读取系统寄存器的值到通用寄存器 MSR 更新系统寄存器的值 ARMv8体系结构7类系统寄存器 通用系统控制寄存器(System Control Register SCTLR) 调试寄存器 性能监控寄存器 活动监控寄存器 统计扩展寄存器 RAS寄存器 通用定时寄存器 特殊系统寄存器 描　述 CurrentEL 获取当前系统的异常等级 DAIF 获取和设置PSTATE寄存器中的DAIF掩码 NZCV 获取和设置PSTATE寄存器中的条件掩码 PAN 获取和设置PSTATE寄存器中的PAN掩码 SPSel 获取和设置当前寄存器的SP寄存器 UAO 获取和设置PSTATE寄存器中的UAO掩码 6.6 内存屏障指令 ARMv8体系结构是弱一致性内存模型，内存访问次序可能和程序预取顺序不一样\n指 令 描　述 DMB 数据存储屏障，确保在执行新的存储访问前所有存储器访问都已完成 DSB 数据同步屏障，确保在下一个指令执行前所有存储器访问都已完成 ISB 指令同步屏障，清空流水线，确保在执行新的指令前，之前所有指令都已完成 新的加载和存储指令\n指 令 描　述 LDAR 加载-获取(laod-acquire)指令 LDAR指令后面的读写内存指令必须在LDAR指令之前执行 STLR 存储-释放(store-release)指令 所有的加载和存储指令必须在STLR指令之前完成 第7章 A64指令集的陷阱 7.1 加载宏标签 ARMv8体系结构，在没有使能MMU情况下，访问内存地址变成访问设备类型的内存(device memory)。内存类型分为普通类型内存和设备类型内存 对设备类型内服访问发起不对齐访问，会触发对齐异常 系统MMU使能后，访问内存变成了访问普通类型内存，对普通类型内存发起一个不对齐访问，分为两种情况\n当SCTLR_ELx寄存器的A字段为1时，触发一个对齐异常 当SCTLR_ELx寄存器的A字段为0时，系统自动完成不对齐访问 7.2 加载字符串 7.3 读写寄存器导致树莓派死机 7.4 LDXR指令导致水平4B死机 7.5 在汇编中实现串口输出功能 7.6 纷享Linux5.0的启动汇编代码 Linux内核入口函数stext，在arch/arm64/kernel/haed.S汇编文件中实现。系统上电复位后，启动引导程序(bootloader)或BIOS初始化，最终跳转到Linux内核入口函数stext汇编函数，启动引导程序必要初始化，如内存设备初始化、磁盘设备初始化以及将内核镜像加载到运行地址，然后跳转到Linux内核入口。 内核汇编入口到C语言入口start_kernel()函数之间的汇编代码\n第8章 GNU汇编器 汇编器 符号 伪指令 kernel_ventry宏 汇编代码同汇编器生成目标代码，然后由连接器链接成可执行二进制程序 ARM64汇编器：1）ARM公司汇编器，2）GNU项目AS汇编器 aarch64-linux-gnu，级汇编后文件Wieaarch64体系结构 8.1 编译流程与ELF文件 GCC编译流程： 1）预处理(pre-process)，GCC预处理器(cpp)，生成 *.i 文件 2）编译(compile)，C语言编译器(ccl)，对预处理文件进行词法、语法分析及语义分析 3）汇编(assemble)，汇编器(as)把汇编代码翻译成机器语言，并生成可重定位目标文件 4）链接(link)，连接器(ld)把所有生成可重定位目标文件以及用到的库文件综合成可执行二进制文件 gcc -E text.c -o text.i gcc -S text.i -o text.s as test.s -o test.o ld -o test test.o -lc ELF格式，待补充链接 ld --version 链接器在链接过程中对所有输入可重定位目标文件的符号表进行符号解析和重定位，每个符号在输出文件的相应段中得到一个确定的地址，最终生成一个符号表(symbol table) 8.2 汇编程序 # -o 输出二进制 -Map 输出符号表 -lc 链接libc库 ld test.o -o test -Map test.map -lc # 获取程序符号表 -s 显示符号表内容 readelf -s test 8.3 汇编语法 汇编代码注释 单行 # 或 // ，多行 /* */ 符号可表示地址、变量或函数 全局符号：使用global声明 本地符号：在本地汇编代码中引用 本地标签：供汇编器和程序员临时使用 8.4 常用伪指令 伪指令仅在汇编器编译期间起作用 .align 对齐伪指令 数据定义伪指令 函数相关伪指令 段相关伪指令 .section 伪指令 宏相关伪指令 8.5 AArch64依赖特性 AArch64特有命令行选项 第9章 链接器与链接脚本 链接器LD 链接脚本 加载地址、虚拟地址和链接地址 位置无关代码 重定位、Uboot重定位、打开MMU后重定位 9.1 链接器 链接器把目标文件(包括标准库函数目标文件)的代码段、数据段及符号表等内容按照某种格式(ELF)组合成一个可执行二进制文件 链接器使用链接脚本(Linker Script LS)语言，链接脚本把二进制文件.o，综合成可执行二进制文件 ld -o mytest test1.o test2.o -lc ld命令选项 9.3 链接脚本 链接器使用-T参数指定链接脚本，不指定使用内置链接脚本 9.2.1 链接程序 可执行程序由代码段、数据段、未初始化数据段。 Linux内置链接脚本是vmlinux.lds.S文件 SECTIONS { . = 0X10000; .text : { *{.text} } . = 0x8000000; .data : { *{.data} } .bss : { *{.bss} } } 9.2.2 设置入口点 ENTRY(symbol) 9.2.3 输出段和输入段包括段的名字、大小、可加载属性及可分配属性。可加载属性用于在运行是加载这些段内容到内存中，可分配属性用于在内存中预留一个区域，并不会加载这个区域内容 链接脚本关于段地址：加载地址和虚拟地址，加载地址是加载时段所在的地址，运行地址是虚拟地址是运行是所在的地址。通常两个地址相同的，不同情况是代码段被加载到ROM中，在程序启动是被复制到RAM中，即 ROM地址是加载地址，RAM地址是虚拟地址 9.2.7 常用内建函数 链接脚本语言包含内建函数 1.ABSOLUTE(exp) 2.ADDR(section) 3.ALIGN(align) 4.SIZEOF(section) 9.3 重定位 加载地址：存储代码的物理地址，GNU链接脚本里为LMA 运行地址：程序运行时地址，GNU链接脚本里为VMA 链接地址：在编译、链接时指定的地址，使用aarch64-linux-gnu-objdump工具进行反汇编时查看的就是链接地址 9.3.1 BenOS重定位 9.3.2 UBoot和Linux内核重定位 // linux5.0/arch/arm64/kernel/head.S __primary_switch; adrp\tx1, init_pg_dir bl\t__enable_mmu ldr x8, =__primary_switched adrp\tx0, __PHY_OFFSET br\tx8 第10章 GCC内嵌汇编代码 内嵌汇编代码关键字asm、volatile、inline及goto 内嵌汇编代码输出部分 = 和 + 内嵌汇编代码输出部分和输入部分的参数 内嵌汇编代码 # 和 ## 10.1 内嵌汇编代码基本用法 内嵌汇编代码两种形式： 基础内嵌汇编代码，不带参数 扩展内嵌汇编代码，可带输入/输出参数 10.1.1 基础内嵌汇编代码 asm { \"汇编指令\" } 10.1.2 扩展内嵌汇编代码 asm 修饰词( 指令部分 : 输出部分 : 输入部分 : 损坏部分) 常用修饰符: volatile：关闭GCC优化 inline：内联，GCC把汇编代码编译为尽可能短的代码 goto：跳转到C语言标签 10.1.3 内嵌汇编代码的修饰符和约束符 10.1.4 使用汇编符号名 10.1.5 内嵌汇编函数与宏结合 10.1.6 使用goto修饰符 第11章 异常处理 ARM64处理器，异常类型 ARM64处理器异常等级 同步异常和异步异常 ARM64处理器异常发生后CPU处理 LR和ELR返回地址 11.1 异常处理基本概念 ARMv8体系结构中，异常和中断都属于异常处理\n11.1.1 异常类型 1.中断 ARM64处理器中，中断请求分成普通中断请求(Interrupt Request IRQ)和快速中断请求(Fast Interrupt Request FIQ)\n2.中止 中止主要有指令中止(Instruction abort)和数据中止(data abort)两种，指访问内存地址发生错误(如缺页)，处理器内部的MMU捕获这些错误并且报告给处理器，指令中止是指当前处理器尝试执行某条指令时发生错误，数据中止指使用加载或存储指令读写外部存储单元发生错误 3.复位 复位(reset)，由CPU复位引脚产生复位信号，让CPU进入复位状态，并重新启动 4.系统调用 ARMv8体系结构提供3中软件尝试的异常和3种系统调用\nSVC指令：用户态程序请求操作系统内核的服务 HVC指令：客户操作系统(guest OS)请求虚拟机监控器(hypervisor)的服务 SMC指令：普通世界中的程序请求安全监控器(secure monitor) 11.1.2 异常等级 处理器两种运行模式：一种是特权模式，另一种是非特权模式，操作系统内核运行在特权模式 ARM64处理器支持4种特权模式，异常等级(Exception Level EL)：\nEL0 非特权模式，运行应用程序 EL1 特权模式，运行操作系统内核 EL2 运行虚拟化管理程序 EL3 运行安全世界的管理程序 11.1.3 同步异常和异步异常 异常分成同步异常和异步异常两种，同步异常是处理器执行某条指令而直接导致的异常，指令异常和数据异常为同步异常 中断称为异步异常 异步异常包括物理中断和虚拟中断：\n物理中断分为3种：SError、IRQ、FIQ 虚拟中断分为3种：VSError、vIRQ、vFIQ 11.2 异常处理与返回 11.2.1 异常入口 CPU内核感知异常发生，生成一个目标异常等级，CPU会做： 1）把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx中 2）把返回地址保存到对应目标异常等级的ELR_ELx中 3）把PSTATE寄存器中D、A、I、F标志位置为1，禁止中断 4）对于同步异常，分析异常原因，写入ESR_ELx 5）切换SP寄存器为目标异常等级的SP_ELx寄存器 6）从异常现场的异常等级切换到对应的目标异常等级，然后跳转到异常向量表 11.2.2 异常返回 操作系统系统处理完后，执行一条ERET指令从异常返回，指令执行如下操作： 1）从ELR_ELx中恢复PC指针 2）从SPSR_ELx中恢复PSTATE寄存器的状态 11.2.3 异常返回地址 两个寄存器存放不同返回地址： 1）X30寄存器(LR)，存放子函数的返回地址，函数完成调用RET指令返回父函数 2）ELR_ELx，存放异常返回地址，执行ERET指令返回异常现场 11.2.4 异常处理路由 异常处理路由指的是当异常发生时应该在哪个异常等级处理\n11.2.5 栈选择 ARMv8体系结构，每个异常等级都有对应的栈指针(SP)寄存器，通过SPSel寄存器配置SP，SPSel寄存器SP字段0，EL使用SP_EL0作为栈指针，1表示SP_ELx作为栈指针寄存器 栈必须16字节对齐\n11.2.6 异常处理的执行状态 11.2.7 异常返回的执行状态 SPSR决定ERET指令返回是不是切换执行模式\n11.3 异常向量表 11.3.1 ARMv8异常向量表 异常相关处理指令存储在内存中，存储位置为异常向量，ARM体系结构中，异常向量存储到一个异常向量表中\n地 址 异 常 类 型 描　述 + 0x000 同步 使用SP_EL0执行状态的当前异常等级 + 0x080 IRQ/vIRQ + 0x100 FIQ/vFIQ + 0x180 SError/vSError + 0x400 同步 在AArch64执行状态下的低异常等级 + 0x480 IRQ/vIRQ + 0x500 FIQ/vFIQ + 0x580 SError/vSError + 0x600 同步 在AArch32执行状态下的低异常等级 + 0x680 IRQ/vIRQ + 0x700 FIQ/vFIQ + 0x780 SError/vSError 11.3.2 Linux5.0 内核的异常向量表 Linux5.0 内核异常向量表在arch/arm64/kernel/entry.S\n\u003carch/arm64/kernel/entry.S\u003e 11.3.3 VBAR_ELx ARMv8体系结构中VBAR_ELx寄存器来设置异常向量表地址 ARMv8体系结构异常向量表特点： 1）除EL0外，每个EL都有自己的异常向量表 2）异常向量表基地址设置到VBAR_ELx中 3）异常向量表起始地址必须以2KB字节对齐 4）每个表项存放32条指令，共128字节 11.4 异常现场 ARM64处理器异常现场，需要在栈空间保存： 1）PSTATE寄存器的值 2）PC值 3）SP值 4）X0~X30寄存器的值 这个栈空间指发生异常时进程的内核态的栈空间 11.5 同步异常 ARMv8体系结构中一个访问失效相关寄存器–异常综合信息寄存器(Exception Syndrome Register ESR)\n11.5.1 异常类型 11.5.2 数据异常 第 12 章 中断处理 中断处理一般过程 中断现场 参考文档 ARM Architecture Reference Manual Supplement®ARMv8.1, for ARMv8-A architecture profile\nARM Cortex -A Series®®Version: 1.0 Programmer’s Guide for ARMv8-A\nARM® Cortex®-A72 MPCore Processor Revision: r0p3 Technical Reference Manual\n",
  "wordCount" : "12934",
  "inLanguage": "en",
  "datePublished": "2022-07-12T00:21:58+08:00",
  "dateModified": "2022-07-12T00:21:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Zain"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://liuz0123.gitee.io/zain/posts/tech/arm64%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zain's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://liuz0123.gitee.io/zain/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://liuz0123.gitee.io/zain/" accesskey="h" title="Zain&#39;s Blog (Alt + H)">
            <img src="https://liuz0123.gitee.io/zain/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">Zain&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://liuz0123.gitee.io/zain/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/links" title="🤝 闲言俗语">
                <span>🤝 闲言俗语</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://liuz0123.gitee.io/zain/">主页</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                ARM64体系结构编程与实践
            </h1>
            <div class="post-meta">Create:&nbsp;<span title='2022-07-12 00:21:58 +0800 CST'>2022-07-12</span>&nbsp;|&nbsp;Update:&nbsp;2022-07-12&nbsp;|&nbsp;Words:&nbsp;12934&nbsp;|&nbsp;&nbsp;26 min&nbsp;|&nbsp;
&nbsp;Zain



                &nbsp;|&nbsp;tags: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://liuz0123.gitee.io/zain/tags/arm/">ARM</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| Viewers: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%ac%ac1%e7%ab%a0-arm64%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%80" aria-label="第1章 ARM64体系结构基础">第1章 ARM64体系结构基础</a><ul>
                        
                <li>
                    <a href="#11-arm%e7%ae%80%e4%bb%8b" aria-label="1.1 ARM简介">1.1 ARM简介</a></li>
                <li>
                    <a href="#12-armv8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="1.2 ARMv8体系结构基础知识">1.2 ARMv8体系结构基础知识</a><ul>
                        
                <li>
                    <a href="#121-armv8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" aria-label="1.2.1 ARMv8体系结构">1.2.1 ARMv8体系结构</a></li>
                <li>
                    <a href="#122-armv8%e5%a4%84%e7%90%86%e5%99%a8%e5%86%85%e6%a0%b8" aria-label="1.2.2 ARMv8处理器内核">1.2.2 ARMv8处理器内核</a></li>
                <li>
                    <a href="#123-armv8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="1.2.3 ARMv8体系结构基本概念">1.2.3 ARMv8体系结构基本概念</a></li>
                <li>
                    <a href="#124-a64%e6%8c%87%e4%bb%a4%e9%9b%86" aria-label="1.2.4 A64指令集">1.2.4 A64指令集</a></li>
                <li>
                    <a href="#125-armv8%e5%a4%84%e7%90%86%e5%99%a8%e6%89%a7%e8%a1%8c%e7%8a%b6%e6%80%81" aria-label="1.2.5 ARMv8处理器执行状态">1.2.5 ARMv8处理器执行状态</a></li>
                <li>
                    <a href="#126-armv8%e6%95%b0%e6%8d%ae%e5%ae%bd%e5%ba%a6" aria-label="1.2.6 ARMv8数据宽度">1.2.6 ARMv8数据宽度</a></li></ul>
                </li>
                <li>
                    <a href="#13-armv8%e5%af%84%e5%ad%98%e5%99%a8" aria-label="1.3 ARMv8寄存器">1.3 ARMv8寄存器</a><ul>
                        
                <li>
                    <a href="#131-%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8" aria-label="1.3.1 通用寄存器">1.3.1 通用寄存器</a></li>
                <li>
                    <a href="#132-%e5%a4%84%e7%90%86%e5%99%a8%e7%8a%b6%e6%80%81" aria-label="1.3.2 处理器状态">1.3.2 处理器状态</a></li>
                <li>
                    <a href="#133-%e7%89%b9%e6%ae%8a%e5%af%84%e5%ad%98%e5%99%a8" aria-label="1.3.3 特殊寄存器">1.3.3 特殊寄存器</a><ul>
                        
                <li>
                    <a href="#1%e9%9b%b6%e5%af%84%e5%ad%98%e5%99%a8" aria-label="1.零寄存器">1.零寄存器</a></li>
                <li>
                    <a href="#2pc%e6%8c%87%e9%92%88%e5%af%84%e5%ad%98%e5%99%a8" aria-label="2.PC指针寄存器">2.PC指针寄存器</a></li>
                <li>
                    <a href="#3sp%e5%af%84%e5%ad%98%e5%99%a8" aria-label="3.SP寄存器">3.SP寄存器</a></li>
                <li>
                    <a href="#4%e5%a4%87%e4%bb%bd%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8" aria-label="4.备份状态寄存器">4.备份状态寄存器</a></li>
                <li>
                    <a href="#5-elr" aria-label="5. ELR">5. ELR</a></li>
                <li>
                    <a href="#6currentel%e5%af%84%e5%ad%98%e5%99%a8" aria-label="6.CurrentEL寄存器">6.CurrentEL寄存器</a></li>
                <li>
                    <a href="#7daif%e5%af%84%e5%ad%98%e5%99%a8" aria-label="7.DAIF寄存器">7.DAIF寄存器</a></li>
                <li>
                    <a href="#8spsel%e5%af%84%e5%ad%98%e5%99%a8" aria-label="8.SPSel寄存器">8.SPSel寄存器</a></li>
                <li>
                    <a href="#9pan%e5%af%84%e5%ad%98%e5%99%a8" aria-label="9.PAN寄存器">9.PAN寄存器</a></li>
                <li>
                    <a href="#10uao%e5%af%84%e5%ad%98%e5%99%a8" aria-label="10.UAO寄存器">10.UAO寄存器</a></li>
                <li>
                    <a href="#11nzcv%e5%af%84%e5%ad%98%e5%99%a8" aria-label="11.NZCV寄存器">11.NZCV寄存器</a></li></ul>
                </li>
                <li>
                    <a href="#134-%e7%b3%bb%e7%bb%9f%e5%af%84%e5%ad%98%e5%99%a8" aria-label="1.3.4 系统寄存器">1.3.4 系统寄存器</a></li></ul>
                </li>
                <li>
                    <a href="#14-cortex-a72%e5%a4%84%e7%90%86%e5%99%a8%e4%bb%8b%e7%bb%8d" aria-label="1.4 Cortex-A72处理器介绍">1.4 Cortex-A72处理器介绍</a><ul>
                        <ul>
                        
                <li>
                    <a href="#1%e6%8c%87%e4%bb%a4%e9%a2%84%e5%8f%96%e5%8d%95%e5%85%83" aria-label="1.指令预取单元">1.指令预取单元</a></li>
                <li>
                    <a href="#2%e6%8c%87%e4%bb%a4%e8%af%91%e7%a0%81%e5%8d%95%e5%85%83" aria-label="2.指令译码单元">2.指令译码单元</a></li>
                <li>
                    <a href="#3%e6%8c%87%e4%bb%a4%e5%88%86%e6%b4%be%e5%8d%95%e5%85%83" aria-label="3.指令分派单元">3.指令分派单元</a></li>
                <li>
                    <a href="#4%e5%8a%a0%e8%bd%bd%e5%ad%98%e5%82%a8%e5%8d%95%e5%85%83" aria-label="4.加载/存储单元">4.加载/存储单元</a></li>
                <li>
                    <a href="#5l1%e5%86%85%e5%ad%98%e5%ad%90%e7%b3%bb%e7%bb%9f" aria-label="5.L1内存子系统">5.L1内存子系统</a></li>
                <li>
                    <a href="#6mmu" aria-label="6.MMU">6.MMU</a></li>
                <li>
                    <a href="#7l2%e5%86%85%e5%ad%98%e5%ad%90%e7%b3%bb%e7%bb%9f" aria-label="7.L2内存子系统">7.L2内存子系统</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#15-armv9%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" aria-label="1.5 ARMv9体系结构">1.5 ARMv9体系结构</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac2%e7%ab%a0-%e6%90%ad%e5%bb%ba%e6%a0%91%e8%8e%93%e6%b4%be%e7%8e%af%e5%a2%83" aria-label="第2章 搭建树莓派环境">第2章 搭建树莓派环境</a><ul>
                        
                <li>
                    <a href="#21-%e6%a0%91%e8%8e%93%e6%b4%be" aria-label="2.1 树莓派">2.1 树莓派</a></li>
                <li>
                    <a href="#22-%e6%90%ad%e5%bb%ba%e6%a0%91%e8%8e%93%e6%b4%be%e7%8e%af%e5%a2%83" aria-label="2.2 搭建树莓派环境">2.2 搭建树莓派环境</a><ul>
                        
                <li>
                    <a href="#222-%e5%ae%89%e8%a3%85%e6%a0%91%e8%8e%93%e6%b4%be%e5%ae%98%e6%96%b9os" aria-label="2.2.2 安装树莓派官方OS">2.2.2 安装树莓派官方OS</a></li>
                <li>
                    <a href="#224-%e4%bd%bf%e7%94%a8gdb%e5%92%8cqemu%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%b0%83%e8%af%95benos" aria-label="2.2.4 使用GDB和QEMU虚拟机调试BenOS">2.2.4 使用GDB和QEMU虚拟机调试BenOS</a></li></ul>
                </li>
                <li>
                    <a href="#23-benos%e4%bb%a3%e7%a0%81" aria-label="2.3 BenOS代码">2.3 BenOS代码</a></li>
                <li>
                    <a href="#24-qemu%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%8earm64" aria-label="2.4 QEMU虚拟机与ARM64">2.4 QEMU虚拟机与ARM64</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac3%e7%ab%a0-a64%e6%8c%87%e4%bb%a4%e9%9b%86i--%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4" aria-label="第3章 A64指令集I —— 加载与存储指令">第3章 A64指令集I —— 加载与存储指令</a><ul>
                        
                <li>
                    <a href="#31-a64%e6%8c%87%e4%bb%a4%e9%9b%86%e4%bb%8b%e7%bb%8d" aria-label="3.1 A64指令集介绍">3.1 A64指令集介绍</a></li>
                <li>
                    <a href="#32-a64%e6%8c%87%e4%bb%a4%e7%bc%96%e7%a0%81" aria-label="3.2 A64指令编码">3.2 A64指令编码</a></li>
                <li>
                    <a href="#33-%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4" aria-label="3.3 加载与存储指令">3.3 加载与存储指令</a><ul>
                        
                <li>
                    <a href="#331-%e5%9f%ba%e4%ba%8e%e5%9f%ba%e5%9c%b0%e5%9d%80%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f" aria-label="3.3.1 基于基地址寻址模式">3.3.1 基于基地址寻址模式</a><ul>
                        
                <li>
                    <a href="#1%e5%9f%ba%e5%9c%b0%e6%a8%a1%e5%bc%8f" aria-label="1.基地模式">1.基地模式</a></li>
                <li>
                    <a href="#2%e5%9f%ba%e5%9c%b0%e5%9d%80%e5%8a%a0%e5%81%8f%e7%a7%bb%e9%87%8f%e6%a8%a1%e5%bc%8f" aria-label="2.基地址加偏移量模式">2.基地址加偏移量模式</a></li>
                <li>
                    <a href="#3%e5%9f%ba%e5%9c%b0%e5%9d%80%e6%89%a9%e5%b1%95%e6%a8%a1%e5%bc%8f" aria-label="3.基地址扩展模式">3.基地址扩展模式</a></li></ul>
                </li>
                <li>
                    <a href="#332-%e5%8f%98%e5%9f%ba%e6%a8%a1%e5%bc%8f" aria-label="3.3.2 变基模式">3.3.2 变基模式</a></li>
                <li>
                    <a href="#333-pc%e7%9b%b8%e5%af%b9%e5%af%bb%e5%9d%80%e6%a8%a1%e5%bc%8f" aria-label="3.3.3 PC相对寻址模式">3.3.3 PC相对寻址模式</a></li>
                <li>
                    <a href="#334-ldr%e4%bc%aa%e6%8c%87%e4%bb%a4" aria-label="3.3.4 LDR伪指令">3.3.4 LDR伪指令</a></li></ul>
                </li>
                <li>
                    <a href="#34-%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4%e5%8f%98%e7%a7%8d" aria-label="3.4 加载与存储指令变种">3.4 加载与存储指令变种</a><ul>
                        
                <li>
                    <a href="#341-%e4%b8%8d%e5%90%8c%e4%bd%8d%e5%ae%bd%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4" aria-label="3.4.1 不同位宽加载与存储指令">3.4.1 不同位宽加载与存储指令</a></li>
                <li>
                    <a href="#342-%e4%b8%8d%e5%8f%af%e6%89%a9%e5%b1%95%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4" aria-label="3.4.2 不可扩展加载与存储指令">3.4.2 不可扩展加载与存储指令</a></li>
                <li>
                    <a href="#343-%e5%a4%9a%e5%ad%97%e8%8a%82%e5%86%85%e5%ad%98%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4" aria-label="3.4.3 多字节内存加载与存储指令">3.4.3 多字节内存加载与存储指令</a><ul>
                        
                <li>
                    <a href="#1%e5%9f%ba%e5%9c%b0%e5%9d%80%e5%81%8f%e7%a7%bb%e9%87%8f%e6%a8%a1%e5%bc%8f" aria-label="1.基地址偏移量模式">1.基地址偏移量模式</a></li>
                <li>
                    <a href="#2%e5%89%8d%e5%8f%98%e5%9f%ba%e6%a8%a1%e5%bc%8f" aria-label="2.前变基模式">2.前变基模式</a></li>
                <li>
                    <a href="#3%e5%90%8e%e5%8f%98%e5%9f%ba%e6%a8%a1%e5%bc%8f" aria-label="3.后变基模式">3.后变基模式</a></li></ul>
                </li>
                <li>
                    <a href="#344-%e7%8b%ac%e5%8d%a0%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e6%8c%87%e4%bb%a4" aria-label="3.4.4 独占内存访问指令">3.4.4 独占内存访问指令</a></li>
                <li>
                    <a href="#345-%e9%9a%90%e5%90%ab%e5%8a%a0-%e8%8e%b7%e5%8f%96%e5%ad%98%e5%82%a8-%e9%87%8a%e6%94%be%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c%e5%8e%9f%e8%af%ad" aria-label="3.4.5 隐含加-获取/存储-释放内存屏障原语">3.4.5 隐含加-获取/存储-释放内存屏障原语</a></li>
                <li>
                    <a href="#346-%e9%9d%9e%e7%89%b9%e6%9d%83%e8%ae%bf%e9%97%ae%e7%ba%a7%e5%88%ab%e5%8a%a0%e8%bd%bd%e5%92%8c%e5%ad%98%e5%82%a8%e6%8c%87%e4%bb%a4" aria-label="3.4.6 非特权访问级别加载和存储指令">3.4.6 非特权访问级别加载和存储指令</a></li></ul>
                </li>
                <li>
                    <a href="#35-%e5%85%a5%e6%a0%88%e5%92%8c%e5%87%ba%e6%a0%88" aria-label="3.5 入栈和出栈">3.5 入栈和出栈</a></li>
                <li>
                    <a href="#36-mov%e6%8c%87%e4%bb%a4" aria-label="3.6 MOV指令">3.6 MOV指令</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac4%e7%ab%a0-a64%e6%8c%87%e4%bb%a4%e9%9b%862--%e7%ae%97%e6%9c%af%e4%b8%8e%e7%a7%bb%e4%bd%8d%e6%8c%87%e4%bb%a4" aria-label="第4章 A64指令集2 —— 算术与移位指令">第4章 A64指令集2 —— 算术与移位指令</a><ul>
                        
                <li>
                    <a href="#41-%e6%9d%a1%e4%bb%b6%e6%93%8d%e4%bd%9c%e7%a0%81" aria-label="4.1 条件操作码">4.1 条件操作码</a></li>
                <li>
                    <a href="#42-%e5%8a%a0%e6%b3%95%e5%92%8c%e5%87%8f%e8%82%a5%e6%8c%87%e4%bb%a4" aria-label="4.2 加法和减肥指令">4.2 加法和减肥指令</a><ul>
                        
                <li>
                    <a href="#421-%e5%8a%a0%e6%b3%95" aria-label="4.2.1 加法">4.2.1 加法</a></li>
                <li>
                    <a href="#422-%e5%87%8f%e6%b3%95" aria-label="4.2.2 减法">4.2.2 减法</a></li></ul>
                </li>
                <li>
                    <a href="#43-cmp%e6%8c%87%e4%bb%a4" aria-label="4.3 CMP指令">4.3 CMP指令</a></li>
                <li>
                    <a href="#44-%e6%9d%a1%e4%bb%b6%e8%a1%a8%e7%a4%ba%e4%bd%8d" aria-label="4.4 条件表示位">4.4 条件表示位</a></li>
                <li>
                    <a href="#45-%e7%a7%bb%e4%bd%8d%e6%8c%87%e4%bb%a4" aria-label="4.5 移位指令">4.5 移位指令</a></li>
                <li>
                    <a href="#46-%e4%bd%8d%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4" aria-label="4.6 位操作指令">4.6 位操作指令</a></li>
                <li>
                    <a href="#47-%e4%bd%8d%e6%ae%b5%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4" aria-label="4.7 位段操作指令">4.7 位段操作指令</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac5%e7%ab%a0-a64%e6%8c%87%e4%bb%a4%e9%9b%863--%e6%af%94%e8%be%83%e6%8c%87%e4%bb%a4%e4%b8%8e%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4" aria-label="第5章 A64指令集3 —— 比较指令与跳转指令">第5章 A64指令集3 —— 比较指令与跳转指令</a><ul>
                        
                <li>
                    <a href="#51-%e6%af%94%e8%be%83%e6%8c%87%e4%bb%a4" aria-label="5.1 比较指令">5.1 比较指令</a><ul>
                        
                <li>
                    <a href="#511-cmn%e6%8c%87%e4%bb%a4" aria-label="5.1.1 CMN指令">5.1.1 CMN指令</a></li>
                <li>
                    <a href="#512-csel%e6%8c%87%e4%bb%a4" aria-label="5.1.2 CSEL指令">5.1.2 CSEL指令</a></li>
                <li>
                    <a href="#513-cset%e6%8c%87%e4%bb%a4" aria-label="5.1.3 CSET指令">5.1.3 CSET指令</a></li>
                <li>
                    <a href="#514-csinc%e6%8c%87%e4%bb%a4" aria-label="5.1.4 CSINC指令">5.1.4 CSINC指令</a></li></ul>
                </li>
                <li>
                    <a href="#52-%e8%b7%b3%e8%bd%ac%e4%b8%8e%e8%bf%94%e5%9b%9e%e6%8c%87%e4%bb%a4" aria-label="5.2 跳转与返回指令">5.2 跳转与返回指令</a><ul>
                        
                <li>
                    <a href="#521-%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4" aria-label="5.2.1 跳转指令">5.2.1 跳转指令</a></li>
                <li>
                    <a href="#522-%e8%bf%94%e5%9b%9e%e6%8c%87%e4%bb%a4" aria-label="5.2.2 返回指令">5.2.2 返回指令</a></li>
                <li>
                    <a href="#523-%e6%af%94%e8%be%83%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4" aria-label="5.2.3 比较跳转指令">5.2.3 比较跳转指令</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac6%e7%ab%a0-a64%e6%8c%87%e4%bb%a4%e9%9b%86--%e5%85%b6%e4%bb%96%e9%87%8d%e8%a6%81%e6%8c%87%e4%bb%a4" aria-label="第6章 A64指令集 —— 其他重要指令">第6章 A64指令集 —— 其他重要指令</a><ul>
                        
                <li>
                    <a href="#61-pc%e7%9b%b8%e5%af%b9%e5%9c%b0%e5%9d%80%e5%8a%a0%e8%bd%bd%e6%8c%87%e4%bb%a4" aria-label="6.1 PC相对地址加载指令">6.1 PC相对地址加载指令</a></li>
                <li>
                    <a href="#62-ldr%e4%b8%8eadrp%e6%8c%87%e4%bb%a4%e5%8c%ba%e5%88%ab" aria-label="6.2 LDR与ADRP指令区别">6.2 LDR与ADRP指令区别</a></li>
                <li>
                    <a href="#63-%e7%8b%ac%e5%8d%a0%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e6%8c%87%e4%bb%a4" aria-label="6.3 独占内存访问指令">6.3 独占内存访问指令</a></li>
                <li>
                    <a href="#64-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%8c%87%e4%bb%a4" aria-label="6.4 异常处理指令">6.4 异常处理指令</a></li>
                <li>
                    <a href="#65-%e7%b3%bb%e7%bb%9f%e5%af%84%e5%ad%98%e5%99%a8%e8%ae%bf%e9%97%ae%e6%8c%87%e4%bb%a4" aria-label="6.5 系统寄存器访问指令">6.5 系统寄存器访问指令</a></li>
                <li>
                    <a href="#66-%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c%e6%8c%87%e4%bb%a4" aria-label="6.6 内存屏障指令">6.6 内存屏障指令</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac7%e7%ab%a0-a64%e6%8c%87%e4%bb%a4%e9%9b%86%e7%9a%84%e9%99%b7%e9%98%b1" aria-label="第7章 A64指令集的陷阱">第7章 A64指令集的陷阱</a><ul>
                        
                <li>
                    <a href="#71-%e5%8a%a0%e8%bd%bd%e5%ae%8f%e6%a0%87%e7%ad%be" aria-label="7.1 加载宏标签">7.1 加载宏标签</a></li>
                <li>
                    <a href="#72-%e5%8a%a0%e8%bd%bd%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="7.2 加载字符串">7.2 加载字符串</a></li>
                <li>
                    <a href="#73-%e8%af%bb%e5%86%99%e5%af%84%e5%ad%98%e5%99%a8%e5%af%bc%e8%87%b4%e6%a0%91%e8%8e%93%e6%b4%be%e6%ad%bb%e6%9c%ba" aria-label="7.3 读写寄存器导致树莓派死机">7.3 读写寄存器导致树莓派死机</a></li>
                <li>
                    <a href="#74-ldxr%e6%8c%87%e4%bb%a4%e5%af%bc%e8%87%b4%e6%b0%b4%e5%b9%b34b%e6%ad%bb%e6%9c%ba" aria-label="7.4 LDXR指令导致水平4B死机">7.4 LDXR指令导致水平4B死机</a></li>
                <li>
                    <a href="#75-%e5%9c%a8%e6%b1%87%e7%bc%96%e4%b8%ad%e5%ae%9e%e7%8e%b0%e4%b8%b2%e5%8f%a3%e8%be%93%e5%87%ba%e5%8a%9f%e8%83%bd" aria-label="7.5 在汇编中实现串口输出功能">7.5 在汇编中实现串口输出功能</a></li>
                <li>
                    <a href="#76-%e7%ba%b7%e4%ba%ablinux50%e7%9a%84%e5%90%af%e5%8a%a8%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81" aria-label="7.6 纷享Linux5.0的启动汇编代码">7.6 纷享Linux5.0的启动汇编代码</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac8%e7%ab%a0-gnu%e6%b1%87%e7%bc%96%e5%99%a8" aria-label="第8章 GNU汇编器">第8章 GNU汇编器</a><ul>
                        
                <li>
                    <a href="#81-%e7%bc%96%e8%af%91%e6%b5%81%e7%a8%8b%e4%b8%8eelf%e6%96%87%e4%bb%b6" aria-label="8.1 编译流程与ELF文件">8.1 编译流程与ELF文件</a></li>
                <li>
                    <a href="#82-%e6%b1%87%e7%bc%96%e7%a8%8b%e5%ba%8f" aria-label="8.2 汇编程序">8.2 汇编程序</a></li>
                <li>
                    <a href="#83-%e6%b1%87%e7%bc%96%e8%af%ad%e6%b3%95" aria-label="8.3 汇编语法">8.3 汇编语法</a></li>
                <li>
                    <a href="#84-%e5%b8%b8%e7%94%a8%e4%bc%aa%e6%8c%87%e4%bb%a4" aria-label="8.4 常用伪指令">8.4 常用伪指令</a></li>
                <li>
                    <a href="#85-aarch64%e4%be%9d%e8%b5%96%e7%89%b9%e6%80%a7" aria-label="8.5 AArch64依赖特性">8.5 AArch64依赖特性</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac9%e7%ab%a0-%e9%93%be%e6%8e%a5%e5%99%a8%e4%b8%8e%e9%93%be%e6%8e%a5%e8%84%9a%e6%9c%ac" aria-label="第9章 链接器与链接脚本">第9章 链接器与链接脚本</a><ul>
                        
                <li>
                    <a href="#91-%e9%93%be%e6%8e%a5%e5%99%a8" aria-label="9.1 链接器">9.1 链接器</a></li>
                <li>
                    <a href="#93-%e9%93%be%e6%8e%a5%e8%84%9a%e6%9c%ac" aria-label="9.3 链接脚本">9.3 链接脚本</a><ul>
                        
                <li>
                    <a href="#921-%e9%93%be%e6%8e%a5%e7%a8%8b%e5%ba%8f" aria-label="9.2.1 链接程序">9.2.1 链接程序</a></li>
                <li>
                    <a href="#922-%e8%ae%be%e7%bd%ae%e5%85%a5%e5%8f%a3%e7%82%b9" aria-label="9.2.2 设置入口点">9.2.2 设置入口点</a></li>
                <li>
                    <a href="#923" aria-label="9.2.3">9.2.3</a></li>
                <li>
                    <a href="#927-%e5%b8%b8%e7%94%a8%e5%86%85%e5%bb%ba%e5%87%bd%e6%95%b0" aria-label="9.2.7 常用内建函数">9.2.7 常用内建函数</a><ul>
                        
                <li>
                    <a href="#1absoluteexp" aria-label="1.ABSOLUTE(exp)">1.ABSOLUTE(exp)</a></li>
                <li>
                    <a href="#2addrsection" aria-label="2.ADDR(section)">2.ADDR(section)</a></li>
                <li>
                    <a href="#3alignalign" aria-label="3.ALIGN(align)">3.ALIGN(align)</a></li>
                <li>
                    <a href="#4sizeofsection" aria-label="4.SIZEOF(section)">4.SIZEOF(section)</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#93-%e9%87%8d%e5%ae%9a%e4%bd%8d" aria-label="9.3 重定位">9.3 重定位</a><ul>
                        
                <li>
                    <a href="#931-benos%e9%87%8d%e5%ae%9a%e4%bd%8d" aria-label="9.3.1 BenOS重定位">9.3.1 BenOS重定位</a></li>
                <li>
                    <a href="#932-uboot%e5%92%8clinux%e5%86%85%e6%a0%b8%e9%87%8d%e5%ae%9a%e4%bd%8d" aria-label="9.3.2 UBoot和Linux内核重定位">9.3.2 UBoot和Linux内核重定位</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac10%e7%ab%a0-gcc%e5%86%85%e5%b5%8c%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81" aria-label="第10章 GCC内嵌汇编代码">第10章 GCC内嵌汇编代码</a><ul>
                        
                <li>
                    <a href="#101-%e5%86%85%e5%b5%8c%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95" aria-label="10.1 内嵌汇编代码基本用法">10.1 内嵌汇编代码基本用法</a><ul>
                        
                <li>
                    <a href="#1011-%e5%9f%ba%e7%a1%80%e5%86%85%e5%b5%8c%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81" aria-label="10.1.1 基础内嵌汇编代码">10.1.1 基础内嵌汇编代码</a></li>
                <li>
                    <a href="#1012-%e6%89%a9%e5%b1%95%e5%86%85%e5%b5%8c%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81" aria-label="10.1.2 扩展内嵌汇编代码">10.1.2 扩展内嵌汇编代码</a></li>
                <li>
                    <a href="#1013-%e5%86%85%e5%b5%8c%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%e7%9a%84%e4%bf%ae%e9%a5%b0%e7%ac%a6%e5%92%8c%e7%ba%a6%e6%9d%9f%e7%ac%a6" aria-label="10.1.3 内嵌汇编代码的修饰符和约束符">10.1.3 内嵌汇编代码的修饰符和约束符</a></li>
                <li>
                    <a href="#1014-%e4%bd%bf%e7%94%a8%e6%b1%87%e7%bc%96%e7%ac%a6%e5%8f%b7%e5%90%8d" aria-label="10.1.4 使用汇编符号名">10.1.4 使用汇编符号名</a></li>
                <li>
                    <a href="#1015-%e5%86%85%e5%b5%8c%e6%b1%87%e7%bc%96%e5%87%bd%e6%95%b0%e4%b8%8e%e5%ae%8f%e7%bb%93%e5%90%88" aria-label="10.1.5 内嵌汇编函数与宏结合">10.1.5 内嵌汇编函数与宏结合</a></li>
                <li>
                    <a href="#1016-%e4%bd%bf%e7%94%a8goto%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="10.1.6 使用goto修饰符">10.1.6 使用goto修饰符</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac11%e7%ab%a0-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" aria-label="第11章 异常处理">第11章 异常处理</a><ul>
                        
                <li>
                    <a href="#111-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="11.1 异常处理基本概念">11.1 异常处理基本概念</a><ul>
                        
                <li>
                    <a href="#1111-%e5%bc%82%e5%b8%b8%e7%b1%bb%e5%9e%8b" aria-label="11.1.1 异常类型">11.1.1 异常类型</a><ul>
                        
                <li>
                    <a href="#1%e4%b8%ad%e6%96%ad" aria-label="1.中断">1.中断</a></li>
                <li>
                    <a href="#2%e4%b8%ad%e6%ad%a2" aria-label="2.中止">2.中止</a></li>
                <li>
                    <a href="#3%e5%a4%8d%e4%bd%8d" aria-label="3.复位">3.复位</a></li>
                <li>
                    <a href="#4%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="4.系统调用">4.系统调用</a></li></ul>
                </li>
                <li>
                    <a href="#1112-%e5%bc%82%e5%b8%b8%e7%ad%89%e7%ba%a7" aria-label="11.1.2 异常等级">11.1.2 异常等级</a></li>
                <li>
                    <a href="#1113-%e5%90%8c%e6%ad%a5%e5%bc%82%e5%b8%b8%e5%92%8c%e5%bc%82%e6%ad%a5%e5%bc%82%e5%b8%b8" aria-label="11.1.3 同步异常和异步异常">11.1.3 同步异常和异步异常</a></li></ul>
                </li>
                <li>
                    <a href="#112-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e4%b8%8e%e8%bf%94%e5%9b%9e" aria-label="11.2 异常处理与返回">11.2 异常处理与返回</a><ul>
                        
                <li>
                    <a href="#1121-%e5%bc%82%e5%b8%b8%e5%85%a5%e5%8f%a3" aria-label="11.2.1 异常入口">11.2.1 异常入口</a></li>
                <li>
                    <a href="#1122-%e5%bc%82%e5%b8%b8%e8%bf%94%e5%9b%9e" aria-label="11.2.2 异常返回">11.2.2 异常返回</a></li>
                <li>
                    <a href="#1123-%e5%bc%82%e5%b8%b8%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80" aria-label="11.2.3 异常返回地址">11.2.3 异常返回地址</a></li>
                <li>
                    <a href="#1124-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e8%b7%af%e7%94%b1" aria-label="11.2.4 异常处理路由">11.2.4 异常处理路由</a></li>
                <li>
                    <a href="#1125-%e6%a0%88%e9%80%89%e6%8b%a9" aria-label="11.2.5 栈选择">11.2.5 栈选择</a></li>
                <li>
                    <a href="#1126-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e7%9a%84%e6%89%a7%e8%a1%8c%e7%8a%b6%e6%80%81" aria-label="11.2.6 异常处理的执行状态">11.2.6 异常处理的执行状态</a></li>
                <li>
                    <a href="#1127-%e5%bc%82%e5%b8%b8%e8%bf%94%e5%9b%9e%e7%9a%84%e6%89%a7%e8%a1%8c%e7%8a%b6%e6%80%81" aria-label="11.2.7 异常返回的执行状态">11.2.7 异常返回的执行状态</a></li></ul>
                </li>
                <li>
                    <a href="#113-%e5%bc%82%e5%b8%b8%e5%90%91%e9%87%8f%e8%a1%a8" aria-label="11.3 异常向量表">11.3 异常向量表</a><ul>
                        
                <li>
                    <a href="#1131-armv8%e5%bc%82%e5%b8%b8%e5%90%91%e9%87%8f%e8%a1%a8" aria-label="11.3.1 ARMv8异常向量表">11.3.1 ARMv8异常向量表</a></li>
                <li>
                    <a href="#1132-linux50-%e5%86%85%e6%a0%b8%e7%9a%84%e5%bc%82%e5%b8%b8%e5%90%91%e9%87%8f%e8%a1%a8" aria-label="11.3.2 Linux5.0 内核的异常向量表">11.3.2 Linux5.0 内核的异常向量表</a></li>
                <li>
                    <a href="#1133-vbar_elx" aria-label="11.3.3 VBAR_ELx">11.3.3 VBAR_ELx</a></li></ul>
                </li>
                <li>
                    <a href="#114-%e5%bc%82%e5%b8%b8%e7%8e%b0%e5%9c%ba" aria-label="11.4 异常现场">11.4 异常现场</a></li>
                <li>
                    <a href="#115-%e5%90%8c%e6%ad%a5%e5%bc%82%e5%b8%b8" aria-label="11.5 同步异常">11.5 同步异常</a><ul>
                        
                <li>
                    <a href="#1151-%e5%bc%82%e5%b8%b8%e7%b1%bb%e5%9e%8b" aria-label="11.5.1 异常类型">11.5.1 异常类型</a></li>
                <li>
                    <a href="#1152-%e6%95%b0%e6%8d%ae%e5%bc%82%e5%b8%b8" aria-label="11.5.2 数据异常">11.5.2 数据异常</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac-12-%e7%ab%a0-%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86" aria-label="第 12 章 中断处理">第 12 章 中断处理</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3" aria-label="参考文档">参考文档</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h1 id="第1章-arm64体系结构基础">第1章 ARM64体系结构基础<a hidden class="anchor" aria-hidden="true" href="#第1章-arm64体系结构基础">#</a></h1>
<ul>
<li>ARMv8体系结构处理器包含<code>31</code>个通用寄存器</li>
<li>AArch64执行状态包含·<code>4</code>个异常等级，EL0~EL3，用户态、内核态、虚拟机、安全态</li>
<li>PSTATE寄存器中NZCV标志：负零进溢</li>
<li>PSTATE寄存器DAIF异常掩码标志位</li>
</ul>
<h2 id="11-arm简介">1.1 ARM简介<a hidden class="anchor" aria-hidden="true" href="#11-arm简介">#</a></h2>
<p> ARM体系结构是一种硬件规范，主要约定指令集、芯片内部体系结构  <br>
 ARMv8体系结构处理器IP Cortex-A53、Cortex-A55、Cortex-A72、Cortex-A77  <br></p>
<h2 id="12-armv8体系结构基础知识">1.2 ARMv8体系结构基础知识<a hidden class="anchor" aria-hidden="true" href="#12-armv8体系结构基础知识">#</a></h2>
<h3 id="121-armv8体系结构">1.2.1 ARMv8体系结构<a hidden class="anchor" aria-hidden="true" href="#121-armv8体系结构">#</a></h3>
<p> ARMv8是64位处理器指令集和体系结构  <br></p>
<ul>
<li>64位虚拟地址空间，32位仅支持4GB</li>
<li>31个64位宽通用寄存器</li>
<li>支持16KB和64Kb页面，降低TLB未命中率</li>
<li>异常处理模型EL0~EL3</li>
<li>加载-获取指令(Load-Acquire Instruction)，存储-释放指令(Store-Release Instruction)</li>
</ul>
<h3 id="122-armv8处理器内核">1.2.2 ARMv8处理器内核<a hidden class="anchor" aria-hidden="true" href="#122-armv8处理器内核">#</a></h3>
<ul>
<li>Cortex-A53</li>
<li>Cortex-A57</li>
<li>Cortex-A72</li>
</ul>
<h3 id="123-armv8体系结构基本概念">1.2.3 ARMv8体系结构基本概念<a hidden class="anchor" aria-hidden="true" href="#123-armv8体系结构基本概念">#</a></h3>
<p> ARMv8体系结构基本概念和定义  <br></p>
<ul>
<li>处理机PE(Processing Element):处理器处理事务过程抽象</li>
<li>执行状态(execution state):处理器运行时环境，包括寄存器位宽、支持指令集、异常模型、内存管理以及编程模型  <br></li>
</ul>
<blockquote>
<p>ARMv8两个执行状态</p>
<blockquote>
<p>AArch64：64位执行状态   <br></p>
<blockquote>
<p>31个通用寄存器   <br>
64位程序计数(PC)指针寄存器、栈指针(Stack Pointer SP)寄存器及异常链接寄存器(Exception Link Register ELR)  <br>
A64指令集   <br>
ARMv8异常模型，4个异常等级，即EL0~EL3   <br>
64位内存模型   <br>
一组处理器状态(PSTATE)保存PE状态  <br>
AArch32: 32位执行状态   <br></p>
</blockquote>
</blockquote>
</blockquote>
<p> AArch64状态，部分系统寄存器在不同异常等级提供不同变种寄存器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>register_name<span style="color:#f92672">&gt;</span>_ELx  <span style="color:#75715e">// x: 0 1 2 3
</span></span></span></code></pre></div><h3 id="124-a64指令集">1.2.4 A64指令集<a hidden class="anchor" aria-hidden="true" href="#124-a64指令集">#</a></h3>
<p> ARMv8体系结构64位指令集：处理64位宽寄存器和数据并使用64位指针访问内存</p>
<h3 id="125-armv8处理器执行状态">1.2.5 ARMv8处理器执行状态<a hidden class="anchor" aria-hidden="true" href="#125-armv8处理器执行状态">#</a></h3>
<p> AArch64状态异常等级(exception level)确定处理器当前运行的特权级别</p>
<ul>
<li>EL0：用户特权</li>
<li>EL1：系统特权，操作系统内核，系统使能虚拟化扩展，运行虚拟操作系统内核</li>
<li>EL2：运行虚拟化扩展的虚拟监控程序(hypervisor)</li>
<li>EL3：运行安全世界中安全监控器(secure monitor)</li>
</ul>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221204150429.png" alt="20221204150429"  />
</p>
<h3 id="126-armv8数据宽度">1.2.6 ARMv8数据宽度<a hidden class="anchor" aria-hidden="true" href="#126-armv8数据宽度">#</a></h3>
<ul>
<li>字节(byte)：8位</li>
<li>半字(halfword)：16位</li>
<li>字(word)：32位</li>
<li>双字(doubleword)：64位</li>
<li>四字(quadword)：128位</li>
</ul>
<h2 id="13-armv8寄存器">1.3 ARMv8寄存器<a hidden class="anchor" aria-hidden="true" href="#13-armv8寄存器">#</a></h2>
<h3 id="131-通用寄存器">1.3.1 通用寄存器<a hidden class="anchor" aria-hidden="true" href="#131-通用寄存器">#</a></h3>
<p> AArch64执行状态支持31个64位通用寄存器，X0~X30寄存器，AArch32状态支持16个32位通用寄存器  <br>
 AArch64状态下，X表示64位通用寄存器，W表示低32位的数据</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221204151151.png" alt="20221204151151"  />
</p>
<h3 id="132-处理器状态">1.3.2 处理器状态<a hidden class="anchor" aria-hidden="true" href="#132-处理器状态">#</a></h3>
<p> AArch64体系结构使用PSTATE寄存器表示当前处理器状态</p>
<table>
	<tr>
	    <th>分　　类</th>
	    <th>字　　段</th>
	    <th>描　　述</th>  
	    <th>描　　述</th>  
	</tr >
	<tr >
	    <td rowspan="4">条件标志位</td>
	    <td>N</td>
	    <td>负数标志位。
在结果是有符号的二进制补码的情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0</td>
	</tr>
	<tr>
	    <td>Z</td>
	    <td>0标志位。如果结果为0，则Z=1；如果结果不为0，则Z=0</td>
	</tr>
    <tr>
	    <td>C</td>
	    <td>进位标志位。当发生无符号数溢出时，C=1。其他情况下，C=0</td>
	</tr>
    <tr>
	    <td>V</td>
	    <td>有符号数溢出标志位。<br>　对于加/减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1；如果未发生溢出，则V=0。<br>　对于其他指令，V通常不发生变化</td>
	</tr>
    <tr >
	    <td rowspan="3">执行状态控制</td>
	    <td>SS</td>
	    <td>软件单步。该位为1，说明在异常处理中使能了软件单步功能</td>
	</tr>
    <tr>
	    <td>IL</td>
	    <td>不合法的异常状态</td>
	</tr>
    <tr>
	    <td>nRW</td>
	    <td>当前执行状态 <br>　0：处于AArch64状态 <br>　1：处于AArch32状态</td>
	</tr>
    <tr >
	    <td rowspan="2">执行状态控制</td>
	    <td>EL</td>
	    <td>当前异常等级 <br> 　0：表示EL0<br> 　1：表示EL1<br> 　2：表示EL2<br> 　3：表示EL3</td>
	</tr>
    <tr>
	    <td>SP</td>
	    <td>选择SP寄存器。当运行在EL0时，处理器选择EL0的SP寄存器，即SP_EL0；当处理器运行在其他异常等级时，处理器可以选择使用SP_EL0或者对应的SP_ELn寄存器</td>
	</tr>
    <tr >
	    <td rowspan="4">异常掩码标志位</td>
	    <td>D</td>
	    <td>调试位。使能该位可以在异常处理过程中打开调试断点和软件单步等功能</td>
	</tr>
    <tr>
	    <td>A</td>
	    <td>用来屏蔽系统错误（SError）</td>
	</tr>
    <tr>
	    <td>I</td>
	    <td>用来屏蔽IRQ</td>
	</tr>
    <tr>
	    <td>F</td>
	    <td>用来屏蔽FIQ</td>
	</tr>
    <tr >
	    <td rowspan="2">访问权限</td>
	    <td>PAN</td>
	    <td>特权模式禁止访问（Privileged Access Never）位是ARMv8.1的扩展特性 <br> 　1：在EL1或者EL2访问属于EL0的虚拟地址时会触发一个访问权限错误 <br> 　0：不支持该功能，需要软件来模拟</td>
	</tr>
    <tr>
	    <td>UAO</td>
	    <td>用户访问覆盖标志位，是ARMv8.2的扩展特性 <br> 　1：当运行在EL1或者EL2时，没有特权的加载存储指令可以和有特权的加载存储指令一样访问内存，如LDTR指令<br>　0：不支持该功能</td>
	</tr>
</table>
<h3 id="133-特殊寄存器">1.3.3 特殊寄存器<a hidden class="anchor" aria-hidden="true" href="#133-特殊寄存器">#</a></h3>
<p> ARMv8体系结构除31个通用寄存器外，还提供多个特殊寄存器</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221204153018.png" alt="20221204153018"  />
</p>
<h4 id="1零寄存器">1.零寄存器<a hidden class="anchor" aria-hidden="true" href="#1零寄存器">#</a></h4>
<p> ARMv8提供两个零寄存器(zero register)，寄存器内部全是0，WZR是32位零寄存器，XZR是64位零寄存器</p>
<h4 id="2pc指针寄存器">2.PC指针寄存器<a hidden class="anchor" aria-hidden="true" href="#2pc指针寄存器">#</a></h4>
<p> PC指针寄存器用来存储当前运行指令的<code>下一条指令地址</code>，控制程序中指令的运行顺序，不可直接访问  <br></p>
<h4 id="3sp寄存器">3.SP寄存器<a hidden class="anchor" aria-hidden="true" href="#3sp寄存器">#</a></h4>
<p> ARMv8体系结构支持4个异常等级，每个异常等级有专门SP寄存器：SP_EL0、SP_EL1、SP_EL2、SP_EL3  <br>
 Linux内核使用SP_EL0存放进程中<code>task_struct</code>数据结构指针</p>
<h4 id="4备份状态寄存器">4.备份状态寄存器<a hidden class="anchor" aria-hidden="true" href="#4备份状态寄存器">#</a></h4>
<p> 运行异常处理程序时，处理器备份程序会保存备份程序状态寄存器(Savaed Program Status Register SPSR)里。当异常发生时，处理器会把PSTATE寄存器的值暂时保存到SPSR里，当异常处理完成并返回时，再把SPSR值恢复到PSTATE寄存器，SPSR字段：</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221204172503.png" alt="20221204172503"  />
</p>
<table>
	<tr>
	    <th>字　　段</th>
	    <th>描　　述</th>
	</tr >
	<tr >
	    <td>N</td>
	    <td>负数标志位</td>
	</tr>
    <tr >
	    <td>Z</td>
	    <td>零标志位</td>
	</tr>
    <tr >
	    <td>C</td>
	    <td>进位标志位</td>
	</tr>
    <tr >
	    <td>V</td>
	    <td>有符号数溢出标志位</td>
	</tr>
    <tr >
	    <td>DIT</td>
	    <td>与数据无关的指令时序（Data Independent Timing），ARMv8.4的扩展特性</td>
	</tr>
    <tr >
	    <td>UAO</td>
	    <td>用户访问覆盖标志位，ARMv8.2的扩展特性</td>
	</tr>
     <tr >
	    <td>PAN</td>
	    <td>特权模式禁止访问位，ARMv8.1的扩展特性</td>
	</tr>
     <tr >
	    <td>SS</td>
	    <td>表示是否使能软件单步功能。若该位为1，说明在异常处理中使能了软件单步功能</td>
	</tr>
     <tr >
	    <td>IL</td>
	    <td>不合法的异常状态</td>
	</tr>
     <tr >
	    <td>D</td>
	    <td>调试位。使能该位可以在异常处理过程中打开调试断点和软件单步等功能</td>
	</tr>
     <tr >
	    <td>A</td>
	    <td>用来屏蔽系统错误</td>
	</tr>
     <tr >
	    <td>I</td>
	    <td>用来屏蔽IRQ</td>
	</tr>
     <tr >
	    <td>F</td>
	    <td>用来屏蔽FIQ</td>
	</tr>
     <tr >
	    <td>M[4]</td>
	    <td>用来表示异常处理过程中处于哪个执行状态，若为0，表示AArch64状态</td>
	</tr>
     <tr >
	    <td>M[3:0]</td>
	    <td>异常模式</td>
	</tr>
</table>
<h4 id="5-elr">5. ELR<a hidden class="anchor" aria-hidden="true" href="#5-elr">#</a></h4>
<p> ELR存放异常返回地址</p>
<h4 id="6currentel寄存器">6.CurrentEL寄存器<a hidden class="anchor" aria-hidden="true" href="#6currentel寄存器">#</a></h4>
<p> 该寄存器表示PSTATE寄存器中EL字段，保存异常等级，使用MRS指令读取当前异常等级</p>
<h4 id="7daif寄存器">7.DAIF寄存器<a hidden class="anchor" aria-hidden="true" href="#7daif寄存器">#</a></h4>
<p> 该寄存器表示PSTATE寄存器中[D、A、I、F]字段</p>
<h4 id="8spsel寄存器">8.SPSel寄存器<a hidden class="anchor" aria-hidden="true" href="#8spsel寄存器">#</a></h4>
<p> 寄存器表示PSTATE寄存器中SP字段，用于在SP_EL0和SP_ELn中选择SP寄存器</p>
<h4 id="9pan寄存器">9.PAN寄存器<a hidden class="anchor" aria-hidden="true" href="#9pan寄存器">#</a></h4>
<p> PAN寄存器表示PSTATE寄存器中PAN字段，通过MSR和MRS指令设置PAN寄存器<br>
 内核态访问用户态内存，主动调用内核接口，如copy_from_user()或copy_to_user()  <br></p>
<p> PAN寄存器值： <br>
 0：表示内核态可访问用户态内存 <br>
 1：表示内核态访问用户态内存会触发访问权限异常 <br></p>
<h4 id="10uao寄存器">10.UAO寄存器<a hidden class="anchor" aria-hidden="true" href="#10uao寄存器">#</a></h4>
<p> 该寄存器表示PSTATE寄存器中UAO(User Access Override 用户访问覆盖)字段，MSR和MRS设置UAO寄存器，1表示EL1和EL2执行非特权指令效果和特权指令一样</p>
<h4 id="11nzcv寄存器">11.NZCV寄存器<a hidden class="anchor" aria-hidden="true" href="#11nzcv寄存器">#</a></h4>
<p> PSTATE寄存器中{N, Z, C, V}</p>
<h3 id="134-系统寄存器">1.3.4 系统寄存器<a hidden class="anchor" aria-hidden="true" href="#134-系统寄存器">#</a></h3>
<p> ARMv8体系结构7类系统寄存器  <br></p>
<ul>
<li>通用系统控制寄存器</li>
<li>调试寄存器</li>
<li>性能监控寄存器</li>
<li>活动监控寄存器</li>
<li>统计扩展寄存器</li>
<li>RAS寄存器</li>
<li>通用定时寄存器</li>
</ul>
<p> 系统寄存器支持不同的异常等级访问，Reg_ELx  <br>
 MSR和MRS指令访问系统寄存器  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>mrs x0, TTBR0_EL1   <span style="color:#75715e">// 把TTBR0_EL1值复制到X0寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>msr TTBR0_El1, X0   <span style="color:#75715e">// 把X0寄存器值复制到TTBR0_EL1
</span></span></span></code></pre></div><h2 id="14-cortex-a72处理器介绍">1.4 Cortex-A72处理器介绍<a hidden class="anchor" aria-hidden="true" href="#14-cortex-a72处理器介绍">#</a></h2>
<p> 树莓派4B开发板，内置了4个Cortex-A72处理器内核  <br>
 Cortex-A72处理器支持特性  <br></p>
<ul>
<li>
<p>采用ARMv8体系结构规范来设计，兼容ARMv8.0协议。</p>
</li>
<li>
<p>超标量处理器设计，支持乱序执行的流水线。</p>
</li>
<li>
<p>基于分支目标缓冲区(BTB)和全局..缓冲区(GHB)</p>
</li>
<li>
<p>支持48个表项的全相连指令TLB，可以支持4 KB、64 KB以及1 MB大小的页面。</p>
</li>
<li>
<p>支持32个表项的全相连数据TLB，可以支持4 KB、64 KB以及1 MB大小的页面。</p>
</li>
<li>
<p>每个处理器内核支持4路组相连的L2 TLB。</p>
</li>
<li>
<p>48 KB的L1指令高速缓存以及32 KB的L1数据高速缓存。</p>
</li>
<li>
<p>可配置大小的L2高速缓存，可以配置为512 KB、1 MB、2 MB以及4 MB大小。</p>
</li>
<li>
<p>基于AMBA4总线协议的ACE（AXI Coherency Extension）或者CHI（CoherentHubInterface）。</p>
</li>
<li>
<p>支持PMUv3体系结构的性能监视单元。</p>
</li>
<li>
<p>支持多处理器调试的CTI（Cross Trigger Interface）。</p>
</li>
<li>
<p>支持GIC（可选）。</p>
</li>
<li>
<p>支持多电源域（power domain）的电源管理。</p>
</li>
</ul>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221204175403.png" alt="20221204175403"  />
</p>
<h4 id="1指令预取单元">1.指令预取单元<a hidden class="anchor" aria-hidden="true" href="#1指令预取单元">#</a></h4>
<p> 指令预取单元从L1指令高速缓存中获取指令，每个周期向译码单元最多发送3条指令。支持动态和静态分支预测，指令预取单元功能：</p>
<ul>
<li>L1指令高速缓存是一个48 KB大小、3路组相连的高速缓存，每个缓存行的大小为64字节。</li>
<li>支持48个表项的全相连指令TLB，可以支持4 KB、64 KB以及1 MB大小的页面。</li>
<li>带有分支目标缓冲器的2级动态预测器，用于快速生成目标。</li>
<li>支持静态分支预测。</li>
<li>支持间接预测。</li>
<li>返回栈缓冲器。</li>
</ul>
<h4 id="2指令译码单元">2.指令译码单元<a hidden class="anchor" aria-hidden="true" href="#2指令译码单元">#</a></h4>
<p> 指令译码单元对A32、T32、A64指令集进行译码   <br>
 指令译码单元执行寄存器重命名，消除写后写(WAW)和读后写(WAR)实现乱序执行   <br></p>
<h4 id="3指令分派单元">3.指令分派单元<a hidden class="anchor" aria-hidden="true" href="#3指令分派单元">#</a></h4>
<p> 指令分派单元控制译码后的指令何时被分派到执行管道及返回的结果何时终止，包括ARM核心通用寄存器、SIMD和浮点寄存器</p>
<h4 id="4加载存储单元">4.加载/存储单元<a hidden class="anchor" aria-hidden="true" href="#4加载存储单元">#</a></h4>
<p> 加载/存储单元(LSU)执行加载和存储指令，包括L1数据存储系统</p>
<h4 id="5l1内存子系统">5.L1内存子系统<a hidden class="anchor" aria-hidden="true" href="#5l1内存子系统">#</a></h4>
<p> L1内存子系统包括指令内存系统和数据内存系统  <br>
 L1指令内存系统包括如下特性  <br></p>
<ul>
<li>具有48 KB的指令高速缓存，3路组相连映射。</li>
<li>缓存行的大小为64字节。</li>
<li>支持物理索引物理标记（PIPT）。</li>
<li>高速缓存行的替换算法为LRU（Least Recently Used）算法。</li>
</ul>
<p> L1数据内存系统包括如下特性  <br></p>
<ul>
<li>具有32 KB的数据高速缓存，两路组相连映射。</li>
<li>缓存行的大小为64字节。</li>
<li>支持物理索引物理标记。</li>
<li>对于普通内存，支持乱序发射、预测以及非阻塞的加载请求访问；对于设备内存，支持非预测以及非阻塞的加载请求访问。</li>
<li>高速缓存行的替换算法为LRU算法。</li>
<li>支持硬件预取。</li>
</ul>
<h4 id="6mmu">6.MMU<a hidden class="anchor" aria-hidden="true" href="#6mmu">#</a></h4>
<p> MMU实现虚拟地址到物理地址转换，AArch64支持4KB、16KB、64KB页面  <br>
 MMMU包括：</p>
<ul>
<li>48表项全相连的L1指令TLB</li>
<li>32表项全相连的L1数据TLB</li>
<li>4路组相连L2 TLB</li>
</ul>
<p> TLB支持8位或16位ASID，还支持VMID(虚拟化)</p>
<h4 id="7l2内存子系统">7.L2内存子系统<a hidden class="anchor" aria-hidden="true" href="#7l2内存子系统">#</a></h4>
<p> L2内存子系统不仅负责处理每个处理器内核的L1指令和数据高速缓存未命中的情况，还通过ACE或者CHI连接到内存系统。其特性  <br></p>
<ul>
<li>可配置L2高速缓存的大小，大小可以是512 KB、1 MB、2 MB、4 MB。</li>
<li>缓存行大小为64字节。</li>
<li>支持物理索引物理标记。</li>
<li>具有16路组相连高速缓存。</li>
<li>缓存一致性监听控制单元（Snoop Control Unit，SCU）。</li>
<li>具有可配置的128位宽的ACE或者CHI。</li>
<li>具有可选的128位宽的ACP接口。</li>
<li>支持硬件预取。</li>
</ul>
<h2 id="15-armv9体系结构">1.5 ARMv9体系结构<a hidden class="anchor" aria-hidden="true" href="#15-armv9体系结构">#</a></h2>
<p> ARMv9体系结构新加入的特性包括：  <br></p>
<ul>
<li>全新的可伸缩矢量扩展（Scalable Vector Extension version 2，SVE2）计算；</li>
<li>机密计算体系结构（Confidential Compute Architecture，CCA），基于硬件提供的安全环境来保护用户敏感数据；</li>
<li>分支记录缓冲区扩展（Branch Record Buffer Extension，BRBE），它以低成本的方式捕获控制路径历史的分支记录缓冲区；</li>
<li>内嵌跟踪扩展（Embedded Trace Extension，ETE）以及跟踪缓冲区扩展（Trace Buffer Extension，TRBE），用于增强对ARMv9处理器内核的调试和跟踪功能；</li>
<li>事务内存扩展（Transactional Memory Extension，TME）</li>
</ul>
<br>
<h1 id="第2章-搭建树莓派环境">第2章 搭建树莓派环境<a hidden class="anchor" aria-hidden="true" href="#第2章-搭建树莓派环境">#</a></h1>
<h2 id="21-树莓派">2.1 树莓派<a hidden class="anchor" aria-hidden="true" href="#21-树莓派">#</a></h2>
<p> 树莓派4B 博通BCM2711芯片  <br></p>
<ul>
<li>CPU内核：4核 A72 1.5GHz</li>
<li>L1缓存： 32KB数据缓存，48KB指令缓存</li>
<li>L2缓存： 1MB</li>
<li>GPU： VideoCoreV1核心，500MHz</li>
<li>内存： LPDDR4</li>
</ul>
<p> 两种地址模式：</p>
<ul>
<li>低地址模式</li>
<li>35位全地址模式</li>
</ul>
<h2 id="22-搭建树莓派环境">2.2 搭建树莓派环境<a hidden class="anchor" aria-hidden="true" href="#22-搭建树莓派环境">#</a></h2>
<h3 id="222-安装树莓派官方os">2.2.2 安装树莓派官方OS<a hidden class="anchor" aria-hidden="true" href="#222-安装树莓派官方os">#</a></h3>
<p> boot分区包括文件：</p>
<ul>
<li>bootcode.bin：引导程序</li>
<li>start4.elf：树莓派4B的GPU固件</li>
<li>start.elf： 树莓派3B的GPU固件</li>
<li>config.txt：配置文件</li>
</ul>
<h3 id="224-使用gdb和qemu虚拟机调试benos">2.2.4 使用GDB和QEMU虚拟机调试BenOS<a hidden class="anchor" aria-hidden="true" href="#224-使用gdb和qemu虚拟机调试benos">#</a></h3>
<h2 id="23-benos代码">2.3 BenOS代码<a hidden class="anchor" aria-hidden="true" href="#23-benos代码">#</a></h2>
<h2 id="24-qemu虚拟机与arm64">2.4 QEMU虚拟机与ARM64<a hidden class="anchor" aria-hidden="true" href="#24-qemu虚拟机与arm64">#</a></h2>
<p> QEMU虚拟机与ARM64实验平台，书中Ubuntu20.04  <br>
 1)安装工具</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt-get install qemu-system-arm libncurses5-dev gcc-aarch64-linux-gnu build-essential git bison flex libssl-dev
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看ARM gcc版本</span>
</span></span><span style="display:flex;"><span>aarch64-linux-gnu-gcc -v
</span></span></code></pre></div><p> 2)下载仓库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone git@github.com:figozhang/runninglinuxkernel_5.0.git
</span></span></code></pre></div><p> 3)编译内核及创建文件系统 <br>
 rootfs_arm64.tar.xz文件基于20.04系统的根文件系统创建</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 编译内核</span>
</span></span><span style="display:flex;"><span>cd runninglinuxkernel_5.0
</span></span><span style="display:flex;"><span>./run_rlk_arm64.sh build_kernel
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 编译文件系统  生成rootfs_arm64.ext4根文件系统</span>
</span></span><span style="display:flex;"><span>cd runninglinuxkernel_5.0
</span></span><span style="display:flex;"><span>sudo ./run_rlk_arm64.sh build_rootfs
</span></span></code></pre></div><p> 4)运行ARM64版本Linux系统</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>./run_rlk_arm64.sh run
</span></span><span style="display:flex;"><span><span style="color:#75715e"># root   123</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 或</span>
</span></span><span style="display:flex;"><span>qemu-system-aarch64 -m <span style="color:#ae81ff">1024</span> -cpu max,sve<span style="color:#f92672">=</span>on,sev256<span style="color:#f92672">=</span>on -M virts
</span></span></code></pre></div><p> 5)在线安装软件包  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 查看网络配置</span>
</span></span><span style="display:flex;"><span>ifconfig 
</span></span></code></pre></div><p> 6)主机和QEMU虚拟机共享文件  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cp test.c runninglinuxkernel_5.0/kmodules/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># qemu</span>
</span></span><span style="display:flex;"><span>cd /mnt
</span></span><span style="display:flex;"><span>ls
</span></span></code></pre></div><br>
<h1 id="第3章-a64指令集i--加载与存储指令">第3章 A64指令集I —— 加载与存储指令<a hidden class="anchor" aria-hidden="true" href="#第3章-a64指令集i--加载与存储指令">#</a></h1>
<p> A64指令特点  <br></p>
<h2 id="31-a64指令集介绍">3.1 A64指令集介绍<a hidden class="anchor" aria-hidden="true" href="#31-a64指令集介绍">#</a></h2>
<p> ARMv8体系结构，A64指令集64位指令集，处理64位宽寄存器和数据，并使用64位指针访问内存，A64指令集指令宽度为32位  <br>
 A64指集分类：</p>
<ul>
<li>内存加载和存储指令</li>
<li>多字节内存加载和存储指令</li>
<li>算数和移位指令</li>
<li>移位操作指令</li>
<li>位操作指令</li>
<li>条件操作指令</li>
<li>跳转指令</li>
<li>独占内存访问</li>
<li>内存屏障指令</li>
<li>异常处理指令</li>
<li>系统寄存器访问指令</li>
</ul>
<h2 id="32-a64指令编码">3.2 A64指令编码<a hidden class="anchor" aria-hidden="true" href="#32-a64指令编码">#</a></h2>
<p> A64指令集指令宽度为32位，第24~28位识别指令分类</p>
<p> op0字段值</p>
<table>
	<tr>
	    <th>op0 字段值</th>
	    <th>说    明</th>
	</tr>
	<tr>
	    <td>0000x</td>
	    <td>保留</td>
    </tr>
    <tr>
	    <td>0010x</td>
	    <td>可伸缩矢量扩展(SVE)指令</td>
    </tr>
    <tr>
	    <td>100xx</td>
	    <td>数据处理指令(立即数)</td>
    </tr>
    <tr>
	    <td>101xx</td>
	    <td>分支处理指令、异常处理指令及系统寄存器访问指令</td>
    </tr>
    <tr>
	    <td>x1x0x</td>
	    <td>加载与存储指令</td>
    </tr>
    <tr>
	    <td>x101x</td>
	    <td>数据处理指令(基于寄存器)</td>
    </tr>
    <tr>
	    <td>x111x</td>
	    <td>数据处理指令(浮点数与SIMD)</td>
    </tr>
</table>
<p> 加载与存储指令分类  <br></p>
<p> 为什么指令编码宽度是32位？  <br>
 A64指令集基于寄存器加载和存储体系结构设计，数据加载、存储及处理在通用寄存器中。ARM64一共31个通用寄存器X0~X30，因此在指令编码中使用5位宽，可索引32个通用寄存器  <br></p>
<ul>
<li>使用寄存器作为基地址，把SP(栈指针)寄存器当做第31个通用寄存器</li>
<li>用作源寄存器操作数时，把XZR当作第31个通用寄存器</li>
</ul>
<h2 id="33-加载与存储指令">3.3 加载与存储指令<a hidden class="anchor" aria-hidden="true" href="#33-加载与存储指令">#</a></h2>
<p> ARMv8体系结构基于指令加载和存储体系结构，所有数据处理都通过通用寄存器完成，不能直接在内存中完成  <br></p>
<p> 常见内存加载指令是LDR指令，存储指令STR指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDR <span style="color:#960050;background-color:#1e0010">目标寄存器</span>,  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">存储器地址</span><span style="color:#f92672">&gt;</span>  <span style="color:#75715e">// 把存储地址中的数据加载到目标寄存器中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>STR <span style="color:#960050;background-color:#1e0010">源寄存器</span>,  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">存储器地址</span><span style="color:#f92672">&gt;</span>    <span style="color:#75715e">// 把源寄存器数据存储到存储器中 
</span></span></span></code></pre></div><table>
	<tr>
	    <th>寻 址 模 式</th>
	    <th>说   明</th>
	</tr>
	<tr>
	    <td>基地址模式</td>
	    <td>[Xn]</td>
    </tr>
    <tr>
	    <td>基地址加偏移量模式</td>
	    <td>[Xn, #offset]</td>
    </tr>
    <tr>
	    <td>前变基模式</td>
	    <td>[Xn, #offset]!</td>
    </tr>
    <tr>
	    <td>后变基模式</td>
	    <td>[Xn] #offset</td>
    </tr>
    <tr>
	    <td>PC相对地址模式</td>
	    <td> < lable></td>
    </tr>
</table>
<h3 id="331-基于基地址寻址模式">3.3.1 基于基地址寻址模式<a hidden class="anchor" aria-hidden="true" href="#331-基于基地址寻址模式">#</a></h3>
<p> 基地址模式寄存器值表示地址，基地址加偏移量模式基地址加上可正可负偏移  <br></p>
<h4 id="1基地模式">1.基地模式<a hidden class="anchor" aria-hidden="true" href="#1基地模式">#</a></h4>
<p> 指令以Xn寄存器值为内存地址，加载此内存地址内容到Xt寄存器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDR Xt, [Xn] 
</span></span></code></pre></div><p> 指令把Xt寄存器中内容存储到Xn寄存器的内存地址中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>STR Xt, [Xn]  <span style="color:#f92672">?</span>
</span></span></code></pre></div><h4 id="2基地址加偏移量模式">2.基地址加偏移量模式<a hidden class="anchor" aria-hidden="true" href="#2基地址加偏移量模式">#</a></h4>
<p> 指令把Xn寄存器值加偏移量(offset是8的倍数)，以相加的结果作为内存地址，加载此地址内容到Xt寄存器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 偏移量从指令编码imm12字段获取 0~32760B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LDR Xt, [Xn, <span style="color:#960050;background-color:#1e0010">$</span>offset]
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 基地址加偏移量存储指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>STR Xt, [Xn, <span style="color:#960050;background-color:#1e0010">$</span>offset]
</span></span></code></pre></div><h4 id="3基地址扩展模式">3.基地址扩展模式<a hidden class="anchor" aria-hidden="true" href="#3基地址扩展模式">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, {<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">&gt;</span>, (<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">&gt;</span>){, <span style="color:#f92672">&lt;</span>extend<span style="color:#f92672">&gt;</span> {<span style="color:#f92672">&lt;</span>amount<span style="color:#f92672">&gt;</span>}}}
</span></span><span style="display:flex;"><span>STR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, {<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">&gt;</span>, (<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">&gt;</span>){, <span style="color:#f92672">&lt;</span>extend<span style="color:#f92672">&gt;</span> {<span style="color:#f92672">&lt;</span>amount<span style="color:#f92672">&gt;</span>}}}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"></code></pre></div><h3 id="332-变基模式">3.3.2 变基模式<a hidden class="anchor" aria-hidden="true" href="#332-变基模式">#</a></h3>
<p> 两种变基模式</p>
<ul>
<li>前变基：先更新偏移量地址，后访问内存</li>
<li>后变基：先访问内存地址，后更新偏移量地址</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 前变基模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LDR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>simm<span style="color:#f92672">&gt;</span>]<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>STR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>simm<span style="color:#f92672">&gt;</span>]<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 后变基模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LDR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>simm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>STR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>simm<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h3 id="333-pc相对寻址模式">3.3.3 PC相对寻址模式<a hidden class="anchor" aria-hidden="true" href="#333-pc相对寻址模式">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// LDR指令访问标签的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LDR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>label<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h3 id="334-ldr伪指令">3.3.4 LDR伪指令<a hidden class="anchor" aria-hidden="true" href="#334-ldr伪指令">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// LDR伪指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LDR Xt, <span style="color:#f92672">=&lt;</span>label<span style="color:#f92672">&gt;</span>  <span style="color:#75715e">// 把label标记的地址加载到Xt寄存器
</span></span></span></code></pre></div><p> Linux内核实现重定位伪代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>__primary_switch:
</span></span><span style="display:flex;"><span>	adrp  x1, init_pg_dir
</span></span><span style="display:flex;"><span>	b1  __enable_mmu  <span style="color:#75715e">// 打开MMU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	ldr  x8, <span style="color:#f92672">=</span>__primary_switched  <span style="color:#75715e">// 跳转 到链接地址，即内核空间虚拟地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	adrp  x0, __PHYS_OFFSET  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	br  x8
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(__primary_switch)
</span></span></code></pre></div><h2 id="34-加载与存储指令变种">3.4 加载与存储指令变种<a hidden class="anchor" aria-hidden="true" href="#34-加载与存储指令变种">#</a></h2>
<h3 id="341-不同位宽加载与存储指令">3.4.1 不同位宽加载与存储指令<a hidden class="anchor" aria-hidden="true" href="#341-不同位宽加载与存储指令">#</a></h3>
<p> LDR、LDRSW、LDRB、LDRSB、LDRH、LDRSH、STRB、STRH</p>
<h3 id="342-不可扩展加载与存储指令">3.4.2 不可扩展加载与存储指令<a hidden class="anchor" aria-hidden="true" href="#342-不可扩展加载与存储指令">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDUR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>{, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>simm<span style="color:#f92672">&gt;</span>}]
</span></span><span style="display:flex;"><span>STUR <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>{, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>simm<span style="color:#f92672">&gt;</span>}]
</span></span></code></pre></div><p> 不可扩展LDUR和STUR数据位宽变种</p>
<h3 id="343-多字节内存加载与存储指令">3.4.3 多字节内存加载与存储指令<a hidden class="anchor" aria-hidden="true" href="#343-多字节内存加载与存储指令">#</a></h3>
<p> A64提供LDP和STP指令</p>
<h4 id="1基地址偏移量模式">1.基地址偏移量模式<a hidden class="anchor" aria-hidden="true" href="#1基地址偏移量模式">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDP <span style="color:#f92672">&lt;</span>Xt1<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xt2<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>{, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>}]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>STP <span style="color:#f92672">&lt;</span>Xt1<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xt2<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>{, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>}]
</span></span></code></pre></div><h4 id="2前变基模式">2.前变基模式<a hidden class="anchor" aria-hidden="true" href="#2前变基模式">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDP <span style="color:#f92672">&lt;</span>Xt1<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xt2<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>]<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>STP <span style="color:#f92672">&lt;</span>Xt1<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xt2<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>]<span style="color:#f92672">!</span>
</span></span></code></pre></div><h4 id="3后变基模式">3.后变基模式<a hidden class="anchor" aria-hidden="true" href="#3后变基模式">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LDP <span style="color:#f92672">&lt;</span>Xt1<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xt2<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>STP <span style="color:#f92672">&lt;</span>Xt1<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xt2<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h3 id="344-独占内存访问指令">3.4.4 独占内存访问指令<a hidden class="anchor" aria-hidden="true" href="#344-独占内存访问指令">#</a></h3>
<p> ARMv8体系结构独占内存访问(exclusive memory access)指令，A64指令集LDXR指令尝试在内存总线中申请一个独占访问锁，然后访问一个内存地址。STXR会往LDXR指令申请独占访问内存地址中写入新内容。LDXR和STXR组合实现同步操作，如Linux内核自旋锁  <br>
 ARMv8多字节多占内存访问指令，LDXP和STXP</p>
<h3 id="345-隐含加-获取存储-释放内存屏障原语">3.4.5 隐含加-获取/存储-释放内存屏障原语<a hidden class="anchor" aria-hidden="true" href="#345-隐含加-获取存储-释放内存屏障原语">#</a></h3>
<p> 内存屏障原语LDAR和STAR</p>
<h3 id="346-非特权访问级别加载和存储指令">3.4.6 非特权访问级别加载和存储指令<a hidden class="anchor" aria-hidden="true" href="#346-非特权访问级别加载和存储指令">#</a></h3>
<h2 id="35-入栈和出栈">3.5 入栈和出栈<a hidden class="anchor" aria-hidden="true" href="#35-入栈和出栈">#</a></h2>
<p> 栈(stack)后进先出数据结构，保存：</p>
<ul>
<li>临时存储数据，如局部变量</li>
<li>参数：参数小于等于8个，用X0~X7通用寄存器传递，超过8个使用栈</li>
</ul>
<p> 栈从高地址向低地址扩展，栈指针(Stack Pointer SP)指向栈顶  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 栈向下扩展16字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stp x29, x30, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">-</span><span style="color:#ae81ff">16</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add sp, sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放8字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>add sp, sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ldp x29, x30, [sp], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span></code></pre></div><h2 id="36-mov指令">3.6 MOV指令<a hidden class="anchor" aria-hidden="true" href="#36-mov指令">#</a></h2>
<p> MOV指令寄存器直接搬移和立即数搬移</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 寄存器搬移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MOV <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 立即数搬移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MOV <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MOVZ <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm16<span style="color:#f92672">&gt;</span>, LSL <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>shift<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ORR <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, XZR, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p> objdump指令查看MOV指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>aarch64<span style="color:#f92672">-</span>linux<span style="color:#f92672">-</span>gnu<span style="color:#f92672">-</span>objdump <span style="color:#f92672">-</span>s <span style="color:#f92672">-</span>d  <span style="color:#f92672">-</span>M no<span style="color:#f92672">-</span>aliases test.o
</span></span></code></pre></div><br>
<h1 id="第4章-a64指令集2--算术与移位指令">第4章 A64指令集2 —— 算术与移位指令<a hidden class="anchor" aria-hidden="true" href="#第4章-a64指令集2--算术与移位指令">#</a></h1>
<ul>
<li>N、Z、C、V 4个条件标志位作用</li>
</ul>
<h2 id="41-条件操作码">4.1 条件操作码<a hidden class="anchor" aria-hidden="true" href="#41-条件操作码">#</a></h2>
<p> A64指令集在PSTATE寄存器中有4个条件标志位，N 负数、 Z 零、 C 进位、 V 溢出  <br></p>
<h2 id="42-加法和减肥指令">4.2 加法和减肥指令<a hidden class="anchor" aria-hidden="true" href="#42-加法和减肥指令">#</a></h2>
<h3 id="421-加法">4.2.1 加法<a hidden class="anchor" aria-hidden="true" href="#421-加法">#</a></h3>
<p> add、adds、adc</p>
<h3 id="422-减法">4.2.2 减法<a hidden class="anchor" aria-hidden="true" href="#422-减法">#</a></h3>
<p> SUB、SUBS</p>
<h2 id="43-cmp指令">4.3 CMP指令<a hidden class="anchor" aria-hidden="true" href="#43-cmp指令">#</a></h2>
<p> A64指令集中 CMP指令内部调用SUBS指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 立即数的CMP指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CMP <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>{, <span style="color:#f92672">&lt;</span>shift<span style="color:#f92672">&gt;</span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上述等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SUBS XZR, <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span> {, <span style="color:#f92672">&lt;</span>shift<span style="color:#f92672">&gt;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 寄存器的CMP指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CMP <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;&lt;</span>m<span style="color:#f92672">&gt;</span>{, <span style="color:#f92672">&lt;</span>extend<span style="color:#f92672">&gt;</span> {<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>amount<span style="color:#f92672">&gt;</span>}}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 移位操作的CMP指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CMP指令于添加操作后缀
</span></span></span></code></pre></div><h2 id="44-条件表示位">4.4 条件表示位<a hidden class="anchor" aria-hidden="true" href="#44-条件表示位">#</a></h2>
<h2 id="45-移位指令">4.5 移位指令<a hidden class="anchor" aria-hidden="true" href="#45-移位指令">#</a></h2>
<p> 常见移位指令：</p>
<ul>
<li>LSL：逻辑左移，最高位丢弃，最低位补0</li>
<li>LSR：逻辑右移，最高位补0，最低位丢弃</li>
<li>ASR：算术右移，最低位丢弃，最高位按符号位扩展</li>
<li>ROR：循环右移，最低位移到最高位</li>
</ul>
<h2 id="46-位操作指令">4.6 位操作指令<a hidden class="anchor" aria-hidden="true" href="#46-位操作指令">#</a></h2>
<p> 两种与操作指令</p>
<ul>
<li>AND：按位与操作</li>
<li>ANDS：带条件标志位与操作，影响Z标志位</li>
</ul>
<p> 或操作指令</p>
<ul>
<li>ORR</li>
<li>EOR 异或</li>
</ul>
<p> 位清除操作</p>
<ul>
<li>BIC</li>
</ul>
<p> CLZ指令 计算为1的最高位前面有几个零</p>
<h2 id="47-位段操作指令">4.7 位段操作指令<a hidden class="anchor" aria-hidden="true" href="#47-位段操作指令">#</a></h2>
<p> 1.位段插入操作指令 BFI</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"></code></pre></div><p> 2.位段提取操作指令 UBFX</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"></code></pre></div><br>
<h1 id="第5章-a64指令集3--比较指令与跳转指令">第5章 A64指令集3 —— 比较指令与跳转指令<a hidden class="anchor" aria-hidden="true" href="#第5章-a64指令集3--比较指令与跳转指令">#</a></h1>
<ul>
<li>RET与ERET</li>
</ul>
<h2 id="51-比较指令">5.1 比较指令<a hidden class="anchor" aria-hidden="true" href="#51-比较指令">#</a></h2>
<p> 比较指令</p>
<ul>
<li>CMP  CMN</li>
<li>CSEL：条件选择指令</li>
<li>CSET：条件置位指令</li>
<li>CSINC：条件选择并增加指令</li>
</ul>
<h3 id="511-cmn指令">5.1.1 CMN指令<a hidden class="anchor" aria-hidden="true" href="#511-cmn指令">#</a></h3>
<p> CMN指令将一个数与另一个数相反数进行比较</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>CMN <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>imm<span style="color:#f92672">&gt;</span>{, <span style="color:#f92672">&lt;</span>shift<span style="color:#f92672">&gt;</span>}
</span></span><span style="display:flex;"><span>CMN <span style="color:#f92672">&lt;</span>XN<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;&lt;</span>m<span style="color:#f92672">&gt;</span>{, <span style="color:#f92672">&lt;</span>extend<span style="color:#f92672">&gt;</span> {<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#f92672">&lt;</span>amount<span style="color:#f92672">&gt;</span>}}
</span></span></code></pre></div><h3 id="512-csel指令">5.1.2 CSEL指令<a hidden class="anchor" aria-hidden="true" href="#512-csel指令">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// cond为真，返回Xn，为假，返回Xm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CSEL <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xm<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>cond<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h3 id="513-cset指令">5.1.3 CSET指令<a hidden class="anchor" aria-hidden="true" href="#513-cset指令">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// cond为真，Xd寄存器为1，否则为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CSET <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>cond<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h3 id="514-csinc指令">5.1.4 CSINC指令<a hidden class="anchor" aria-hidden="true" href="#514-csinc指令">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// cond为真，返回Xn寄存器值，否则返回Xm寄存器值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CSINC <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Xm<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>cond<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h2 id="52-跳转与返回指令">5.2 跳转与返回指令<a hidden class="anchor" aria-hidden="true" href="#52-跳转与返回指令">#</a></h2>
<h3 id="521-跳转指令">5.2.1 跳转指令<a hidden class="anchor" aria-hidden="true" href="#521-跳转指令">#</a></h3>
<table>
	<tr>
	    <th>指   令</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>B</td>
	    <td>跳转指令<br> B Lable</td>
	</tr>
	<tr>
	    <td>B.cond</td>
	    <td>有条件跳转指令<br> B.cond Lable</td>
	</tr>
	<tr>
	    <td>BL</td>
	    <td>带返回值跳转指令<br> BL Lable</td>
	</tr>
	<tr>
	    <td>BR</td>
	    <td>跳转到寄存器指定地址<br> BR Xn</td>
	</tr>
	<tr>
	    <td>BLR</td>
	    <td>跳转到寄存器指定地址<br> BLR Xn</td>
	</tr>
</table>
<h3 id="522-返回指令">5.2.2 返回指令<a hidden class="anchor" aria-hidden="true" href="#522-返回指令">#</a></h3>
<p> A64两条返回指令： <br></p>
<ul>
<li>RET：用于子函数返回，返回地址保存在LR</li>
<li>ERET：从当前的异常模式返回，把SPSR内容恢复到PSTATE寄存器中，从ELR中获取跳转地址并返回到该地址，ERET可实现处理器模式切换，如EL1到EL0</li>
</ul>
<h3 id="523-比较跳转指令">5.2.3 比较跳转指令<a hidden class="anchor" aria-hidden="true" href="#523-比较跳转指令">#</a></h3>
<table>
	<tr>
	    <th>指   令</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>CBZ</td>
	    <td>比较并跳转指令<br> CBZ Xt, Lable</td>
	</tr>
	<tr>
	    <td>CBNZ</td>
	    <td>比较并跳转指令<br> CBNZ Xt, Lable</td>
	</tr>
	<tr>
	    <td>TBZ</td>
	    <td>测试位并跳转指令<br> TBZ R< t>, #imm, lable</td>
	</tr>
	<tr>
	    <td>TBNZ</td>
	    <td>测试并跳转指令<br> TBNZ R< t>， #imm, lable</td>
	</tr>
</table>
<br>
<h1 id="第6章-a64指令集--其他重要指令">第6章 A64指令集 —— 其他重要指令<a hidden class="anchor" aria-hidden="true" href="#第6章-a64指令集--其他重要指令">#</a></h1>
<ul>
<li>ADR/ADRP与伪指令LDR</li>
<li>ADRP指令获取的是与 4KB 对齐的地址</li>
</ul>
<h2 id="61-pc相对地址加载指令">6.1 PC相对地址加载指令<a hidden class="anchor" aria-hidden="true" href="#61-pc相对地址加载指令">#</a></h2>
<p> A64指令集PC相对地址加载指令——ADR和ADRP指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ADR 加载当前PC值+-1MB范围内label地址到Xd寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ADR <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>label<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ADRP 加载当前PC值一段范围内的label地址到Xd寄存器，与label地址按4Kb对齐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 即偏移量位 -4Gb~4GB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ADRP <span style="color:#f92672">&lt;</span>Xd<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>label<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h2 id="62-ldr与adrp指令区别">6.2 LDR与ADRP指令区别<a hidden class="anchor" aria-hidden="true" href="#62-ldr与adrp指令区别">#</a></h2>
<p> 树莓派上电复位后，固件(BOOTROM)把很想加载到<code>0x80000</code>地址处  <br>
 LDR伪指令加载的是绝对地址，即程序编译是的链接地址。ADR/ADRP指令加载的是当前PC的相对地址(PC relative-address)，即当前PC值加上label的偏移量，理解位当前运行是label的物理地址  <br></p>
<h2 id="63-独占内存访问指令">6.3 独占内存访问指令<a hidden class="anchor" aria-hidden="true" href="#63-独占内存访问指令">#</a></h2>
<p> ARMv8体系结构，A64指令集，LDXR指令尝试在内存总线中申请一个独占访问的锁，然后访问一个内存地址。STXR指令会往LDXR指令已经申请的独占访问内存地址宏写入新内容。  <br></p>
<h2 id="64-异常处理指令">6.4 异常处理指令<a hidden class="anchor" aria-hidden="true" href="#64-异常处理指令">#</a></h2>
<table>
	<tr>
	    <th>指   令</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>SVC</td>
	    <td>系统调用指令<br> SVC #imm</td>
	</tr>
	<tr>
	    <td>HVC</td>
	    <td>虚拟化系统调用指令<br> HVC #imm</td>
	</tr>
	<tr>
	    <td>SMC</td>
	    <td>安全监控系统调用指令<br> SMC #imm</td>
	</tr>
</table>
<h2 id="65-系统寄存器访问指令">6.5 系统寄存器访问指令<a hidden class="anchor" aria-hidden="true" href="#65-系统寄存器访问指令">#</a></h2>
<p> ARMv8体系结构MRS和MSR指令直接访问寄存器  <br></p>
<table>
	<tr>
	    <th>指   令</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>MRS</td>
	    <td>读取系统寄存器的值到通用寄存器</td>
	</tr>
	<tr>
	    <td>MSR</td>
	    <td>更新系统寄存器的值</td>
	</tr>
</table>
<p> ARMv8体系结构7类系统寄存器  <br></p>
<ul>
<li>通用系统控制寄存器(System Control Register SCTLR)</li>
<li>调试寄存器</li>
<li>性能监控寄存器</li>
<li>活动监控寄存器</li>
<li>统计扩展寄存器</li>
<li>RAS寄存器</li>
<li>通用定时寄存器</li>
</ul>
<table>
	<tr>
	    <th>特殊系统寄存器</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>CurrentEL</td>
	    <td>获取当前系统的异常等级</td>
	</tr>
	<tr>
	    <td>DAIF</td>
	    <td>获取和设置PSTATE寄存器中的DAIF掩码</td>
	</tr>
	<tr>
	    <td>NZCV</td>
	    <td>获取和设置PSTATE寄存器中的条件掩码</td>
	</tr>
	<tr>
	    <td>PAN</td>
	    <td>获取和设置PSTATE寄存器中的PAN掩码</td>
	</tr>
	<tr>
	    <td>SPSel</td>
	    <td>获取和设置当前寄存器的SP寄存器</td>
	</tr>
	<tr>
	    <td>UAO</td>
	    <td>获取和设置PSTATE寄存器中的UAO掩码</td>
	</tr>
</table>
<h2 id="66-内存屏障指令">6.6 内存屏障指令<a hidden class="anchor" aria-hidden="true" href="#66-内存屏障指令">#</a></h2>
<p> ARMv8体系结构是弱一致性内存模型，内存访问次序可能和程序预取顺序不一样</p>
<table>
	<tr>
	    <th>指   令</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>DMB</td>
	    <td>数据存储屏障，确保在执行新的存储访问前所有存储器访问都已完成</td>
	</tr>
	<tr>
	    <td>DSB</td>
	    <td>数据同步屏障，确保在下一个指令执行前所有存储器访问都已完成</td>
	</tr>
<tr>
	    <td>ISB</td>
	    <td>指令同步屏障，清空流水线，确保在执行新的指令前，之前所有指令都已完成</td>
	</tr>
</table>
<p> 新的加载和存储指令</p>
<table>
	<tr>
	    <th>指   令</th>
	    <th>描　 述</th>
	</tr>
	<tr>
	    <td>LDAR</td>
	    <td>加载-获取(laod-acquire)指令 <br> LDAR指令后面的读写内存指令必须在LDAR指令之前执行</td>
	</tr>
	<tr>
	    <td>STLR</td>
	    <td>存储-释放(store-release)指令 <br> 所有的加载和存储指令必须在STLR指令之前完成</td>
	</tr>
</table>
<br>
<h1 id="第7章-a64指令集的陷阱">第7章 A64指令集的陷阱<a hidden class="anchor" aria-hidden="true" href="#第7章-a64指令集的陷阱">#</a></h1>
<h2 id="71-加载宏标签">7.1 加载宏标签<a hidden class="anchor" aria-hidden="true" href="#71-加载宏标签">#</a></h2>
<p> ARMv8体系结构，在没有使能MMU情况下，访问内存地址变成访问设备类型的内存(device memory)。内存类型分为普通类型内存和设备类型内存  <br>
 对设备类型内服访问发起不对齐访问，会触发对齐异常 <br>
 系统MMU使能后，访问内存变成了访问普通类型内存，对普通类型内存发起一个不对齐访问，分为两种情况</p>
<ul>
<li>当SCTLR_ELx寄存器的A字段为1时，触发一个对齐异常</li>
<li>当SCTLR_ELx寄存器的A字段为0时，系统自动完成不对齐访问</li>
</ul>
<h2 id="72-加载字符串">7.2 加载字符串<a hidden class="anchor" aria-hidden="true" href="#72-加载字符串">#</a></h2>
<h2 id="73-读写寄存器导致树莓派死机">7.3 读写寄存器导致树莓派死机<a hidden class="anchor" aria-hidden="true" href="#73-读写寄存器导致树莓派死机">#</a></h2>
<h2 id="74-ldxr指令导致水平4b死机">7.4 LDXR指令导致水平4B死机<a hidden class="anchor" aria-hidden="true" href="#74-ldxr指令导致水平4b死机">#</a></h2>
<h2 id="75-在汇编中实现串口输出功能">7.5 在汇编中实现串口输出功能<a hidden class="anchor" aria-hidden="true" href="#75-在汇编中实现串口输出功能">#</a></h2>
<h2 id="76-纷享linux50的启动汇编代码">7.6 纷享Linux5.0的启动汇编代码<a hidden class="anchor" aria-hidden="true" href="#76-纷享linux50的启动汇编代码">#</a></h2>
<p> Linux内核入口函数<code>stext</code>，在<code>arch/arm64/kernel/haed.S</code>汇编文件中实现。系统上电复位后，启动引导程序(bootloader)或BIOS初始化，最终跳转到Linux内核入口函数<code>stext</code>汇编函数，启动引导程序必要初始化，如内存设备初始化、磁盘设备初始化以及将内核镜像加载到运行地址，然后跳转到Linux内核入口。  <br>
 内核汇编入口到C语言入口<code>start_kernel()</code>函数之间的汇编代码</p>
<br>
<h1 id="第8章-gnu汇编器">第8章 GNU汇编器<a hidden class="anchor" aria-hidden="true" href="#第8章-gnu汇编器">#</a></h1>
<ul>
<li>汇编器</li>
<li>符号</li>
<li>伪指令</li>
<li>kernel_ventry宏</li>
</ul>
<p> 汇编代码同汇编器生成目标代码，然后由连接器链接成可执行二进制程序  <br>
 ARM64汇编器：1）ARM公司汇编器，2）GNU项目AS汇编器  <br>
 aarch64-linux-gnu，级汇编后文件Wieaarch64体系结构   <br></p>
<h2 id="81-编译流程与elf文件">8.1 编译流程与ELF文件<a hidden class="anchor" aria-hidden="true" href="#81-编译流程与elf文件">#</a></h2>
<p> GCC编译流程：   <br>
 1）预处理(pre-process)，GCC预处理器(cpp)，生成 *.i 文件  <br>
 2）编译(compile)，C语言编译器(ccl)，对预处理文件进行词法、语法分析及语义分析    <br>
 3）汇编(assemble)，汇编器(as)把汇编代码翻译成机器语言，并生成可重定位目标文件     <br>
 4）链接(link)，连接器(ld)把所有生成可重定位目标文件以及用到的库文件综合成可执行二进制文件   <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>gcc -E text.c -o text.i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gcc -S text.i -o text.s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>as test.s -o test.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ld -o test test.o -lc
</span></span></code></pre></div><p> ELF格式，待补充链接  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ld --version
</span></span></code></pre></div><p> 链接器在链接过程中对所有输入可重定位目标文件的符号表进行符号解析和重定位，每个符号在输出文件的相应段中得到一个确定的地址，最终生成一个符号表(symbol table)  <br></p>
<h2 id="82-汇编程序">8.2 汇编程序<a hidden class="anchor" aria-hidden="true" href="#82-汇编程序">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># -o 输出二进制  -Map 输出符号表  -lc 链接libc库</span>
</span></span><span style="display:flex;"><span>ld test.o -o test -Map test.map -lc
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 获取程序符号表 -s 显示符号表内容</span>
</span></span><span style="display:flex;"><span>readelf -s test 
</span></span></code></pre></div><h2 id="83-汇编语法">8.3 汇编语法<a hidden class="anchor" aria-hidden="true" href="#83-汇编语法">#</a></h2>
<p> 汇编代码注释 单行 <code>#</code> 或 <code>//</code> ，多行 <code>/* */</code>  <br>
 符号可表示地址、变量或函数   <br>
 全局符号：使用global声明   <br>
 本地符号：在本地汇编代码中引用   <br>
 本地标签：供汇编器和程序员临时使用   <br></p>
<h2 id="84-常用伪指令">8.4 常用伪指令<a hidden class="anchor" aria-hidden="true" href="#84-常用伪指令">#</a></h2>
<p> 伪指令仅在汇编器编译期间起作用   <br></p>
<p>  .align 对齐伪指令   <br></p>
<p> 数据定义伪指令   <br></p>
<p> 函数相关伪指令    <br></p>
<p> 段相关伪指令  <br></p>
<p>  .section 伪指令 <br></p>
<p> 宏相关伪指令  <br></p>
<h2 id="85-aarch64依赖特性">8.5 AArch64依赖特性<a hidden class="anchor" aria-hidden="true" href="#85-aarch64依赖特性">#</a></h2>
<p> AArch64特有命令行选项  <br></p>
<br>
<h1 id="第9章-链接器与链接脚本">第9章 链接器与链接脚本<a hidden class="anchor" aria-hidden="true" href="#第9章-链接器与链接脚本">#</a></h1>
<ul>
<li>链接器LD</li>
<li>链接脚本</li>
<li>加载地址、虚拟地址和链接地址</li>
<li>位置无关代码</li>
<li>重定位、Uboot重定位、打开MMU后重定位</li>
</ul>
<h2 id="91-链接器">9.1 链接器<a hidden class="anchor" aria-hidden="true" href="#91-链接器">#</a></h2>
<p> 链接器把目标文件(包括标准库函数目标文件)的代码段、数据段及符号表等内容按照某种格式(ELF)组合成一个可执行二进制文件  <br>
 链接器使用链接脚本(Linker Script LS)语言，链接脚本把二进制文件.o，综合成可执行二进制文件 <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ld -o mytest test1.o test2.o -lc
</span></span></code></pre></div><p> ld命令选项  <br></p>
<h2 id="93-链接脚本">9.3 链接脚本<a hidden class="anchor" aria-hidden="true" href="#93-链接脚本">#</a></h2>
<p> 链接器使用<code>-T</code>参数指定链接脚本，不指定使用内置链接脚本  <br></p>
<h3 id="921-链接程序">9.2.1 链接程序<a hidden class="anchor" aria-hidden="true" href="#921-链接程序">#</a></h3>
<p> 可执行程序由代码段、数据段、未初始化数据段。  <br>
 Linux内置链接脚本是vmlinux.lds.S文件  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	. <span style="color:#f92672">=</span> 0X10000;
</span></span><span style="display:flex;"><span>	.text : <span style="color:#f92672">{</span> *<span style="color:#f92672">{</span>.text<span style="color:#f92672">}</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	. <span style="color:#f92672">=</span> 0x8000000;
</span></span><span style="display:flex;"><span>	.data : <span style="color:#f92672">{</span> *<span style="color:#f92672">{</span>.data<span style="color:#f92672">}</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	.bss : <span style="color:#f92672">{</span> *<span style="color:#f92672">{</span>.bss<span style="color:#f92672">}</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="922-设置入口点">9.2.2 设置入口点<a hidden class="anchor" aria-hidden="true" href="#922-设置入口点">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ENTRY<span style="color:#f92672">(</span>symbol<span style="color:#f92672">)</span>
</span></span></code></pre></div><h3 id="923">9.2.3<a hidden class="anchor" aria-hidden="true" href="#923">#</a></h3>
<p> 输出段和输入段包括段的名字、大小、可加载属性及可分配属性。可加载属性用于在运行是加载这些段内容到内存中，可分配属性用于在内存中预留一个区域，并不会加载这个区域内容  <br>
 链接脚本关于段地址：加载地址和虚拟地址，加载地址是加载时段所在的地址，运行地址是虚拟地址是运行是所在的地址。通常两个地址相同的，不同情况是代码段被加载到ROM中，在程序启动是被复制到RAM中，即 ROM地址是加载地址，RAM地址是虚拟地址 <br></p>
<h3 id="927-常用内建函数">9.2.7 常用内建函数<a hidden class="anchor" aria-hidden="true" href="#927-常用内建函数">#</a></h3>
<p> 链接脚本语言包含内建函数  <br></p>
<h4 id="1absoluteexp">1.ABSOLUTE(exp)<a hidden class="anchor" aria-hidden="true" href="#1absoluteexp">#</a></h4>
<h4 id="2addrsection">2.ADDR(section)<a hidden class="anchor" aria-hidden="true" href="#2addrsection">#</a></h4>
<h4 id="3alignalign">3.ALIGN(align)<a hidden class="anchor" aria-hidden="true" href="#3alignalign">#</a></h4>
<h4 id="4sizeofsection">4.SIZEOF(section)<a hidden class="anchor" aria-hidden="true" href="#4sizeofsection">#</a></h4>
<h2 id="93-重定位">9.3 重定位<a hidden class="anchor" aria-hidden="true" href="#93-重定位">#</a></h2>
<p> <strong>加载地址</strong>：存储代码的物理地址，GNU链接脚本里为LMA  <br>
 <strong>运行地址</strong>：程序运行时地址，GNU链接脚本里为VMA   <br>
 <strong>链接地址</strong>：在编译、链接时指定的地址，使用<code>aarch64-linux-gnu-objdump</code>工具进行反汇编时查看的就是链接地址  <br></p>
<h3 id="931-benos重定位">9.3.1 BenOS重定位<a hidden class="anchor" aria-hidden="true" href="#931-benos重定位">#</a></h3>
<h3 id="932-uboot和linux内核重定位">9.3.2 UBoot和Linux内核重定位<a hidden class="anchor" aria-hidden="true" href="#932-uboot和linux内核重定位">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux5.0/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	__primary_switch;
</span></span><span style="display:flex;"><span>	adrp	x1, init_pg_dir
</span></span><span style="display:flex;"><span>	bl		__enable_mmu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ldr 	x8, <span style="color:#f92672">=</span>__primary_switched
</span></span><span style="display:flex;"><span>	adrp	x0, __PHY_OFFSET
</span></span><span style="display:flex;"><span>	br		x8
</span></span></code></pre></div><br>
<h1 id="第10章-gcc内嵌汇编代码">第10章 GCC内嵌汇编代码<a hidden class="anchor" aria-hidden="true" href="#第10章-gcc内嵌汇编代码">#</a></h1>
<ul>
<li>内嵌汇编代码关键字asm、volatile、inline及goto</li>
<li>内嵌汇编代码输出部分 = 和 +</li>
<li>内嵌汇编代码输出部分和输入部分的参数</li>
<li>内嵌汇编代码 # 和 ##</li>
</ul>
<h2 id="101-内嵌汇编代码基本用法">10.1 内嵌汇编代码基本用法<a hidden class="anchor" aria-hidden="true" href="#101-内嵌汇编代码基本用法">#</a></h2>
<p> 内嵌汇编代码两种形式：  <br>
 基础内嵌汇编代码，不带参数   <br>
 扩展内嵌汇编代码，可带输入/输出参数  <br></p>
<h3 id="1011-基础内嵌汇编代码">10.1.1 基础内嵌汇编代码<a hidden class="anchor" aria-hidden="true" href="#1011-基础内嵌汇编代码">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">asm</span> { <span style="color:#e6db74">&#34;汇编指令&#34;</span> }
</span></span></code></pre></div><h3 id="1012-扩展内嵌汇编代码">10.1.2 扩展内嵌汇编代码<a hidden class="anchor" aria-hidden="true" href="#1012-扩展内嵌汇编代码">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">asm</span> <span style="color:#960050;background-color:#1e0010">修饰词</span>(
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">指令部分</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">:</span> <span style="color:#960050;background-color:#1e0010">输出部分</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">:</span> <span style="color:#960050;background-color:#1e0010">输入部分</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">:</span> <span style="color:#960050;background-color:#1e0010">损坏部分</span>)
</span></span></code></pre></div><p> 常用修饰符: <br>
 volatile：关闭GCC优化  <br>
 inline：内联，GCC把汇编代码编译为尽可能短的代码  <br>
 goto：跳转到C语言标签   <br></p>
<h3 id="1013-内嵌汇编代码的修饰符和约束符">10.1.3 内嵌汇编代码的修饰符和约束符<a hidden class="anchor" aria-hidden="true" href="#1013-内嵌汇编代码的修饰符和约束符">#</a></h3>
<h3 id="1014-使用汇编符号名">10.1.4 使用汇编符号名<a hidden class="anchor" aria-hidden="true" href="#1014-使用汇编符号名">#</a></h3>
<h3 id="1015-内嵌汇编函数与宏结合">10.1.5 内嵌汇编函数与宏结合<a hidden class="anchor" aria-hidden="true" href="#1015-内嵌汇编函数与宏结合">#</a></h3>
<h3 id="1016-使用goto修饰符">10.1.6 使用goto修饰符<a hidden class="anchor" aria-hidden="true" href="#1016-使用goto修饰符">#</a></h3>
<br>
<h1 id="第11章-异常处理">第11章 异常处理<a hidden class="anchor" aria-hidden="true" href="#第11章-异常处理">#</a></h1>
<ul>
<li>ARM64处理器，异常类型</li>
<li>ARM64处理器异常等级</li>
<li>同步异常和异步异常</li>
<li>ARM64处理器异常发生后CPU处理</li>
<li>LR和ELR返回地址</li>
</ul>
<h2 id="111-异常处理基本概念">11.1 异常处理基本概念<a hidden class="anchor" aria-hidden="true" href="#111-异常处理基本概念">#</a></h2>
<p> ARMv8体系结构中，异常和中断都属于异常处理</p>
<h3 id="1111-异常类型">11.1.1 异常类型<a hidden class="anchor" aria-hidden="true" href="#1111-异常类型">#</a></h3>
<h4 id="1中断">1.中断<a hidden class="anchor" aria-hidden="true" href="#1中断">#</a></h4>
<p> ARM64处理器中，中断请求分成普通中断请求(Interrupt Request IRQ)和快速中断请求(Fast Interrupt Request FIQ)</p>
<h4 id="2中止">2.中止<a hidden class="anchor" aria-hidden="true" href="#2中止">#</a></h4>
<p> 中止主要有指令中止(Instruction abort)和数据中止(data abort)两种，指访问内存地址发生错误(如缺页)，处理器内部的MMU捕获这些错误并且报告给处理器，指令中止是指当前处理器尝试执行某条指令时发生错误，数据中止指使用加载或存储指令读写外部存储单元发生错误  <br></p>
<h4 id="3复位">3.复位<a hidden class="anchor" aria-hidden="true" href="#3复位">#</a></h4>
<p> 复位(reset)，由CPU复位引脚产生复位信号，让CPU进入复位状态，并重新启动  <br></p>
<h4 id="4系统调用">4.系统调用<a hidden class="anchor" aria-hidden="true" href="#4系统调用">#</a></h4>
<p> ARMv8体系结构提供3中软件尝试的异常和3种系统调用</p>
<ul>
<li>SVC指令：用户态程序请求操作系统内核的服务</li>
<li>HVC指令：客户操作系统(guest OS)请求虚拟机监控器(hypervisor)的服务</li>
<li>SMC指令：普通世界中的程序请求安全监控器(secure monitor)</li>
</ul>
<h3 id="1112-异常等级">11.1.2 异常等级<a hidden class="anchor" aria-hidden="true" href="#1112-异常等级">#</a></h3>
<p> 处理器两种运行模式：一种是特权模式，另一种是非特权模式，操作系统内核运行在特权模式  <br>
 ARM64处理器支持4种特权模式，异常等级(Exception Level EL)：</p>
<ul>
<li>EL0 非特权模式，运行应用程序</li>
<li>EL1 特权模式，运行操作系统内核</li>
<li>EL2 运行虚拟化管理程序</li>
<li>EL3 运行安全世界的管理程序</li>
</ul>
<h3 id="1113-同步异常和异步异常">11.1.3 同步异常和异步异常<a hidden class="anchor" aria-hidden="true" href="#1113-同步异常和异步异常">#</a></h3>
<p> 异常分成同步异常和异步异常两种，同步异常是处理器执行某条指令而直接导致的异常，指令异常和数据异常为同步异常  <br>
 中断称为异步异常  <br>
 异步异常包括物理中断和虚拟中断：</p>
<ul>
<li>物理中断分为3种：SError、IRQ、FIQ</li>
<li>虚拟中断分为3种：VSError、vIRQ、vFIQ</li>
</ul>
<h2 id="112-异常处理与返回">11.2 异常处理与返回<a hidden class="anchor" aria-hidden="true" href="#112-异常处理与返回">#</a></h2>
<h3 id="1121-异常入口">11.2.1 异常入口<a hidden class="anchor" aria-hidden="true" href="#1121-异常入口">#</a></h3>
<p> CPU内核感知异常发生，生成一个目标异常等级，CPU会做： <br>
 1）把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx中 <br>
 2）把返回地址保存到对应目标异常等级的ELR_ELx中  <br>
 3）把PSTATE寄存器中D、A、I、F标志位置为1，禁止中断 <br>
 4）对于同步异常，分析异常原因，写入ESR_ELx  <br>
 5）切换SP寄存器为目标异常等级的SP_ELx寄存器 <br>
 6）从异常现场的异常等级切换到对应的目标异常等级，然后跳转到异常向量表 <br></p>
<h3 id="1122-异常返回">11.2.2 异常返回<a hidden class="anchor" aria-hidden="true" href="#1122-异常返回">#</a></h3>
<p> 操作系统系统处理完后，执行一条ERET指令从异常返回，指令执行如下操作： <bt>
 1）从ELR_ELx中恢复PC指针  <br>
 2）从SPSR_ELx中恢复PSTATE寄存器的状态  <br></p>
<h3 id="1123-异常返回地址">11.2.3 异常返回地址<a hidden class="anchor" aria-hidden="true" href="#1123-异常返回地址">#</a></h3>
<p> 两个寄存器存放不同返回地址： <br>
 1）X30寄存器(LR)，存放子函数的返回地址，函数完成调用RET指令返回父函数 <br>
 2）ELR_ELx，存放异常返回地址，执行ERET指令返回异常现场  <br></p>
<h3 id="1124-异常处理路由">11.2.4 异常处理路由<a hidden class="anchor" aria-hidden="true" href="#1124-异常处理路由">#</a></h3>
<p> 异常处理路由指的是当异常发生时应该在哪个异常等级处理</p>
<h3 id="1125-栈选择">11.2.5 栈选择<a hidden class="anchor" aria-hidden="true" href="#1125-栈选择">#</a></h3>
<p> ARMv8体系结构，每个异常等级都有对应的栈指针(SP)寄存器，通过SPSel寄存器配置SP，SPSel寄存器SP字段0，EL使用SP_EL0作为栈指针，1表示SP_ELx作为栈指针寄存器 <br>
 栈必须16字节对齐</p>
<h3 id="1126-异常处理的执行状态">11.2.6 异常处理的执行状态<a hidden class="anchor" aria-hidden="true" href="#1126-异常处理的执行状态">#</a></h3>
<h3 id="1127-异常返回的执行状态">11.2.7 异常返回的执行状态<a hidden class="anchor" aria-hidden="true" href="#1127-异常返回的执行状态">#</a></h3>
<p> SPSR决定ERET指令返回是不是切换执行模式</p>
<h2 id="113-异常向量表">11.3 异常向量表<a hidden class="anchor" aria-hidden="true" href="#113-异常向量表">#</a></h2>
<h3 id="1131-armv8异常向量表">11.3.1 ARMv8异常向量表<a hidden class="anchor" aria-hidden="true" href="#1131-armv8异常向量表">#</a></h3>
<p> 异常相关处理指令存储在内存中，存储位置为异常向量，ARM体系结构中，异常向量存储到一个异常向量表中<br></p>
<table>
	<tr>
	    <th>地  址</th>
	    <th>异 常 类 型</th>
	    <th>描　　述</th>  
	</tr >
	<tr>
	    <td>+ 0x000 </td>
	    <td>同步</td>
	    <td  rowspan="4">使用SP_EL0执行状态的当前异常等级</td>
	</tr>
	<tr>
	    <td>+ 0x080 </td>
	    <td>IRQ/vIRQ</td>
	</tr>
	<tr>
	    <td>+ 0x100 </td>
	    <td>FIQ/vFIQ</td>
	</tr>
	<tr>
	    <td>+ 0x180 </td>
	    <td>SError/vSError</td>
	</tr>
	<tr>
	    <td>+ 0x400 </td>
	    <td>同步</td>
	    <td  rowspan="4">在AArch64执行状态下的低异常等级</td>
	</tr>
	<tr>
	    <td>+ 0x480 </td>
	    <td>IRQ/vIRQ</td>
	</tr>
	<tr>
	    <td>+ 0x500 </td>
	    <td>FIQ/vFIQ</td>
	</tr>
	<tr>
	    <td>+ 0x580 </td>
	    <td>SError/vSError</td>
	</tr>
	<tr>
	    <td>+ 0x600 </td>
	    <td>同步</td>
	    <td  rowspan="4">在AArch32执行状态下的低异常等级</td>
	</tr>
	<tr>
	    <td>+ 0x680 </td>
	    <td>IRQ/vIRQ</td>
	</tr>
	<tr>
	    <td>+ 0x700 </td>
	    <td>FIQ/vFIQ</td>
	</tr>
	<tr>
	    <td>+ 0x780 </td>
	    <td>SError/vSError</td>
	</tr>
</table>
<h3 id="1132-linux50-内核的异常向量表">11.3.2 Linux5.0 内核的异常向量表<a hidden class="anchor" aria-hidden="true" href="#1132-linux50-内核的异常向量表">#</a></h3>
<p> Linux5.0 内核异常向量表在<code>arch/arm64/kernel/entry.S</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>arch<span style="color:#f92672">/</span>arm64<span style="color:#f92672">/</span>kernel<span style="color:#f92672">/</span>entry.S<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><h3 id="1133-vbar_elx">11.3.3 VBAR_ELx<a hidden class="anchor" aria-hidden="true" href="#1133-vbar_elx">#</a></h3>
<p> ARMv8体系结构中VBAR_ELx寄存器来设置异常向量表地址 <br>
 ARMv8体系结构异常向量表特点： <br>
 1）除EL0外，每个EL都有自己的异常向量表 <br>
 2）异常向量表基地址设置到VBAR_ELx中 <br>
 3）异常向量表起始地址必须以2KB字节对齐  <br>
 4）每个表项存放32条指令，共128字节  <br></p>
<h2 id="114-异常现场">11.4 异常现场<a hidden class="anchor" aria-hidden="true" href="#114-异常现场">#</a></h2>
<p> ARM64处理器异常现场，需要在栈空间保存： <br>
 1）PSTATE寄存器的值 <br>
 2）PC值  <br>
 3）SP值  <br>
 4）X0~X30寄存器的值  <br>
 这个栈空间指发生异常时进程的内核态的栈空间 <br></p>
<h2 id="115-同步异常">11.5 同步异常<a hidden class="anchor" aria-hidden="true" href="#115-同步异常">#</a></h2>
<p> ARMv8体系结构中一个访问失效相关寄存器&ndash;异常综合信息寄存器(Exception Syndrome Register ESR)</p>
<h3 id="1151-异常类型">11.5.1 异常类型<a hidden class="anchor" aria-hidden="true" href="#1151-异常类型">#</a></h3>
<h3 id="1152-数据异常">11.5.2 数据异常<a hidden class="anchor" aria-hidden="true" href="#1152-数据异常">#</a></h3>
<br>
<h1 id="第-12-章-中断处理">第 12 章 中断处理<a hidden class="anchor" aria-hidden="true" href="#第-12-章-中断处理">#</a></h1>
<ul>
<li>中断处理一般过程</li>
<li>中断现场</li>
</ul>
<br>
<br>
<br>
<h1 id="参考文档">参考文档<a hidden class="anchor" aria-hidden="true" href="#参考文档">#</a></h1>
<p><a href="https://developer.arm.com/documentation/ddi0557/ab?lang=en">ARM Architecture Reference Manual Supplement®ARMv8.1, for ARMv8-A architecture profile</a></p>
<p><a href="https://developer.arm.com/documentation/den0024/a/?lang=en">ARM Cortex -A Series®®Version: 1.0 Programmer’s Guide for ARMv8-A</a></p>
<p><a href="https://developer.arm.com/documentation/100095/0003/?lang=en">ARM® Cortex®-A72 MPCore Processor Revision: r0p3 Technical Reference Manual</a></p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://liuz0123.gitee.io/zain/img/wechat_pay.jpg" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://liuz0123.gitee.io/zain/img/alipay.jpg" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://liuz0123.gitee.io/zain/posts/tech/mit-6.s081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
    <span class="title">« 上一页</span>
    <br>
    <span>MIT 6.S081操作系统</span>
  </a>
  <a class="next" href="https://liuz0123.gitee.io/zain/posts/blog/linuxcommand/">
    <span class="title">下一页 »</span>
    <br>
    <span>LinuxCommand</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou', 
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2022 
        <a href="https://liuz0123.gitee.io/zain/" style="color:#939393;">zain&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号申请中</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="填自己的公安图标链接" style="float:left;margin: 0px 5px 0px 0px;"/>
             公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
