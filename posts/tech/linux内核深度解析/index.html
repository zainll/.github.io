<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux内核深度解析 | zain&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区">
<meta name="author" content="
&nbsp;Zain">
<link rel="canonical" href="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">
<link crossorigin="anonymous" href="/zain/assets/css/stylesheet.6bbe4903eaf247f5c3db656a51fd7b09d982ab42029edfdc123f359e2748dc03.css" integrity="sha256-a75JA&#43;ryR/XD22VqUf17CdmCq0ICnt/cEj81nidI3AM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/zain/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="apple-touch-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="mask-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Linux内核深度解析" />
<meta property="og:description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-05T00:17:58&#43;08:00" />
<meta property="article:modified_time" content="2022-10-05T00:17:58&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux内核深度解析"/>
<meta name="twitter:description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://liuz0123.gitee.io/zain/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Linux内核深度解析",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux内核深度解析",
  "name": "Linux内核深度解析",
  "description": "内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区",
  "keywords": [
    ""
  ],
  "articleBody": "内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区的互斥 虚拟文件系统 第1章 内核引导和初始化 处理器上电-\u003e执行引导程序-\u003e加载内核到内存-\u003e执行内核-\u003e内核初始化-\u003e启动用户空间第一个进程 ARM64处理器到物理地址0取第一条指令\n1.1 引导程序 1.1.1 入口_start ARM64处理器U-Boot程序执行过程，入口u-boot/arch/arm/cpu/armv8/start.S标识_start\n.globl\t_start _start: #if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER) #include #elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) #include #else b\treset #endif 1.1.2 reset reset: /* Allow the board to save important registers */ /* 允许板卡保存重要的寄存器*/ b\tsave_boot_params .globl\tsave_boot_params_ret save_boot_params_ret: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl // 初始化系统控制寄存器 #endif /* * 异常级别可能是3、2或者1，初始状态： * 小端字节序，禁止MMU，禁止指令/数据缓存 */ adr x0, vectors witch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 // 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址 mrs x0, scr_el3 // 设置安全配置寄存器SCR_EL3 orr x0, x0, #0xf /* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */ msr scr_el3, x0 msr cptr_el3, xzr /* 启用浮点和SIMD功能*/ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* 初始化寄存器CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 // 异常级别2 mov x0, #0x33ff msr cptr_el2, x0 /* 启用浮点和SIMD功能 */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u003c\u003c 20 msr cpacr_el1, x0 /* 启用浮点和SIMD功能 */ 0: … /* 应用ARM处理器特定的勘误表*/ bl apply_core_errata /* 处理器特定的初始化*/ bl lowlevel_init // 执行board_init_f()所需最小初始化 #if defined(CONFIG_ARMV8_SPIN_TABLE) \u0026\u0026 !defined(CONFIG_SPL_BUILD) branch_if_master x0, x1, master_cpu b spin_table_secondary_jump // arch/arm/cpu/armv8/spin_tabli.c /* 绝对不会返回*/ #elif defined(CONFIG_ARMV8_MULTIENTRY) branch_if_master x0, x1, master_cpu /* * 从处理器 */ slave_cpu: wfe // 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数 ldr x1, =CPU_RELEASE_ADDR ldr x0, [x1] cbz x0, slave_cpu br x0 /* 跳转到指定地址*/ #endif /* CONFIG_ARMV8_MULTIENTRY */ master_cpu: bl _main // 主处理器执行函数 U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序\n1.1.3 函数_main // arch/arm/lib/crt0_64.S ENTRY(_main) // 设置初始的C语言运行环境，并且调用board_init_f(0)。 #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节*/ mov x0, sp bl board_init_f_alloc_reserve // 在栈的顶部为结构体global_data分配空间 mov sp, x0 mov x18, x0 /* 设置gd */ // 函数board_init_f_init_reserve，初始化结构体global_data bl board_init_f_init_reserve mov x0, #0 bl board_init_f // common/board_f.c 执行数组init_sequence_f中的每个函数 #if !defined(CONFIG_SPL_BUILD) // 设置中间环境（新的栈指针和gd），然后调用函数 // relocate_code(addr_moni) ldr x0, [x18, #GD_START_ADDR_SP] /* 把寄存器x0设置为gd-\u003estart_addr_sp */ bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节 */ ldr x18, [x18, #GD_BD] /* 把寄存器x18设置为gd-\u003ebd */ sub x18, x18, #GD_SIZE /* 新的gd在bd的下面 */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* 把寄存器x9设置为gd-\u003ereloc_off */ add lr, lr, x9 /* 在重定位后新的返回地址 */ ldr x0, [x18, #GD_RELOCADDR] /* 把寄存器x0设置为gd-\u003erelocaddr */ b relocate_code relocation_return: // 设置最终的完整环境 /* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/ bl c_runtime_cpu_setup #endif /* !CONFIG_SPL_BUILD */ #if defined(CONFIG_SPL_BUILD) bl spl_relocate_stack_gd /* 可能返回空指针 重新定位栈*/ // 执行“sp = (x0 != NULL) ? x0 : sp”， // 规避这个约束： // 带条件的mov指令不能把栈指针寄存器作为操作数 mov x1, sp cmp x0, #0 csel x0, x0, x1, ne mov sp, x0 #endif // 用0初始化未初始化数据段 ldr x0, =__bss_start /* 这是自动重定位*/ ldr x1, =__bss_end /* 这是自动重定位*/ clear_loop: str xzr, [x0], #8 cmp x0, x1 b.lo clear_loop /* 调用函数board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ /* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */ b board_init_r /* 不会运行到这里，因为函数board_init_r()不会返回*/ ENDPROC(_main) 1.1.4 函数run_main_loop 数组init_sequence_r最后一个函数run_main_loop，函数执行流程；\nrun_main_loop main_loop bootdely_process # 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量) autoboot_command abortboot # 等待用户按键 run_command_list # 未等待到按键，自动执行环境变量bootcmd bootm命令处理函数do_bootm\ndo_bootm do_bootm_states bootm_start # 初始化全局变量bootm_header_timages bootm_find_os # 把内核镜像从存储设备读到内存 bootm_find_other # ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件 bootm_load_os # 解压病加载内核到正确位置 bootm_os_get_boot_func # 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux do_bootm_linux(flag=BOOTM_STATE_OS_PREP) # 调用boot_prep_linux boot_prep_linux # 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件 boot_selected_os # do_bootm_linux(flag=BOOTM_STATE_OS_GO) boot_jump_linux # 负责跳转到Linux内核 boot_jum_linux do_nonsec_virt_switch smp_kick_all_cpus # CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3 dcache_disable # 禁用处理器的缓存和内存管理单元 # 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el2 switch_to_el1 armv8_switch_to_el1 内核入口 # 在异常级别2执行内核 armv8_switch_to_el2 内核入口 1.2 内核初始化 内核初始化分为汇编语言部分和C语言部分\n1.2.1 汇编语言部分 ARM64架构内核入口_head，直接跳转到标号stext\n// linux-4.14.295/arch/arm64/kernel/head.S _head: #ifdef CONFIG_EFI // 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS add x13, x18, #0x16 b stext #else b stext // 跳转到内核起始位置 .long0 // 保留 #endif stext\n// linux-4.14.295/arch/arm64/kernel/head.S ENTRY(stext) bl preserve_boot_args // 把引导程序传递的4个参数保存在全局数组boot_args中 bl el2_setup // 降级到异常级别1, 寄存器w0存放cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR偏移，默认值是0 bl set_cpu_boot_mode_flag // __boot_cpu_mode[2] 数组 bl __create_page_tables // 创建页表映射 /* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。 * 返回的时候，处理器已经为开启内存管理单元做好准备， * 转换控制寄存器已经设置好。*/ bl __cpu_setup // 初始化处理器 b __primary_switch // 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel ENDPROC(stext) 函数el2_setup a.如果异常级别是1，那么在异常级别1执行内核。 b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。 1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。 \\\n2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核 \\\n基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程 \\\n// 打开KVM字符设备文件。 fd = open(\"/dev/kvm\", O_RDWR); // 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。 vmfd = ioctl(fd, KVM_CREATE_VM, 0); // KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符 vcpu_fd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 从QEMU切换到客户操作系统的过程如下。 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。 为了提高切换速度，ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2 \\\n函数__create_page_tables 1）创建恒等映射，虚拟地址=物理地址__enable_mmu开启内存管理单元 2）为内核镜像创建映射 \\\n映射代码节.idmap.text,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址\n函数__primary_switch 1）__enable_mmu开启内存管理单元 2）__primary_switched __enable_mmu执行流程 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址 __primary_switch执行流程 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE) 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体thread_info的地址(init_task.thread_info) 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors) 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中 5）用0初始化内核的未初始化数据段 6）调用C语言函数start_kernel \\\n1.2.2 C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。 （1）创建1号线程，即init线程，线程函数是kernel_init。 （2）创建2号线程，即kthreadd线程，负责创建内核线程。 （3）0号线程最终变成空闲线程。 \\\ninit线程继续初始化，执行的主要操作如下。 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。 （3）smp_init()：初始化SMP系统，启动所有从处理器。 （4）do_initcalls()：执行级别0～7的初始化。 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。 （7）free_initmem()：释放初始化代码和数据占用的内存。 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。 \\\n级别0～7的初始化，是指使用以下宏注册的初始化函数：\n// include/linux/init.h #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 1.2.3 SMP系统的引导 对称多处理器(Symmetirc Multi-Processor SMP) 3种引导从处理器方法 \\\n自旋表 电源状态协调接口 ACPI停车协议 1.3 init进程 init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有sysvinit、busybox init、upstart、systemd和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件/etc/initab\n第2章 进程管理 2.1 进程 Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。 task_struct结构体是进程描述符，主要成员\nvolatile long state; // 进程状态 void *stack; // 指向内核栈 pid_t pid; // 全局进程号 pid_t tgid // 全局的线程组标识符 struct pid_link pid[PIDTYPE_MAX]; // 进程号，进程组标识符和会话标识符 struct task_struct _rcu *real_parent; // real_parent指向真实的父进程 struct task_struct _rcu *parent; // parent指向父进程 struct task_struct *group_leader; // 指向进村组的组长 const struct cred _rcu *real_cred; // real_cred指向主题和真实客体证书 const struct cred _rcu *cred; // cred指向客体证书 char comm[TASK_COMM_LEN]; // 进程名 int prio, static_prio, nornal_prio; // 调度策略 unsigned int rt_priority,prolicy； // 优先级 cpumask_t cpus_allowed; // 允许进程在哪些处理器上运行 struct mm_struct *mm, *active_mm; // 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符 struct file_struct *files; // 打开文件表 struct nsproxy *nsproxy; // 命名空间 struct signal_struct *signal; // 信号处理 struct sigband_struct *sighand; sigset_t blocked, real_blocked; sigset_t saved_sigmask; struct sigpending pending; struct sysv_sem sysvsem; // UNIx系统5信号量和共享内存 struct sysv_shm sysvshm; 2.2 命名空间 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,容器仅仅是通过命名空间隔离？ \\\n命名空间 隔离资源 控制组cgroup 控制组根目录 进程间通信IPC UNIX系统5进程间通信和POSIx消息队列 network 网络协议 挂载mount 挂载点 PID 进程号 user 用户标识符和组标识符 UNIX分时系统(UTS) 主机名和网络信息服务NIS域名 创建新的命名空间方法： 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间 调用unshare创建新的命名空间 进程使用系统调用setns，绑定一个已经存在的命名空间\n进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。\n2.3 进程标识符 标识符 进程标识符 命名空间给进程分配标识符 线程组标识符 线程组中的主进程称为组长，线程组标识符就是组长的进程标识符\n系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组 进程组标识符 进程组标识符是组长的进程标识符。\n进程可以使用系统调用setpgid创建或者加入一个进程组 会话标识符 进程调用系统调用setsid的时候，创建一个新的会话 pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid \\\n进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，\n2.4 进程关系 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。\n2.5 启动程序 ret = fork(); if (ret \u003e 0) { /* 父进程继续执行 */ } else if (ret == 0) { /* 子进程装载程序 */ ret = execve(filename, argv, envp); } else { /* 创建子进程失败 */ } 2.5.1　创建新进程 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的 两个个系统调用创建进程： \\\nfork：子进程是父进程的副本，用写时复制 clone：可控制子进程和父进程共享哪些资源 vfork：创建子进程，子进程用execve装载程序(已废弃) // 数字表示参数个数 SYSCALL_DEFINE0(fork) // 宏展开 asmlinkage表示C语言函数看被汇编代码调用 asmlinkage long sys_fork(void) 创建进程的进程p和被创建进程c三种关系\n新进程是进程p的子进程 clone传入CLONE_PARENT，兄弟关系 clone传入CLONE_THREAD，同属一个线程组 1. _do_fork函数 // kernel/fork.c long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); // tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址 调用copy_process创建新进程 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置 wake_up_new_task唤醒新进程\n2. copy_process函数 （1）标志组合 CLONE_NEWNS \u0026 CLONE_FS 新进程属于新挂载命名空间\n共享文件系统信息 CLONE_NEWUSER \u0026 CLONE_FS 新进程属于新用户命名空间\n共享文件系统信息 CLONE_THREAD 未设置CLONE_SIGHAND 新进程和当前进程同属一个线程组，\n但不共享信号处理程序 CLONE_SIGHAND 未设置CLONE_VM 新进程和当前进程共享信号处理程序，\n但不共享虚拟内存 （2）dup_task_struct函数 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈 // include/linux/sched.h union thread_union { #ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK struct task_struct task; #endif #ifndef CONFIG_THREAD_INFO_IN_TASK struct thread_info thread_info; #endif unsigned long stack[THREAD_SIZE/sizeof(long)]; }; 内核栈两种布局\nthread_info在内核栈顶部，成员task指向进程描述符 thread_info未占用内核栈 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址 内核栈的长度时THREAD_SIZE，ARM64架构内核栈长度为16KB thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体 // arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long\tflags;\t/* low level flags 底层标志位 */ mm_segment_t\taddr_limit;\t/* address limit 地址限制 */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN u64\tttbr0;\t/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */ #endif u64\tpreempt_count;\t/* 抢占计数器 0 =\u003e preemptible 可抢占, \u003c0 =\u003e bug缺陷 */ }; （3）copy_creds函数 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1\n（4）检查线程数量限制 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS\n（5）sched_fork函数\n为新进程设置调度器相关的参数\n// linux-5.10.102/kernel/sched/core.c 书中为4.x版本 int sched_fork(unsigned long clone_flags, struct task_struct *p) { __sched_fork(clone_flags, p); // 执行基本设置 /* * We mark the process as NEW here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u003estate = TASK_NEW; // 新进程状态设置为TASK_NEW /* * Make sure we do not leak PI boosting priority to the child. */ p-\u003eprio = current-\u003enormal_prio; // 新进程调度优先级设置为当前进程正常优先级 uclamp_fork(p); /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u003esched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { // 限期进程或实时进程 p-\u003epolicy = SCHED_NORMAL; // 调度策略 p-\u003estatic_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u003ert_priority = 0; } else if (PRIO_TO_NICE(p-\u003estatic_prio) \u003c 0) // 普通进程 p-\u003estatic_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u003eprio = p-\u003enormal_prio = p-\u003estatic_prio; set_load_weight(p, false); /* * We don't need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u003esched_reset_on_fork = 0; } if (dl_prio(p-\u003eprio)) // 调度优先级是限期调度累的优先级 return -EAGAIN; // 不允许限期进程分叉生成新的限期进程 else if (rt_prio(p-\u003eprio)) // 调度优先级是实时调度类优先级 p-\u003esched_class = \u0026rt_sched_class; // 调度类设置为实时调度类 else p-\u003esched_class = \u0026fair_sched_class; // 调度优先级是公平调度类的优先级，调度类设置为公平调度类 init_entity_runnable_average(\u0026p-\u003ese); #ifdef CONFIG_SCHED_INFO if (likely(sched_info_on())) memset(\u0026p-\u003esched_info, 0, sizeof(p-\u003esched_info)); #endif #if defined(CONFIG_SMP) p-\u003eon_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026p-\u003epushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026p-\u003epushable_dl_tasks); #endif return 0; } （6）复制或共享资源 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数\n// linux-4.14.295/ipc/sem.c int copy_semundo(unsigned long clone_flags, struct task_struct *tsk) { struct sem_undo_list *undo_list; int error; if (clone_flags \u0026 CLONE_SYSVSEM) { // CLONE_SYSTEM表示UNIX系统5信号量 error = get_undo_list(\u0026undo_list); if (error) return error; refcount_inc(\u0026undo_list-\u003erefcnt); // 5信号量的撤销请求链表，sem_undo_list 计数+1 tsk-\u003esysvsem.undo_list = undo_list; } else tsk-\u003esysvsem.undo_list = NULL; // 新进程5信号量撤销请求链表为空 return 0; } 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表\n// linux-5.10.102/kernel/fork.c static int copy_files(unsigned long clone_flags, struct task_struct *tsk) { struct files_struct *oldf, *newf; int error = 0; /* * A background process may not have any files ... */ oldf = current-\u003efiles; if (!oldf) goto out; if (clone_flags \u0026 CLONE_FILES) { // CLONE_FIELS共享打开文件表 atomic_inc(\u0026oldf-\u003ecount); // files_struct 计数加1 goto out; } newf = dup_fd(oldf, NR_OPEN_MAX, \u0026error); // 新进程把当前进程的打开文件表复制一份 if (!newf) goto out; tsk-\u003efiles = newf; error = 0; out: return error; } 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息 函数copy_fs复制或共享文件系统信息\n// linux-5.10.102/kernel/fork.c static int copy_fs(unsigned long clone_flags, struct task_struct *tsk) { struct fs_struct *fs = current-\u003efs; if (clone_flags \u0026 CLONE_FS) { // CLONE_FS共享文件系统信息 /* tsk-\u003efs is already what we want */ spin_lock(\u0026fs-\u003elock); if (fs-\u003ein_exec) { spin_unlock(\u0026fs-\u003elock); return -EAGAIN; } fs-\u003eusers++; // fs_struct共享文件系统信息结构体 加1 spin_unlock(\u0026fs-\u003elock); return 0; } tsk-\u003efs = copy_fs_struct(fs); // 新进程复制当前进程文件系统信息 if (!tsk-\u003efs) return -ENOMEM; return 0; } 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 函数copy_sighand复制或共享信号处理程序\n// static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk) { struct sighand_struct *sig; if (clone_flags \u0026 CLONE_SIGHAND) { // CLONE_SIGHAND 表示共享信号处理程序 refcount_inc(\u0026current-\u003esighand-\u003ecount); // 引用计数加1 return 0; } // 新进程复制当前进程信号处理程序 sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL); RCU_INIT_POINTER(tsk-\u003esighand, sig); if (!sig) return -ENOMEM; refcount_set(\u0026sig-\u003ecount, 1); spin_lock_irq(\u0026current-\u003esighand-\u003esiglock); memcpy(sig-\u003eaction, current-\u003esighand-\u003eaction, sizeof(sig-\u003eaction)); spin_unlock_irq(\u0026current-\u003esighand-\u003esiglock); /* Reset all signal handler not set to SIG_IGN to SIG_DFL. */ if (clone_flags \u0026 CLONE_CLEAR_SIGHAND) flush_signal_handlers(tsk, 0); return 0; } 5）信号结构体，同属一个线程组的线程才会共享信号结构体 函数copy_signal复制或共享信号结构体\n// linux-5.10.102/kernel/fork.c static int copy_signal(unsigned long clone_flags, struct task_struct *tsk) { struct signal_struct *sig; if (clone_flags \u0026 CLONE_THREAD) // CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct return 0; // 为新进程分配结构体，初始化，继承当前进程资源限制 sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL); tsk-\u003esignal = sig; if (!sig) return -ENOMEM; sig-\u003enr_threads = 1; atomic_set(\u0026sig-\u003elive, 1); refcount_set(\u0026sig-\u003esigcnt, 1); /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */ sig-\u003ethread_head = (struct list_head)LIST_HEAD_INIT(tsk-\u003ethread_node); tsk-\u003ethread_node = (struct list_head)LIST_HEAD_INIT(sig-\u003ethread_head); init_waitqueue_head(\u0026sig-\u003ewait_chldexit); sig-\u003ecurr_target = tsk; init_sigpending(\u0026sig-\u003eshared_pending); INIT_HLIST_HEAD(\u0026sig-\u003emultiprocess); seqlock_init(\u0026sig-\u003estats_lock); prev_cputime_init(\u0026sig-\u003eprev_cputime); #ifdef CONFIG_POSIX_TIMERS INIT_LIST_HEAD(\u0026sig-\u003eposix_timers); hrtimer_init(\u0026sig-\u003ereal_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); sig-\u003ereal_timer.function = it_real_fn; #endif task_lock(current-\u003egroup_leader); memcpy(sig-\u003erlim, current-\u003esignal-\u003erlim, sizeof sig-\u003erlim); task_unlock(current-\u003egroup_leader); posix_cpu_timers_init_group(sig); tty_audit_fork(sig); sched_autogroup_fork(sig); sig-\u003eoom_score_adj = current-\u003esignal-\u003eoom_score_adj; sig-\u003eoom_score_adj_min = current-\u003esignal-\u003eoom_score_adj_min; mutex_init(\u0026sig-\u003ecred_guard_mutex); init_rwsem(\u0026sig-\u003eexec_update_lock); return 0; } 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存 \\ 函数copy_mm复制或共享虚拟内存\n// linux-5.10.102/kernel/freezer.c static int copy_mm(unsigned long clone_flags, struct task_struct *tsk) { struct mm_struct *mm, *oldmm; int retval; tsk-\u003emin_flt = tsk-\u003emaj_flt = 0; tsk-\u003envcsw = tsk-\u003enivcsw = 0; #ifdef CONFIG_DETECT_HUNG_TASK tsk-\u003elast_switch_count = tsk-\u003envcsw + tsk-\u003enivcsw; tsk-\u003elast_switch_time = 0; #endif tsk-\u003emm = NULL; tsk-\u003eactive_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ oldmm = current-\u003emm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); if (clone_flags \u0026 CLONE_VM) { // CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct mmget(oldmm); mm = oldmm; goto good_mm; } retval = -ENOMEM; // 新进程复制当前进程的虚拟内存 mm = dup_mm(tsk, current-\u003emm); if (!mm) goto fail_nomem; good_mm: tsk-\u003emm = mm; tsk-\u003eactive_mm = mm; return 0; fail_nomem: return retval; } 7）命名空间 函数copy_namespace创建或共享命名空间\n// linux-5.10.102/kernel/nsproxy.c int copy_namespaces(unsigned long flags, struct task_struct *tsk) { struct nsproxy *old_ns = tsk-\u003ensproxy; struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns); struct nsproxy *new_ns; int ret; // 如果共享除了用户以外的所有其他命名空间， // 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1 if (likely(!(flags \u0026 (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWCGROUP | CLONE_NEWTIME)))) { if (likely(old_ns-\u003etime_ns_for_children == old_ns-\u003etime_ns)) { get_nsproxy(old_ns); return 0; } } else if (!ns_capable(user_ns, CAP_SYS_ADMIN)) // 进程没有系统管理权限，那么不允许创建新的命名空间 return -EPERM; /* CLONE_NEWIPC must detach from the undolist: after switching * to a new ipc namespace, the semaphore arrays from the old * namespace are unreachable. In clone parlance, CLONE_SYSVSEM * means share undolist with parent, so we must forbid using * it along with CLONE_NEWIPC. */ // 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的 if ((flags \u0026 (CLONE_NEWIPC | CLONE_SYSVSEM)) == (CLONE_NEWIPC | CLONE_SYSVSEM)) return -EINVAL; // 创建新的命名空间代理，然后创建或者共享命名空间 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-\u003efs); if (IS_ERR(new_ns)) return PTR_ERR(new_ns); ret = timens_on_fork(new_ns, tsk); if (ret) { free_nsproxy(new_ns); return ret; } tsk-\u003ensproxy = new_ns; return 0; } 8）I/O上下文 函数copy_io创建或共享I/O上下文\n// linux-5.10.102/kernel/fork.c static int copy_io(unsigned long clone_flags, struct task_struct *tsk) { #ifdef CONFIG_BLOCK struct io_context *ioc = current-\u003eio_context; struct io_context *new_ioc; if (!ioc) return 0; /* Share io context with parent, if CLONE_IO is set */ if (clone_flags \u0026 CLONE_IO) { // CLONE_IO 共享I/O上小文 ioc_task_link(ioc); // 计数nr_tasks加1 tsk-\u003eio_context = ioc; // 共享I/O上下文结构体io_context } else if (ioprio_valid(ioc-\u003eioprio)) { // 创建新的I/O上下文，初始化，继承当前进程的I/O优先级 new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE); if (unlikely(!new_ioc)) return -ENOMEM; new_ioc-\u003eioprio = ioc-\u003eioprio; put_io_context(new_ioc); } #endif return 0; } 9）复制寄存器值 函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct\nARM64架构copy_thread_tls-\u003ecopy_thread\n// linux-5.10.102/arch/arm64/kernel/process.c int copy_thread(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz, struct task_struct *p, unsigned long tls) { struct pt_regs *childregs = task_pt_regs(p); // 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值 memset(\u0026p-\u003ethread.cpu_context, 0, sizeof(struct cpu_context)); /* In case p was allocated the same task_struct pointer as some * other recently-exited task, make sure p is disassociated from * any cpu that may have run that now-exited task recently. * Otherwise we could erroneously skip reloading the FPSIMD * registers for p. */ fpsimd_flush_task_state(p); ptrauth_thread_init_kernel(p); if (likely(!(p-\u003eflags \u0026 PF_KTHREAD))) { // 用户进程 *childregs = *current_pt_regs(); childregs-\u003eregs[0] = 0; /* Read the current TLS pointer from tpidr_el0 as it may be * out-of-sync with the saved value. * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址， * 因为它可能和保存的值不一致 */ *task_user_tls(p) = read_sysreg(tpidr_el0); if (stack_start) { if (is_compat_thread(task_thread_info(p))) childregs-\u003ecompat_sp = stack_start; else childregs-\u003esp = stack_start; } /* If a TLS pointer was passed to clone, use it for the new thread. * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/ if (clone_flags \u0026 CLONE_SETTLS) p-\u003ethread.uw.tp_value = tls; } else { // 内核线程 memset(childregs, 0, sizeof(struct pt_regs)); childregs-\u003epstate = PSR_MODE_EL1h; if (IS_ENABLED(CONFIG_ARM64_UAO) \u0026\u0026 cpus_have_const_cap(ARM64_HAS_UAO)) childregs-\u003epstate |= PSR_UAO_BIT; spectre_v4_enable_task_mitigation(p); if (system_uses_irq_prio_masking()) childregs-\u003epmr_save = GIC_PRIO_IRQON; p-\u003ethread.cpu_context.x19 = stack_start; p-\u003ethread.cpu_context.x20 = stk_sz; } p-\u003ethread.cpu_context.pc = (unsigned long)ret_from_fork; p-\u003ethread.cpu_context.sp = (unsigned long)childregs; ptrace_hw_copy_thread(p); return 0; } （7）设置进程号和进程关系 static __latent_entropy struct task_struct *copy_process( struct pid *pid, int trace, int node, struct kernel_clone_args *args) { // 为新进程分配进程号 // pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号 if (pid != \u0026init_struct_pid) { pid = alloc_pid(p-\u003ensproxy-\u003epid_ns_for_children); if (IS_ERR(pid)) { retval = PTR_ERR(pid); goto bad_fork_cleanup_thread; } } … // 设置新进程退出时发送给父进程的信号 p-\u003epid = pid_nr(pid); if (clone_flags \u0026 CLONE_THREAD) { p-\u003eexit_signal = -1; // 新线程退出时不需要发送信号给父进程 p-\u003egroup_leader = current-\u003egroup_leader; // group_leader指向同一个组长 p-\u003etgid = current-\u003etgid; // tgid存放组长的进程号 } else { if (clone_flags \u0026 CLONE_PARENT) // CLONE_PARENT 新进程和当前进程是兄弟关系 p-\u003eexit_signal = current-\u003egroup_leader-\u003eexit_signal; // 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal else // 父子关系 p-\u003eexit_signal = (clone_flags \u0026 CSIGNAL); // 新进程的成员exit_signal是调用者指定的信号 p-\u003egroup_leader = p; p-\u003etgid = p-\u003epid; } // 控制组的进程数控制器检查是否允许创建新进程： // 从当前进程所属的控制组一直到控制组层级的根， // 如果其中一个控制组的进程数量大于或等于限制， // 那么不允许使用fork和clone创建新进程 cgroup_threadgroup_change_begin(current); retval = cgroup_can_fork(p); if (retval) goto bad_fork_free_pid; write_lock_irq(\u0026tasklist_lock); // 为新进程设置父进程 if (clone_flags \u0026 (CLONE_PARENT|CLONE_THREAD)) { // 新进程和当前进程拥有相同的父进程 p-\u003ereal_parent = current-\u003ereal_parent; p-\u003eparent_exec_id = current-\u003eparent_exec_id; } else { p-\u003ereal_parent = current; // 新进程的父进程是当前进程 p-\u003eparent_exec_id = current-\u003eself_exec_id; } … spin_lock(\u0026current-\u003esighand-\u003esiglock); … if (likely(p-\u003epid)) { … init_task_pid(p, PIDTYPE_PID, pid); if (thread_group_leader(p)) { // true 新进程和当前进程属于同一个进程组 init_task_pid(p, PIDTYPE_PGID, task_pgrp(current)); // 指向同一个进程组的组长的进程号结构体 init_task_pid(p, PIDTYPE_SID, task_session(current)); // 指向同一个会话的控制进程的进程号结构体 if (is_child_reaper(pid)) { ns_of_pid(pid)-\u003echild_reaper = p; p-\u003esignal-\u003eflags |= SIGNAL_UNKILLABLE; // 1号进程是不能杀死的 } p-\u003esignal-\u003eleader_pid = pid; p-\u003esignal-\u003etty = tty_kref_get(current-\u003esignal-\u003etty); p-\u003esignal-\u003ehas_child_subreaper = p-\u003ereal_parent-\u003esignal-\u003e has_child_subreaper || p-\u003ereal_parent-\u003esignal-\u003eis_child_subreaper; list_add_tail(\u0026p-\u003esibling, \u0026p-\u003ereal_parent-\u003echildren); // 新进程添加到父进程的子进程链表 // 新进程添加到进程链表中，链表节点是成员tasks， // 头节点是空闲线程的成员tasks（init_task.tasks） list_add_tail_rcu(\u0026p-\u003etasks, \u0026init_task.tasks); attach_pid(p, PIDTYPE_PGID); // 新进程添加到进程组的进程链表 attach_pid(p, PIDTYPE_SID); // 新进程添加到会话的进程链表 __this_cpu_inc(process_counts); } else { // 创建线程 current-\u003esignal-\u003enr_threads++; // 线程组的线程计数值加1 atomic_inc(\u0026current-\u003esignal-\u003elive); // 原子变量线程组的第2个线程计数值加1 atomic_inc(\u0026current-\u003esignal-\u003esigcnt); // 信号结构体的引用计数加1 list_add_tail_rcu(\u0026p-\u003ethread_group, \u0026p-\u003egroup_leader-\u003ethread_group); // 线程加入线程组的线程链表 list_add_tail_rcu(\u0026p-\u003ethread_node, \u0026p-\u003esignal-\u003ethread_head); // 线程加入线程组的第二条线程链表 } attach_pid(p, PIDTYPE_PID); // 新进程添加到进程号结构体的进程链表 nr_threads++; // 新进程添加到进程号结构体的进程链表 } total_forks++; spin_unlock(\u0026current-\u003esighand-\u003esiglock); … write_unlock_irq(\u0026tasklist_lock); proc_fork_connector(p); cgroup_post_fork(p); cgroup_threadgroup_change_end(current); … return p; } 3.唤醒新进程 wake_up_new_task函数唤醒新进程\n// linux-5.10.102/kernel/sched/core.c void wake_up_new_task(struct task_struct *p) { struct rq_flags rf; struct rq *rq; raw_spin_lock_irqsave(\u0026p-\u003epi_lock, rf.flags); p-\u003estate = TASK_RUNNING; // 切换TASK_RUNNING #ifdef CONFIG_SMP /* Fork balancing, do it here and not earlier because: * - cpus_ptr can change in the fork path * - any previously selected CPU might disappear through hotplug * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq, * as we're not fully set-up yet.*/ p-\u003erecent_used_cpu = task_cpu(p); rseq_migrate(p); __set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); // 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器 #endif rq = __task_rq_lock(p, \u0026rf); // 锁住运行队列 update_rq_clock(rq); // 更新运行队列的时钟 post_init_entity_util_avg(p); // 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值 activate_task(rq, p, ENQUEUE_NOCLOCK); // 把新进程插入运行队列 trace_sched_wakeup_new(p); check_preempt_curr(rq, p, WF_FORK); // 检查新进程是否可以抢占当前进程 #ifdef CONFIG_SMP if (p-\u003esched_class-\u003etask_woken) { // 在SMP系统上，调用调度类的task_woken方法 /* Nothing relies on rq-\u003elock after this, so its fine to * drop it.*/ rq_unpin_lock(rq, \u0026rf); p-\u003esched_class-\u003etask_woken(rq, p); rq_repin_lock(rq, \u0026rf); } #endif task_rq_unlock(rq, p, \u0026rf); // 释放运行队列的锁 } 4.新进程第一次运行 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数\n// linux-5.10.102/arch/arm64/kernel/entry.S tsk .req x28 //当前进程的thread_info结构体的地址 SYM_CODE_START(ret_from_fork) bl\tschedule_tail // 为上一个进程执行清理操作 cbz\tx19, 1f // not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1 mov\tx0, x20 // 内核线程：x19存放线程函数的地址，x20存放线程函数的参数 blr\tx19 // 调用线程函数 1:\tget_current_task tsk // 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址 b\tret_to_user // 返回用户模式 SYM_CODE_END(ret_from_fork) NOKPROBE(ret_from_fork) copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0 // linux-5.10.102/kernel/sched/core.c asmlinkage __visible void schedule_tail(struct task_struct *prev) __releases(rq-\u003elock) { struct rq *rq; /* New tasks start with FORK_PREEMPT_COUNT, see there and * finish_task_switch() for details. * * finish_task_switch() will drop rq-\u003elock() and lower preempt_count * and the preempt_enable() will end up enabling preemption (on * PREEMPT_COUNT kernels).*/ rq = finish_task_switch(prev); // 为上一个进程执行清理操作2.8.6 balance_callback(rq); // 执行运行队列的所有负载均衡回调函数 preempt_enable(); // 开启内核抢占 if (current-\u003eset_child_tid) // pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置 put_user(task_pid_vnr(current), current-\u003eset_child_tid); calculate_sigpending(); } 2.5.2 装载程序 调度器调度新进程，新进程从函数ret_from_fork开始，从系统调用fork返回用户空间，返回值0。然后新进程使用系统调用execve装载程序。Linux内核练个装载程序系统调用： \\\n// 路径名是相对时execve解释为相对调用进程的当前工作目录 int execve(const char *filename, char *const argv[], char *const envp[]); // 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录 // 路径名时绝对的，execveat忽略参数dirfd int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); 参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值\n两个系统调用最终都调用函数do_execveat_common 函数do_open_execat打开可执行文件。 函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器 函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-\u003ep指向在栈底保留一个字长（指针长度）后的位置 函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？ \\ 依次把文件名称、环境字符串和参数字符串压到用户栈 函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止\n1.二进制格式 Linux二进制格式\n// linux-5.10.102/include/linux/binfmts.h struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump;\t/* minimal dump size */ } __randomize_layout; 二进制格式提供3个函数 (1)load_binary 加载普通程序 (2)load_shlib 加载共享库 (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度 二进制格式使用register_binfmt向内核注册\n2.装载ELF程序 ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 linux-5.10.102/include/uapi/linux/elf.h\n目标文件(可重定位文件)，.o，多个模板文件链接生成可执行文件或共享库 可执行文件 共享库 .so 核心转储文件(core dump file) ELF文件分成4部分：ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)，ELF只有首部的位置是固定的。\n程序首部表就是段表(segment table)，段(segment)是从运行角度描述，节(section)是从链接角度描述。 64位ELF文件格式\n参考链接： ELF 格式详解 https://blog.csdn.net/shanandqiu/article/details/115206426 ELF文件格式简介 https://blog.csdn.net/GrayOnDream/article/details/124564129\n# 查看ELF首部 readelf -h # 查看程序首部表 readelf -l # 查看节首部表 readelf -S ELF解析程序 linux-5.10.102/fs/binfmt_elf.c 解析64位ELF程序，和处理器架构无关 linux-5.10.102/fs/compat_binfmt_elf.c 在64位内核中解析32位ELF程序，和处理器架构无 \\\n装载ELF程序函数load_elf_binary\n1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构 2）读取程序首部表 3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。 4）检查解释器的ELF首部，读取解释器的程序首部表 5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间 6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域 7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈 8）把可加载段映射到进程的虚拟地址空间 9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段 10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口 11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈 12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread\n// linux-5.10.102/arch/arm64/include/asm/processor.h static inline void start_thread_common(struct pt_regs *regs, unsigned long pc) { memset(regs, 0, sizeof(*regs)); forget_syscall(regs); regs-\u003epc = pc; /* 把程序计数器设置为程序的入口 */ } static inline void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp) { start_thread_common(regs, pc); regs-\u003epstate = PSR_MODE_EL0t; /* 把处理器状态设置为0，其中异常级别是0 */ spectre_v4_enable_task_mitigation(current); regs-\u003esp = sp; /*设置用户栈指针 */ } 3.装载脚本程序 脚本程序前两个字节是#!，后面是解释器程序的名称和参数。解释器用来执行脚本程序 linux-5.10.102/fs/binfmt_script.c函数load_script负责装载脚本程序\n1）检查前两个字节是不是脚本程序的标识符 2）解析处解释程序的名称和参数 3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈 4）调用opens_exec打开解释程序文件 5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区 6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止 \\\n2.6 进程退出 进程退出两种情况：进程主动退出和终止进程 Linux内核两个主动退出的系统调用 \\\n// 线程退出 void exit(int status); // 一个线程组所有线程退出 void exit_group(int status); glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数 终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用\n// // 发送信号给进程或进程组 int kill(pid_t pid, int sig); // 发送信号给线程 已废弃 int tkill(int tid, int sig); // 发送信号给线程 int tgkill(int tgid, int tid, int sig); 父进程是否关注子进程退出事假， 1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。进程默认关注子进程退出事件，通过系统调用sigaction对信号SIGHLD设置标志SA_NOCLDWAIT(CLD是child)，子进程退出时不变成僵尸进程或设置忽略信号SIGCHLD 2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 Linux内核3个系统调用等待子进程状态改变：子进程终止、信号SIGSTOP使子进程停止执行或信号SIGCONT使子进程继续执行\npid_t waitpid(pid_t pid, int *wstatus, int options); int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); pit_t wiat4(pit_t pid, int *wstatus, int options, staruct usage *rusage); // 废弃 父进程退出时，给子进程寻找领养者 1）进程属于一个线程组，且还有其他线程，选择任意其他线程 2）选择最亲近的充当\"替补领养者\"的祖先进程，进程使用系统调用prtctl(PR_SET_CHILD_SUBREAPER)设置为替换领养者 3）选择所属进程号命名空间的1号进程 2.6.1 线程组退出 exit_group 系统调用exit_group执行流程\n一个线程组的两个线程，线程1和线程2，线程1调用exit_group使线程组退出，线程1执行流程： 1）把退出码保存在结构体成员group_exit_code中，传递给线程2 2）给线程组设置正在退出标志 3）向线程2发送杀死信号，唤醒线程2，线程2处理杀死信号 4）线程1调用函数do_exit以退出 线程2退出的执行流程，函数do_group_exit执行流程\n线程2可能发挥用户模式3种情况 （1）执行完系统调用 （2）被中断抢占，中断处理程序执行完 （3）执行指令是生成异常，异常处理程序执行完 \\\ndo_exit函数执行流程 （1）释放各种资源，把资源引用计数减一，如果引用计数变为0，则释放数据结构 （2）调用函数exit_notify，为子进程选择领养者，然后把自己死讯通知父进程 （3）把进程状态设置为死亡(TASK_DEAD) （4）最后一次调用函数__schedule以调度进程 死亡进程调用__schedule时进程调度器处理流程\n// linux-5.10.102/kernel/sched/core.c __schedule() --\u003e context_switch() --\u003e finish_task_switch() static struct rq *finish_task_switch(struct task_struct *prev) __releases(rq-\u003elock) { … prev_state = prev-\u003estate; … if (unlikely(prev_state == TASK_DEAD)) { if (prev-\u003esched_class-\u003etask_dead) prev-\u003esched_class-\u003etask_dead(prev); // 执行调度类task_dead … // 如果结构体thread_info放在进程描述符里面， // 而不是放在内核栈的顶部，那么释放进程的内核栈 put_task_stack(prev); // 进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符 put_task_struct(prev); } … } 2.6.2 终止进程 系统调用kill向线程组或进程组发送信号linux-5.10.102/kernel/signal.c，执行流程 函数__send_signal主要代码\n// linux-5.10.102/kernel/signal.c static int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns) { struct sigpending *pending; struct sigqueue *q; int override_rlimit; int ret = 0, result; … result = TRACE_SIGNAL_IGNORED; // 目标线程忽略信号,不发送信号 if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED))) goto ret; // 确定把信号添加到哪个信号队列和集合 pending = group ? \u0026t-\u003esignal-\u003eshared_pending : \u0026t-\u003epending; result = TRACE_SIGNAL_ALREADY_PENDING; // 传统信号，并且信号集合已经包含同一个信号,不发送 if (legacy_queue(pending, sig)) goto ret; … // 判断分配信号队列节点时是否可以忽略信号队列长度的限制 if (sig \u003c SIGRTMIN) override_rlimit = (is_si_special(info) || info-\u003esi_code \u003e= 0); else override_rlimit = 0; // 分配一个信号队列节点 q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit); if (q) { list_add_tail(\u0026q-\u003elist, \u0026pending-\u003elist); // 添加到信号队列中 … } else if (!is_si_special(info)) { … } out_set: signalfd_notify(t, sig); sigaddset(\u0026pending-\u003esignal, sig); // 信号添加到信号集合中 // 在线程组中查找一个没有屏蔽信号的线程，唤醒它，让它处理信号 complete_signal(sig, t, group); ret: … return ret; } 2.6.3 查询子进程终止原因 系统调用waitid\nint waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); pid_t waitpid(pid_t pid, int *wstatus, int options); 参数 参数值 含义 idtype P_ALL 等待任意子进程，忽略参数id P_PID 等待进程号为id的子进程 P_PGID 等待进程组标识符是id的任意子进程 options WEXITED 等待退出的子进程 WSTOPPED 等待收到信号SIGSTOP并停止执行的子进程 WCONTINUED 等待收到信号SIGCONT并继续执行的子进程 WNOHANG 如果没有子进程退出，立即返回 WNOWAIT 让子进程处于僵尸状态，以后可以再次查询状态信息 do_wait函数执行流程\n2.7 进程状态 状态 state 含义 就绪状态 TASK_RUNNING 正在运行队列中等待调度器调度 运行状态 TASK_RUNNING 被调度器选中，正在处理器上运行 轻度睡眠 TASK_INTERRUPTIBLE 可信号打断的睡眠状态 中度睡眠 TASK_KILLABLE 只能被致命的信号打断 深度睡眠 TASK_UNINTERRUPTIBLE 不可打断的睡眠状态 僵尸状态 TASK_DEAD 被调度器选中，正在处理器上运行 死亡状态 TASK_DEAD 如果父进程不关注子进程退出事件，那么子进程退出时自动消亡 进程状态变迁 2.8 进程调度 2.8.1 调度策略 Linux内核支持的调度策略 （1）限制进程使用限期调度策略(SCHED_DEADLINE)，3个参数：运行时间runtime，截止期限deadline和周期period （2）实时进程支持两种调度策略：先进先出调度(SCHED_FIFO)和轮流调度(SCHED_RR) （3）普通进程两种调度策略：标准轮流分时(SCHED_NORMAL)和空闲(SCHED_BATCH)，Linux内核引入完全公平调度算法后，批量调度策略废弃。 \\\n2.8.2 进程优先级 限期进程的优先级比实时进程高，实时进程的优先级比普通进程高。 限期进程的优先级是−1。 实时进程的实时优先级是1～99，优先级数值越大，表示优先级越高。 普通进程的静态优先级是100～139，优先级数值越小，表示优先级越高，可通过修改nice值（即相对优先级，取值范围是−20～19）改变普通进程的优先级，优先级等于120加上nice值 task_struct中，4个成员和优先级有关 \\\ninclude/linux/sched.h struct task_struct { … int prio; int static_prio; int normal_prio; unsigned int rt_priority; … }; 优先级 限期进程 实时进程 普通进程 prio\n调度优先级(数值越小，表示优先级越高) 大多数prio等于normal_prio static_prio\n静态优先级 总是0 总是0 120 + nice值数值越小，\n表示优先级越高 normal_prio\n正常优先级(数值越小，表示优先级越高) -1 99 − rt_priority static_prio 实时优先级 总是0 值越大，优先级越高 2.8.3 调度类 Linux内核抽象一个调度类sched_class，目前实现5种调度类，优先级从上到下从高到低：\n调度类 调度策略 调度算法 调度对象 停机调度类\nstop_sched_class 无 无 停机进程 限期调度类\ndl_sched_class SCHED_DEADLINE 最早期限优先 限期进程 实时调度类\nrt_sched_class SCHED_FIFO\nSCHED_RR 先进先出\n轮流调度 实时进程 公平调度类\ncfs_sched_class SCHED_NORMAL\nSCHED_IDIE 完全公平调度算法 普通进程 空闲调度类\nidle_sched_class 无 无 每个处理器上的空闲线程 详细信息参考书籍\n2.8.4 运行队列 每个处理器有一个运行队列，结构体rq，定义全局变量\n// linux-5.10.102/kernel/sched/cpuacct.c DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); // linux-5.10.102/kernel/sched/sched.h struct rq { // 运行队列 ... struct cfs_rq\tcfs; // 公平运行队列 struct rt_rq\trt; // 实时运行队列 struct dl_rq\tdl; // 限期运行队列 ... struct task_struct\t*idle; // 空闲线程 struct task_struct\t*stop; // 迁移线程 }; 2.8.5 任务分组 1.任务分组方式 任务分组方式 控制宏 配置方式 自动组 CONFIG_SCHED_AUTOGROUP /proc/sys/kernel/sched_autogroup_enabled 运行过程中开启关闭，默认值1\n源文件kernel/sched/auto_group.c CPU控制组版本1 CONFIG_CGROUPS\nCONFIG_CGROUP_SCHED mount -t tmpfs cgroup_root /sys/fs/cgroup\nmkdir /sys/fs/cgroup/cpu\nmount -t cgroup -o cpu none /sys/fs/cgroup/cpu\ncd /sys/fs/cgroup/cpu\nmkdir multimedia # 创建\"multimedia\"任务组\nmkdir browser # 创建\"browser\"任务组\necho 2048 \u003e multimedia/cpu.shares\necho 1024 \u003e browser/cpu.shares\necho \u003c pid1\u003e \u003e browser/tasks echo \u003c pid2\u003e \u003e multimedia/tasks\necho \u003c pid1\u003e \u003e browser/cgroup.procs\necho \u003c pid2\u003e \u003e multimedia/cgroup.procs cgroup版本2 mount -t tmpfs cgroup_root /sys/fs/cgroup\nmount -t cgroup2 none /sys/fs/cgroup\ncd /sys/fs/cgroup echo \"+cpu\" \u003e cgroup.subtree_control\nmkdir multimedia # 创建\"multimedia\"任务组 mkdir browser # 创建\"browser\"任务组\necho 2048 \u003e multimedia/cpu.weight\necho 1024 \u003e browser/cpu.weight\necho \u003c pid1\u003e \u003e browser/cgroup.procs\necho \u003c pid2\u003e \u003e multimedia/cgroup.procs echo threaded \u003e browser/cgroup.type echo \u003c pid1\u003e \u003e browser/cgroup.threads echo threaded \u003e multimedia/cgroup.type echo \u003c pid2\u003e \u003e multimedia/cgroup.threads 2. 数据结构 task_group,默认任务组是更任务组(全局变量root_task_group)\n成员 说明 const struct sched_class *sched_class 调度类 struct sched_entity se 公平调度实体 struct sched_dl_entity dl 限期调度实体 任务组在每个处理器上有公平调度实体、公平运行队列、实时调度实体和实时运行队列，根任务组比较特殊：没有公平调度实体和实时调度实体\n每个处理器上，计算任务组的公平调度实体的权重的方法如下（参考源文件“kernel/ sched/fair.c”中的函数update_cfs_shares\n2.8.6 调度进程 调度进程的核心函数是__schedule()\nkernel/sched/core.c // preempt是否抢占，true抢占调度，false主动调度 static void __sched notrace __schedule(bool preempt) { 1. 调用pick_next_task选择下一个进程 2. 调用context_switch切换进程 } 1.选择下一个进程 函数pick_next_task // linux-5.10.102/kernel/sched/core.c static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) { const struct sched_class *class; struct task_struct *p; /* Optimization: we know that if all tasks are in the fair class we can * call that function directly, but only if the @prev task wasn't of a * higher scheduling class, because otherwise those loose the * opportunity to pull in more work from other CPUs.*/ // 优化：如果所有进程属于公平调度类 // 直接调用公平调度类的pick_next_task方法 if (likely(prev-\u003esched_class \u003c= \u0026fair_sched_class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = pick_next_task_fair(rq, prev, rf); if (unlikely(p == RETRY_TASK)) goto restart; /* Assumes fair_sched_class-\u003enext == idle_sched_class */ // 假定公平调度类的下一个调度类是空闲调度类 if (!p) { put_prev_task(rq, prev); p = pick_next_task_idle(rq); } return p; } restart: put_prev_task_balance(rq, prev, rf); for_each_class(class) { p = class-\u003epick_next_task(rq); if (p) return p; } /* The idle class should always have a runnable task: */ // 空闲调度类应该总是有一个运行的进程 BUG(); } 待补充\n2.切换进程 context_switch 1）switch_mm_irqs_off负责切换进程的用户虚拟地址空间 2）switch_to切换处理器的寄存器\n// linux-5.10.102/kernel/sched/core.c static __always_inline struct rq * context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next, struct rq_flags *rf) { prepare_task_switch(rq, prev, next); // 准备工作，调用prepare_arch_switch /* For paravirt, this is coupled with an exit in switch_to to * combine the page table reload and the switch backend into * one hypercall. */ // 开始上下文切换 arch_start_context_switch(prev); /* * kernel -\u003e kernel lazy + transfer active * user -\u003e kernel lazy + mmgrab() active * * kernel -\u003e user switch + mmdrop() active * user -\u003e user switch */ if (!next-\u003emm) { // to kernel // 通知处理器架构不需要切换用户虚拟地址空间，加速进程切换的技术称为惰性TLB enter_lazy_tlb(prev-\u003eactive_mm, next); next-\u003eactive_mm = prev-\u003eactive_mm; if (prev-\u003emm) // from user 切换进程的用户虚拟地址空间 mmgrab(prev-\u003eactive_mm); else prev-\u003eactive_mm = NULL; } else { // to user membarrier_switch_mm(rq, prev-\u003eactive_mm, next-\u003emm); /* * sys_membarrier() requires an smp_mb() between setting * rq-\u003ecurr / membarrier_switch_mm() and returning to userspace. * * The below provides this either through switch_mm(), or in * case 'prev-\u003eactive_mm == next-\u003emm' through * finish_task_switch()'s mmdrop(). */ switch_mm_irqs_off(prev-\u003eactive_mm, next-\u003emm, next); if (!prev-\u003emm) { // from kernel /* will mmdrop() in finish_task_switch(). */ rq-\u003eprev_mm = prev-\u003eactive_mm; prev-\u003eactive_mm = NULL; } } rq-\u003eclock_update_flags \u0026= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); prepare_lock_switch(rq, next, rf); /* Here we just switch the register state and the stack. */ // 只切换寄存器状态和栈 switch_to(prev, next, prev); barrier(); return finish_task_switch(prev); } （1）切换用户虚拟地址空间。\n// ARM64架构使用switch_mm_irqs_off include/linux/mmu_context.h #ifndef switch_mm_irqs_off #define switch_mm_irqs_off switch_mm #endif switch_mm函数\n// linux-5.10.102/arch/arm64/include/asm/mmu_context.h static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { if (prev != next) __switch_mm(next); /* Update the saved TTBR0_EL1 of the scheduled-in task as the previous * value may have not been initialised yet (activate_mm caller) or the * ASID has changed since the last run (following the context switch * of another thread of the same process).*/ /* 更新调入进程保存的寄存器TTBR0_EL1值， * 因为可能还没有初始化（调用者是函数activate_mm）， * 或者ASID自从上次运行以来已经改变（在同一个线程组的另一个线程切换上下文以后） * 避免把保留的寄存器TTBR0_EL1值设置为swapper_pg_dir（init_mm；例如通过函数idle_task_exit）*/ update_saved_ttbr0(tsk, next); } static inline void __switch_mm(struct mm_struct *next) { /*init_mm.pgd does not contain any user mappings and it is always * active for kernel addresses in TTBR1. Just set the reserved TTBR0.*/ /*init_mm.pgd没有包含任何用户虚拟地址的映射，对于TTBR1的内核虚拟地址总是有效的。 * 只设置保留的TTBR0 */ if (next == \u0026init_mm) { cpu_set_reserved_ttbr0(); return; } // 为进程分配地址空间标识符 check_and_switch_context(next); } 待补充\n（2）切换寄存器\n// linux-5.10.102/include/asm-generic/switch_to.h #define switch_to(prev, next, last)\t\\ do {\t\\ ((last) = __switch_to((prev), (next)));\t\\ } while (0) 函数__switch_to\n__notrace_funcgraph struct task_struct *__switch_to(struct task_struct *prev, struct task_struct *next) { struct task_struct *last; fpsimd_thread_switch(next); // 切换浮点寄存器 tls_thread_switch(next); // 切换本地存储相关的寄存器 hw_breakpoint_thread_switch(next); // 切换吊事寄存器 contextidr_thread_switch(next); // 把上下文标识符寄存器CONTEXTIDR_EL1设置为下一个进程号 entry_task_switch(next); // 使用处理器变量__entry_task记录下一个进程描述符的地址 uao_thread_switch(next); // 根据下一个进程可访问的虚拟地址空间上限恢复用户访问覆盖（User Access Override，UAO）状态 ssbs_thread_switch(next); // erratum_1418040_thread_switch(next); /* Complete any pending TLB or cache maintenance on this CPU in case * the thread migrates to a different CPU. * This full barrier is also required by the membarrier system * call.*/ // 在这个处理器上执行完前面的所有页表缓存或者缓存维护操作 // 以防线程迁移到其他处理器 // 数据同步屏障，确保屏障前面的缓存维护操作和页表缓存维护操作执行完 dsb(ish); /* MTE thread switching must happen after the DSB above to ensure that * any asynchronous tag check faults have been logged in the TFSR*_EL1 * registers.*/ mte_thread_switch(next); /* the actual thread switch */ // 实际线程切换 切换通用寄存器 last = cpu_switch_to(prev, next); return last; } 1）切换浮点寄存器，函数fpsimd_thread_switch负责切换浮点，内核不允许使用浮点数，只有用户空间可以使用浮点数,切换出去的进程把浮点寄存器的值保存在进程描述符的成员thread.fpsimd_state中。ARM64架构实现的linux-5.10.102/arch/arm64/kernel/fpsimd.c函数fpsimd_thread_switch \\ 2）切换通用寄存器，\n被调用函数负责保存的寄存器x19～x28 寄存器x29，即帧指针（Frame Pointer，FP）寄存器 栈指针（Stack Pointer，SP）寄存器 寄存器x30，即链接寄存器（Link Register，LR），它存放函数的返回地址 用户栈指针寄存器SP_EL0，内核使用它存放当前进程的进程描述符的第一个成员thread_info的地址 cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址\n// linux-5.10.102/arch/arm64/kernel/entry.S SYM_FUNC_START(cpu_switch_to) mov\tx10, #THREAD_CPU_CONTEXT // cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址 add\tx8, x0, x10 // x8存放上一个进程的进程描述符的成员thread.cpu_context的地址 mov\tx9, sp // x9保存栈指针 stp\tx19, x20, [x8], #16\t// store callee-saved registers stp\tx21, x22, [x8], #16 // 把上一个进程的寄存器x19～x28、x29、SP和LR stp\tx23, x24, [x8], #16 // 保存到上一个进程的进程描述符的成员thread.cpu_context中 stp\tx25, x26, [x8], #16 // stp\tx27, x28, [x8], #16 stp\tx29, x9, [x8], #16 str\tlr, [x8] // LR存放函数的返回地址 add\tx8, x1, x10 // x8存放下一个进程的进程描述符的成员thread.cpu_context的地址 ldp\tx19, x20, [x8], #16\t// restore callee-saved registers ldp\tx21, x22, [x8], #16 // 使用下一个进程的进程描述符的成员thread.cpu_context ldp\tx23, x24, [x8], #16 // 保存的值恢复下一个进程的寄存器x19～x28、x29、SP和LR ldp\tx25, x26, [x8], #16 ldp\tx27, x28, [x8], #16 ldp\tx29, x9, [x8], #16 ldr\tlr, [x8] mov\tsp, x9 msr\tsp_el0, x1 // 用户栈指针寄存器SP_EL0设置为下一个进程的进程描述符的第一个成员thread_info的地址 ptrauth_keys_install_kernel x1, x8, x9, x10 scs_save x0, x8 // 函数返回，返回值是寄存器x0的值：上一个进程的进程描述符的地址 scs_load x1, x8 ret SYM_FUNC_END(cpu_switch_to) NOKPROBE(cpu_switch_to) cpu_switch_to切换通用寄存器的过程，从进程prev切换到进程next。进程prev把通用寄存器的值保存在进程描述符的成员thread.cpu_context中，然后进程next从进程描述符的成员thread.cpu_context恢复通用寄存器的值，使用用户栈指针寄存器SP_EL0存放进程next的进程描述符的成员thread_info的地址 \\\nARM64架构切换通用寄存器 链接寄存器存放函数的返回地址，函数cpu_switch_to把链接寄存器设置为进程描述符的成员thread.cpu_context.pc，进程被调度后从返回地址开始执行 进程的返回地址分为以下两种情况:\n创建的新进程，函数copy_thread把进程描述符的成员thread.cpu_context.pc设置为函数ret_from_fork的地址 其他情况，返回地址是函数context_switch中调用函数cpu_switch_to之后的一行代码：“last = 函数cpu_switch_to的返回值”，返回地址记录在进程描述符的成员thread.cpu_context.pc中 （3）清理工作 函数finish_task_switch在从进程prev切换到进程next后为进程prev执行清理工作\n// kernel/sched/core.c static struct rq *finish_task_switch(struct task_struct *prev) __releases(rq-\u003elock) { struct rq *rq = this_rq(); // rq是当前处理器的运行队列 struct mm_struct *mm = rq-\u003eprev_mm; long prev_state; /* The previous task will have left us with a preempt_count of 2 * because it left us after: *\tschedule() *\tpreempt_disable();\t// 1 *\t__schedule() *\traw_spin_lock_irq(\u0026rq-\u003elock)\t// 2 * Also, see FORK_PREEMPT_COUNT.*/ if (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET, \"corrupted preempt_count: %s/%d/0x%x\\n\", current-\u003ecomm, current-\u003epid, preempt_count())) preempt_count_set(FORK_PREEMPT_COUNT); rq-\u003eprev_mm = NULL; /* A task struct has one reference for the use as \"current\". * If a task dies, then it sets TASK_DEAD in tsk-\u003estate and calls * schedule one last time. The schedule call will never return, and * the scheduled task must drop that reference. * * We must observe prev-\u003estate before clearing prev-\u003eon_cpu (in * finish_task), otherwise a concurrent wakeup can get prev * running on another CPU and we could rave with its RUNNING -\u003e DEAD * transition, resulting in a double drop.*/ prev_state = prev-\u003estate; vtime_task_switch(prev); // 计算进程prev的时间统计 perf_event_task_sched_in(prev, current); finish_task(prev); // 把prev-\u003eon_cpu设置为0，表示进程prev没有在处理器上运行；然后释放运行队列的锁，开启硬中断 finish_lock_switch(rq); finish_arch_post_lock_switch(); // 执行处理器架构特定的清理工作,ARM64为空 kcov_finish_switch(current); fire_sched_in_preempt_notifiers(current); /* When switching through a kernel thread, the loop in * membarrier_{private,global}_expedited() may have observed that * kernel thread and not issued an IPI. It is therefore possible to * schedule between user-\u003ekernel-\u003euser threads without passing though * switch_mm(). Membarrier requires a barrier after storing to * rq-\u003ecurr, before returning to userspace, so provide them here: * * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly * provided by mmdrop(), * - a sync_core for SYNC_CORE.*/ if (mm) { membarrier_mm_sync_core_before_usermode(mm); mmdrop(mm); } if (unlikely(prev_state == TASK_DEAD)) { // 进程主动退出或者被终止 if (prev-\u003esched_class-\u003etask_dead) prev-\u003esched_class-\u003etask_dead(prev); // 所属调度类的task_dead方法 /* * Remove function-return probe instances associated with this * task and put them back on the free list.*/ kprobe_flush_task(prev); /* Task is done with its stack. */ /*释放进程的内核栈 */ put_task_stack(prev); // 把进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符 put_task_struct_rcu_user(prev); } tick_nohz_task_switch(); return rq; } 2.8.7 调度时机 调度进程的时机: （1）进程主动调用schedule()函数 （2）周期性地调度，抢占当前进程，强迫当前进程让出处理器 （3）唤醒进程的时候，被唤醒的进程可能抢占当前进程 （4）创建新进程的时候，新进程可能抢占当前进程。\n1.主动调度 内核中3种主动调度方式： （1）直接调用schedule()函数来调度进程 （2）调用有条件重调度函数cond_resched()。非抢占式内核中，函数cond_resched()判断当前进程是否设置了需要重新调度的标志，如果设置了，就调度进程；抢占式内核中，cond_resched()为空 （3）如果需要等待某个资源，例如互斥锁或信号量，那么把进程的状态设置为睡眠状态，然后调用schedule()函数以调度进程\n2.周期调度 周期调度的函数是scheduler_tick()，它调用当前进程所属调度类的task_tick方法。 （1）限期调度类的周期调度 task_tick –\u003e task_tick_dl –\u003e update_curr_dl\n// kernel/sched/deadline.c static void update_curr_dl(struct rq *rq) { struct task_struct *curr = rq-\u003ecurr; struct sched_dl_entity *dl_se = \u0026curr-\u003edl; u64 delta_exec, scaled_delta_exec; ... delta_exec = now - curr-\u003ese.exec_start; if (unlikely((s64)delta_exec \u003c= 0)) { if (unlikely(dl_se-\u003edl_yielded)) goto throttle; return; } ... dl_se-\u003eruntime -= scaled_delta_exec; // 计算限期进程的剩余运行时间 throttle: // // 如果限期进程用完了运行时间或者主动让出处理器 if (dl_runtime_exceeded(dl_se) || dl_se-\u003edl_yielded) { dl_se-\u003edl_throttled = 1; // 设置节流标志 /* If requested, inform the user about runtime overruns. */ if (dl_runtime_exceeded(dl_se) \u0026\u0026 (dl_se-\u003eflags \u0026 SCHED_FLAG_DL_OVERRUN)) dl_se-\u003edl_overrun = 1; __dequeue_task_dl(rq, curr, 0); if (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr))) enqueue_task_dl(rq, curr, ENQUEUE_REPLENISH); if (!is_leftmost(curr, \u0026rq-\u003edl)) resched_curr(rq); } ... } （2）实时调度类的周期调度 \\\n实时调度类的task_tick方法是函数task_tick_rt\n// linux-5.10.102/kernel/sched/rt.c static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued) { struct sched_rt_entity *rt_se = \u0026p-\u003ert; ... if (p-\u003epolicy != SCHED_RR) // 调度策略不是轮流调度 return; // 把时间片减一，如果没用完时间片，那么返回 if (--p-\u003ert.time_slice) return; // 用完了时间片，那么重新分配时间片 p-\u003ert.time_slice = sched_rr_timeslice; /* Requeue to the end of queue if we (and all of our ancestors) are not * the only element on the queue */ for_each_sched_rt_entity(rt_se) { if (rt_se-\u003erun_list.prev != rt_se-\u003erun_list.next) { requeue_task_rt(rq, p, 0); resched_curr(rq); return; } } } （3）公平调度类的周期调度 公平调度类的task_tick方法是函数task_tick_fair\n// kernel/sched/fair.c static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026curr-\u003ese; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); entity_tick(cfs_rq, se, queued); } ... } // kernel/sched/fair.c static void entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued) { ... if (cfs_rq-\u003enr_running \u003e 1) // 公平运行队列的进程数量超过1 check_preempt_tick(cfs_rq, curr); } // kernel/sched/fair.c static void check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr) { unsigned long ideal_runtime, delta_exec; struct sched_entity *se; s64 delta; ideal_runtime = sched_slice(cfs_rq, curr); delta_exec = curr-\u003esum_exec_runtime - curr-\u003eprev_sum_exec_runtime; if (delta_exec \u003e ideal_runtime) { resched_curr(rq_of(cfs_rq)); /* The current task ran long enough, ensure it doesn't get * re-elected due to buddy favours.*/ clear_buddies(cfs_rq, curr); return; } /* Ensure that a task that missed wakeup preemption by a * narrow margin doesn't have to wait for a full slice. * This also mitigates buddy induced latencies under load.*/ if (delta_exec \u003c sysctl_sched_min_granularity) return; se = __pick_first_entity(cfs_rq); delta = curr-\u003evruntime - se-\u003evruntime; if (delta \u003c 0) return; if (delta \u003e ideal_runtime) resched_curr(rq_of(cfs_rq)); } （4）中断返回时调度。 ARM64架构的中断处理程序的入口是e10_irq，中断处理程序执行完以后，跳转到标号ret_to_user以返回用户模式。标号ret_to_user判断当前进程的进程描述符的成员thread_info.flags有没有设置标志位集合_TIF_WORK_MASK中的任何一个标志位，如果设置了其中一个标志位，那么跳转到标号work_pending，标号work_pending调用函数do_notify_resume\n// arch/arm64/kernel/entry.S 5.10.102 代码中没有？ ret_to_user: disable_irq // 禁止中断 ldr x1, [tsk, #TSK_TI_FLAGS] and x2, x1, #_TIF_WORK_MASK cbnz x2, work_pending finish_ret_to_user: enable_step_tsk x1, x2 kernel_exit 0 ENDPROC(ret_to_user) work_pending: mov x0, sp /* * 寄存器x0存放第一个参数regs * 寄存器x1存放第二个参数task_struct.thread_info.flags */ bl do_notify_resume #ifdef CONFIG_TRACE_IRQFLAGS bl trace_hardirqs_on // 在用户空间执行时开启中断 #endif ldr x1, [tsk, #TSK_TI_FLAGS] // 重新检查单步执行 b finish_ret_to_user 函数do_notify_resume判断当前进程的进程描述符的成员thread_info.flags有没有设置需要重新调度的标志位_TIF_NEED_RESCHED，如果设置了，那么调用函数schedule()以调度进程。\n// arch/arm64/kernel/signal.c asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int thread_flags) { ... do { if (thread_flags \u0026 _TIF_NEED_RESCHED) { schedule(); } else { … } local_irq_disable(); thread_flags = READ_ONCE(current_thread_info()-\u003eflags); } while (thread_flags \u0026 _TIF_WORK_MASK); } 3.唤醒进程时抢占 唤醒进程的时候，被唤醒的进程可能抢占当前进程\n唤醒进程时抢占 （1）如果被唤醒的进程和当前进程属于相同的调度类，那么调用调度类的check_preempt_curr方法以检查是否可以抢占当前进程 （2）如果被唤醒的进程所属调度类的优先级高于当前进程所属调度类的优先级，那么给当前进程设置需要重新调度的标志\n调度类 check_preempt_curr方法是函数 算法 停机调度类 check_preempt_curr_stop 空函数 限期调度类 check_preempt_curr_dl 如果被唤醒的进程的绝对截止期限比当前进程的绝对截止期限小，那么给当前进程设置需要重新调度的标志 实时调度类 check_preempt_curr_rt 优先级比当前进程的优先级高，那么给当前进程设置需要重新调度的标志 公平调度类 check_preempt_wakeup 空闲调度类 check_preempt_curr_idle 无条件抢占，给当前进程设置需要重新调度的标志 check_preempt_wakeup函数\n// linux-5.10.102/kernel/sched/fair.c static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) { // 当前进程的调度策略是SCHED_IDLE，被唤醒的进程的调度策略是SCHED_NORMAL或者SCHED_BATCH，那么允许抢占，给当前进程设置需要重新调度的标志 struct task_struct *curr = rq-\u003ecurr; struct sched_entity *se = \u0026curr-\u003ese, *pse = \u0026p-\u003ese; ... if (unlikely(task_has_idle_policy(curr)) \u0026\u0026 likely(!task_has_idle_policy(p))) goto preempt; if (unlikely(p-\u003epolicy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION)) return; // 为当前进程和被唤醒的进程找到两个兄弟调度实体 find_matching_se(\u0026se, \u0026pse); update_curr(cfs_rq_of(se)); BUG_ON(!pse); if (wakeup_preempt_entity(se, pse) == 1) { // 判断是否可以抢占 // 允许抢占，给当前进程设置需要重新调度的标志 ... goto preempt; } return; preempt: resched_curr(rq); ... } static int wakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se) { s64 gran, vdiff = curr-\u003evruntime - se-\u003evruntime; if (vdiff \u003c= 0) return -1; gran = wakeup_gran(se); if (vdiff \u003e gran) return 1; return 0; } 4.创建新进程时抢占 使用系统调用fork、clone和 vfork创建新进程使，新进程可抢占当前进程；使用韩式kernel_thread创建新的内核线程是，新内核线程可抢占当前进程 5.内核抢占 内核抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，需要打开配置宏CONFIG_PREEMPT。抢占式内核和非抢占式内核。进程tthread_info结构体一个类型为int的成员preempt_count为抢占计数器。\n待补充\n6.高精度调度时钟 高精度时钟的精度是纳秒,需要通过配置宏启用。\n2.8.8 带宽管理 调度类管理进程占用的处理器带宽的方法\n1.限期调度类的带框管理 每个限期进程有自己的带宽，内核把限期进程的运行时间统计到根实时任务组的运行时间里面了，限期进程共享实时进程的带宽\n// kernel/sched/deadline.c static void update_curr_dl(struct rq *rq) { … if (rt_bandwidth_enabled()) { struct rt_rq *rt_rq = \u0026rq-\u003ert; raw_spin_lock(\u0026rt_rq-\u003ert_runtime_lock); if (sched_rt_bandwidth_account(rt_rq)) rt_rq-\u003ert_time += delta_exec; raw_spin_unlock(\u0026rt_rq-\u003ert_runtime_lock); } } 2.实时调度类的带宽管理 指定实时进程的带宽有以下两种方式 （1）指定全局带宽：带宽包含的两个参数是周期和运行时间，即指定在每个周期内所有实时进程的运行时间总和。 默认的周期是1秒，默认的运行时间是0.95秒。可以借助文件“/proc/sys/kernel/sched_rt_period_us”设置周期，借助文件“/proc/sys/kernel/sched_rt_runtime_us”设置运行时间 配置宏CONFIG_RT_GROUP_SCHED，即支持实时任务组，那么全局带宽指定了所有实时任务组的总带宽 （2）指定每个实时任务组的带宽：在每个指定的周期，允许一个实时任务组最多执行长时间。当实时任务组在一个周期用完了带宽时，这个任务组将会被节流，不允许继续运行，直到下一个周期。可以使用cgroup设置一个实时任务组的周期和运行时间，cgroup版本1的配置方法如下\ncgroup版本1的配置方法 1）cpu.rt_period_us：周期，默认值是1秒。 2）cpu.rt_runtime_us：运行时间，默认值是0，把运行时间设置为非零值以后才允许把实时进程加入任务组，设置为−1表示没有带宽限制。 cgroup版本1的配置示例如下。 1）挂载cgroup文件系统，把CPU控制器关联到控制组层级树。 mount -t cgroup -o cpu none /sys/fs/cgroup/cpu 2）创建一个任务组。 cd /sys/fs/cgroup/cpu mkdir browser # 创建\"browser\"任务组 3）把实时运行时间设置为10毫秒。 echo 10000 \u003e browser/cpu.rt_runtime_us 4）把一个实时进程加入任务组。 echo \u003e browser/cgroup.procs cgroup版本2从内核4.15版本开始支持CPU控制器，暂时不支持实时进程。\n一个处理器用完了实时运行时间，可以从其他处理器借用实时运行时间，称为实时运行时间共享，对应调度特性RT_RUNTIME_SHARE，默认开启。\nkernel/sched/features.h SCHED_FEAT(RT_RUNTIME_SHARE, true) 实时任务组的带宽存放在结构体task_group的成员rt_bandwidth中：\n// kernel/sched/sched.h struct task_group { … #ifdef CONFIG_RT_GROUP_SCHED … struct rt_bandwidth rt_bandwidth; #endif … }; 节流\n书中详细解释\n3.公平调度类的带宽管理 使用周期和限额指定一个公平任务组的带宽 使用cgroup设置一个公平任务组的周期和限额，cgroup版本1的配置 \\\ncgroup版本1的配置方法 cgroup版本2的配置示例 \\ cgroup版本2的配置方法 （1）节流：在以下两种情况下，调度器会检查公平运行队列是否用完运行时间。 1）put_prev_task_fair：调度器把当前正在运行的普通进程放回公平运行队列。 2）pick_next_task_fair：当前正在运行的进程属于公平调度类，调度器选择下一个普通进程。\n（2）周期定时器：在每个周期的开始，重新填充任务组的带宽，把带宽分配给节流的公平运行队列。周期定时器的处理函数是sched_cfs_period_timer，它把主要工作委托给函数do_sched_cfs_period_timer\n// kernel/sched/fair.c static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun) { … throttled = !list_empty(\u0026cfs_b-\u003ethrottled_cfs_rq); … __refill_cfs_bandwidth_runtime(cfs_b); // 新填充任务组的带宽 if (!throttled) { cfs_b-\u003eidle = 1; return 0; } … while (throttled \u0026\u0026 cfs_b-\u003eruntime \u003e 0) { runtime = cfs_b-\u003eruntime; raw_spin_unlock(\u0026cfs_b-\u003elock); // 把任务组的可用运行时间分配给节流的公平运行队列 runtime = distribute_cfs_runtime(cfs_b, runtime, runtime_expires); raw_spin_lock(\u0026cfs_b-\u003elock); throttled = !list_empty(\u0026cfs_b-\u003ethrottled_cfs_rq); cfs_b-\u003eruntime -= min(runtime, cfs_b-\u003eruntime); } … } 函数__refill_cfs_bandwidth_runtime负责重新填充任务组的带宽：“把可用运行时间设置成限额，把运行时间的到期时间设置成当前时间加上1个周期”\n// kernel/sched/fair.c void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b) { u64 now; if (cfs_b-\u003equota == RUNTIME_INF) return; now = sched_clock_cpu(smp_processor_id()); cfs_b-\u003eruntime = cfs_b-\u003equota; cfs_b-\u003eruntime_expires = now + ktime_to_ns(cfs_b-\u003eperiod); } 函数distribute_cfs_runtime负责把任务组的可用运行时间分配给节流的公平运行队列\nstatic void distribute_cfs_runtime(struct cfs_bandwidth *cfs_b) { struct cfs_rq *cfs_rq; u64 runtime, remaining = 1; rcu_read_lock(); list_for_each_entry_rcu(cfs_rq, \u0026cfs_b-\u003ethrottled_cfs_rq, throttled_list) { struct rq *rq = rq_of(cfs_rq); struct rq_flags rf; rq_lock_irqsave(rq, \u0026rf); if (!cfs_rq_throttled(cfs_rq)) goto next; /* By the above check, this should never be true */ SCHED_WARN_ON(cfs_rq-\u003eruntime_remaining \u003e 0); raw_spin_lock(\u0026cfs_b-\u003elock); /* cfs_rq-\u003eruntime_remaining是公平运行队列的剩余运行时间 */ runtime = -cfs_rq-\u003eruntime_remaining + 1; if (runtime \u003e cfs_b-\u003eruntime) runtime = cfs_b-\u003eruntime; cfs_b-\u003eruntime -= runtime; remaining = cfs_b-\u003eruntime; raw_spin_unlock(\u0026cfs_b-\u003elock); cfs_rq-\u003eruntime_remaining += runtime; /* we check whether we're throttled above */ /* 上面检查过是否被节流 */ if (cfs_rq-\u003eruntime_remaining \u003e 0) unthrottle_cfs_rq(cfs_rq); next: rq_unlock_irqrestore(rq, \u0026rf); if (!remaining) break; } rcu_read_unlock(); } （3）取有余补不足：\n2.9 SMP调度 SMP系统进程调度器特性: （1）使每个处理器负载尽可能均衡 （2）设置进程的处理器亲和性(affinity)，即允许进程在哪些处理器上执行 （3）进程从一个处理器迁移到另一个处理器\n2.9.1 进程的处理器亲和性 进程描述符增加两个成员\n// include/linux/sched.h struct task_struct { … int nr_cpus_allowed; // 保存允许的处理器掩码 cpumask_t cpus_allowed;\t// 保存允许的处理器数量 … }; 1.应用编程接口 内核系统调用\n// sched_setaffinity用来设置进程的处理器亲和性掩码 int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); // sched_getaffinity用来获取进程的处理器亲和性掩码 int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); 内核线程函数设置处理器亲和性掩码\n// kthread_bind用来把一个刚刚创建的内核线程绑定到一个处理器 void kthread_bind(struct task_struct *p, unsigned int cpu); // set_cpus_allowed_ptr用来设置内核线程的处理器亲和性掩码 int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask); 2.使用cpuset配置 cpuset在单独使用的时候，可以使用cpuset伪文件系统配置，配置方法\n2.9.2 对调度器的扩展 SMP系统上，调度类增加方法\n// kernel/sched/sched.h struct sched_class { … #ifdef CONFIG_SMP // 为进程选择运行队列 int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); // 在进程被迁移到新的处理器之前调用 void (*migrate_task_rq)(struct task_struct *p); // 用来在进程被唤醒以后调用 void (*task_woken) (struct rq *this_rq, struct task_struct *task); // 设置处理器亲和性的时候执行调度类的特殊处理 void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); #endif … }; 进程在内存和缓存中的数据是最少的，是有价值的实现负载均衡的机会：1）创建新进程，2）调用execve装载程序\n创建新进程时负载均衡 装载程序时负载均衡 2.9.3 限期调度类的处理器负载均衡 2.9.4 实时调度类的处理器负载均衡 2.9.5 公平调度类的处理器负载均衡 2.9.6 迁移线程 每个处理器有一个迁移线程，线程名称是“migration/”，属于停机调度类，可以抢占所有其他进程，其他进程不可以抢占它。迁移线程有两个作用 （1）调度器发出迁移请求，迁移线程处理迁移请求，把进程迁移到目标处理器。 （2）执行主动负载均衡。\n2.9.7 隔离处理器 2.10 进程的上下文安全 第3章 内存管理 3.1 内存管理子系统架构 用户空间、内核空间和硬件3个层面 1.用户空间 应用程序使用malloc()申请内存，使用free()释放内存。 malloc()和free()是glibc库的内存分配器ptmalloc提供的接口，ptmalloc使用系统调用brk或mmap向内核以页为单位申请内存，然后划分成小内存块分配给应用程序 用户空间的内存分配器，除了glibc库的ptmalloc，还有谷歌的tcmalloc和FreeBSD的jemalloc\n2.内核空间 （1）内核空间的基本功能 虚拟内存管理负责从进程的虚拟地址空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页 内核使用延迟分配物理内存的策略，进程第一次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页 页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口kmalloc()和释放内存的接口kfree()，支持3种块分配器：SLAB分配器、SLUB分配器和SLOB分配器。 \\\n（2）内核空间的扩展功能。 \\\n不连续页分配器提供了分配内存的接口vmalloc和释放内存的接口vfree 连续内存分配器（Contiguous Memory Allocator，CMA）用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用 \\\n3.硬件层面 处理器包含一个称为内存管理单元（Memory Management Unit，MMU）的部件，负责把虚拟地址转换成物理地址 内存管理单元包含一个称为页表缓存（Translation Lookaside Buffer，TLB）的部件，保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表 \\\n3.2 虚拟地址空间布局 3.2.1 虚拟地址空间划分 ARM64处理器不支持完全的64位虚拟地址，ARMv8.2 标准的大虚拟地址(Large Virtual Address，LVA)支持，并且页长度是64KB，那么虚拟地址的最大宽度是52位 可以为虚拟地址配置比最大宽度小的宽度，并且可以为内核虚拟地址和用户虚拟地址配置不同的宽度。转换控制寄存器（Translation Control Register）TCR_EL1的字段T0SZ定义了必须是全0的最高位的数量，字段T1SZ定义了必须是全1的最高位的数量，用户虚拟地址的宽度是（64-TCR_EL1.T0SZ），内核虚拟地址的宽度是（64-TCR_EL1.T1SZ） \\\n页长度 虚拟地址宽度 4KB 39 16KB 47 64KB 42 可选择48位虚拟地址 3.2.2 用户虚拟地址空间布局 进程的用户虚拟地址空间的起始地址是0，长度是TASK_SIZE，ARM64架构下TASK_SIZE下 （1）32位用户空间程序：TASK_SIZE值是TASK_SIZE_32，即0x100000000，4GB （2）64位用户空间程序：TASK_SIZE值是TASK_SIZE_64，即 2^VA_BITS，VA_BITS是编译内核时选择的虚拟地址位数。 \\\n//arch/arm64/include/asm/memory.h linux4.x #define VA_BITS (CONFIG_ARM64_VA_BITS) #define TASK_SIZE_64 (UL(1) \u003c\u003c VA_BITS) #ifdef CONFIG_COMPAT /* 支持执行32位用户空间程序 */ #define TASK_SIZE_32 UL(0x100000000) /* test_thread_flag(TIF_32BIT)判断用户空间程序是不是32位 */ #define TASK_SIZE (test_thread_flag(TIF_32BIT) ? \\ TASK_SIZE_32 : TASK_SIZE_64) #define TASK_SIZE_OF(tsk) (test_tsk_thread_flag(tsk, TIF_32BIT) ? \\ TASK_SIZE_32 : TASK_SIZE_64) #else #define TASK_SIZE TASK_SIZE_64 #endif /* CONFIG_COMPAT */ // linux-5.10.102/arch/arm64/include/asm/memory.h #define VA_BITS\t(CONFIG_ARM64_VA_BITS) #define _PAGE_OFFSET(va)\t(-(UL(1) \u003c\u003c (va))) #define PAGE_OFFSET\t(_PAGE_OFFSET(VA_BITS)) #define KIMAGE_VADDR\t(MODULES_END) #define BPF_JIT_REGION_START\t(KASAN_SHADOW_END) #define BPF_JIT_REGION_SIZE\t(SZ_128M) #define BPF_JIT_REGION_END\t(BPF_JIT_REGION_START + BPF_JIT_REGION_SIZE) #define MODULES_END\t(MODULES_VADDR + MODULES_VSIZE) #define MODULES_VADDR\t(BPF_JIT_REGION_END) #define MODULES_VSIZE\t(SZ_128M) #define VMEMMAP_START\t(-VMEMMAP_SIZE - SZ_2M) #define VMEMMAP_END\t(VMEMMAP_START + VMEMMAP_SIZE) #define PCI_IO_END\t(VMEMMAP_START - SZ_2M) #define PCI_IO_START\t(PCI_IO_END - PCI_IO_SIZE) #define FIXADDR_TOP\t(PCI_IO_START - SZ_2M) 进程的用户虚拟地址空间包含： （1）代码段、数据段和未初始化数据段 （2）动态库代码段、数据段和初始化数据段 （3）存放动态生成的数据的堆 （4）存放局部变量和实现函数调用的栈 （5）存放在栈底部的环境变量和参数字符串 （6）把文件区间映射到虚拟地址空间的内存映射区域 内核使用内存描述符mm_struct描述进程的用户虚拟地址空间，内存描述符主要成员\natomic_t mm_users; // 共享同一个用户虚拟地址空间进程的数量，即线程组包含的进程的数量 atomic_t mm_count; // 内存描述符的引用计数 struct vm_area_struct *mmap; // 虚拟内存区域链表 struct rb_root mm_rb; // 虚拟内存区域红黑树 unsigned long(*get_unmapped_area)(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags); // 在内存映射区域找到一个没有映射的区域 pgd_t *pgd; // 指向页全局目录，即第一级页表 unsigned long mmap_base; // 内存映射区的起始地址 unsigned long task_size; // 用户虚拟地址空间的长度 unsigned long start_code, end_code; // 代码段的起始地址和结束地址 unsigned long start_data, end_data; // 数据段的起始地址和结束地址 unsigned long start_brk, brk; // 堆的起始地址和结束地址 unsigned long start_stack; // 栈的起始地址 unsigned long arg_start, arg_end; // 参数字符串起始地址和结束地址 unsigned long env_start, env_end; // 环境变量的起始地址和结束地址 struct mm_struct *mm; // 进程mm指向一个内存描述符，内核线程mm为空指针 struct mm_struct　*active_mm; // 进程的active_mm和mm总是指向同一个内存描述符 // 内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符 进程地址空间随机化： （1）进程描述符成员personality是否设置ADDR_NO_RANDOMIZE （2）全局变量randomize_va_spce：0表示关闭虚拟地址空间随机化，1表示内存映射区和栈起始地址随机化，2表示内存映射区、栈和堆起始地址随机化，文件/proc/sys/kernel/randomize_va_space修改 \\\n栈向下增长，起始地址STACK_TOP，\n// arch/arm64/include/asm/processor.h #define STACK_TOP_MAX TASK_SIZE_64 #ifdef CONFIG_COMPAT /* 支持执行32位用户空间程序 */ #define AARCH32_VECTORS_BASE 0xffff0000 #define STACK_TOP (test_thread_flag(TIF_32BIT) ? \\ AARCH32_VECTORS_BASE : STACK_TOP_MAX) #else #define STACK_TOP STACK_TOP_MAX #endif /* CONFIG_COMPAT */ 内存映射区域的起始地址是内存描述符的成员 mmap_base\n用户虚拟地址空间两种布局 新布局：内存映射区域自顶向下增长，起始地址是(STACK_TOP − 栈的最大长度 − 间隙)，默认启用内存映射区域随机化，需要把起始地址减去一个随机值 \\\n进程调用execve以装载ELF文件的时候，函数load_elf_binary将会创建进程的用户虚拟地址空间 \\\n函数arch_pick_mmap_layout负责选择内存映射区域的布局。ARM64架构定义的函数arch_pick_mmap_layout\n// linux-5.10.102/mm/util.c void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack) { unsigned long random_factor = 0UL; if (current-\u003eflags \u0026 PF_RANDOMIZE) random_factor = arch_mmap_rnd(); if (mmap_is_legacy(rlim_stack)) { // 自底向上 mm-\u003emmap_base = TASK_UNMAPPED_BASE + random_factor; mm-\u003eget_unmapped_area = arch_get_unmapped_area; // } else { // 自顶向下 mm-\u003emmap_base = mmap_base(random_factor, rlim_stack); mm-\u003eget_unmapped_area = arch_get_unmapped_area_topdown; } } static int mmap_is_legacy(struct rlimit *rlim_stack) { if (current-\u003epersonality \u0026 ADDR_COMPAT_LAYOUT) return 1; if (rlim_stack-\u003erlim_cur == RLIM_INFINITY) return 1; return sysctl_legacy_va_layout; } 内存映射区域的起始地址的计算\n// linux-5.10.102/arch/arm64/include/asm/efi.h #ifdef CONFIG_COMPAT #define STACK_RND_MASK\t(test_thread_flag(TIF_32BIT) ? \\ 0x7ff \u003e\u003e (PAGE_SHIFT - 12) : \\ 0x3ffff \u003e\u003e (PAGE_SHIFT - 12)) #else #define STACK_RND_MASK\t(0x3ffff \u003e\u003e (PAGE_SHIFT - 12)) #endif // arch/arm64/mm/mmap.c #define MIN_GAP (SZ_128M + ((STACK_RND_MASK \u003c\u003c PAGE_SHIFT) + 1)) #define MAX_GAP (STACK_TOP/6*5) static unsigned long mmap_base(unsigned long rnd) { unsigned long gap = rlimit(RLIMIT_STACK); if (gap \u003c MIN_GAP) gap = MIN_GAP; else if (gap \u003e MAX_GAP) gap = MAX_GAP; return PAGE_ALIGN(STACK_TOP - gap - rnd); } 函数load_elf_binary：函数setup_arg_pages把栈顶设置为STACK_TOP减去随机值，然后把环境变量和参数从临时栈移到最终的用户栈；函数set_brk设置堆的起始地址，如果启用堆随机化，把堆的起始地址加上随机值\n// fs/binfmt_elf.c static int load_elf_binary(struct linux_binprm *bprm) { … retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP), executable_stack); … retval = set_brk(elf_bss, elf_brk, bss_prot); … if ((current-\u003eflags \u0026 PF_RANDOMIZE) \u0026\u0026 (randomize_va_space \u003e 1)) { current-\u003emm-\u003ebrk = current-\u003emm-\u003estart_brk = arch_randomize_brk(current-\u003emm); } … } 3.2.3 内核地址空间布局 ARM64处理器架构内核地址空间布局 (1)先行映射区范围[PAGE_OFFSET, 2^64-1]，起始地址PAGE_OFFSET = (OxFFFF FFFF FFFF FFFF « (VA_BITS-1))，长度为内核虚拟地址空间的一半，虚拟地址和物理地址是线性关系 \\ 虚拟地址 = ((物理地址-PHYS_OFFSET)+PAGE_OFFSET)，PHY_OFFSET是内存起始物理地址 (2)vmemmap 区域的范围是[VMEMMAP_START, PAGE_OFFSET)，长度是VMEMMAP_SIZE =（线性映射区域的长度 / 页长度 * page结构体的长度上限） (3)PCI I/O区域的范围是[PCI_IO_START, PCI_IO_END)，长度是16MB，结束地址是PCI_IO_END = (VMEMMAP_START − 2MB)。外围组件互联（Peripheral Component Interconnect，PCI）是一种总线标准，PCI I/O区域是PCI设备的I/O地址空间 (4)定映射区域的范围是[FIXADDR_START, FIXADDR_TOP)，长度是FIXADDR_SIZE，结束地址是FIXADDR_TOP = (PCI_IO_START − 2MB) (5)vmalloc区域的范围是[VMALLOC_START, VMALLOC_END），起始地址是VMALLOC_START，等于内核模块区域的结束地址，结束地址是VMALLOC_END = (PAGE_OFFSET − PUD_SIZE − VMEMMAP_SIZE − 64KB)，其中PUD_SIZE是页上级目录表项映射的地址空间的长度 vmalloc区域是函数vmalloc使用的虚拟地址空间，内核镜像在vmalloc区域，起始虚拟地址是(KIMAGE_VADDR + TEXT_OFFSET) ，其中KIMAGE_VADDR是内核镜像的虚拟地址的基准值，等于内核模块区域的结束地址MODULES_END；TEXT_OFFSET是内存中的内核镜像相对内存起始位置的偏移 (6)内核模块区域的范围是[MODULES_VADDR, MODULES_END)，长度是128MB，起始地址是MODULES_VADDR =（内核虚拟地址空间的起始地址 + KASAN影子区域的长度）。内核模块区域是内核模块使用的虚拟地址空间 (7)KASAN影子区域的起始地址是内核虚拟地址空间的起始地址，长度是内核虚拟地址空间长度的1/8。内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具 \\\n3.3 物理地址空间 处理器通过外围设备控制器的寄存器访问外围设备，寄存器分为控制寄存器、状态寄存器和数据寄存器三大类，外围设备的寄存器通常被连续地编址。处理器对外围设备寄存器的编址方式有两种： （1）I/O映射方式(I/O-mapped) （2）内存映射方式(memroy-mapped)：精简指令集的处理器通常只实现一个物理地址空间，外围设备和物理内存使用统一的物理地址空间，处理器可以像访问一个内存单元那样访问外围设备，不需要提供专门的I/O指令 \\\n程序通过虚拟地址访问外设寄存器，内核函数把外设寄存器物理地址映射到虚拟地址空间\n// ioremap()把外设寄存器物理地址映射到内核虚拟地址空间 void* ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); // io_remap_pfn_range()函数把外设寄存器的物理地址映射到进程的用户虚拟地址空间 int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn, unsigned long size, pgprot_t prot); // iounmap()删除函数ioremap()创建映射 void iounmap(void *addr); ARM64架构两种内存类型： （1）正常内存(Normal Memory)：包括物理内存和只读存储器(ROM)，共享属性和可缓存 （2）设备内存(Device Memory)：指分配给外围设备寄存器的物理地址区域，外部共享，不可缓存 ARM64架构3种属性把设备分为4种类型: （1）Device-nGnRnE （2）Device-nGnRE。 （3）Device-nGRE。 （4）Device-GRE \\\n寄存器TCR_EL1（Translation Control Register for Exception Level 1，异常级别1的转换控制寄存器）的字段IPS（Intermediate Physical Address Size，中间物理地址长度）控制物理地址的宽度，IPS字段的长度是3位\n3.4　内存映射 进程在虚拟地址空间中创建映射： （1）文件映射，把文件一个区间映射到进程虚拟地址空间，数据源是存储设备上的文件，文件页 （2）匿名映射，把物理内存映射到进程虚拟地址空间，无数据源，匿名页 修改对其他进程可见和释放传递底层文件，内存映射分为共享映射和私有映射。 \u0026ensp；（1）共享映射：修改数据时映射相同区域的其他进程可以看见，如果是文件支持的映射，修改会传递到底层文件。 （2）私有映射：第一次修改数据时会从数据源复制一个副本，然后修改副本，其他进程看不见，不影响数据源 两个进程可以使用共享的文件映射实现共享内存，进程间通信？。匿名映射通常是私有映射，共享的匿名映射只可能出现在父进程和子进程之间。 进程的虚拟地址空间中，代码段和数据段是私有的文件映射，未初始化数据段、堆和栈是私有的匿名映射 内存映射的原理。 （1）创建内存映射的时候，在进程的用户虚拟地址空间中分配一个虚拟内存区域。 （2）Linux内核采用延迟分配物理内存的策略，在进程第一次访问虚拟页的时候，产生缺页异常。如果是文件映射，那么分配物理页，把文件指定区间的数据读到物理页中，然后在页表中把虚拟页映射到物理页；如果是匿名映射，那么分配物理页，然后在页表中把虚拟页映射到物理页\n3.4.1 应用编程接口 系统调用\n// 1.mmap()创建内存映射 void *mmap(void *addr, size_t length, int prot, int flags, in fd, off_t offset); // 2. mremap()扩大或缩小内存映射，可移动 void *mreemap(void *old_address, size_t old_size, size_t new_size, int flags, ... /*void *new_address */); // 3. munmap() 删除内存印刷 int munmap(void *addr, size_t length); // 4. brk() 设置堆上界 int brk(void *addr); // 6. mprotect()设置虚拟内存区域的访问权限 int mprotect(void *addr, size_t len, int prot); // 7. madvise 箱内核体术内存使用建议，配合内核预读和缓存 int madvise(void *addr, size_t length, int advice); 内核空间函数\n// 1. remap_pfn_range把内存的物理页映射到进程的虚拟地址空间，实现进程和内核共享内存 int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn,unsigned long size, pgprot_t prot); // 2.io_remap_pfn_range把外设寄存器的物理地址映射到进程的虚拟地址空间，进程可以直接访问外设寄存器 int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn, unsigned long size, pgprot_t prot); 应用程序通常使用C标准库提供的函数malloc()申请内存。glibc库的内存分配器ptmalloc使用brk或mmap向内核以页为单位申请虚拟内存，然后把页划分成小内存块分配给应用程序。默认的阈值是128KB，如果应用程序申请的内存长度小于阈值，ptmalloc分配器使用brk向内核申请虚拟内存，否则ptmalloc分配器使用mmap向内核申请虚拟内存 \\\n应用程序可以直接使用mmap向内核申请虚拟内存 系统调用mmap() 系统调用mprotect() 系统调用madvise()\n3.4.2 数据结构 1. 虚拟内存区域 内核使用结构体vm_area_struct描述虚拟内存区域\nstruct vm_area_struct { /* The first cache line has the info for VMA tree walking. */ /* Our start address within vm_mm. */ unsigned long vm_start;\t// 起始地址 /* The first byte after our end address within vm_mm. */ unsigned long vm_end; // 结束地址 /* linked list of VM areas per task, sorted by address */ // 虚拟内存区域链表，按起始地址排序 struct vm_area_struct *vm_next, *vm_prev; // 红黑树节点 struct rb_node vm_rb; /* Largest free memory gap in bytes to the left of this VMA. * Either between this VMA and vma-\u003evm_prev, or between one of the * VMAs below us in the VMA rbtree and its -\u003evm_prev. This helps * get_unmapped_area find a free area of the right size.*/ unsigned long rb_subtree_gap; /* Second cache line starts here. */ // 指向内存描述符，即虚拟内存区域所属的用户虚拟地址空间 struct mm_struct *vm_mm;\t/* The address space we belong to. */ /* Access permissions of this VMA. * See vmf_insert_mixed_prot() for discussion.*/ // 保护位，即访问权限 pgprot_t vm_page_prot; unsigned long vm_flags;\t/* Flags, see mm.h. */ /* For areas with an address space and backing store, * linkage into the address_space-\u003ei_mmap interval tree.*/ // 为了支持查询一个文件区间被映射到哪些虚拟内存区域， // 把一个文件映射到的所有虚拟内存区域加入该文件的地址空间结构体 // address_space的成员i_mmap指向的区间树 struct { struct rb_node rb; unsigned long rb_subtree_last; } shared; /* file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma * list, after a COW of one of the file pages.\tA MAP_SHARED vma * can only be in the i_mmap tree. An anonymous MAP_PRIVATE, stack * or brk vma (with NULL file) can only be in an anon_vma list.*/ // 把虚拟内存区域关联的所有anon_vma实例串联起来。 // 一个虚拟内存区域会关联到父进程的anon_vma实例和自己的anon_vma实例 struct list_head anon_vma_chain; /* Serialized by mmap_lock \u0026 * page_table_lock */ // 指向一个anon_vma实例，结构体anon_vma用来组织匿名页 // 被映射到的所有虚拟地址空间 struct anon_vma *anon_vma;\t/* Serialized by page_table_lock */ /* Function pointers to deal with this struct. */ // 虚拟内存操作集合 const struct vm_operations_struct *vm_ops; /* Information about our backing store: */ // 文件偏移，单位是页 unsigned long vm_pgoff;\t/* Offset (within vm_file) in PAGE_SIZE units */ // 文件，如果是私有的匿名映射，该成员是空指针 struct file * vm_file;\t/* File we map to (can be NULL). */ void * vm_private_data;\t/* was vm_pte (shared mem) */ #ifdef CONFIG_SWAP atomic_long_t swap_readahead_info; #endif #ifndef CONFIG_MMU struct vm_region *vm_region;\t/* NOMMU mapping region */ #endif #ifdef CONFIG_NUMA struct mempolicy *vm_policy;\t/* NUMA policy for the VMA */ #endif struct vm_userfaultfd_ctx vm_userfaultfd_ctx; } __randomize_layout; 文件映射的虚拟内存区域 （1）成员vm_file指向文件的一个打开实例（file）。索引节点代表一个文件，描述文件的属性。 （2）成员vm_pgoff存放文件的以页为单位的偏移。 （3）成员vm_ops指向虚拟内存操作集合，创建文件映射的时候调用文件操作集合中的mmap方法（file-\u003ef_op-\u003emmap）以注册虚拟内存操作集合。例如：假设文件属于EXT4文件系统，文件操作集合中的mmap方法是函数ext4_file_mmap，该函数把虚拟内存区域的成员vm_ops设置为ext4_file_vm_ops\n共享匿名映射的虚拟内存区域 （1）成员vm_file指向文件的一个打开实例（file）。 （2）成员vm_pgoff存放文件的以页为单位的偏移。 （3）成员vm_ops指向共享内存的虚拟内存操作集合shmem_vm_ops。\n私有匿名映射的虚拟内存区域 （1）页保护位（vm_area_struct.vm_page_prot）：描述虚拟内存区域的访问权限。内核定义了一个保护位映射数组，把VM_READ、VM_WRITE、VM_EXEC和VM_SHARED这4个标志转换成保护位组合 P代表私有（Private），S代表共享（Shared），后面的3个数字分别表示可读、可写和可执行，例如__P000表示私有、不可读、不可写和不可执行，__S111表示共享、可读、可写和可执行\n// mm/mmap.c pgprot_t protection_map[16] = { __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 }; pgprot_t vm_get_page_prot(unsigned long vm_flags) { return __pgprot(pgprot_val(protection_map[vm_flags \u0026 (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) | pgprot_val(arch_vm_get_page_prot(vm_flags))); } // include/linux/mman.h #ifndef arch_vm_get_page_prot #define arch_vm_get_page_prot(vm_flags) __pgprot(0) #endif 虚拟内存区域标志：结构体vm_area_struct的成员vm_flags存放虚拟内存区域的标志，头文件“include/linux/mm.h”定义了各种标志 VM_READ、VM_WRITE、VM_EXEC、VM_SHARED、VM_GROWSDOWN、VM_DONTEXPAND、VM_ACCOUNT、VM_NORESERVE、VM_HUGETLB、VM_ARCH_1、VM_ARCH_2、VM_HUGEPAGE、VM_MERGEABLE\n虚拟内存操作集合（vm_operations_struct）：定义了虚拟内存区域的各种操作方法\n// include/linux/mm.h struct vm_operations_struct { // 在创建虚拟内存区域时调用open方法，通常不使用，设置为空指针 void (*open)(struct vm_area_struct * area); // 在删除虚拟内存区域时调用close方法，通常不使用，设置为空指针 void (*close)(struct vm_area_struct * area); // 使用系统调用mremap移动虚拟内存区域时调用mremap方法 int (*mremap)(struct vm_area_struct * area); // 使用系统调用mremap移动虚拟内存区域时调用mremap方法 int (*fault)(struct vm_fault *vmf); // huge_fault方法针对使用透明巨型页的文件映射 int (*huge_fault)(struct vm_fault *vmf, enum page_entry_size pe_size); // 读文件映射的虚拟页时，如果没有映射到物理页，生成缺页异常 void (*map_pages)(struct vm_fault *vmf, pgoff_t start_pgoff, pgoff_t end_pgoff); /* 通知以前的只读页即将变成可写， * 如果返回一个错误，将会发送信号SIGBUS给进程*/ int (*page_mkwrite)(struct vm_fault *vmf); /* 使用VM_PFNMAP或者VM_MIXEDMAP时调用，功能和page_mkwrite相同*/ int (*pfn_mkwrite)(struct vm_fault *vmf); … } 2.链表和树 虚拟内存区域的链表和树 (1)双向链表，mm_struct.mmap指向第一个vm_area_struct实例 (2)红黑树，mm_struct.mm_rb指向红黑树的根 \\\n3.4.3 创建内存映射 C标准库封装了函数mmap用来创建内存映射\nasmlinkage long sys_mmap(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, off_t off); asmlinkage long sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, off_t off); ARM64架构只实现系统调用mmap\n系统调用sys_mmap执行流程 do_mmap的执行流程 待补充\n3.4.4 虚拟内存过量提交策略 虚拟内存过量提交，是指所有进程提交的虚拟内存的总和超过物理内存的容量，内存管理子系统支持3种虚拟内存过量 （1）OVERCOMMIT_GUESS(0)：猜测，估算可用内存的数量，因为没法准确计算可用内存的数量，所以说是猜测。 （2）OVERCOMMIT_ALWAYS(1)：总是允许过量提交。 （3）OVERCOMMIT_NEVER(2)：不允许过量提交。 /proc/sys/vm/overcommit_memory修改策略 在创建新的内存映射时，调用函数__vm_enough_memory根据虚拟内存过量提交策略判断内存是否足够\n3.4.5 删除内存映射 系统调用munmap用来删除内存映射，它有两个参数：起始地址和长度，mm/mmap.c中的函数do_munmap\n系统调用munmap执行流程 3.5 物理内存组织 3.5.1 体系结构 多处理器系统两种体系结构： (1)非一致内存访问(Non-Uniform Memory Access NUMA)：内存为多个内存节点多处理器系统 (2)对称多处理器(Symmetric Multi-Process SMP)：一直内存访问(UMA)\n3.5.2 内存模型 内存管理子系统支持3种内存模型 (1)平坦内存(Flat Memory)：内存物理地址空间是连续的 (2)不连续内存(Discontiguous Memory)：内存物理地址空间存在空洞 (3)系数内存(Sparse Memory)：内存物理地址空间存在空洞\n3.5.3 三级结构 内存管理子系统使用节点(node)、区域(zone)和页(page)三级结构描述物理内存。 \\\n1.内存节点 内存节点两种情况： （1）NUMA系统内存节点 （2）具有不连续内存的UMA系统 内存节点使用pglist_data结构体描述内存布局，内核定义宏NODE_DATA(nid)，获取节点的pglist_data实例。平坦内存模型，只有一个pglist_data实例contig_page_data\n内存节点的pglist_data实例 pglist_data结构主要成员：\n// include/linux/mmzone.h typedef struct pglist_data { struct zone node_zones[MAX_NR_ZONES]; /* 内存区域数组 */ struct zonelist node_zonelists[MAX_ZONELISTS]; /* 备用区域列表 */ int nr_zones; /* 该节点包含的内存区域数量 */ #ifdef CONFIG_FLAT_NODE_MEM_MAP /* 除了稀疏内存模型以外 */ struct page *node_mem_map; /* 页描述符数组 */ #ifdef CONFIG_PAGE_EXTENSION struct page_ext *node_page_ext; /* 页的扩展属性 */ #endif #endif … unsigned long node_start_pfn; /* 该节点的起始物理页号 */ unsigned long node_present_pages; /* 物理页总数 */ unsigned long node_spanned_pages; /* 物理页范围的总长度，包括空洞 */ int node_id; /* 节点标识符 */ … } pg_data_t; 2.内存区域 内核定义内存节点区域\n// include/linux/mmzone.h enum zone_type { #ifdef CONFIG_ZONE_DMA ZONE_DMA, // 直接内存访问区域 #endif #ifdef CONFIG_ZONE_DMA32 ZONE_DMA32, #endif // 内核虚拟地址和物理地址是线性映射的关系，即虚拟地址 =（物理地址 + 常量） ZONE_NORMAL, // 直接映射区域 #ifdef CONFIG_HIGHMEM ZONE_HIGHMEM, // 高端内存区域 #endif ZONE_MOVABLE, // 可移动区域 #ifdef CONFIG_ZONE_DEVICE ZONE_DEVICE, // 设备区域 #endif __MAX_NR_ZONES }; 每个内存区域用一个zone结构体描述\n// include/linux/mmzone.h struct zone { unsigned long watermark[NR_WMARK]; /* 页分配器使用的水线 */ … long lowmem_reserve[MAX_NR_ZONES]; /* 页分配器使用，当前区域保留多少页不能借给 高的区域类型 */ … struct pglist_data *zone_pgdat; /* 指向内存节点的pglist_data实例 */ struct per_cpu_pageset __percpu *pageset; /* 每处理器页集合 */ … unsigned long zone_start_pfn; /* 当前区域的起始物理页号 */ unsigned long managed_pages; /* 伙伴分配器管理的物理页的数量 */ unsigned long spanned_pages; /* 当前区域跨越的总页数，包括空洞 */ unsigned long present_pages; /* 当前区域存在的物理页的数量，不包括空洞 */ const char *name; /* 区域名称 */ … struct free_area free_area[MAX_ORDER]; /* 不同长度的空闲区域 */ … } 3.物理页 每个物理页对应一个page结构体，称为页描述符，内存节点的pglist_data实例的成员node_mem_map指向该内存节点包含的所有物理页的页描述符注册的数组。 结构体page成员flags布局 | [SECTION] | [NODE] | ZONE | [LAST_CPUPID] | … | FLAGS | SECTION是稀疏内存模型中的段编号，NODE是节点编号，ZONE是区域类型，FLAGS是标志位 头文件include/linux/mm_types.h定义了page结构体\n// include/linux/mm.h // 得到物理页所属的内存节点的编号 static inline int page_to_nid(const struct page *page) { return (page-\u003eflags \u003e\u003e NODES_PGSHIFT) \u0026 NODES_MASK; } // 得到物理页所属的内存区域的类型 static inline enum zone_type page_zonenum(const struct page *page) { return (page-\u003eflags \u003e\u003e ZONES_PGSHIFT) \u0026 ZONES_MASK; } 3.6 引导内存分配器 在内核初始化的过程中需要分配内存，内核提供了临时的引导内存分配器，在页分配器和块分配器初始化完毕后，把空闲的物理页交给页分配器管理，丢弃引导内存分配器，开启配置宏CONFIG_NO_BOOTMEM，memblock就会取代bootmem。 3.6.1 bootmem分配器 3.6.2 memblock分配器 1.数据结构 memblock分配器数据结构\n// include/linux/memblock.h struct memblock { bool bottom_up; /* 表示分配内存的方式 是从下向上的方向？ */ phys_addr_t current_limit; // 可分配内存的最大物理地址 struct memblock_type memory; // 存类型（包括已分配的内存和未分配的内存） struct memblock_type reserved; // 预留类型（已分配的内存） #ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP struct memblock_type physmem; // 物理内存类型 #endif }; 内存块类型的数据结构\n// include/linux/memblock.h struct memblock_type { unsigned long cnt; /* 内存块区域数量 */ unsigned long max; /* 已分配数组的大小 */ phys_addr_t total_size; /* 内存块区域的总长度 所有区域的长度 */ struct memblock_region *regions; // 指向内存块区域数组 char *name; // 存块类型的名称 }; 内存块区域的数据结构\n// include/linux/memblock.h struct memblock_region { phys_addr_t base; // 起始物理地址 phys_addr_t size; // 长度 unsigned long flags; // 标志 MEMBLOCK_NONE或其他标志 #ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP int nid; // 节点编号 #endif }; /* memblock标志位的定义. */ enum { MEMBLOCK_NONE = 0x0, /* 无特殊要求 */ MEMBLOCK_HOTPLUG = 0x1, /* 可热插拔区域 */ MEMBLOCK_MIRROR = 0x2, /* 镜像区域 */ MEMBLOCK_NOMAP = 0x4, /* 不添加到内核直接映射 */ }; 2.初始化 源文件“mm/memblock.c”定义了全局变量memblock，把成员bottom_up初始化为假，表示从高地址向下分配。 ARM64内核初始化memblock分配器的过程是： （1）解析设备树二进制文件中的节点“/memory”，把所有物理内存范围添加到memblock. memory，具体过程参考3.6.3节。 （2）在函数arm64_memblock_init中初始化memblock。 arm64_memblock_init主要流程：\nstart_kernel() –\u003e setup_arch() –\u003e arm64_memblock_init()\n// arch/arm64/mm/init.c void __init arm64_memblock_init(void) { const s64 linear_region_size = -(s64)PAGE_OFFSET; // 解析设备树二进制文件中节点“/chosen”的属性“linux,usable-memory-range”， // 得到可用内存的范围，把超出这个范围的物理内存范围从memblock.memory中删除。 fdt_enforce_memory_region(); // 局变量memstart_addr记录内存的起始物理地址 memstart_addr = round_down(memblock_start_of_DRAM(), ARM64_MEMSTART_ALIGN); // 把线性映射区域不能覆盖的物理内存范围从memblock.memory中删除 memblock_remove(max_t(u64, memstart_addr + linear_region_size, __pa_symbol(_end)), ULLONG_MAX); if (memstart_addr + linear_region_size \u003c memblock_end_of_DRAM()) { /* 确保memstart_addr严格对齐 */ memstart_addr = round_up(memblock_end_of_DRAM() - linear_region_size, ARM64_MEMSTART_ALIGN); memblock_remove(0, memstart_addr); } if (memory_limit != (phys_addr_t)ULLONG_MAX) { memblock_mem_limit_remove_map(memory_limit); memblock_add(__pa_symbol(_text), (u64)(_end - _text)); } … // 把内核镜像占用的物理内存范围添加到memblock.reserved memblock_reserve(__pa_symbol(_text), _end - _text); … // 从设备树二进制文件中的内存保留区域和节点“/reserved-memory” // 读取保留的物理内存范围，添加到memblock.reserved中 early_init_fdt_scan_reserved_mem(); … } 3.编程接口 memblock分配器接口\n// 添加新的内存块区域到memblock.memory中 memblock_add // 删除内存块区域 memblock_remove // 分配内存 memblock_alloc // 释放内存 memblock_free 4.算法 memblock分配器把所有内存添加到memblock.memory中，把分配出去的内存块添加到memblock.reserved中 函数memblock_alloc负责分配内存，主要为函数memblock_alloc_range_nid (1)memblock_find_in_range_node函数memblock_find_in_range_node (2)memblock_reserve函数把分配出去的内存块区域添加到memblock.reserved中 \\\n3.6.3 物理内存信息 内核初始化的过程中，引导内存分配器负责分配内存。ARM64架构使用扁平设备树（Flattened Device Tree，FDT）描述板卡的硬件信息。驱动开发者编写设备树源文件（Device Tree Source，DTS），存放在目录“arch/arm64/boot/dts”下，然后使用设备树编译器（Device Tree Compiler，DTC）把设备树源文件转换成设备树二进制文件（Device Tree Blob，DTB），接着把设备树二进制文件写到存储设备上。设备启动时，引导程序把设备树二进制文件从存储设备读到内存中，引导内核的时候把设备树二进制文件的起始地址传给内核，内核解析设备树二进制文件后得到硬件信息 \\\n设备树源文件.dts,描述物理内存布局\n/ { // “/”根节点 #address-cells = \u003c2\u003e; // 地址的单元数量 #size-cells = \u003c2\u003e; // 一个长度的单元数量 memory@80000000 { // 描述物理内存布局 device_type = \"memory\"; // 设备类型 // 物理内存范围 reg = \u003c0x00000000 0x80000000 0 0x80000000\u003e, \u003c0x00000008 0x80000000 0 0x80000000\u003e; }; }; 内核在初始化的时候调用函数early_init_dt_scan_nodes以解析设备树二进制文件，从而得到物理内存信息 \\\nstart_kernel() –\u003e setup_arch() –\u003e setup_machine_fdt() –\u003e early_init_dt_scan_nodes()\n// drivers/of/fdt.c void __init early_init_dt_scan_nodes(void) { … /* 初始化size-cells和address-cells信息 */ // early_init_dt_scan_root，解析根节点的属性“#address-cells”得到地址的单元数量， // 保存在全局变量dt_root_addr_cells中；解析根节点的属性“#size-cells”得到 // 长度的单元数量，保存在全局变量dt_root_size_cells中 of_scan_flat_dt(early_init_dt_scan_root, NULL); /* 调用函数early_init_dt_add_memory_arch设置内存 */ of_scan_flat_dt(early_init_dt_scan_memory, NULL); } early_init_dt_scan_memory解析memory节点\n// drivers/of/fdt.c int __init early_init_dt_scan_memory(unsigned long node, const char *uname, int depth, void *data) { // 解析节点的属性“device_type” const char *type = of_get_flat_dt_prop(node, \"device_type\", NULL); const __be32 *reg, *endp; int l; … /* 只扫描 \"memory\" 节点 */ if (type == NULL) { /* 如果没有属性“device_type”，判断节点名称是不是“memory@0”*/ if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, \"memory@0\") != 0) return 0; } else if (strcmp(type, \"memory\") != 0) // 描述物理内存信息 return 0; reg = of_get_flat_dt_prop(node, \"linux,usable-memory\", \u0026l); if (reg == NULL) reg = of_get_flat_dt_prop(node, \"reg\", \u0026l); if (reg == NULL) return 0; endp = reg + (l / sizeof(__be32)); … while ((endp - reg) \u003e= (dt_root_addr_cells + dt_root_size_cells)) { u64 base, size; base = dt_mem_next_cell(dt_root_addr_cells, \u0026reg); size = dt_mem_next_cell(dt_root_size_cells, \u0026reg); if (size == 0) continue; … early_init_dt_add_memory_arch(base, size); … } return 0; } 解析出每块内存的起始地址和大小后，调用函数early_init_dt_add_memory_arch\n// drivers/of/fdt.c void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size) { const u64 phys_offset = MIN_MEMBLOCK_ADDR; if (!PAGE_ALIGNED(base)) { if (size \u003c PAGE_SIZE - (base \u0026 ~PAGE_MASK)) { pr_warn(\"Ignoring memory block 0x%llx - 0x%llx\\n\", base, base + size); return; } size -= PAGE_SIZE - (base \u0026 ~PAGE_MASK); base = PAGE_ALIGN(base); } size \u0026= PAGE_MASK; if (base \u003e MAX_MEMBLOCK_ADDR) { pr_warning(\"Ignoring memory block 0x%llx - 0x%llx\\n\", base, base + size); return; } if (base + size - 1 \u003e MAX_MEMBLOCK_ADDR) { pr_warning(\"Ignoring memory range 0x%llx - 0x%llx\\n\", ((u64)MAX_MEMBLOCK_ADDR) + 1, base + size); size = MAX_MEMBLOCK_ADDR - base + 1; } if (base + size \u003c phys_offset) { pr_warning(\"Ignoring memory block 0x%llx - 0x%llx\\n\", base, base + size); return; } if (base \u003c phys_offset) { pr_warning(\"Ignoring memory range 0x%llx - 0x%llx\\n\", base, phys_offset); size -= phys_offset - base; base = phys_offset; } // 把物理内存范围添加到memblock.memory memblock_add(base, size); } 3.7 伙伴分配器 内核初始化完毕后，使用页分配器管理物理页，当前使用的页分配器是伙伴分配器buddy allocato\n3.7.1 基本的伙伴分配器 连续的物理页称为页块（page block）。阶（order）是伙伴分配器的一个术语，是页的数量单位，2n个连续页称为n阶页块。满足以下条件的两个n阶页块称为伙伴（buddy） 伙伴分配器分配和释放物理页的数量单位是阶\n3.7.2 分区的伙伴分配器 1.数据结构 分区的伙伴分配器专注于某个内存节点的某个区域。内存区域的结构体成员free_area用来维护空闲页块，数组下标对应页块的阶数。结构体free_area的成员free_list是空闲页块的链表nr_free是空闲页块的数量。内存区域的结构体成员managed_pages是伙伴分配器管理的物理页的数量，不包括引导内存分配器分配的物理页\ninclude/linux/mmzone.h struct zone { … /* 不同长度的空闲区域 */ struct free_area free_area[MAX_ORDER]; // MAX_ORDER是最大阶数 … unsigned long managed_pages; … } ____cacheline_internodealigned_in_smp; struct free_area { struct list_head free_list[MIGRATE_TYPES]; unsigned long nr_free; }; // include/linux/mmzone.h /* 空闲内存管理-分区的伙伴分配器 */ #ifndef CONFIG_FORCE_MAX_ZONEORDER #define MAX_ORDER 11 #else #define MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER #endif 2．根据分配标志得到首选区域类型 3. 备用区域列表 4．区域水线 5．防止过度借用 3.7.3　根据可移动性分组 3.7.4　每处理器页集合 内核针对分配单页做了性能优化，为了减少处理器之间的锁竞争，在内存区域增加 1个每处理器页集合。\ninclude/linux/mmzone.h struct zone { … struct per_cpu_pageset __percpu *pageset; /* 在每个处理器上有一个页集合 */ … } ____cacheline_internodealigned_in_smp; struct per_cpu_pageset { struct per_cpu_pages pcp; … }; struct per_cpu_pages { int count; /* 链表里面页的数量 */ int high; /* 如果页的数量达到高水线，需要返还给伙伴分配器 */ int batch; /* 批量添加或删除的页数量 */ struct list_head lists[MIGRATE_PCPTYPES]; /* 每种迁移类型一个页链表 */ }; 3.7.5　分配页 1．分配接口 页分配器分配页接口\n// 求分配一个阶数为order的页块，返回一个page实例 alloc_pages(gfp_mask, order) // 在阶数为0情况下的简化形式，只分配一页 alloc_page(gfp_mask) // 只能从低端内存区域分配页，并且返回虚拟地址 __get_free_pages(gfp_mask, order) // 在阶数为0情况下的简化形式，只分配一页 __get_free_page(gfp_mask) // 参数gfp_mask设置了标志位__GFP_ZERO且阶数为0情况下的简化形式，只分配一页，并且用零初始化 get_zeroed_page(gfp_mask) 2．分配标志位 分配页的函数都带一个分配标志位参数，分配标志位分为以下5类 (1)区域修饰符\n(2)页移动性和位置提示\n(3)水线修饰符\n(4)回收修饰符\n(5)行动修饰符\n3．复合页 如果设置了标志位__GFP_COMP并且分配了一个阶数大于0的页块，页分配器会把页块组成复合页（compound page）。复合页最常见的用处是创建巨型页。 复合页的第一页叫首页（head page），其他页都叫尾页（tail page）\n复合页的结构 4．对高阶原子分配的优化处理 5．核心函数的实现 3.7.6　释放页 页分配器提供了以下释放页的接口 （1）void __free_pages(struct page *page, unsigned int order)，第一个参数是第一个物理页的page实例的地址，第二个参数是阶数 （2）void free_pages(unsigned long addr, unsigned int order)，第一个参数是第一个物理页的起始内核虚拟地址，第二个参数是阶数 \\\n3.8　块分配器 Linux内核提供了块分配器，处理小块内存分配问题，最早为SLAB分配器。大量物理内存的大型计算机上SLUB分配器，小内存的嵌入式设备上SLOB \\\n3.8.1 编程接口 3种块分配器提供了统一的编程接口，块分配器在初始化的时候创建了一些通用的内存缓存，从普通区域分配页的内存缓存的名称是kmalloc-，DMA区域分配页的内存缓存的名称是dma-kmalloc-，执行命令cat /proc/slabinfo可以看到这些通用的内存缓存 \\\n// 分配内存 void *kmalloc(size_t size, gfp_t flags); // 重新分配内存 void *krealloc(const void *p, size_t new_size, gfp_t flags); // 释放内存 void kfree(const void *objp); 创建专用的内存缓存\n// 创建内存缓存 struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void *)); // 从指定的内存缓存分配对象 void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags); // 释放对象 void kmem_cache_free(struct kmem_cache *cachep, void *objp); // 销毁内存缓存 void kmem_cache_destroy(struct kmem_cache *s); 3.8.2 SLAB分配器 1.数据结构 内存缓存的数据结构 （1）每个内存缓存对应一个kmem_cache实例 \\\n（2）每个内存节点对应一个kmem_cache_node实例\npage结构体的成员 1)flags设置标志位PG_slab，表示页属于SLAB分配器 2)s_mem存放slab第一个对象的地址 3)active表示已分配对象的数量 4)lru作为链表节点加入其中一条slab链表 5)slab_cache指向kmem_cache实例 6)freelist指向空闲对象链表 \\\n（3）kmem_cache实例的成员cpu_slab指向array_cache实例，\n2.空闲对象链表 每个slab需要一个空闲对象链表，从而把所有空闲对象链接起来，空闲对象链表是用数组实现的，page-\u003efreelist指向空闲对象链表\n使用对象存放空闲对象链表-初始状态 使用对象存放空闲对象链表-分配最后一个空闲对象 空闲对象链表在slab外面 3.计算slab长度 函数calculate_slab_order负责计算slab长度，从0阶到kmalloc()函数支持的最大阶数（KMALLOC_MAX_ORDER）\n4.着色 5．每处理器数组缓存 内存缓存为每个处理器创建了一个数组缓存（结构体array_cache）。释放对象时，把对象存放到当前处理器对应的数组缓存中\n每处理器数组缓冲 6．对NUMA的支持 SLAB分配器支持NUMA 7．内存缓存合并 减少内存开销和增加对象的缓存热度，块分配器会合并相似的内存缓存\n8.回收内存 所有对象空闲的slab，没有立即释放，而是放在空闲slab链表中。只有内存节点上空闲对象的数量超过限制，才开始回收空闲slab，直到空闲对象的数量小于或等于限制 结构体kmem_cache_node的成员slabs_free是空闲slab链表的头节点，成员free_objects是空闲对象的数量，成员free_limit是空闲对象的数量限制 \\\n回收空闲slab 3.8.3　SLUB分配器 1．数据结构 SLUB分配器内存缓存的数据结构 2．空闲对象链表 空闲对象链表的初始状态 分配一个对象以后的空闲对象链表 3．计算slab长度 SLUB分配器在创建内存缓存的时候计算了两种slab长度：最优slab和最小slab\n4．每处理器slab缓存 SLUB分配器的每处理器slab缓存 5．对NUMA的支持 （1）内存缓存针对每个内存节点创建一个kmem_cache_node实例 （2）分配对象时，如果当前处理器的slab缓存是空的，需要重填当前处理器的slab缓存 \\\n6.回收内存 对于所有对象空闲的slab，如果内存节点的部分空闲slab的数量大于或等于最小部分空闲slab数量，那么直接释放，否则放在部分空闲slab链表的尾部\n7.调试 3.8.4　SLOB分配器 1．数据结构 SLOB分配器内存缓存的数据结构 2．空闲对象链表 空闲对象链表的初始状态 分配一个对象以后的空闲对象链表 3．分配对象 分配对象时，根据对象长度选择不同的策略\n3.9　不连续页分配器 3.9.1　编程接口 不连续页分配器提供了以下编程接口\n// vmalloc函数：分配不连续的物理页并且把物理页映射到连续的虚拟地址空间 void *vmalloc(unsigned long size); // vfree函数：释放vmalloc分配的物理页和虚拟地址空间 void vfree(const void *addr); // vmap函数：把已经分配的不连续物理页映射到连续的虚拟地址空间 // pages是page指针数组，count是page指针数组大小，flags标志位，prot页保护位 void *vmap(struct page **pages, unsigned int count, unsigned long flags, pgprot_t prot); // vunmap函数：释放使用vmap分配的虚拟地址空间 void vunmap(const void *addr); // kvmalloc函数：先尝试使用kmalloc分配内存块，如果失败，那么使用vmalloc函数分配不连续的物理页 void *kvmalloc(size_t size, gfp_t flags); // kvfree函数：如果内存块是使用vmalloc分配的，那么使用vfree释放，否则使用kfree释放 void kvfree(const void *addr); 3.9.2　数据结构 不连续页分配器的数据结构 使用vmap函数分配虚拟内存区域 3.9.3　技术原理 vmalloc虚拟地址空间的范围是[VMALLOC_START, VMALLOC_END)\n// arch/arm64/include/asm/pgtable.h #define VMALLOC_START (MODULES_END) #define VMALLOC_END (PAGE_OFFSET - PUD_SIZE - VMEMMAP_SIZE - SZ_64K) MODULES_END是内核模块区域的结束地址，PAGE_OFFSET是线性映射区域的起始地址，PUD_SIZE是一个页上层目录表项映射的地址空间长度，VMEMMAP_SIZE是vmemmap区域的长度。 vmalloc虚拟地址空间的起始地址等于内核模块区域的结束地址。 vmalloc虚拟地址空间的结束地址等于（线性映射区域的起始地址−一个页上层目录表项映射的地址空间长度−vmemmap区域的长度−64KB） 函数vmalloc的执行过程分为3步 （1）分配虚拟内存区域 分配vm_struct实例和vmap_area实例 （2） 分配物理页 vm_struct实例的成员nr_pages存放页数n；分配page指针数组 （3）在内核的页表中把虚拟页映射到物理页 内核的页表就是0号内核线程的页表。0号内核线程的进程描述符是全局变量init_task，成员active_mm指向全局变量init_mm，init_mm的成员pgd指向页全局目录swapper_pg_dir\n3.10　每处理器内存分配器 多处理器系统中，每处理器变量为每个处理器生成一个变量的副本\n3.10.1　编程接口 每处理器变量分为静态和动态两种\n1.静态每处理器变量 宏“DEFINE_PER_CPU(type, name)”定义普通的静态每处理器变量，使用宏“DECLARE_PER_CPU(type, name)”声明普通的静态每处理器变量\n// 宏“DEFINE_PER_CPU(type, name)”展开 // 静态每处理器变量存放在“.data..percpu” __attribute__((section(\".data..percpu\"))) __typeof__(type) name 2．动态每处理器变量 为动态每处理器变量分配内存的函数\n// __alloc_percpu_gfp为动态每处理器变量分配内存 void __percpu *__alloc_percpu_gfp(size_t size, size_t align, gfp_t gfp); // 宏alloc_percpu_gfp(type, gfp)是函数__alloc_percpu_gfp的简化形式 // 宏alloc_percpu_gfp(type, gfp)是函数__alloc_percpu_gfp的简化形式 void __percpu *__alloc_percpu(size_t size, size_t align); // free_percpu释放动态每处理器变量的内存 void free_percpu(void __percpu *__pdata); 3．访问每处理器变量 宏“this_cpu_ptr(ptr)”用来得到当前处理器的变量副本的地址，宏“get_cpu_var(var)”用来得到当前处理器的变量副本的值\n// 宏this_cpu_ptr(ptr)展开 unsigned long __ptr; __ptr = (unsigned long) (ptr); (typeof(ptr)) (__ptr + per_cpu_offset(raw_smp_processor_id())); 宏“per_cpu_ptr(ptr, cpu)”用来得到指定处理器的变量副本的地址，宏“per_cpu(var, cpu)”用来得到指定处理器的变量副本的值。 宏“get_cpu_ptr(var)”禁止内核抢占并且返回当前处理器的变量副本的地址，宏“put_cpu_ptr(var)”开启内核抢占，这两个宏成对使用 宏“get_cpu_var(var)”禁止内核抢占并且返回当前处理器的变量副本的值，宏“put_cpu_var(var)”开启内核抢占，这两个宏成对使用 \\\n3.10.2　技术原理 每处理器区域是按块（chunk）分配的 分配块的方式有两种: (1)分配块的方式有两种 (2)分配块的方式有两种 \\\n基于vmalloc区域的每处理器内存分配器 每个块对应一个pcpu_chunk实例\n基于内核内存的每处理器内存分配器 3.11　页表 3.11.1　统一的页表框架 页表用来把虚拟页映射到物理页，并且存放页的保护位，即访问权限 Linux 4.11版本以前，Linux内核把页表分为4级 (1)页全局目录(Page Global Directory PGD) (2)页上层目录(Page Upper DIrectory PUD) (3)页中间目录(Page Middle Directory PMD) (4)直接页表(Page Table PT) 4.11版本把页表扩展到五级，在页全局目录和页上层目录之间增加了页四级目录(Page 4th Directory，P4D) \\\n内核也有一个页表，0号内核线程的进程描述符init_task的成员active_mm指向内存描述符init_mm，内存描述符init_mm的成员pgd指向内核的页全局目录swapper_pg_dir 虚拟地址被分解为6个部分：页全局目录索引、页四级目录索引、页上层目录索引、页中间目录索引、直接页表索引和页内偏移 \\\n3.11.2　ARM64处理器的页表 ARM64处理器把页表称为转换表(translation table)，最多4级。ARM64处理器支持3 种页长度：4KB、16KB和64KB。 、 页长度是4KB：使用4级转换表，转换表和内核的页表术语的对应关系是：0级转换表对应页全局目录，1级转换表对应页上层目录，2级转换表对应页中间目录，3级转换表对应直接页表 \\\n3.12　页表缓存 处理器的内存管理单元（Memory Management Unit，MMU）负责把虚拟地址转换成物理地址。 TLB（Translation Lookaside Buffer）的高速缓存，TLB直译为转换后备缓冲区，意译为页表缓存，缓存最近使用过的页表项。两级页表缓存：第一级TLB分为指令TLB和数据TLB，好处是取指令和取数据可以并行执行；第二级TLB是统一TLB（Unified TLB），即指令和数据共用的TLB\n3.12.1　TLB表项格式 ARM64处理器的每条TLB表项不仅包含虚拟地址和物理地址，也包含属性：内存类型、缓存策略、访问权限、地址空间标识符（Address Space Identifier，ASID）和虚拟机标识符（Virtual Machine Identifier，VMID）。地址空间标识符区分不同进程的页表项，虚拟机标识符区分不同虚拟机的页表项 \\\n3.12.2　TLB管理 页表改变以后冲刷TLB的函数\n// 使所有TLB表项失效 void flush_tlb_all(void); // 使指定用户地址空间的某个范围的TLB表项失效 // 参数vma是虚拟内存区域，start是起始地址，end是结束地址（不包括） void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end); // 使指定用户地址空间里面的指定虚拟页的TLB表项失效 // 参数vma是虚拟内存区域，uaddr是一个虚拟页中的任意虚拟地址 void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr); // 使内核的某个虚拟地址范围的TLB表项失效 // 参数start是起始地址，end是结束地址（不包括） void flush_tlb_kernel_range(unsigned long start, unsigned long end); // 修改页表项以后把页表项设置到页表缓存 // 由软件管理页表缓存的处理器必须实现该函数，例如MIPS处理器 // ARM64处理器的内存管理单元可以访问内存中的页表，把页表项复制到页表缓存，所以ARM64架构的函数update_mmu_cache什么都不用做 void update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep); // 内核把进程从一个处理器迁移到另一个处理器以后，调用该函数以更新页表缓存或上下文特定信息 void tlb_migrate_finish(struct mm_struct *mm); ARM64架构没有提供写TLB的指令。 ARM64架构提供了一条TLB失效指令\nTLBI \u003ctype\u003e\u003clevel\u003e{IS} {, \u003cXt\u003e} ARM64内核flush_tlb_all函数\n// arch/arm64/include/asm/tlbflush.h static inline void flush_tlb_all(void) {\t// dsb数据同步屏障 dsb(ishst); // ishst中的ish表示共享域是内部共享 __tlbi(vmalle1is); // 使所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效 dsb(ish); // ish表示数据同步屏障指令对所有核起作用 isb(); // 指令同步屏障 } // 宏展开 static inline void flush_tlb_all(void) { // dsb确保屏障前面的存储指令执行完 // ishst中的ish表示共享域是内部共享 // st表示存储（store），ishst表示数据同步屏障指令对所有核的存储指令起作用 asm volatile(\"dsb ishst\" : : : \"memory\"); // 使所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效 asm (\"tlbi vmalle1is\" : :); // 确保前面的TLB失效指令执行完。ish表示数据同步屏障指令对所有核起作用 asm volatile(\"dsb ish\" : : : \"memory\"); // isb是指令同步屏障,冲刷处理器的流水线，重新读取屏障指令后面的所有指令 asm volatile(\"isb\" : : : \"memory\"); } ARM64内核实现了函数local_flush_tlb_all，用来使当前核的所有TLB表项失效\n// arch/arm64/include/asm/tlbflush.h static inline void local_flush_tlb_all(void) { dsb(nshst); __tlbi(vmalle1); // 仅仅使当前核的TLB表项失效 dsb(nsh); // nsh是非共享,数据同步屏障指令仅仅在当前核起作用 isb(); } 3.12.3　地址空间标识符 ARM64处理器的页表缓存使用非全局(not global，nG)位区分内核和进程的页表项(nG位为0表示内核的页表项)，使用地址空间标识符(Address Space Identifier，ASID)区分不同进程的页表项 ARM64处理器的ASID长度8位或者16位，寄存器ID_AA64MMFR0_EL1段ASIDBits存放处理器支持的ASID长度。16位ASID使用寄存器TCR_EL1的AS(ASID Size)位控制实际使用的ASID长度，AS 0为8位ASID，AS 1为16位ASID 寄存器TCR_EL1的A1位决定使用哪个寄存器存放当前进程的ASID,寄存器TTBR0_EL1 用户0或TTBR1_EL1内核？存放当前进程ASID 内存描述符的成员context存放架构特定的内存管理上下文，数据类型是结构体mm_context_t，ARM64架构定义的结构体 // arch/arm64/include/asm/mmu.h typedef struct { atomic64_t id; // 成员id存放内核给进程分配的软件ASID … } mm_context_t; 全局变量asid_bits保存ASID长度，全局变量asid_generation的高56位保存全局ASID版本号，位图asid_map记录哪些ASID被分配 当全局ASID版本号加1时，每个处理器需要清空页表缓存，位图tlb_flush_pending保存需要清空页表缓存的处理器集合 // arch/arm64/mm/context.c static u32 asid_bits; static atomic64_t asid_generation; static unsigned long *asid_map; static DEFINE_PER_CPU(atomic64_t, active_asids); static DEFINE_PER_CPU(u64, reserved_asids); static cpumask_t tlb_flush_pending; 进程被调度时，函数check_and_switch_context负责检查是否需要给进程重新分配ASID __schedule() -\u003e context_switch() -\u003e switch_mm_irqs_off() -\u003e switch_mm() -\u003e check_and_switch_context()\n// arch/arm64/mm/context.c void check_and_switch_context(struct mm_struct *mm, unsigned int cpu) { unsigned long flags; u64 asid; asid = atomic64_read(\u0026mm-\u003econtext.id); if (!((asid ^ atomic64_read(\u0026asid_generation)) \u003e\u003e asid_bits) \u0026\u0026 atomic64_xchg_relaxed(\u0026per_cpu(active_asids, cpu), asid)) goto switch_mm_fastpath; raw_spin_lock_irqsave(\u0026cpu_asid_lock, flags); asid = atomic64_read(\u0026mm-\u003econtext.id); if ((asid ^ atomic64_read(\u0026asid_generation)) \u003e\u003e asid_bits) { asid = new_context(mm, cpu); atomic64_set(\u0026mm-\u003econtext.id, asid); } if (cpumask_test_and_clear_cpu(cpu, \u0026tlb_flush_pending)) local_flush_tlb_all(); atomic64_set(\u0026per_cpu(active_asids, cpu), asid); raw_spin_unlock_irqrestore(\u0026cpu_asid_lock, flags); switch_mm_fastpath: if (!system_uses_ttbr0_pan()) cpu_switch_mm(mm-\u003epgd, mm); } 函数new_context负责分配ASID\n// arch/arm64/mm/context.c static u64 new_context(struct mm_struct *mm, unsigned int cpu) { static u32 cur_idx = 1; u64 asid = atomic64_read(\u0026mm-\u003econtext.id); u64 generation = atomic64_read(\u0026asid_generation); if (asid != 0) { u64 newasid = generation | (asid \u0026 ~ASID_MASK); if (check_update_reserved_asid(asid, newasid)) return newasid; asid \u0026= ~ASID_MASK; if (!__test_and_set_bit(asid, asid_map)) return newasid; } asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, cur_idx); if (asid != NUM_USER_ASIDS) goto set_asid; generation = atomic64_add_return_relaxed(ASID_FIRST_VERSION, \u0026asid_generation); flush_context(cpu); asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, 1); set_asid: __set_bit(asid, asid_map); cur_idx = asid; return asid | generation; } 函数flush_context负责重新初始化ASID分配状态\n// arch/arm64/mm/context.c static void flush_context(unsigned int cpu) { int i; u64 asid; bitmap_clear(asid_map, 0, NUM_USER_ASIDS); … smp_wmb(); for_each_possible_cpu(i) { asid = atomic64_xchg_relaxed(\u0026per_cpu(active_asids, i), 0); if (asid == 0) asid = per_cpu(reserved_asids, i); __set_bit(asid \u0026 ~ASID_MASK, asid_map); per_cpu(reserved_asids, i) = asid; } cpumask_setall(\u0026tlb_flush_pending); } 3.12.4　虚拟机标识符 虚拟机里面运行的客户操作系统的虚拟地址转换成物理地址分两个阶段： 第 1 阶段把虚拟地址转换成中间物理地址 第 2 阶段把中间物理地址转换成物理地址 第 1 阶段转换由客户操作系统的内核控制，和非虚拟化的转换过程相同。第 2 阶段转换由虚拟机监控器控制，虚拟机监控器为每个虚拟机维护一个转换表，分配一个虚拟机标识符(Virtual Machine Identifier，VMID)，寄存器VTTBR_EL2(虚拟化转换表基准寄存器，Virtualization Translation Table Base Register)存放当前虚拟机的阶段2转换表的物理地址\n3.13　巨型页 使用长度为2MB甚至更大的巨型页，可以大幅减少TLB未命中和缺页异常的数量，大幅提高应用程序的性能 (1)使用hugetlbfs伪文件系统实现巨型页 (2)透明巨型页 3.13.1　处理器对巨型页的支持 ARM64处理器支持巨型页的方式有两种 (1)通过块描述符支持 (2)通过页/块描述符的连续位支持 页长度为4KB时通过块描述符支持巨型页 页长度为4KB时通过页/块描述符的连续位支持巨型页 3.13.2　标准巨型页 编译内核时需要打开配置宏CONFIG_HUGETLBFS和CONFIG_HUGETLB_PAGE 文件“/proc/sys/vm/nr_hugepages”指定巨型页池中永久巨型页的数量 ——————– 待补充 ———————–\n3.13.3　透明巨型页 (1)分配透明巨型页 函数handle_mm_fault是页错误异常处理程序的核心函数，如果触发异常的虚拟内存区域使用普通页或透明巨型页，把主要工作委托给函数__handle_mm_fault 透明巨型页的页错误异常处理 函数create_huge_pmd负责分配页中间目录级别的巨型页 3.14　页错误异常处理 虚拟页没有映射到物理页，或者没有访问权限，处理器将生成页错误异常 缺页异常,虚拟页没有映射到物理页 (1)访问用户栈的时候，超出了当前用户栈的范围，需要扩大用户栈 (2)进程申请虚拟内存区域的时候，通常没有分配物理页，进程第一次访问的时候触发页错误异常 (3)内存不足的时候，内核把进程的匿名页换出到交换区 (4)一个文件页被映射到进程的虚拟地址空间，内存不足的时候 (5)程序错误，访问没有分配给进程的虚拟内存区域 没有访问权限，两种情况 (1)写时复制(Copy on Write，CoW) 页错误异常处理程序成功地把虚拟页映射到物理页 (2)程序错误，发送段违法(SIGSEGV)信号以杀死进程 3.14.1　处理器架构特定部分 1.生成页错误异常 ARM64处理器在取指令或数据，需把虚拟地址转换成物理地址，分两种情况 (1)虚拟地址的高16位不是全1或全0，是非法地址，生成页错误异常 (2)虚拟地址的高16位是全1或全0，内存管理单元根据关键字{地址空间标识符，虚拟地址}查找TLB 寄存器TTBR1_EL1存放内核的页全局目录的物理地址，寄存器TTBR0_EL1存放进程的页全局目录的物理地址 命中了TLB表项，从TLB表项读取访问权限，检查访问权限，如果没有访问权限，生成页错误异常 没有命中TLB表项，内存管理单元将会查询内存中的页表，称为转换表遍历（translation table walk），分两种情况 （1）虚拟地址的高16位全部是1，是内核虚拟地址，查询内核的页表，从寄存器TTBR1_EL1取内核的页全局目录的物理地址 （2）虚拟地址的高16位全部是0，用户虚拟地址，查询进程的页表，从寄存器TTBR0_EL1取进程的页全局目录的物理地址 2.处理页错误异常 ARM64架构的内核异常向量表，起始地址是vectors（源文件arch/arm64/ kernel/entry.S），每个异常向量的长度是128字节，在Linux内核中每个异常向量只有一条指令：跳转到对应的处理程序。异常向量表的虚拟地址存放在异常级别1的向量基准地址寄存器(Vector Base Address Register for Exception Level 1，VBAR_EL1)中\nARM64处理器处理页错误异常 (1)异常类型是异常级别1生成的同步异常，异常向量的偏移是0x200，异常向量跳转到函数el1_sync (2)异常类型是64位用户程序在异常级别0生成的同步异常，异常向量的偏移是0x400，异常向量跳转到函数el0_sync (3)异常类型是32位用户程序在异常级别0生成的同步异常，异常向量的偏移是0x600，异常向量跳转到函数el0_sync_compat 函数el0_sync根据异常级别1的异常症状寄存器的异常类别字段处理 (1)异常类别是异常级别0生成的数据中止(data abort)，即在异常级别0访问数据时生成页错误异常，调用函数el0_da (2)异常类别是异常级别0生成的指令中止(instruction abort)，即在异常级别0取指令时生成页错误异常，调用函数el0_ia ARM64处理器，异常级别1的异常症状寄存器(ESR_EL1，Exception Syndrome Register for Exception Level 1)用来存放异常的症状信息 EC：异常类别(Exception Class)，指示引起异常的原因 ISS：指令特定症状 （1）do_mem_abort函数 do_mem_abort函数根据异常症状寄存器的指令特定症状字段的指令错误状态码，调用数组fault_info中处理函数 指令错误状态码和处理函数的对应关系\n指令错误状态码 说　明 处 理 函 数 4 0级转换错误 do_translation_fault 5 1级转换错误 do_translation_fault 6 2级转换错误 do_translation_fault 7 3级转换错误 do_page_fault 9 1级访问标志错误 do_page_fault 10 2级访问标志错误 do_page_fault 11 3级访问标志错误 do_page_fault 13 1级权限错误 do_page_fault 14 2级权限错误 do_page_fault 15 3级权限错误 do_page_fault 33 对齐错误 do_alignment_fault 其他 其他错误 do_bad （2）do_translation_fault函数 do_translation_fault处理在0级、1级或2级转换表中匹配的表项是无效描述符\n// arch/arm64/mm/fault.c // addr触发异常的虚拟地址 esr异常症状状态寄存器值 regs指向内核栈中保存的被打断的进程的寄存器集合 static int __kprobes do_translation_fault(unsigned long addr, unsigned int esr, struct pt_regs *regs) { if (addr \u003c TASK_SIZE) return do_page_fault(addr, esr, regs); // 虚拟地址是用户虚拟地址 // 异常虚拟地址是内核虚拟地址或不规范地址 do_bad_area(addr, esr, regs); return 0; } do_bad_area\n// arch/arm64/mm/fault.c static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs) { struct task_struct *tsk = current; struct mm_struct *mm = tsk-\u003eactive_mm; const struct fault_info *inf; if (user_mode(regs)) { inf = esr_to_fault_info(esr); // 异常是在用户模式 __do_user_fault(tsk, addr, esr, inf-\u003esig, inf-\u003ecode, regs); // 发送信号以杀死进程 } else __do_kernel_fault(mm, addr, esr, regs); // 异常是在内核模式下生成 } （3）函数do_page_fault\n函数do_page_fault的执行流 // arch/arm64/mm/fault.c linux4.x static int __kprobes do_page_fault(unsigned long addr, unsigned int esr, struct pt_regs *regs) { struct task_struct *tsk; struct mm_struct *mm; int fault, sig, code; unsigned long vm_flags = VM_READ | VM_WRITE; unsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE; … tsk = current; mm = tsk-\u003emm; // 禁止执行页错误异常处理程序，或者处于原子上下文，或者当前进程是内核线程 if (faulthandler_disabled() || !mm) goto no_context; if (user_mode(regs)) mm_flags |= FAULT_FLAG_USER; if (is_el0_instruction_abort(esr)) { vm_flags = VM_EXEC; } else if ((esr \u0026 ESR_ELx_WNR) \u0026\u0026 !(esr \u0026 ESR_ELx_CM)) { vm_flags = VM_WRITE; mm_flags |= FAULT_FLAG_WRITE; } if (addr \u003c USER_DS \u0026\u0026 is_permission_fault(esr, regs, addr)) { /* 如果从异常级别0进入，regs-\u003eorig_addr_limit可能是0 */ if (regs-\u003eorig_addr_limit == KERNEL_DS) die(\"Accessing user space memory with fs=KERNEL_DS\", regs, esr); if (is_el1_instruction_abort(esr)) die(\"Attempting to execute userspace memory\", regs, esr); if (!search_exception_tables(regs-\u003epc)) die(\"Accessing user space memory outside uaccess.h routines\", regs, esr); } if (!down_read_trylock(\u0026mm-\u003emmap_sem)) { if (!user_mode(regs) \u0026\u0026 !search_exception_tables(regs-\u003epc)) goto no_context; retry: down_read(\u0026mm-\u003emmap_sem); } else { might_sleep(); … } fault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk); if ((fault \u0026 VM_FAULT_RETRY) \u0026\u0026 fatal_signal_pending(current)) return 0; … if (mm_flags \u0026 FAULT_FLAG_ALLOW_RETRY) { if (fault \u0026 VM_FAULT_MAJOR) { tsk-\u003emaj_flt++; … } else { tsk-\u003emin_flt++; … } if (fault \u0026 VM_FAULT_RETRY) { mm_flags \u0026= ~FAULT_FLAG_ALLOW_RETRY; mm_flags |= FAULT_FLAG_TRIED; goto retry; } } up_read(\u0026mm-\u003emmap_sem); if (likely(!(fault \u0026 (VM_FAULT_ERROR | VM_FAULT_BADMAP | VM_FAULT_BADACCESS)))) return 0; if (!user_mode(regs)) goto no_context; if (fault \u0026 VM_FAULT_OOM) { pagefault_out_of_memory(); return 0; } if (fault \u0026 VM_FAULT_SIGBUS) { sig = SIGBUS; code = BUS_ADRERR; } else { sig = SIGSEGV; code = fault == VM_FAULT_BADACCESS ? SEGV_ACCERR : SEGV_MAPERR; } __do_user_fault(tsk, addr, esr, sig, code, regs); return 0; no_context: __do_kernel_fault(mm, addr, esr, regs); return 0; } 原子上下文：执行硬中断、执行软中断、禁止硬中断、禁止软中断和禁止内核抢占这五种情况不允许睡眠，称为原子上下文 函数__do_page_fault的执行流程 // arch/arm64/mm/fault.c static int __do_page_fault(struct mm_struct *mm, unsigned long addr, unsigned int mm_flags, unsigned long vm_flags, struct task_struct *tsk) { struct vm_area_struct *vma; int fault; vma = find_vma(mm, addr); fault = VM_FAULT_BADMAP; if (unlikely(!vma)) goto out; if (unlikely(vma-\u003evm_start \u003e addr)) goto check_stack; good_area: if (!(vma-\u003evm_flags \u0026 vm_flags)) { fault = VM_FAULT_BADACCESS; goto out; } return handle_mm_fault(vma, addr \u0026 PAGE_MASK, mm_flags); check_stack: if (vma-\u003evm_flags \u0026 VM_GROWSDOWN \u0026\u0026 !expand_stack(vma, addr)) goto good_area; out: return fault; } 3.14.2　用户空间页错误异常 函数handle_mm_fault处理用户空间的页错误异常，两种情况： (1)进程在用户模式下访问用户虚拟地址，生成页错误异常 (2)进程在内核模式下访问用户虚拟地址，生成页错误异常。进程通过系统调用进入内核模式，系统调用传入用户空间的缓冲区，进程在内核模式下访问用户空间的缓冲区 // mm/memory.c int handle_mm_fault(struct vm_area_struct *vma, unsigned long address, unsigned int flags) { … if (unlikely(is_vm_hugetlb_page(vma))) ret = hugetlb_fault(vma-\u003evm_mm, vma, address, flags); else ret = __handle_mm_fault(vma, address, flags); … } 巨型页函数hugetlb_fault，普通页__handle_mm_fault\n// mm/memory.c static int __handle_mm_fault(struct vm_area_struct *vma, unsigned long address, unsigned int flags) { struct vm_fault vmf = { .vma = vma, .address = address \u0026 PAGE_MASK, .flags = flags, .pgoff = linear_page_index(vma, address), .gfp_mask = __get_fault_gfp_mask(vma), }; struct mm_struct *mm = vma-\u003evm_mm; pgd_t *pgd; p4d_t *p4d; int ret; // 在页全局目录中查找虚拟地址对应的表项 pgd = pgd_offset(mm, address); p4d = p4d_alloc(mm, pgd, address); // 在页四级目录中查找虚拟地址对应的表项 if (!p4d) return VM_FAULT_OOM; // 在页上层目录中查找虚拟地址对应的表项 vmf.pud = pud_alloc(mm, p4d, address); if (!vmf.pud) return VM_FAULT_OOM; … // 在页中间目录中查找虚拟地址对应的表项 vmf.pmd = pmd_alloc(mm, vmf.pud, address); if (!vmf.pmd) return VM_FAULT_OOM; … // 到达直接页表 return handle_pte_fault(\u0026vmf); } // mm/memory.c static int handle_pte_fault(struct vm_fault *vmf) { pte_t entry; // 直接页表中查找虚拟地址对应的表项 if (unlikely(pmd_none(*vmf-\u003epmd))) { vmf-\u003epte = NULL; } else { … vmf-\u003epte = pte_offset_map(vmf-\u003epmd, vmf-\u003eaddress); vmf-\u003eorig_pte = *vmf-\u003epte; barrier(); if (pte_none(vmf-\u003eorig_pte)) { pte_unmap(vmf-\u003epte); vmf-\u003epte = NULL; } } // 页表项不存在 if (!vmf-\u003epte) { if (vma_is_anonymous(vmf-\u003evma)) return do_anonymous_page(vmf); else return do_fault(vmf); } // 页表项存在，但是页不在物理内存 if (!pte_present(vmf-\u003eorig_pte)) return do_swap_page(vmf); … vmf-\u003eptl = pte_lockptr(vmf-\u003evma-\u003evm_mm, vmf-\u003epmd); // 获取页表锁的地址 spin_lock(vmf-\u003eptl); // 锁住页表 entry = vmf-\u003eorig_pte; if (unlikely(!pte_same(*vmf-\u003epte, entry))) // 重新读取页表项的值 goto unlock; if (vmf-\u003eflags \u0026 FAULT_FLAG_WRITE) { if (!pte_write(entry)) return do_wp_page(vmf); // 执行写时复制 entry = pte_mkdirty(entry); // 页表项有写权限 } entry = pte_mkyoung(entry); // 设置页表项的访问标志位 if (ptep_set_access_flags(vmf-\u003evma, vmf-\u003eaddress, vmf-\u003epte, entry, vmf-\u003eflags \u0026 FAULT_FLAG_WRITE)) { // 设置页表项 update_mmu_cache(vmf-\u003evma, vmf-\u003eaddress, vmf-\u003epte); // 更新处理器的内存管理单元的页表缓存 } else { if (vmf-\u003eflags \u0026 FAULT_FLAG_WRITE) flush_tlb_fix_spurious_fault(vmf-\u003evma, vmf-\u003eaddress); } unlock: // 释放页表的锁 pte_unmap_unlock(vmf-\u003epte, vmf-\u003eptl); return 0; } 1．匿名页的缺页异常 函数do_anonymous_page处理私有匿名页的缺页异常\n// mm/memory.c static int do_anonymous_page(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u003evma; … struct page *page; pte_t entry; /* 没有“-\u003evm_ops”的文件映射？ */ if (vma-\u003evm_flags \u0026 VM_SHARED) return VM_FAULT_SIGBUS; // 直接页表不存在，分配页表 if (pte_alloc(vma-\u003evm_mm, vmf-\u003epmd, vmf-\u003eaddress)) return VM_FAULT_OOM; … /* 如果是读操作，映射到零页 */ if (!(vmf-\u003eflags \u0026 FAULT_FLAG_WRITE) \u0026\u0026 !mm_forbids_zeropage(vma-\u003evm_mm)) { entry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf-\u003eaddress), vma-\u003evm_page_prot)); vmf-\u003epte = pte_offset_map_lock(vma-\u003evm_mm, vmf-\u003epmd, vmf-\u003eaddress, \u0026vmf-\u003eptl); if (!pte_none(*vmf-\u003epte)) goto unlock; … goto setpte; } /* 分配我们自己的私有页 */ if (unlikely(anon_vma_prepare(vma))) goto oom; page = alloc_zeroed_user_highpage_movable(vma, vmf-\u003eaddress); if (!page) goto oom; … __SetPageUptodate(page); entry = mk_pte(page, vma-\u003evm_page_prot); if (vma-\u003evm_flags \u0026 VM_WRITE) entry = pte_mkwrite(pte_mkdirty(entry)); vmf-\u003epte = pte_offset_map_lock(vma-\u003evm_mm, vmf-\u003epmd, vmf-\u003eaddress, \u0026vmf-\u003eptl); if (!pte_none(*vmf-\u003epte)) goto release; … inc_mm_counter_fast(vma-\u003evm_mm, MM_ANONPAGES); page_add_new_anon_rmap(page, vma, vmf-\u003eaddress, false); … lru_cache_add_active_or_unevictable(page, vma); setpte: set_pte_at(vma-\u003evm_mm, vmf-\u003eaddress, vmf-\u003epte, entry); /* 不需要从页表缓存删除页表项，因为以前虚拟页没有映射到物理页 */ update_mmu_cache(vma, vmf-\u003eaddress, vmf-\u003epte); unlock: pte_unmap_unlock(vmf-\u003epte, vmf-\u003eptl); return 0; release: … put_page(page); goto unlock; oom_free_page: put_page(page); oom: return VM_FAULT_OOM; } 2．文件页的缺页异常 触发文件页的缺页异常: (1)启动程序时，第一次访问的时候触发文件页的缺页异常 (2)进程使用mmap创建文件映射，第一次访问的时候触发文件页的缺页异常 函数do_fault处理文件页和共享匿名页的缺页异常 // mm/memory.c static int do_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u003evma; int ret; /* 这个vm_area_struct结构体在执行mmap()的时候没有完全填充，或者缺少标志位VM_DONTEXPAND。 */ if (!vma-\u003evm_ops-\u003efault) ret = VM_FAULT_SIGBUS; else if (!(vmf-\u003eflags \u0026 FAULT_FLAG_WRITE)) // 缺页异常是由读文件页触发 ret = do_read_fault(vmf); // 处理读文件页错误 else if (!(vma-\u003evm_flags \u0026 VM_SHARED)) // 缺页异常是由写私有文件页触发 ret = do_cow_fault(vmf); // 写私有文件页错误, 执行写时复制 else // 缺页异常是由写共享文件页触发 ret = do_shared_fault(vmf); // 处理写共享文件页错误 … return ret; } （1）处理读文件页错误 // mm/memory.c static int do_read_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u003evma; int ret = 0; // 全局变量fault_around_bytes控制总长度，默认值是64KB。如果页长度是4KB，就一次读取16页 if (vma-\u003evm_ops-\u003emap_pages \u0026\u0026 fault_around_bytes \u003e\u003e PAGE_SHIFT \u003e 1) { ret = do_fault_around(vmf); if (ret) return ret; } // 文件页读到文件的页缓存中 ret = __do_fault(vmf); if (unlikely(ret \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) return ret; // 虚拟页映射到文件的页缓存中的物理页 ret |= finish_fault(vmf); unlock_page(vmf-\u003epage); if (unlikely(ret \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) put_page(vmf-\u003epage); return ret; } 函数finish_fault负责设置页表项，把主要工作委托给函数alloc_set_pte\n函数finish_fault的执行流程 // mm/memory.c int alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg, struct page *page) { struct vm_area_struct *vma = vmf-\u003evma; bool write = vmf-\u003eflags \u0026 FAULT_FLAG_WRITE; pte_t entry; int ret; … if (!vmf-\u003epte) { // 直接页表不存在，分配直接页表 ret = pte_alloc_one_map(vmf); if (ret) return ret; } /* 锁住页表后重新检查 */ if (unlikely(!pte_none(*vmf-\u003epte))) return VM_FAULT_NOPAGE; // 直接页表不存在，那么分配直接页表 flush_icache_page(vma, page); entry = mk_pte(page, vma-\u003evm_page_prot); // 使用页帧号和访问权限生成页表项的值 if (write) // 写访问，设置页表项的脏标志位和写权限位 entry = maybe_mkwrite(pte_mkdirty(entry), vma); /* 写时复制的页 */ if (write \u0026\u0026 !(vma-\u003evm_flags \u0026 VM_SHARED)) { inc_mm_counter_fast(vma-\u003evm_mm, MM_ANONPAGES); page_add_new_anon_rmap(page, vma, vmf-\u003eaddress, false); … lru_cache_add_active_or_unevictable(page, vma); } else { inc_mm_counter_fast(vma-\u003evm_mm, mm_counter_file(page)); page_add_file_rmap(page, false); } set_pte_at(vma-\u003evm_mm, vmf-\u003eaddress, vmf-\u003epte, entry); /* 不需要使无效：一个不存在的页不会被缓存 */ update_mmu_cache(vma, vmf-\u003eaddress, vmf-\u003epte); return 0; } // mm/memory.c static int do_cow_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u003evma; int ret; if (unlikely(anon_vma_prepare(vma))) return VM_FAULT_OOM; // 关联一个anon_vma实例到虚拟内存区域 vmf-\u003ecow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-\u003eaddress); if (!vmf-\u003ecow_page) return VM_FAULT_OOM; … ret = __do_fault(vmf); // 把文件页读到文件的页缓存 if (unlikely(ret \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) goto uncharge_out; if (ret \u0026 VM_FAULT_DONE_COW) return ret; // 把文件的页缓存中物理页的数据复制到副本物理页 copy_user_highpage(vmf-\u003ecow_page, vmf-\u003epage, vmf-\u003eaddress, vma); __SetPageUptodate(vmf-\u003ecow_page); // 设置副本页描述符的标志位PG_uptodate，表示物理页包含有效的数据 // 设置页表项，把虚拟页映射到副本物理页 ret |= finish_fault(vmf); unlock_page(vmf-\u003epage); put_page(vmf-\u003epage); if (unlikely(ret \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) goto uncharge_out; return ret; uncharge_out: … put_page(vmf-\u003ecow_page); return ret; } // mm/memory.c static int do_shared_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u003evma; int ret, tmp; // 把文件页读到文件的页缓存中 ret = __do_fault(vmf); if (unlikely(ret \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) return ret; if (vma-\u003evm_ops-\u003epage_mkwrite) { unlock_page(vmf-\u003epage); tmp = do_page_mkwrite(vmf); if (unlikely(!tmp || (tmp \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) { put_page(vmf-\u003epage); return tmp; } } // 设置页表项，把虚拟页映射到文件的页缓存中的物理页 ret |= finish_fault(vmf); if (unlikely(ret \u0026 (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY))) { unlock_page(vmf-\u003epage); put_page(vmf-\u003epage); return ret; } // 设置页的脏标志位，表示页的数据被修改 fault_dirty_shared_page(vma, vmf-\u003epage); return ret; } 3．写时复制 两种情况会执行写时复制(Copy on Write，CoW) (1)进程分叉生成子进程的时候，为了避免复制物理页，子进程和父进程以只读方式共享所有私有的匿名页和文件页 (2)进程创建私有的文件映射，然后读访问，触发页错误异常 函数do_wp_page处理写时复制\n函数wp_page_copy执行写时复制\n// mm/memory.c static int wp_page_copy(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf-\u003evma; struct mm_struct *mm = vma-\u003evm_mm; struct page *old_page = vmf-\u003epage; struct page *new_page = NULL; pte_t entry; int page_copied = 0; const unsigned long mmun_start = vmf-\u003eaddress \u0026 PAGE_MASK; const unsigned long mmun_end = mmun_start + PAGE_SIZE; struct mem_cgroup *memcg; // 关联一个anon_vma实例到虚拟内存区域 if (unlikely(anon_vma_prepare(vma))) goto oom; if (is_zero_pfn(pte_pfn(vmf-\u003eorig_pte))) { // 是零页，分配一个物理页，然后用零初始化 new_page = alloc_zeroed_user_highpage_movable(vma,vmf-\u003eaddress); if (!new_page) goto oom; } else { // 不是零页，分配一个物理页，然后把数据复制到新的物理页 new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-\u003eaddress); if (!new_page) goto oom; cow_user_page(new_page, old_page, vmf-\u003eaddress, vma); } … // 不是零页，那么分配一个物理页，然后把数据复制到新的物理页 __SetPageUptodate(new_page); // mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end); vmf-\u003epte = pte_offset_map_lock(mm, vmf-\u003epmd, vmf-\u003eaddress, \u0026vmf-\u003eptl); // 锁住页表 if (likely(pte_same(*vmf-\u003epte, vmf-\u003eorig_pte))) { … flush_cache_page(vma, vmf-\u003eaddress, pte_pfn(vmf-\u003eorig_pte)); // 从缓存中冲刷页 // 使用新的物理页和访问权限生成页表项的值 entry = mk_pte(new_page, vma-\u003evm_page_prot); entry = maybe_mkwrite(pte_mkdirty(entry), vma); // 把页表项清除，并且冲刷页表缓存 ptep_clear_flush_notify(vma, vmf-\u003eaddress, vmf-\u003epte); // 建立新物理页到虚拟页的反向映射 page_add_new_anon_rmap(new_page, vma, vmf-\u003eaddress, false); … // 把物理页添加到活动LRU链表或不可回收LRU链表中，页回收算法需要从LRU链表中选择需要回收的物理页 lru_cache_add_active_or_unevictable(new_page, vma); // 修改页表项 set_pte_at_notify(mm, vmf-\u003eaddress, vmf-\u003epte, entry); // 更新页表缓存 update_mmu_cache(vma, vmf-\u003eaddress, vmf-\u003epte); if (old_page) { // 删除旧物理页到虚拟页的反向映射 page_remove_rmap(old_page, false); } /* 释放旧的物理页 */ new_page = old_page; page_copied = 1; } else { … } if (new_page) put_page(new_page); // 释放页表的锁 pte_unmap_unlock(vmf-\u003epte, vmf-\u003eptl); mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end); if (old_page) { if (page_copied \u0026\u0026 (vma-\u003evm_flags \u0026 VM_LOCKED)) { lock_page(old_page); if (PageMlocked(old_page)) munlock_vma_page(old_page); unlock_page(old_page); } put_page(old_page); } return page_copied ? VM_FAULT_WRITE : 0; oom_free_new: put_page(new_page); oom: if (old_page) put_page(old_page); return VM_FAULT_OOM; } 3.14.3　内核模式页错误异常 内核使用线性映射区域的虚拟地址，在内存管理子系统初始化的时把虚拟地址映射到物理地址，运行过程中使用vmalloc()函数从vmalloc区域分配虚拟内存区域，vmalloc()函数会分配并且映射到物理页 有些系统调用会传入用户空间的缓冲区，内核必须使用头文件“uaccess.h”定义的专用函数访问用户空间的缓冲区，专用函数在异常表中添加了可能触发异常的指令地址和异常修正程序的地址。如果访问用户空间的缓冲区时生成页错误异常，页错误异常处理程序发现用户虚拟地址没有被分配给进程，就在异常表中查找指令地址对应的异常修正程序，如果找到了，使用异常修正程序修正异常，避免内核崩溃 在内核模式下执行时触发页错误异常，ARM64架构内核的处理流程，3种处理方式 (1)不允许内核执行用户空间治疗，内核模式执行用户态指令，内核崩溃 (2)内核模式下访问用户虚拟地址，先使用函数__do_page_fault处理，处理失败使用__do_kernel_fault处理 (3)其他情况 __do_kernel_fault处理 1.函数__do_kernel_fault 访问数据生成的异常，函数__do_kernel_fault尝试在异常表中查找异常修正程序 找到异常修正程序，把保存在内核栈中的异常链接寄存器(ELR_EL1，Exception Link Register for Exception Level 1)的值修改为异常修正程序的虚拟地址。当异常处理程序返回的时候，处理器把程序计数器设置成异常链接寄存器的值，执行异常修正程序 如果没有找到异常修正程序，内核崩溃 函数__do_kernel_fault\n// arch/arm64/mm/fault.c static void __do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int esr, struct pt_regs *regs) { const char *msg; // 如果异常是由访问数据生成的，那么在异常表中查找异常修复程序 if (!is_el1_instruction_abort(esr) \u0026\u0026 fixup_exception(regs)) return; // 清除任何可能阻止在终端打印信息的自旋锁 bust_spinlocks(1); if (is_permission_fault(esr, regs, addr)) { if (esr \u0026 ESR_ELx_WNR) msg = \"write to read-only memory\"; else msg = \"read from unreadable memory\"; } else if (addr \u003c PAGE_SIZE) { msg = \"NULL pointer dereference\"; } else { msg = \"paging request\"; } // 打印触发页错误异常的原因 pr_alert(\"Unable to handle kernel %s at virtual address %08lx\\n\", msg, addr); // 打印页表信息 show_pte(mm, addr); die(\"Oops\", regs, esr); // 调用函数die()以打印寄存器信息 bust_spinlocks(0); // 停止清除任何可能阻止打印信息的自旋锁 do_exit(SIGKILL); // 终止当前进程 } 函数fixup_exception根据指令地址在异常表中查找，然后把保存在内核栈中的异常链接寄存器的值修改为异常修正程序的虚拟地址\n// arch/arm64/mm/extable.c int fixup_exception(struct pt_regs *regs) { const struct exception_table_entry *fixup; fixup = search_exception_tables(instruction_pointer(regs)); if (fixup) regs-\u003epc = (unsigned long)\u0026fixup-\u003efixup + fixup-\u003efixup; return fixup != NULL; } 异常表项中存储的指令地址是相对地址：fixup-\u003einsn =（指令的虚拟地址 − \u0026fixup-\u003einsn） 异常表项中存储的异常修正程序的地址是相对地址：fixup-\u003efixup =（异常修正程序的虚拟地址 − \u0026fixup-\u003efixup） regs-\u003epc是保存在内核栈中的异常链接寄存器的值 函数search_exception_tables根据指令地址在异常表中查找表项\n// kernel/extable.c const struct exception_table_entry *search_exception_tables(unsigned long addr) { const struct exception_table_entry *e; // 在内核的异常表中查找 e = search_extable(__start___ex_table, __stop___ex_table-1, addr); if (!e) // 在内核的异常表中没有找到，根据触发异常的指令的虚拟地址找到内核模块， e = search_module_extables(addr); // 在内核模块的异常表中查找 return e; } 2.异常表 进程在内核模式下运行的时候，访问用户虚拟地址时，应用程序通常是不可信任的，不能保证传入的用户虚拟地址是合法的，采取措施保护内核。使用异常表，每条表项有两个字段 (1)触发异常的指令的虚拟地址 (2)异常修正程序的起始虚拟地址 异常表项定义\n// arch/arm64/include/asm/extable.h struct exception_table_entry { int insn, fixup; }; 内核有一张异常表，全局变量__start___ex_table存放异常表的起始地址，__stop___ex_table存放异常表的结束地址 进程在内核模式下访问用户虚拟地址的时候，只允许使用头文件“uaccess.h”声明的函数，以函数get_user为例，函数get_user从用户空间读取C语言标准类型的数据，ARM64架构实现 // arch/arm64/include/asm/uaccess.h #define get_user(x, ptr) \\ ({ \\ __typeof__(*(ptr)) __user *__p = (ptr); \\ might_fault(); \\ access_ok(VERIFY_READ, __p, sizeof(*__p)) ? \\ __get_user((x), __p) : \\ ((x) = 0, -EFAULT); \\ }) 在64位内核中长整数的长度是8字节，把“__get_user((x), __p)”展开\nasm volatile( \\ \"1: ldr %x1, [%2]\\n\", \\ \"2:\\n\" \\ \" .section .fixup, \\\"ax\\\"\\n\" \\ \" .align 2\\n\" \\ \"3: mov %w0, %3\\n\" \\ \" mov %1, #0\\n\" \\ \" b 2b\\n\" \\ \" .previous\\n\" \\ \" .pushsection __ex_table, \\\"a\\\"\\n\" \\ \" .align 3\\n\" \\ \" .long (1b - .), (3b - .)\\n\" \\ \" .popsection\\n\" : \"+r\" (err), \"=\u0026r\" (x) \\ : \"r\" (__p), \"i\" (-EFAULT)) 链接脚本\n// arch/arm64/kernel/vmlinux.lds.S … . = ALIGN(SEGMENT_ALIGN); _etext = .; /* 代码段的结束地址 */ RO_DATA(PAGE_SIZE) /* 从这里到 */ EXCEPTION_TABLE(8) /* __init_begin将被标记为只读和不可执行 */ NOTES … // 宏EXCEPTION_TABLE的定义 // include/asm-generic/vmlinux.lds.h // 异常表 #define EXCEPTION_TABLE(align) \\ . = ALIGN(align); \\ __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) { \\ VMLINUX_SYMBOL(__start___ex_table) = .; \\ KEEP(*(__ex_table)) \\ VMLINUX_SYMBOL(__stop___ex_table) = .; \\ } 内核的全局变量__start___ex_table存放异常表节（__ex_table）的起始地址，__stop___ex_table存放异常表节的结束地址 3.15　反碎片技术 反碎片技术 (1)2.6.23版本引入了虚拟可移动区域 (2)3.5版本内存碎片整理技术 (3).6.24版本引入了根据可移动性分组的技术 (4).6.35版本引入了内存碎片整理技术 3.15.1　虚拟可移动区域 可移动区域(ZONE_MOVABLE)是一个伪内存区域：把物理内存分为两个区域，一个区域用于分配不可移动的页，另一个区域用于分配可移动的页\n3.15.2　内存碎片整理 内存碎片整理(memory compaction，意译为“内存碎片整理”)：从内存区域的底部扫描已分配的可移动页，从内存区域的顶部扫描空闲页，把底部的可移动页移到顶部的空闲页，在底部形成连续的空闲页 1.使用方法 内存碎片整理功能，必须开启配置文件“mm/Kconfig”定义的配置宏CONFIG_COMPACTION，默认开启\n3.16　页回收 申请分配页的时候，页分配器首先尝试使用低水线分配页。如果使用低水线分配失败，说明内存轻微不足，页分配器将会唤醒内存节点的页回收内核线程，异步回收页，然后尝试使用最低水线分配页。如果使用最低水线分配失败，说明内存严重不足，页分配器将会直接回收页 内核使用LRU（Least Recently Used，最近最少使用）算法选择最近最少使用的物理页\n3.16.1　数据结构 1．LRU链表 页回收算法使用LRU算法选择回收的页。每个内存节点的pglist_data实例有一个成员lruvec，称为LRU向量，LRU向量包含5条LRU链表 待补充\n3.16.2　发起页回收 申请分配页的时候，页分配器首先尝试使用低水线分配页。如果使用低水线分配失败，说明内存轻微不足，页分配器将会唤醒所有符合分配条件的内存节点的页回收线程，异步回收页，然后尝试使用最低水线分配页。如果分配失败，说明内存严重不足，页分配器将会直接回收页。如果直接回收页失败，那么判断是否应该重新尝试回收页 3.16.3　计算扫描的页数 3.16.4　收缩活动页链表 3.16.5　回收不活动页 3.16.6　页交换 3.16.7　回收slab缓存 3.17　内存耗尽杀手 当内存严重不足的时候，页分配器在多次尝试直接页回收失败以后，就会调用内存耗尽杀手（OOM killer，OOM是“Out of Memory”的缩写），选择进程杀死，释放内存\nflowchart LR __alloc_pages_showpath[Hard edge] --\u003e|Link text| __alloc_pages_may_oom(Round edge) __alloc_pages_may_oom --\u003e out_of_memeory{Decision} 3.17.1　使用方法 3.17.2　技术原理 3.18　内存资源控制器 控制组(cgroup)的内存资源控制器用来控制一组进程的内存使用量，启用内存资源控制器的控制组简称内存控制组（memcg）。控制组把各种资源控制器称为子系统，内存资源控制器也称为内存子系统\n3.18.1　使用方法 3.18.2　技术原理 3.19　处理器缓存 处理器和内存之间增加了缓存。缓存和内存的区别 (1)缓存是静态随机访问存储器(Static Random Access Memory，SRAM) (2)内存是动态随机访问存储器(Dynamic Random Access Memory，DRAM) 一级缓存分为一级指令缓存(i-cache，instruction cache)和一级数据数据(d-cache，data cache)。二级缓存是指令和数据共享的统一缓存(unified cache) 3.19.1　缓存结构 32KB四路组相连缓存(32KB 4-way set associative cache) 缓存的结构 缓存由多个容量相同的子缓存并联组成，每个子缓存称为路(Way)，四路表示4个子缓存并联\nARM64处理器的指令缓存有3种类型 (1)PIPT缓存 ： 物理地址生成索引和标签的缓存\n(2)VPIPT（VMID-aware PIPT）缓存 (3)VIPT：虚拟地址生成索引、从物理地址生成标签\n3.19.2　缓存策略 缓存分配有两种策略 (1)写分配(write allocation) (2)读分配(read allocation) 缓存更新有两种策略 (1)写回(write back) (2)写透(write-through) 3.19.3 缓存维护 3.ARM64处理器缓存维护 ARM64处理器支持3种缓存操作。 （1）使缓存行失效（invalidate）：清除缓存行的有效位。 （2）清理（clean）缓存行：首先把标记为脏的缓存行里面的数据写到下一级缓存或内存，然后清除缓存行的有效位。只适用于使用写回策略的数据缓存。 （3）清零（zero）：把缓存里面的一个内存块清零，不需要先从内存读数据到缓存中。只适用于数据缓存 3.19.4　SMP缓存一致性 原生的MESI协议有4种状态。MESI是4种状态的首字母缩写，缓存行的4种状态\n3.20 连续内存分配器 连续内存分配器（Contiguous Memory Allocator，CMA）:保留一块大的内存区域，当设备驱动不使用的时候，内核的其他模块可以使用\n3.21 userfaultfd userfaultfd（用户页错误文件描述符）用来拦截和处理用户空间的页错误异常，内核通过文件描述符将页错误异常的信息传递给用户空间，然后由用户空间决定要往虚拟页写入的数据。传统的页错误异常由内核独自处理，现在改为由内核和用户空间一起控制。 userfaultfd是为了解决QEMU/KVM虚拟机动态迁移的问题而出现的。所谓动态迁移，就是将虚拟机从一端迁移到另一端，而在迁移的过程中虚拟机能够继续提供服务，有两种实现方案\n3.22 内存错误检测工具KASAN 内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具，为发现“释放后使用”和“越界访问”这两类缺陷提供了快速和综合的解决方案 KASAN使用编译时插桩（compile-time instrumentation）检查每个内存访问\n第4章 中断、异常和系统调用 4.1 ARM64异常处理 4.1.1 异常级别 ARM64处理器4个异常级别：0~3\nARM64处理器的异常级别 虚拟机里面运行一个操作系统，运行虚拟机的操作系统称为宿主操作系统(host OS)，虚拟机里面的操作系统称为客户操作系统(guest OS) 开源虚拟机管理软件是QEMU，QEMU支持基于内核的虚拟机(Kernel-based Virtual Machine，KVM)。KVM直接在处理器上执行客户操作系统，虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要从异常级别1切换到异常级别2。 ARM64架构的安全扩展定义了两种安全状态：正常世界和安全世界。通过异常级别3的安全监控器切换\n4.1.2 异常分类 ARM64体系结构中，异常分为同步异常和异步异常 同步异常包括： (1)系统调用，异常级别0使用svc(Supervisor Call)指令陷入异常级别1，异常级别1使用hvc(Hypervisor Call)指令陷入异常级别2，异常级别2使用smc(Secure Monitor Call)指令陷入异常级别3 (2)数据中止，即访问数据时的页错误异常，无映射，无写权限 (3)指令中止，取指令时的页错误异常，无映射，无执行权限 (4)栈指针或指令地址没有对齐 (5)没有定义的指令 (6)调试异常 异步异常包括: (1)中断(normal priority interrupt，IRQ)，即普通优先级的中断。 (2)快速中断(fast interrupt FIQ)，高优先级中断 (3)系统错误(System Error SError)，硬件错误触发的异常 4.1.3 异常向量表 存储异常处理程序的内存位置称为异常向量，ARM64处理器的异常级别1、2和3，每个异常级别都有自己的异常向量表，异常向量表的起始虚拟地址存放在寄存器VBAR_ELn(向量基准地址寄存器，Vector Based Address Register)中 地址 异常类型 含义 VBAR_ELn + 0x000 同步异常 当前异常级别生成的异常，使用异常级别0的栈指针寄存器SP_EL0 + 0x080 中断 + 0x100 快速中断 + 0x180 系统错误 + 0x200 同步异常 当前异常级别生成的异常，使用当前异常级别的栈指针寄存器SP_ELn + 0x280 中断 + 0x300 快速中断 + 0x380 系统错误 + 0x400 同步异常 64位应用程序在异常级别（n−1）生成的异常 + 0x480 中断 + 0x500 快速中断 + 0x580 系统错误 + 0x600 同步异常 32位应用程序在异常级别（n−1）生成的异常 + 0x680 中断 + 0x700 快速中断 + 0x780 系统错误 ARM64架构内核定义的异常级别1的异常向量表 // ach/arm64/kernel/entry.S .align 11 ENTRY(vectors) ventry el1_sync_invalid // 异常级别1生成的同步异常，使用栈指针寄存器SP_EL0 ventry el1_irq_invalid // 异常级别1生成的中断，使用栈指针寄存器SP_EL0 ventry el1_fiq_invalid // 异常级别1生成的快速中断，使用栈指针寄存器SP_EL0 ventry el1_error_invalid // 异常级别1生成的系统错误，使用栈指针寄存器SP_EL0 ventry el1_sync // 异常级别1生成的同步异常，使用栈指针寄存器SP_EL1 ventry el1_irq // 异常级别1生成的中断，使用栈指针寄存器SP_EL1 ventry el1_fiq_invalid // 异常级别1生成的快速中断，使用栈指针寄存器SP_EL1 ventry el1_error_invalid // 异常级别1生成的系统错误，使用栈指针寄存器SP_EL1 ventry el0_sync // 64位应用程序在异常级别0生成的同步异常 ventry el0_irq // 64位应用程序在异常级别0生成的中断 ventry el0_fiq_invalid // 64位应用程序在异常级别0生成的快速中断 ventry el0_error_invalid// 64位应用程序在异常级别0生成的系统错误 #ifdef CONFIG_COMPAT /* 表示支持执行32位程序 */ ventry el0_sync_compat // 32位应用程序在异常级别0生成的同步异常 ventry el0_irq_compat // 32位应用程序在异常级别0生成的中断 ventry el0_fiq_invalid_compat // 32位应用程序在异常级别0生成的快速中断 ventry el0_error_invalid_compat// 32位应用程序在异常级别0生成的系统错误 #else ventry el0_sync_invalid // 32位应用程序在异常级别0生成的同步异常 ventry el0_irq_invalid // 32位应用程序在异常级别0生成的中断 ventry el0_fiq_invalid // 32位应用程序在异常级别0生成的快速中断 ventry el0_error_invalid// 32位应用程序在异常级别0生成的系统错误 #endif END(vectors) ventry是一个宏，参数是跳转标号，即异常处理程序的标号\n// arch/arm64/include/asm/assembler.h .macro ventry label .align 7 b \\label .endm // ventry el1_sync展开 .align 7 b el1_sync 启动过程中，0号处理器称为引导处理器，其他处理器称为从处理器。引导处理器在函数__primary_switched()中把寄存器VBAR_EL1设置为异常级别1的异常向量表的起始虚拟地址 _head() -\u003e stext() -\u003e __primary_switch() -\u003e __primary_switched() // arch/arm64/kernel/head.S __primary_switched: … adr_l x8, vectors msr vbar_el1, x8 // 把寄存器VBAR_EL1设置为异常向量表的起始虚拟地址 isb … b start_kernel ENDPROC(__primary_switched) 从处理器在函数__secondary_switched()中把寄存器VBAR_EL1设置为异常级别1的异常向量表的起始虚拟地址\nsecondary_entry() -\u003e secondary_startup() -\u003e __secondary_switched() // arch/arm64/kernel/head.S __secondary_switched: adr_l x5, vectors msr vbar_el1, x5 isb … b secondary_start_kernel ENDPROC(__secondary_switched) 4.1.4 异常处理 处理器取出异常处理的时候，自动执行的操作 (1)把当前的处理器状态（Processor State，PSTATE）保存在寄存器SPSR_EL1（保存程序状态寄存器，Saved Program Status Register）中 (2)把返回地址保存在寄存器ELR_EL1（异常链接寄存器，Exception Link Register）中 系统调用，那么返回地址是系统调用指令后面的指令 除系统调用外的同步异常，那么返回地址是生成异常的指令 异步异常，那么返回地址是没有执行的第一条指令 (3)把处理器状态的DAIF这4个异常掩码位都设置为1，禁止这4种异常，D是调试掩码位（Debug mask bit），A是系统错误掩码位（SError mask bit），I是中断掩码位（IRQ mask bit），F是快速中断掩码位（FIQ mask bit） (4)同步异常或系统错误异常，把生成异常的原因保存在寄存器ESR_EL1（异常症状寄存器，Exception Syndrome Register）中 (5)同步异常，把错误地址保存在寄存器FAR_EL1（错误地址寄存器，Fault Address Register）中 (6)处理器处于用户模式（异常级别0），那么把异常级别提升到1 (7)根据向量基准地址寄存器VBAR_EL1、异常类型和生成异常的异常级别计算出异常向量的虚拟地址，执行异常向量 对于64位应用程序在用户模式（异常级别0）下生成的同步异常，入口是el0_sync\n// arch/arm64/kernel/entry.S el0_sync: kernel_entry 0 // 把所有通用寄存器的值保存在当前进程的内核栈 mrs x25, esr_el1 // 读异常症状寄存器 lsr x24, x25, #ESR_ELx_EC_SHIFT // 异常类别 cmp x24, #ESR_ELx_EC_SVC64 // 64位系统调用 b.eq el0_svc // 系统调用，调用函数el0_svc cmp x24, #ESR_ELx_EC_DABT_LOW // 异常级别0的数据中止 b.eq el0_da // 访问数据时的页错误异常，调用函数el0_da cmp x24, #ESR_ELx_EC_IABT_LOW // 异常级别0的指令中止 b.eq el0_ia // 取指令时的页错误异常，调用函数el0_ia cmp x24, #ESR_ELx_EC_FP_ASIMD // 访问浮点或者高级SIMD b.eq el0_fpsimd_acc // 访问浮点或高级SIMD，调用函数el0_fpsimd_acc cmp x24, #ESR_ELx_EC_FP_EXC64 // 浮点或者高级SIMD异常 b.eq el0_fpsimd_exc // 浮点或高级SIMD异常，调用函数el0_fpsimd_exc cmp x24, #ESR_ELx_EC_SYS64 // 可配置陷入 b.eq el0_sys // 可配置陷入，调用函数el0_sys cmp x24, #ESR_ELx_EC_SP_ALIGN // 栈对齐异常 b.eq el0_sp_pc cmp x24, #ESR_ELx_EC_PC_ALIGN // 指令地址对齐异常 b.eq el0_sp_pc cmp x24, #ESR_ELx_EC_UNKNOWN // 异常级别0的未知异常 b.eq el0_undef cmp x24, #ESR_ELx_EC_BREAKPT_LOW // 异常级别0的调试异常 b.ge el0_dbg b el0_inv 可配置陷入，调用函数el0_sys\n// arch/arm64/kernel/entry.S el1_sync: kernel_entry 1 mrs x1, esr_el1 // 读异常症状寄存器 lsr x24, x1, #ESR_ELx_EC_SHIFT // 异常类别 cmp x24, #ESR_ELx_EC_DABT_CUR // 异常级别1的数据中止 b.eq el1_da cmp x24, #ESR_ELx_EC_IABT_CUR // 异常级别1的指令中止 b.eq el1_ia cmp x24, #ESR_ELx_EC_SYS64 // 可配置陷入 b.eq el1_undef cmp x24, #ESR_ELx_EC_SP_ALIGN // 栈对齐异常 b.eq el1_sp_pc cmp x24, #ESR_ELx_EC_PC_ALIGN // 指令地址对齐异常 b.eq el1_sp_pc cmp x24, #ESR_ELx_EC_UNKNOWN // 异常级别1的未知异常 b.eq el1_undef cmp x24, #ESR_ELx_EC_BREAKPT_CUR // 异常级别1的调试异常 b.ge el1_dbg b el1_inv 以64位应用程序在用户模式（异常级别0）下访问数据时生成的页错误异常为例，处理函数是el0_da\n// arch/arm64/kernel/entry.S el0_da: mrs x26, far_el1 // 获取数据的虚拟地址，存放在寄存器x26 enable_dbg_and_irq // msr daifclr, #(8 | 2) 开启调试异常和中断 … clear_address_tag x0, x26 mov x1, x25 mov x2, sp bl do_mem_abort // 调用C语言函数 b ret_to_user 内核模式（异常级别1）下访问数据时生成的页错误异常为例说明，处理函数是el1_da\n// arch/arm64/kernel/entry.S el1_da: mrs x3, far_el1 enable_dbg tbnz x23, #7, 1f enable_irq 1: clear_address_tag x0, x3 mov x2, sp // 结构体 pt_regs bl do_mem_abort disable_irq kernel_exit 1 异常处理程序执行完的时候，调用kernel_exit返回。kernel_exit是一个宏，参数el是返回的异常级别，0表示返回异常级别0，1表示返回异常级别1\n// arch/arm64/kernel/entry.S .macro kernel_exit, el … ldp x21, x22, [sp, #S_PC] //加载保存的寄存器ELR_EL1和SPSR_EL1的值 … .if \\el == 0 /* 如果返回用户模式（异常级别0）*/ ldr x23, [sp, #S_SP] msr sp_el0, x23 /* 恢复异常级别0的栈指针寄存器 */ … .endif msr elr_el1, x21 msr spsr_el1, x22 ldp x0, x1, [sp, #16 * 0] ldp x2, x3, [sp, #16 * 1] ldp x4, x5, [sp, #16 * 2] ldp x6, x7, [sp, #16 * 3] ldp x8, x9, [sp, #16 * 4] ldp x10, x11, [sp, #16 * 5] ldp x12, x13, [sp, #16 * 6] ldp x14, x15, [sp, #16 * 7] ldp x16, x17, [sp, #16 * 8] ldp x18, x19, [sp, #16 * 9] ldp x20, x21, [sp, #16 * 10] ldp x22, x23, [sp, #16 * 11] ldp x24, x25, [sp, #16 * 12] ldp x26, x27, [sp, #16 * 13] ldp x28, x29, [sp, #16 * 14] ldr lr, [sp, #S_LR] add sp, sp, #S_FRAME_SIZE eret .endm 执行指令eret的时候，处理器自动使用寄存器SPSR_EL1保存的值恢复处理器状态，使用寄存器ELR_EL1保存的返回地址恢复程序计数器（Program Counter，PC）\n4.2 中断 中断是外围设备通知处理器的一种机制\n4.2.1　中断控制器 ARM标准的中断控制器，称为通用中断控制器（Generic Interrupt Controller，GIC） 软件 GIC v2控制器有两个主要的功能块 1）分发器（Distributor） 2）处理器接口（CPU Interface） 中断有以下4种类型:SGI、PPI、SPI、LPI SGI 软件生成的中断 0~15 PPI 私有外设中断 16~31 SPI 共享外设中断 32~1020 LPI 局部特点外设中断\n边沿触发、电平触发 中断有以下4种状态。 （1）Inactive：中断源没有发送中断。\n（2）Pending：中断源已经发送中断，等待处理器处理。\n（3）Active：处理器已经确认中断，正在处理。 （4）Active and pending：处理器正在处理中断，相同的中断源又发送了一个中断。 GIC v2控制器描述符\n// drivers/irqchip/irq-gic.c static struct irq_chip gic_chip = { .irq_mask = gic_mask_irq, .irq_unmask = gic_unmask_irq, .irq_eoi = gic_eoi_irq, .irq_set_type = gic_set_type, .irq_get_irqchip_state = gic_irq_get_irqchip_state, .irq_set_irqchip_state = gic_irq_set_irqchip_state, .flags = IRQCHIP_SET_TYPE_MASKED | IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND, }; 4.2.2　中断域 每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域 1．创建中断域 中断控制器的驱动程序使用分配函数irq_domain_add_*()创建和注册中断域，调用者给分配函数提供irq_domain_ops结构体，分配函数在执行成功的时候返回irq_domain的指针\n分配主要为函数__irq_domain_add()。函数__irq_domain_add()的执行过程是：分配一个irq_domain结构体，初始化成员，然后把中断域添加到全局链表irq_domain_list中 2．创建映射 向中断域添加硬件中断号到Linux中断号的映射，内核提供了函数irq_create_mapping\nunsigned int irq_create_mapping(struct irq_domain *domain, irq_hw_number_t hwirq); 3．查找映射 中断处理程序需要根据硬件中断号查找Linux中断号，内核提供了函数irq_find_mapping：\nunsigned int irq_find_mapping(struct irq_domain *domain, irq_hw_number_t hwirq); 输入参数是中断域和硬件中断号，返回Linux中断号\n4.2.3　中断控制器驱动初始化 ARM64架构使用扁平设备树（Flattened Device Tree，FDT）描述板卡的硬件信息。编写设备树源文件（Device Tree Source，DTS），存放在目录“arch/arm64/boot/dts”下，然后使用设备树编译器（Device Tree Compiler，DTC）把设备树源文件转换成设备树二进制文件（Device Tree Blob，DTB），最后把设备树二进制文件写到存储设备上\n1．设备树源文件 3.初始化 函数irqchip_init –\u003e of_irq_init –\u003e __irqchip_of_table start_kernel() -\u003e init_IRQ() -\u003e irqchip_init() -\u003e of_irq_init() -\u003e gic_of_init() -\u003e __gic_init_bases() -\u003e __irqchip_of_table() 4.2.4　Linux中断处理 向中断域添加硬件中断号到Linux中断号的映射时，内核分配一个Linux中断号和一个中断描述符irq_desc 中断描述符有两个层次的中断处理函数\n存储Linux中断号到中断描述符的映射关系 (1)中断编号是稀疏的（即不连续），那么使用基数树（radix tree）存储 (2)中断编号是连续的，那么使用数组存储\n// kernel/irq/irqdesc.c #ifdef CONFIG_SPARSE_IRQ static RADIX_TREE(irq_desc_tree, GFP_KERNEL); #else struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = { [0 ... NR_IRQS-1] = { .handle_irq = handle_bad_irq, .depth = 1, .lock = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-\u003elock), } }; #endif handle_irq() -\u003e gic_irq_domain_map() // 硬件中断号小于32 -\u003e handle_percpu_devid_irq() // 中断号大于或等于32 -\u003e handle_fasteoi_irq() irq_create_mapping() -\u003e irq_domain_associate() -\u003e domain-\u003eops-\u003emap() // drivers/irqchip/irq-gic.c static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw) { struct gic_chip_data *gic = d-\u003ehost_data; if (hw \u003c 32) { irq_set_percpu_devid(irq); irq_domain_set_info(d, irq, hw, \u0026gic-\u003echip, d-\u003ehost_data, handle_percpu_devid_irq, NULL, NULL); irq_set_status_flags(irq, IRQ_NOAUTOEN); } else { irq_domain_set_info(d, irq, hw, \u0026gic-\u003echip, d-\u003ehost_data, handle_fasteoi_irq, NULL, NULL); irq_set_probe(irq); } return 0; } Linux中断处理流程 // arch/arm64/kernel/entry.S .align 6 el0_irq: kernel_entry 0 el0_irq_naked: enable_dbg … irq_handler … b ret_to_user ENDPROC(el0_irq) .macro irq_handler ldr_l x1, handle_arch_irq mov x0, sp irq_stack_entry blr x1 irq_stack_exit .endm 函数handle_irq_event，执行设备驱动程序注册的处理函数\n// handle_irq_event() -\u003e handle_irq_event_percpu() -\u003e __handle_irq_event_percpu() kernel/irq/handle.c irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags) { irqreturn_t retval = IRQ_NONE; unsigned int irq = desc-\u003eirq_data.irq; struct irqaction *action; for_each_action_of_desc(desc, action) { irqreturn_t res; … res = action-\u003ehandler(irq, action-\u003edev_id); … switch (res) { case IRQ_WAKE_THREAD: … __irq_wake_thread(desc, action); /*继续往下走，把“action-\u003eflags”作为生成随机数的一个因子 */ case IRQ_HANDLED: *flags |= action-\u003eflags; break; default: break; } retval |= res; } return retval; } 4.2.5　中断线程化 内核提供的函数request_threaded_irq()用来注册线程化的中断\nint request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long flags, const char *name, void *dev); 每个中断处理描述符（irqaction）对应一个内核线程，成员thread指向内核线程的进程描述符，成员thread_fn指向线程处理函数\n// include/linux/interrupt.h struct irqaction { … irq_handler_t thread_fn; struct task_struct *thread; … } ____cacheline_internodealigned_in_smp; 中断处理线程是优先级为50、调度策略是SCHED_FIFO的实时内核线程，名称是“irq/”后面跟着Linux中断号，线程处理函数是irq_thread()\nrequest_threaded_irq() -\u003e __setup_irq() -\u003e setup_irq_thread() // kernel/irq/manage.c static int setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary) { struct task_struct *t; struct sched_param param = { .sched_priority = MAX_USER_RT_PRIO/2, }; if (!secondary) { t = kthread_create(irq_thread, new, \"irq/%d-%s\", irq, new-\u003ename); } else { t = kthread_create(irq_thread, new, \"irq/%d-s-%s\", irq, new-\u003ename); param.sched_priority -= 1; } … sched_setscheduler_nocheck(t, SCHED_FIFO, \u0026param); … } handle_fasteoi_irq() -\u003e handle_irq_event() -\u003e handle_irq_event_percpu() -\u003e __handle_irq_event_percpu() // kernel/irq/handle.c irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags) { irqreturn_t retval = IRQ_NONE; unsigned int irq = desc-\u003eirq_data.irq; struct irqaction *action; for_each_action_of_desc(desc, action) { irqreturn_t res; … res = action-\u003ehandler(irq, action-\u003edev_id); … switch (res) { case IRQ_WAKE_THREAD: … __irq_wake_thread(desc, action); /*继续往下走，把“action-\u003eflags”作为生成随机数的一个因子*/ case IRQ_HANDLED: *flags |= action-\u003eflags; break; default: break; } retval |= res; } return retval; } 中断处理线程的处理函数是irq_thread()，调用函数irq_thread_fn()，然后函数irq_thread_fn()调用注册的线程处理函数\n// kernel/irq/manage.c static int irq_thread(void *data) { struct callback_head on_exit_work; struct irqaction *action = data; struct irq_desc *desc = irq_to_desc(action-\u003eirq); irqreturn_t (*handler_fn)(struct irq_desc *desc, struct irqaction *action); if (force_irqthreads \u0026\u0026 test_bit(IRQTF_FORCED_THREAD, \u0026action-\u003ethread_flags)) handler_fn = irq_forced_thread_fn; else handler_fn = irq_thread_fn; … while (!irq_wait_for_interrupt(action)) { irqreturn_t action_ret; … action_ret = handler_fn(desc, action); … } … return 0; } static irqreturn_t irq_thread_fn(struct irq_desc *desc, struct irqaction *action) { irqreturn_t ret; ret = action-\u003ethread_fn(action-\u003eirq, action-\u003edev_id); irq_finalize_oneshot(desc, action); return ret; } 4.2.6　禁止/开启中断 软件可以禁止中断，使处理器不响应所有中断请求，但是不可屏蔽中断（Non Maskable Interrupt，NMI）是个例外，接口： (1)local_irq_disable() (2)local_irq_save(flags) 先把中断状态保存在参数flags中，然后禁止中断 开启中断的接口 (1)local_irq_enable() (2)local_irq_restore(flags) 恢复本地处理器的中断状态 ARM64架构禁止中断的函数local_irq_disable()\nlocal_irq_disable() -\u003e raw_local_irq_disable() -\u003e arch_local_irq_disable() // arch/arm64/include/asm/irqflags.h // 中断掩码位设置成1 static inline void arch_local_irq_disable(void) { asm volatile( \"msr daifset, #2 // arch_local_irq_disable\" : : : \"memory\"); } ARM64架构开启中断的函数local_irq_enable()\nlocal_irq_enable() -\u003e raw_local_irq_enable() -\u003e arch_local_irq_enable() // arch/arm64/include/asm/irqflags.h // 中断掩码位设置成0 static inline void arch_local_irq_enable(void) { asm volatile( \"msr daifclr, #2 // arch_local_irq_enable\" : : : \"memory\"); } 4.2.7　禁止/开启单个中断 // 禁止单个中断的函数 void disable_irq(unsigned int irq); // 开启单个中断的函数 void enable_irq(unsigned int irq); 4.2.8　中断亲和性 设置中断亲和性，允许中断控制器把某个中断转发给哪些处理器，有两种配置方法 (1)写文件“/proc/irq/IRQ#/smp_affinity”，参数是位掩码 (2)文件“/proc/irq/IRQ#/smp_affinity_list”，参数是处理器列表 4.2.9　处理器间中断 多处理器系统中，一个处理器可以向其他处理器发送中断 处理处理器间中断的执行流程\n处理处理器间中断 4.3　中断下半部 中断处理程序分为两部分，上半部（top half，th）在关闭中断的情况下执行，只做对时间非常敏感、与硬件相关或者不能被其他中断打断的工作；下半部（bottom half，bh）在开启中断的情况下执行，可以被其他中断打断 上半部称为硬中断（hardirq），下半部有3种：软中断（softirq）、小任务（tasklet）和工作队列（workqueue） 4.3.1　软中断 内核定义了一张软中断向量表，每种软中断有一个唯一的编号，对应一个softirq_action实例，softirq_action实例的成员action是处理函数\n// kernel/softirq.c static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp; // include/linux/interrupt.h struct softirq_action { void (*action)(struct softirq_action *); }; 1．软中断的种类 内核定义了10种软中断\n// include/linux/interrupt.h enum { HI_SOFTIRQ=0, // 高优先级的小任务 TIMER_SOFTIRQ, // 定时器软中断 NET_TX_SOFTIRQ, // 网络栈发送报文的软中断 NET_RX_SOFTIRQ, // 网络栈接收报文的软中断 BLOCK_SOFTIRQ, // 块设备软中断 IRQ_POLL_SOFTIRQ, // 支持I/O轮询的块设备软中断 TASKLET_SOFTIRQ, // 低优先级的小任务 SCHED_SOFTIRQ, // 调度软中断 HRTIMER_SOFTIRQ, /* 没有使用，但是保留，因为有些工具依赖这个编号 */ RCU_SOFTIRQ, /* RCU软中断应该总是最后一个软中断 */ NR_SOFTIRQS }; 2．注册软中断的处理函数 open_softirq()用来注册软中断的处理函数，在软中断向量表中为指定的软中断编号设置处理函数\n// kernel/softirq.c void open_softirq(int nr, void (*action)(struct softirq_action *)) { softirq_vec[nr].action = action; } 3．触发软中断 函数raise_softirq用来触发软中断，参数是软中断编号。\nvoid raise_softirq(unsigned int nr); raise_softirq() -\u003e raise_softirq_irqoff() -\u003e __raise_softirq_irqoff() // kernel/softirq.c void __raise_softirq_irqoff(unsigned int nr) { or_softirq_pending(1UL \u003c\u003c nr); } // 宏or_softirq_pending展开 irq_stat[smp_processor_id()].__softirq_pending |= (1UL \u003c\u003c nr); 4.执行软中断 中断处理程序的后半部分，调用函数irq_exit()以退出中断上下文，处理软中断\n// kernel/softirq.c void irq_exit(void) { … preempt_count_sub(HARDIRQ_OFFSET); if (!in_interrupt() \u0026\u0026 local_softirq_pending()) invoke_softirq(); … } // kernel/softirq.c static inline void invoke_softirq(void) { if (ksoftirqd_running()) return; if (!force_irqthreads) { __do_softirq(); } else { wakeup_softirqd(); } } 函数__do_softirq是执行软中断的核心函数\n// kernel/softirq.c #define MAX_SOFTIRQ_TIME msecs_to_jiffies(2) #define MAX_SOFTIRQ_RESTART 10 asmlinkage __visible void __softirq_entry __do_softirq(void) { unsigned long end = jiffies + MAX_SOFTIRQ_TIME; unsigned long old_flags = current-\u003eflags; int max_restart = MAX_SOFTIRQ_RESTART; struct softirq_action *h; bool in_hardirq; __u32 pending; int softirq_bit; … pending = local_softirq_pending(); … __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET); … restart: set_softirq_pending(0); local_irq_enable(); h = softirq_vec; while ((softirq_bit = ffs(pending))) { … h += softirq_bit - 1; … h-\u003eaction(h); … h++; pending \u003e\u003e= softirq_bit; } … local_irq_disable(); pending = local_softirq_pending(); if (pending) { if (time_before(jiffies, end) \u0026\u0026 !need_resched() \u0026\u0026 --max_restart) goto restart; wakeup_softirqd(); } … __local_bh_enable(SOFTIRQ_OFFSET); … } 5．抢占计数器 进程的thread_info结构体有一个抢占计数器：int preempt_count，它用来表示当前进程能不能被抢占,可通过抢占计数器判断处在什么场景 // nclude/linux/preempt.h #define in_irq() (hardirq_count()) // 正在执行硬中断 #define in_softirq() (softirq_count()) // 禁止软中断和正在执行软中断 #define in_interrupt() (irq_count()) // 正在执行不可屏蔽中断 #define in_serving_softirq() (softirq_count() \u0026 SOFTIRQ_OFFSET) // 正在执行软中断 #define in_nmi() (preempt_count() \u0026 NMI_MASK) // 不可屏蔽中断场景 #define in_task() (!(preempt_count() \u0026 \\ (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET))) // 进程上下文 #define hardirq_count() (preempt_count() \u0026 HARDIRQ_MASK) #define softirq_count() (preempt_count() \u0026 SOFTIRQ_MASK) #define irq_count() (preempt_count() \u0026 (HARDIRQ_MASK | SOFTIRQ_MASK \\ | NMI_MASK)) 6．禁止/开启软中断 禁止软中断的函数是local_bh_disable()\ninclude/linux/bottom_half.h static inline void local_bh_disable(void) { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET); } static __always_inline void __local_bh_disable_ip(unsigned long ip, unsigned int cnt) { preempt_count_add(cnt); barrier(); } include/linux/preempt.h #define SOFTIRQ_DISABLE_OFFSET (2 * SOFTIRQ_OFFSET) // 开启软中断 local_bh_enable() 4.3.2 小任务 tasklet 小任务（tasklet）是基于软中断实现\n1.数据结构 // include/linux/interrupt.h struct tasklet_struct { struct tasklet_struct *next; unsigned long state; atomic_t count; void (*func)(unsigned long); unsigned long data; }; 2．编程接口 3．技术原理 4.3.3　工作队列 4.4　系统调用 系统调用是内核给用户程序提供的编程接口。用户程序调用系统调用，通常使用glibc库针对单个系统调用封装的函数。glibc库没有针对某个系统调用封装函数，用户程序可通用的封装函数syscall() #define _GNU_SOURCE #include #include /* 定义 SYS_xxx */ long syscall(long number, ...); // number系统调用号 // 返回值 0成功，-1错误，错误号在errno 应用程序使用系统调用fork()创建子进程，有两种调用方法\nret = fork(); ret = syscall(SYS_fork); ARM64处理器提供的系统调用指令是svc (1)64位应用程序使用寄存器x8传递系统调用号 (2)寄存器x0～x6最多可以传递7个参数 (3)系统调用执行完的时候，使用寄存器x0存放返回值 4.4.1 定义系统调用 Linux内核使用宏SYSCALL_DEFINE定义系统调用，创建子进程的系统调用fork // kernel/fork.c SYSCALL_DEFINE0(fork) { #ifdef CONFIG_MMU return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0); #else /* 如果处理器没有内存管理单元，那么不支持 */ return -EINVAL; #endif } // SYSCALL_DEFINE0(fork) 展开 asmlinkage long sys_fork(void) // asmlinkage 表示C语言函数可以被汇编代码调用 ARM64架构定义的系统调用表sys_call_table\n// arch/arm64/kernel/sys.c #undef __SYSCALL #define __SYSCALL(nr, sym) [nr] = sym, void * const sys_call_table[__NR_syscalls] __aligned(4096) = { [0 ... __NR_syscalls - 1] = sys_ni_syscall, #include }; ARM64架构，头文件“asm/unistd.h”是“arch/arm64/include/asm/unistd.h”。\n// arch/arm64/include/asm/unistd.h #include // arch/arm64/include/uapi/asm/unistd.h #include // include/asm-generic/unistd.h #include // include/uapi/asm-generic/unistd.h #define __NR_io_setup 0 /* 系统调用号0 */ __SC_COMP(__NR_io_setup, sys_io_setup, compat_sys_io_setup) /* [0] = sys_io_setup, */ … #define __NR_fork 1079 /* 系统调用号1079 */ #ifdef CONFIG_MMU __SYSCALL(__NR_fork, sys_fork) /* [1079] = sys_fork, */ #else __SYSCALL(__NR_fork, sys_ni_syscall) #endif /* CONFIG_MMU */ #undef __NR_syscalls #define __NR_syscalls (__NR_fork+1) 4.4.2 执行系统调用 ARM64处理器把系统调用划分到同步异常，在异常级别1的异常向量表中，系统调用的入口，64位应用程序执行系统调用指令svc，系统调用入口 el0_sync\n// arch/arm64/kernel.c .align 6 el0_sync: kernel_entry 0 mrs x25, esr_el1 // 读异常症状寄存器 lsr x24, x25, #ESR_ELx_EC_SHIFT // 异常类别 cmp x24, #ESR_ELx_EC_SVC64 // 64位系统调用 b.eq el0_svc … el0_svc负责执行系统调用\n// arch/arm64/kernel.c /* * 这些是系统调用处理程序使用的寄存器， * 允许我们理论上最多传递7个参数给一个函数 – x0～x6 * * x7保留，用于32位模式的系统调用号 */ sc_nr .req x25 // 系统调用的数量 scno .req x26 // 系统调用号 stbl .req x27 // 系统调用表的地址 tsk .req x28 // 当前进程的thread_info结构体的地址 .align 6 el0_svc: adrp stbl, sys_call_table // 加载系统调用表的地址 uxtw scno, w8 // 寄存器w8里面的系统调用号 mov sc_nr, #__NR_syscalls el0_svc_naked: // 32位系统调用的入口 stp x0, scno, [sp, #S_ORIG_X0] // 保存原来的x0和系统调用号 enable_dbg_and_irq ct_user_exit 1 // ptrace跟踪系统调用，跳转到__sys_trace处理 ldr x16, [tsk, #TSK_TI_FLAGS] // 检查系统调用钩子 tst x16, #_TIF_SYSCALL_WORK b.ne __sys_trace cmp scno, sc_nr // 检查系统调用号是否超过上限 b.hs ni_sys ldr x16, [stbl, scno, lsl #3] // 系统调用表表项的地址 blr x16 // 调用sys_*函数 b ret_fast_syscall ni_sys: mov x0, sp bl do_ni_syscall b ret_fast_syscall ENDPROC(el0_svc) ret_fast_syscall从系统调用返回用户空间\n// arch/arm64/kernel.c ret_fast_syscall: disable_irq str x0, [sp, #S_X0] /* DEFINE(S_X0, offsetof(struct pt_regs, regs[0])); */ ldr x1, [tsk, #TSK_TI_FLAGS] and x2, x1, #_TIF_SYSCALL_WORK cbnz x2, ret_fast_syscall_trace and x2, x1, #_TIF_WORK_MASK cbnz x2, work_pending enable_step_tsk x1, x2 kernel_exit 0 ret_fast_syscall_trace: enable_irq // 开启中断 b __sys_trace_return_skipped // 我们已经保存了x0 work_pending: mov x0, sp // 'regs' bl do_notify_resume #ifdef CONFIG_TRACE_IRQFLAGS bl trace_hardirqs_on // 在用户空间执行时开启中断 #endif ldr x1, [tsk, #TSK_TI_FLAGS] // 重新检查单步执行 b finish_ret_to_user ret_to_user: … finish_ret_to_user: enable_step_tsk x1, x2 kernel_exit 0 ENDPROC(ret_to_user) work_pending调用函数do_notify_resume\n// arch/arm64/kernel/signal.c asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int thread_flags) { … do { if (thread_flags \u0026 _TIF_NEED_RESCHED) { schedule(); } else { local_irq_enable(); if (thread_flags \u0026 _TIF_UPROBE) uprobe_notify_resume(regs); if (thread_flags \u0026 _TIF_SIGPENDING) do_signal(regs); if (thread_flags \u0026 _TIF_NOTIFY_RESUME) { clear_thread_flag(TIF_NOTIFY_RESUME); tracehook_notify_resume(regs); } if (thread_flags \u0026 _TIF_FOREIGN_FPSTATE) fpsimd_restore_current_state(); } local_irq_disable(); thread_flags = READ_ONCE(current_thread_info()-\u003eflags); } while (thread_flags \u0026 _TIF_WORK_MASK); } 第5章 内核互斥技术 临界区的执行时间比较长或者可能睡眠互斥技术 (1)信号量 (2)读写信号量 (3)互斥锁 (4)实时互斥锁 临界区的执行时间很短，并且不会睡眠 互斥技术 (1)原子变量 (2)自旋锁 (3)读写锁 (4)顺序锁 进程互斥技术 (1)禁止内核抢占 (2)禁止软中断 (3)禁止硬中断 免使用锁的互斥技术 (1)每处理器变量 (2)每处理器计数器 (3)内存屏障 (4)读-复制更新(Read-Copy Update RCU) (5)可睡眠RCU 内核提供了死锁检测工具lockdep 5.1 信号量 信号量允许多个进程同时进入临界区，信号量的计数值设置为1，即二值信号量，这种信号量称为互斥信号量，适合保护比较长的临界区 内核使用的信号量定义\n// include/linux/semaphore.h struct semaphore { raw_spinlock_t lock; // 自旋锁，保护信号量其他成员 unsigned int count; // 计数值，允许多少个进程进入临界区 struct list_head wait_list; // 等待进入临界区进程链表 }; // 获取信号量 void down(struct semaphore *sem); int down_interruptible(struct semaphore *sem); int down_killable(struct semaphore *sem); int down_trylock(struct semaphore *sem); int down_timeout(struct semaphore *sem, long jiffies); // 释放信号量函数 void up(struct semaphore *sem); 5.2 读写信号量 读写信号量,适合在以读为主\n// include/linux/rwsem.h struct rw_semaphore { atomic_long_t count; struct list_head wait_list; raw_spinlock_t wait_lock; struct task_struct *owner; … }; 初始化，使用\n// 初始化静态读写信号量 DECLARE_RWSEM(name); // 运行时动态初始化读写信号量 init_rwsem(sem); // 申请读锁 void down_read(struct rw_semaphore *sem)； int down_read_trylock(struct rw_semaphore *sem)； // 释放读锁 void up_read(struct rw_semaphore *sem); // 申请写锁 void down_write(struct rw_semaphore *sem); int down_write_killable(struct rw_semaphore *sem); int down_write_trylock(struct rw_semaphore *sem); // 写锁降级为读锁 void downgrade_write(struct rw_semaphore *sem); // 释放写锁 void up_write(struct rw_semaphore *sem); 5.3 互斥锁 互斥锁只允许一个进程进入临界区，适合保护比较长的临界区\n// include/linux/mutex.h struct mutex { atomic_long_t owner; spinlock_t wait_lock; #ifdef CONFIG_MUTEX_SPIN_ON_OWNER struct optimistic_spin_queue osq; #endif struct list_head wait_list; … }; 使用互斥锁\n// 初始化静态互斥锁 DEFINE_MUTEX(mutexname); // 运行时动态初始化互斥锁 mutex_init(mutex); // 申请互斥锁 void mutex_lock(struct mutex *lock); int mutex_lock_interruptible(struct mutex *lock); int mutex_lock_killable(struct mutex *lock); int mutex_trylock(struct mutex *lock); // 释放互斥锁 void mutex_unlock(struct mutex *lock); 5.4 实时互斥锁 实时互斥锁是对互斥锁的改进，实现了优先级继承(priority inheritance)，解决了优先级反转(priority inversion)问题\n// include/linux/rtmutex.h struct rt_mutex { raw_spinlock_t wait_lock; struct rb_root waiters; struct rb_node *waiters_leftmost; struct task_struct *owner; … }; 初始化，使用\n// 初始化静态实时互斥锁 DEFINE_RT_MUTEX(mutexname); // 运行时动态初始化实时互斥锁 rt_mutex_init(mutex); // 申请实时互斥锁 void rt_mutex_lock(struct rt_mutex *lock); int rt_mutex_lock_interruptible(struct rt_mutex *lock); int rt_mutex_timed_lock(struct rt_mutex *lock, struct hrtimer_sleeper *timeout); int rt_mutex_trylock(struct rt_mutex *lock); // 释放实时互斥锁 void rt_mutex_unlock(struct rt_mutex *lock); 5.5 原子变量 原子变量用来实现对整数的互斥访问，通常用来实现计数器 内核定义了3种原子变量\n// 整数原子变量，数据类型是atomic_t // include/linux/types.h typedef struct { int counter; } atomic_t; // 长整数原子变量，数据类型是atomic_long_t // 64位整数原子变量，数据类型是atomic64_t 原子变量使用方法\n// 初始化静态原子变量 atomic_t \u003cname\u003e = ATOMINC_INIT(n); // 动态初始化原子变量 atomic_set(v, i); // 读取原子变量 atomic_read(v) // 原子变量加i，并返回 atomic_add_return(i, v) // 原子变量v加i atomic_add(i, v) // 原子变量加1 atomic_inc(v) // 原子变量v减i atomic_sub(i, v) // 原子变量减1 atomic_dec(v) ARM64处理器的原子变量实现 ARM64处理器原子变量指令支持 (1)独占加载指令ldxr (load Exclusive Register) (2)独占存储指令stxr (Store Exclusive Register) // 独占加载指令加载32位数据 ldxr \u003cWt\u003e, [\u003cXn|SP\u003e{,#0}] // 独占存储指令存储32位数据 stxr \u003cWs\u003e, \u003cWt\u003e, [\u003cXn|SP\u003e{,#0}] // 原子加法指令stadd操作32位数据 stadd \u003cWs\u003e, [\u003cXn|SP\u003e] 函数atomic_add(i, v)实现\n// arch/arm64/include/asm/atomic_ll_sc.h static inline void atomic_add(int i, atomic_t *v) { unsigned long tmp; int result; asm volatile(\"// atomic_add \\n\" \\ \" prfm pstl1strm, %2\\n\" \\ \"1: ldxr %w0, %2\\n\" \\ \" \" add \" %w0, %w0, %w3\\n\" \\ \" stxr %w1, %w0, %2\\n\" \\ \" cbnz %w1, 1b\" \\ : \"=\u0026r\" (result), \"=\u0026r\" (tmp), \"+Q\" (v-\u003ecounter) \\ : \"Ir\" (i)); } 原子加法指令stadd实现的函数atomic_add(i, v)\n// arch/arm64/include/asm/atomic_lse.h static inline void atomic_add(int i, atomic_t *v) { register int w0 asm (\"w0\") = i; register atomic_t *x1 asm (\"x1\") = v; asm volatile(\" stadd %w[i], %[v]\\n\" \\ : [i] \"+r\" (w0), [v] \"+Q\" (v-\u003ecounter) \\ : \"r\" (x1) \\ : ); } 5.6 自旋锁 自旋锁用于处理器之间的互斥，适合保护很短的临界区，不允许在临界区睡眠\n// include/linux/spinlock_types.h typedef struct spinlock { union { struct raw_spinlock rlock; … }; } spinlock_t; typedef struct raw_spinlock { arch_spinlock_t raw_lock; … } raw_spinlock_t; Linux内核有一个实时内核分支（开启配置宏CONFIG_PREEMPT_RT）来支持硬实时特性，内核主线只支持软实时 数据类型arch_spinlock_t，ARM64架构的定义\n// arch/arm64/include/asm/spinlock_types.h typedef struct { #ifdef __AARCH64EB__ /* 大端字节序（高位存放在低地址） */ u16 next; u16 owner; #else /* 小端字节序（低位存放在低地址） */ u16 owner; u16 next; #endif } __aligned(4) arch_spinlock_t; 自旋锁使用\n// 初始化自旋锁 DEFINE_SPINLOCK(x); // 运行时初始化自旋锁 spin_lock_init(x); // 申请自旋锁 void spin_lock(spinlock_t *lock); void spin_lock_bh(spinlock_t *lock); void spin_lock_irq(spinlock_t *lock); spin_lock_irqsave(lock, flags); int spin_trylock(spinlock_t *lock); // 释放自旋锁 void spin_unlock(spinlock_t *lock); void spin_unlock_bh(spinlock_t *lock); void spin_unlock_irq(spinlock_t *lock); void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags); 原始自旋锁\n// 初始化原始自旋锁 DEFINE_RAW_SPINLOCK(x); // 运行时初始化原始自旋锁 raw_spin_lock_init (x); // 申请原始自旋锁 raw_spin_lock(lock) raw_spin_lock_bh(lock) raw_spin_lock_irq(lock) raw_spin_lock_irqsave(lock, flags) raw_spin_trylock(lock) // 释放原始自旋锁 raw_spin_unlock(lock) raw_spin_unlock_bh(lock) raw_spin_unlock_irq(lock) raw_spin_unlock_irqrestore(lock, flags) 函数spin_lock()负责申请自旋锁\n// spin_lock() -\u003e raw_spin_lock() -\u003e _raw_spin_lock() -\u003e __raw_spin_lock() -\u003e do_raw_spin_lock() -\u003e arch_spin_lock() arch/arm64/include/asm/spinlock.h static inline void arch_spin_lock(arch_spinlock_t *lock) { unsigned int tmp; arch_spinlock_t lockval, newval; asm volatile( ARM64_LSE_ATOMIC_INSN( /* LL/SC */ \" prfm pstl1strm, %3\\n\" \"1: ldaxr %w0, %3\\n\" \" add %w1, %w0, %w5\\n\" \" stxr %w2, %w1, %3\\n\" \" cbnz %w2, 1b\\n\", /* 大系统扩展的原子指令 */ \" mov %w2, %w5\\n\" \" ldadda %w2, %w0, %3\\n\" __nops(3) ) /* 我们得到锁了吗？*/ \" eor %w1, %w0, %w0, ror #16\\n\" \" cbz %w1, 3f\\n\" \" sevl\\n\" \"2: wfe\\n\" \" ldaxrh %w2, %4\\n\" \" eor %w1, %w2, %w0, lsr #16\\n\" \" cbnz %w1, 2b\\n\" /* 得到锁，临界区从这里开始*/ \"3:\" : \"=\u0026r\" (lockval), \"=\u0026r\" (newval), \"=\u0026r\" (tmp), \"+Q\" (*lock) : \"Q\" (lock-\u003eowner), \"I\" (1 \u003c\u003c TICKET_SHIFT) : \"memory\"); } 5.7 读写自旋锁 读写自旋锁(通常简称读写锁)是自旋锁的改进，区分读者和写者，允许多个读者同时进入临界区，读者和写者互斥，写者和写者互斥 // include/linux/rwlock_types.h typedef struct { arch_rwlock_t raw_lock; … } rwlock_t; // arch/arm64/include/asm/spinlock_types.h typedef struct { volatile unsigned int lock; } arch_rwlock_t; 5.8 顺序锁 顺序锁区分读者和写者\n5.8.1　完整版的顺序锁 顺序锁区分读者和写者\n// include/linux/seqlock.h typedef struct { struct seqcount seqcount; // 序列号 spinlock_t lock; // 自旋锁 } seqlock_t; 5.8.2　只提供序列号的顺序锁 5.9　禁止内核抢占 每个进程的thread_info结构体有一个抢占计数器：“int preempt_count”，其中第0～7位是抢占计数，第8～15位是软中断计数，第16～19位是硬中断计数，第20位是不可屏蔽中断计数 // 禁止内核抢占的编程接口 preempt_disable() // 开启内核抢占的编程接口 preempt_enable() 申请自旋锁的函数包含了禁止内核抢占\nspin_lock() -\u003e raw_spin_lock() -\u003e _raw_spin_lock() -\u003e __raw_spin_lock() // include/linux/spinlock_api_smp.h static inline void __raw_spin_lock(raw_spinlock_t *lock) { preempt_disable(); … LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); } 释放自旋锁的函数包含了开启内核抢占\nspin_unlock() -\u003e raw_spin_unlock() -\u003e _raw_spin_unlock() -\u003e __raw_spin_unlock() // include/linux/spinlock_api_smp.h static inline void __raw_spin_unlock(raw_spinlock_t *lock) { … do_raw_spin_unlock(lock); preempt_enable(); } 5.10　进程和软中断互斥 每个进程的thread_info结构体有一个抢占计数器“int preempt_count”，其中第8～15位是软中断计数 // 禁止软中断的接口 local_bh_disable() // 开启软中断的接口 local_bh_enable() 5.11　进程和硬中断互斥 进程和硬中断可能访问同一个对象，那么进程和硬中断需要互斥，进程需要禁止硬中断 // 禁止硬中断的接口 local_irq_disable() local_irq_save(flags) // 开启硬中断接口 local_irq_enable() local_irq_restore(flags) 5.12　每处理器变量 多处理器系统中，每处理器变量为每个处理器生成一个变量的副本 每处理器变量分为静态和动态两种 5.12.1　静态每处理器变量 5.12.2　动态每处理器变量 5.12.3　访问每处理器变量 5.13　每处理器计数器 原子变量作为计数器\n// include/linux/percpu_counter.h struct percpu_counter { raw_spinlock_t lock; s64 count; … s32 __percpu *counters; }; 5.14　内存屏障 内存屏障（memory barrier）是一种保证内存访问顺序的方法，解决内存访问乱序问题 (1) (2) (3) 内核支持3种内存屏障 (1)编译器屏障 (2)处理器内存屏障 (3)内存映射I/O (Memory Mapping I/O MMIO)写屏障 5.14.1　编译器屏障 编译器屏障\nbarrier(); /// GCC编译器定义的宏“barrier() // include/linux/compiler-gcc.h #define barrier() __asm__ __volatile__(\"\": : :\"memory\") 5.14.2　处理器内存屏障 处理器内存屏障用来解决处理器之间的内存访问乱序问题和处理器访问外围设备的乱序问题 内存屏障类型 强制性内存屏障 SMP内存屏障 通用内存屏障 mb() smp_mb() 写内存屏障 wmb() smp_wmb() 读内存屏障 rmb() smp_rmb() 数据依赖屏障 read_barrier_depends() smp_read_barrier_depends() 5.14.3 MMIO写屏障 // 内核为内存映射I/O写操作提供了一个特殊的屏障 mmiowb(); 5.14.4　隐含内存屏障 内核的有些函数隐含内存屏障 （1）获取和释放函数。 （2）中断禁止函数。 5.14.5　ARM64处理器内存屏障 ARM64处理器提供了3种内存屏障 (1)指令同步屏障(Instruction Synchronization Barrier ISB),指令是isb (2)数据内存屏障(Data Memory Barrier DMB)，指令是dmb (3)数据同步屏障(Data Synchronization Barrier DSb)，指令是dsb 5.15　RCU RCU(Read-Copy Update)读-复制更新 5.15.2　技术原理 5.16　可睡眠RCU 5.17　死锁检测工具lockdep 死锁有以下4种情况 1）进程重复申请同一个锁，称为AA死锁 2）进程申请自旋锁时没有禁止硬中断，进程获取自旋锁以后，硬中断抢占，申请同一个自旋锁 3）两个进程都要获取锁L1和L2，进程1持有锁L1，再去获取锁L2，如果这个时候进程2持有锁L2并且正在尝试获取锁L1，那么进程1和进程2就会死锁，称为AB-BA死锁 4）在一个处理器上进程1持有锁L1，再去获取锁L2，在另一个处理器上进程2持有锁L2，硬中断抢占进程2以后获取锁L1 5.17.1　使用方法 死锁检测工具lockdep的配置宏\n5.17.2　技术原理 第6章 文件系统 6.1　概述 Linux系统中，一切皆文件 Linux文件系统的架构 6.1.1　用户空间层面 应用程序可以直接使用内核提供的系统调用访问文件\n// 挂载文件系统 mount // 卸载目录下挂载的文件系统 umount // 打开文件 open // 关闭文件 close // 写文件 write // 设置文件偏移 lseek // 文件修改过的属性和数据立即写到存储设备 fsync glibc库封装的标准I/O流函数访问文件\n// 打开流 fopen // 关闭流 fclose // 读流 fread // 写流 fwrite // 设置文件偏移 fseek // 冲刷流 fflush 6.1.2　硬件层面 外部存储设备分为块设备、闪存和NVDIMM设备3类 闪存按存储结构分为NAND闪存和NOR闪存 6.1.3　内核空间层面 使不同的文件系统实现能够共存，内核实现了一个抽象层，称为虚拟文件系统（Virtual File System，VFS），也称为虚拟文件系统切换（Virtual Filesystem Switch，VFS） 文件系统分为以下4种 ",
  "wordCount" : "65650",
  "inLanguage": "en",
  "datePublished": "2022-10-05T00:17:58+08:00",
  "dateModified": "2022-10-05T00:17:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Zain"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zain's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://liuz0123.gitee.io/zain/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://liuz0123.gitee.io/zain/" accesskey="h" title="Zain&#39;s Blog (Alt + H)">
            <img src="https://liuz0123.gitee.io/zain/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">Zain&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://liuz0123.gitee.io/zain/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/links" title="🤝 闲言俗语">
                <span>🤝 闲言俗语</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://liuz0123.gitee.io/zain/">主页</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                Linux内核深度解析
            </h1>
            <div class="post-meta">Create:&nbsp;<span title='2022-10-05 00:17:58 +0800 CST'>2022-10-05</span>&nbsp;|&nbsp;Update:&nbsp;2022-10-05&nbsp;|&nbsp;Words:&nbsp;65650&nbsp;|&nbsp;&nbsp;132 min&nbsp;|&nbsp;
&nbsp;Zain



                &nbsp;|&nbsp;tags: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://liuz0123.gitee.io/zain/tags/tech/">tech</a>
                    <a href="https://liuz0123.gitee.io/zain/tags/linux/">、linux</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| Viewers: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%86%85%e5%ae%b9%e6%8f%90%e7%ba%b2" aria-label="内容提纲">内容提纲</a></li>
                <li>
                    <a href="#%e7%ac%ac1%e7%ab%a0-%e5%86%85%e6%a0%b8%e5%bc%95%e5%af%bc%e5%92%8c%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="第1章 内核引导和初始化">第1章 内核引导和初始化</a><ul>
                        
                <li>
                    <a href="#11-%e5%bc%95%e5%af%bc%e7%a8%8b%e5%ba%8f" aria-label="1.1 引导程序">1.1 引导程序</a><ul>
                        
                <li>
                    <a href="#111-%e5%85%a5%e5%8f%a3_start" aria-label="1.1.1 入口_start">1.1.1 入口_start</a></li>
                <li>
                    <a href="#112-reset" aria-label="1.1.2 reset">1.1.2 <code>reset</code></a></li>
                <li>
                    <a href="#113-%e5%87%bd%e6%95%b0_main" aria-label="1.1.3 函数_main">1.1.3 函数_main</a></li>
                <li>
                    <a href="#114-%e5%87%bd%e6%95%b0run_main_loop" aria-label="1.1.4 函数run_main_loop">1.1.4 函数run_main_loop</a></li></ul>
                </li>
                <li>
                    <a href="#12-%e5%86%85%e6%a0%b8%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="1.2 内核初始化">1.2 内核初始化</a><ul>
                        
                <li>
                    <a href="#121-%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86" aria-label="1.2.1 汇编语言部分">1.2.1 汇编语言部分</a></li>
                <li>
                    <a href="#122-c%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86" aria-label="1.2.2 C语言部分">1.2.2 C语言部分</a></li>
                <li>
                    <a href="#123-smp%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%bc%95%e5%af%bc" aria-label="1.2.3 SMP系统的引导">1.2.3 SMP系统的引导</a></li></ul>
                </li>
                <li>
                    <a href="#13-init%e8%bf%9b%e7%a8%8b" aria-label="1.3 init进程">1.3 init进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac2%e7%ab%a0-%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86" aria-label="第2章 进程管理">第2章 进程管理</a><ul>
                        
                <li>
                    <a href="#21-%e8%bf%9b%e7%a8%8b" aria-label="2.1 进程">2.1 进程</a></li>
                <li>
                    <a href="#22-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="2.2 命名空间">2.2 命名空间</a></li>
                <li>
                    <a href="#23-%e8%bf%9b%e7%a8%8b%e6%a0%87%e8%af%86%e7%ac%a6" aria-label="2.3 进程标识符">2.3 进程标识符</a></li>
                <li>
                    <a href="#24-%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb" aria-label="2.4 进程关系">2.4 进程关系</a></li>
                <li>
                    <a href="#25-%e5%90%af%e5%8a%a8%e7%a8%8b%e5%ba%8f" aria-label="2.5 启动程序">2.5 启动程序</a><ul>
                        
                <li>
                    <a href="#251%e5%88%9b%e5%bb%ba%e6%96%b0%e8%bf%9b%e7%a8%8b" aria-label="2.5.1　创建新进程">2.5.1　创建新进程</a><ul>
                        
                <li>
                    <a href="#1-_do_fork%e5%87%bd%e6%95%b0" aria-label="1. _do_fork函数">1. _do_fork函数</a></li>
                <li>
                    <a href="#2-copy_process%e5%87%bd%e6%95%b0" aria-label="2. copy_process函数">2. copy_process函数</a></li>
                <li>
                    <a href="#3%e5%94%a4%e9%86%92%e6%96%b0%e8%bf%9b%e7%a8%8b" aria-label="3.唤醒新进程">3.唤醒新进程</a></li>
                <li>
                    <a href="#4%e6%96%b0%e8%bf%9b%e7%a8%8b%e7%ac%ac%e4%b8%80%e6%ac%a1%e8%bf%90%e8%a1%8c" aria-label="4.新进程第一次运行">4.新进程第一次运行</a></li></ul>
                </li>
                <li>
                    <a href="#252-%e8%a3%85%e8%bd%bd%e7%a8%8b%e5%ba%8f" aria-label="2.5.2 装载程序">2.5.2 装载程序</a><ul>
                        
                <li>
                    <a href="#1%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%a0%bc%e5%bc%8f" aria-label="1.二进制格式">1.二进制格式</a></li>
                <li>
                    <a href="#2%e8%a3%85%e8%bd%bdelf%e7%a8%8b%e5%ba%8f" aria-label="2.装载ELF程序">2.装载ELF程序</a></li>
                <li>
                    <a href="#3%e8%a3%85%e8%bd%bd%e8%84%9a%e6%9c%ac%e7%a8%8b%e5%ba%8f" aria-label="3.装载脚本程序">3.装载脚本程序</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#26-%e8%bf%9b%e7%a8%8b%e9%80%80%e5%87%ba" aria-label="2.6 进程退出">2.6 进程退出</a><ul>
                        
                <li>
                    <a href="#261-%e7%ba%bf%e7%a8%8b%e7%bb%84%e9%80%80%e5%87%ba-exit_group" aria-label="2.6.1 线程组退出 exit_group">2.6.1 线程组退出 exit_group</a></li>
                <li>
                    <a href="#262-%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b" aria-label="2.6.2 终止进程">2.6.2 终止进程</a></li>
                <li>
                    <a href="#263-%e6%9f%a5%e8%af%a2%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%bb%88%e6%ad%a2%e5%8e%9f%e5%9b%a0" aria-label="2.6.3 查询子进程终止原因">2.6.3 查询子进程终止原因</a></li></ul>
                </li>
                <li>
                    <a href="#27-%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81" aria-label="2.7 进程状态">2.7 进程状态</a></li>
                <li>
                    <a href="#28-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6" aria-label="2.8 进程调度">2.8 进程调度</a><ul>
                        
                <li>
                    <a href="#281-%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5" aria-label="2.8.1 调度策略">2.8.1 调度策略</a></li>
                <li>
                    <a href="#282-%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7" aria-label="2.8.2 进程优先级">2.8.2 进程优先级</a></li>
                <li>
                    <a href="#283-%e8%b0%83%e5%ba%a6%e7%b1%bb" aria-label="2.8.3 调度类">2.8.3 调度类</a></li>
                <li>
                    <a href="#284-%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97" aria-label="2.8.4 运行队列">2.8.4 运行队列</a></li>
                <li>
                    <a href="#285-%e4%bb%bb%e5%8a%a1%e5%88%86%e7%bb%84" aria-label="2.8.5 任务分组">2.8.5 任务分组</a><ul>
                        
                <li>
                    <a href="#1%e4%bb%bb%e5%8a%a1%e5%88%86%e7%bb%84%e6%96%b9%e5%bc%8f" aria-label="1.任务分组方式">1.任务分组方式</a></li>
                <li>
                    <a href="#2-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="2. 数据结构">2. 数据结构</a></li></ul>
                </li>
                <li>
                    <a href="#286-%e8%b0%83%e5%ba%a6%e8%bf%9b%e7%a8%8b" aria-label="2.8.6 调度进程">2.8.6 调度进程</a><ul>
                        
                <li>
                    <a href="#1%e9%80%89%e6%8b%a9%e4%b8%8b%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b-%e5%87%bd%e6%95%b0pick_next_task" aria-label="1.选择下一个进程 函数pick_next_task">1.选择下一个进程 函数pick_next_task</a></li>
                <li>
                    <a href="#2%e5%88%87%e6%8d%a2%e8%bf%9b%e7%a8%8b-context_switch" aria-label="2.切换进程 context_switch">2.切换进程 context_switch</a></li></ul>
                </li>
                <li>
                    <a href="#287-%e8%b0%83%e5%ba%a6%e6%97%b6%e6%9c%ba" aria-label="2.8.7 调度时机">2.8.7 调度时机</a><ul>
                        
                <li>
                    <a href="#1%e4%b8%bb%e5%8a%a8%e8%b0%83%e5%ba%a6" aria-label="1.主动调度">1.主动调度</a></li>
                <li>
                    <a href="#2%e5%91%a8%e6%9c%9f%e8%b0%83%e5%ba%a6" aria-label="2.周期调度">2.周期调度</a></li>
                <li>
                    <a href="#3%e5%94%a4%e9%86%92%e8%bf%9b%e7%a8%8b%e6%97%b6%e6%8a%a2%e5%8d%a0" aria-label="3.唤醒进程时抢占">3.唤醒进程时抢占</a></li>
                <li>
                    <a href="#4%e5%88%9b%e5%bb%ba%e6%96%b0%e8%bf%9b%e7%a8%8b%e6%97%b6%e6%8a%a2%e5%8d%a0" aria-label="4.创建新进程时抢占">4.创建新进程时抢占</a></li>
                <li>
                    <a href="#5%e5%86%85%e6%a0%b8%e6%8a%a2%e5%8d%a0" aria-label="5.内核抢占">5.内核抢占</a></li>
                <li>
                    <a href="#6%e9%ab%98%e7%b2%be%e5%ba%a6%e8%b0%83%e5%ba%a6%e6%97%b6%e9%92%9f" aria-label="6.高精度调度时钟">6.高精度调度时钟</a></li></ul>
                </li>
                <li>
                    <a href="#288-%e5%b8%a6%e5%ae%bd%e7%ae%a1%e7%90%86" aria-label="2.8.8 带宽管理">2.8.8 带宽管理</a><ul>
                        
                <li>
                    <a href="#1%e9%99%90%e6%9c%9f%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%b8%a6%e6%a1%86%e7%ae%a1%e7%90%86" aria-label="1.限期调度类的带框管理">1.限期调度类的带框管理</a></li>
                <li>
                    <a href="#2%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%b8%a6%e5%ae%bd%e7%ae%a1%e7%90%86" aria-label="2.实时调度类的带宽管理">2.实时调度类的带宽管理</a></li>
                <li>
                    <a href="#3%e5%85%ac%e5%b9%b3%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%b8%a6%e5%ae%bd%e7%ae%a1%e7%90%86" aria-label="3.公平调度类的带宽管理">3.公平调度类的带宽管理</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#29-smp%e8%b0%83%e5%ba%a6" aria-label="2.9 SMP调度">2.9 SMP调度</a><ul>
                        
                <li>
                    <a href="#291-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e4%ba%b2%e5%92%8c%e6%80%a7" aria-label="2.9.1 进程的处理器亲和性">2.9.1 进程的处理器亲和性</a><ul>
                        
                <li>
                    <a href="#1%e5%ba%94%e7%94%a8%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="1.应用编程接口">1.应用编程接口</a></li>
                <li>
                    <a href="#2%e4%bd%bf%e7%94%a8cpuset%e9%85%8d%e7%bd%ae" aria-label="2.使用cpuset配置">2.使用cpuset配置</a></li></ul>
                </li>
                <li>
                    <a href="#292-%e5%af%b9%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e6%89%a9%e5%b1%95" aria-label="2.9.2 对调度器的扩展">2.9.2 对调度器的扩展</a></li>
                <li>
                    <a href="#293-%e9%99%90%e6%9c%9f%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="2.9.3 限期调度类的处理器负载均衡">2.9.3 限期调度类的处理器负载均衡</a></li>
                <li>
                    <a href="#294-%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="2.9.4 实时调度类的处理器负载均衡">2.9.4 实时调度类的处理器负载均衡</a></li>
                <li>
                    <a href="#295-%e5%85%ac%e5%b9%b3%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="2.9.5 公平调度类的处理器负载均衡">2.9.5 公平调度类的处理器负载均衡</a></li>
                <li>
                    <a href="#296-%e8%bf%81%e7%a7%bb%e7%ba%bf%e7%a8%8b" aria-label="2.9.6 迁移线程">2.9.6 迁移线程</a></li>
                <li>
                    <a href="#297-%e9%9a%94%e7%a6%bb%e5%a4%84%e7%90%86%e5%99%a8" aria-label="2.9.7 隔离处理器">2.9.7 隔离处理器</a></li></ul>
                </li>
                <li>
                    <a href="#210-%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%ae%89%e5%85%a8" aria-label="2.10 进程的上下文安全">2.10 进程的上下文安全</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac3%e7%ab%a0-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="第3章 内存管理">第3章 内存管理</a><ul>
                        
                <li>
                    <a href="#31-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%ad%90%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" aria-label="3.1 内存管理子系统架构">3.1 内存管理子系统架构</a><ul>
                        <ul>
                        
                <li>
                    <a href="#1%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4" aria-label="1.用户空间">1.用户空间</a></li>
                <li>
                    <a href="#2%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4" aria-label="2.内核空间">2.内核空间</a></li>
                <li>
                    <a href="#3%e7%a1%ac%e4%bb%b6%e5%b1%82%e9%9d%a2" aria-label="3.硬件层面">3.硬件层面</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#32-%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80" aria-label="3.2 虚拟地址空间布局">3.2 虚拟地址空间布局</a><ul>
                        
                <li>
                    <a href="#321-%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%88%92%e5%88%86" aria-label="3.2.1 虚拟地址空间划分">3.2.1 虚拟地址空间划分</a></li>
                <li>
                    <a href="#322-%e7%94%a8%e6%88%b7%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80" aria-label="3.2.2 用户虚拟地址空间布局">3.2.2 用户虚拟地址空间布局</a></li>
                <li>
                    <a href="#323-%e5%86%85%e6%a0%b8%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80" aria-label="3.2.3 内核地址空间布局">3.2.3 内核地址空间布局</a></li></ul>
                </li>
                <li>
                    <a href="#33-%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" aria-label="3.3 物理地址空间">3.3 物理地址空间</a></li>
                <li>
                    <a href="#34%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84" aria-label="3.4　内存映射">3.4　内存映射</a><ul>
                        <ul>
                        
                <li>
                    <a href="#341-%e5%ba%94%e7%94%a8%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="3.4.1 应用编程接口">3.4.1 应用编程接口</a></li></ul>
                    
                <li>
                    <a href="#342-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="3.4.2 数据结构">3.4.2 数据结构</a><ul>
                        
                <li>
                    <a href="#1-%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f" aria-label="1. 虚拟内存区域">1. 虚拟内存区域</a></li>
                <li>
                    <a href="#2%e9%93%be%e8%a1%a8%e5%92%8c%e6%a0%91" aria-label="2.链表和树">2.链表和树</a></li></ul>
                </li>
                <li>
                    <a href="#343-%e5%88%9b%e5%bb%ba%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84" aria-label="3.4.3 创建内存映射">3.4.3 创建内存映射</a></li>
                <li>
                    <a href="#344-%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e8%bf%87%e9%87%8f%e6%8f%90%e4%ba%a4%e7%ad%96%e7%95%a5" aria-label="3.4.4 虚拟内存过量提交策略">3.4.4 虚拟内存过量提交策略</a></li>
                <li>
                    <a href="#345-%e5%88%a0%e9%99%a4%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84" aria-label="3.4.5 删除内存映射">3.4.5 删除内存映射</a></li></ul>
                </li>
                <li>
                    <a href="#35-%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e7%bb%84%e7%bb%87" aria-label="3.5 物理内存组织">3.5 物理内存组织</a><ul>
                        
                <li>
                    <a href="#351-%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" aria-label="3.5.1 体系结构">3.5.1 体系结构</a></li>
                <li>
                    <a href="#352-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" aria-label="3.5.2 内存模型">3.5.2 内存模型</a></li>
                <li>
                    <a href="#353-%e4%b8%89%e7%ba%a7%e7%bb%93%e6%9e%84" aria-label="3.5.3 三级结构">3.5.3 三级结构</a><ul>
                        
                <li>
                    <a href="#1%e5%86%85%e5%ad%98%e8%8a%82%e7%82%b9" aria-label="1.内存节点">1.内存节点</a></li>
                <li>
                    <a href="#2%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f" aria-label="2.内存区域">2.内存区域</a></li>
                <li>
                    <a href="#3%e7%89%a9%e7%90%86%e9%a1%b5" aria-label="3.物理页">3.物理页</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#36-%e5%bc%95%e5%af%bc%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.6 引导内存分配器">3.6 引导内存分配器</a><ul>
                        
                <li>
                    <a href="#361-bootmem%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.6.1 bootmem分配器">3.6.1 bootmem分配器</a></li>
                <li>
                    <a href="#362-memblock%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.6.2 memblock分配器">3.6.2 memblock分配器</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="1.数据结构">1.数据结构</a></li>
                <li>
                    <a href="#2%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="2.初始化">2.初始化</a></li>
                <li>
                    <a href="#3%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="3.编程接口">3.编程接口</a></li>
                <li>
                    <a href="#4%e7%ae%97%e6%b3%95" aria-label="4.算法">4.算法</a></li></ul>
                </li>
                <li>
                    <a href="#363-%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%bf%a1%e6%81%af" aria-label="3.6.3 物理内存信息">3.6.3 物理内存信息</a></li></ul>
                </li>
                <li>
                    <a href="#37-%e4%bc%99%e4%bc%b4%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.7 伙伴分配器">3.7 伙伴分配器</a><ul>
                        
                <li>
                    <a href="#371-%e5%9f%ba%e6%9c%ac%e7%9a%84%e4%bc%99%e4%bc%b4%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.7.1 基本的伙伴分配器">3.7.1 基本的伙伴分配器</a></li>
                <li>
                    <a href="#372-%e5%88%86%e5%8c%ba%e7%9a%84%e4%bc%99%e4%bc%b4%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.7.2 分区的伙伴分配器">3.7.2 分区的伙伴分配器</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-1" aria-label="1.数据结构">1.数据结构</a></li>
                <li>
                    <a href="#2%e6%a0%b9%e6%8d%ae%e5%88%86%e9%85%8d%e6%a0%87%e5%bf%97%e5%be%97%e5%88%b0%e9%a6%96%e9%80%89%e5%8c%ba%e5%9f%9f%e7%b1%bb%e5%9e%8b" aria-label="2．根据分配标志得到首选区域类型">2．根据分配标志得到首选区域类型</a></li>
                <li>
                    <a href="#3-%e5%a4%87%e7%94%a8%e5%8c%ba%e5%9f%9f%e5%88%97%e8%a1%a8" aria-label="3. 备用区域列表">3. 备用区域列表</a></li>
                <li>
                    <a href="#4%e5%8c%ba%e5%9f%9f%e6%b0%b4%e7%ba%bf" aria-label="4．区域水线">4．区域水线</a></li>
                <li>
                    <a href="#5%e9%98%b2%e6%ad%a2%e8%bf%87%e5%ba%a6%e5%80%9f%e7%94%a8" aria-label="5．防止过度借用">5．防止过度借用</a></li></ul>
                </li>
                <li>
                    <a href="#373%e6%a0%b9%e6%8d%ae%e5%8f%af%e7%a7%bb%e5%8a%a8%e6%80%a7%e5%88%86%e7%bb%84" aria-label="3.7.3　根据可移动性分组">3.7.3　根据可移动性分组</a></li>
                <li>
                    <a href="#374%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e9%a1%b5%e9%9b%86%e5%90%88" aria-label="3.7.4　每处理器页集合">3.7.4　每处理器页集合</a></li>
                <li>
                    <a href="#375%e5%88%86%e9%85%8d%e9%a1%b5" aria-label="3.7.5　分配页">3.7.5　分配页</a><ul>
                        
                <li>
                    <a href="#1%e5%88%86%e9%85%8d%e6%8e%a5%e5%8f%a3" aria-label="1．分配接口">1．分配接口</a></li>
                <li>
                    <a href="#2%e5%88%86%e9%85%8d%e6%a0%87%e5%bf%97%e4%bd%8d" aria-label="2．分配标志位">2．分配标志位</a></li>
                <li>
                    <a href="#3%e5%a4%8d%e5%90%88%e9%a1%b5" aria-label="3．复合页">3．复合页</a></li>
                <li>
                    <a href="#4%e5%af%b9%e9%ab%98%e9%98%b6%e5%8e%9f%e5%ad%90%e5%88%86%e9%85%8d%e7%9a%84%e4%bc%98%e5%8c%96%e5%a4%84%e7%90%86" aria-label="4．对高阶原子分配的优化处理">4．对高阶原子分配的优化处理</a></li>
                <li>
                    <a href="#5%e6%a0%b8%e5%bf%83%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="5．核心函数的实现">5．核心函数的实现</a></li></ul>
                </li>
                <li>
                    <a href="#376%e9%87%8a%e6%94%be%e9%a1%b5" aria-label="3.7.6　释放页">3.7.6　释放页</a></li></ul>
                </li>
                <li>
                    <a href="#38%e5%9d%97%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.8　块分配器">3.8　块分配器</a><ul>
                        
                <li>
                    <a href="#381-%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="3.8.1 编程接口">3.8.1 编程接口</a></li>
                <li>
                    <a href="#382-slab%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.8.2 SLAB分配器">3.8.2 SLAB分配器</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-2" aria-label="1.数据结构">1.数据结构</a></li>
                <li>
                    <a href="#2%e7%a9%ba%e9%97%b2%e5%af%b9%e8%b1%a1%e9%93%be%e8%a1%a8" aria-label="2.空闲对象链表">2.空闲对象链表</a></li>
                <li>
                    <a href="#3%e8%ae%a1%e7%ae%97slab%e9%95%bf%e5%ba%a6" aria-label="3.计算slab长度">3.计算slab长度</a></li>
                <li>
                    <a href="#4%e7%9d%80%e8%89%b2" aria-label="4.着色">4.着色</a></li>
                <li>
                    <a href="#5%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e6%95%b0%e7%bb%84%e7%bc%93%e5%ad%98" aria-label="5．每处理器数组缓存">5．每处理器数组缓存</a></li>
                <li>
                    <a href="#6%e5%af%b9numa%e7%9a%84%e6%94%af%e6%8c%81" aria-label="6．对NUMA的支持">6．对NUMA的支持</a></li>
                <li>
                    <a href="#7%e5%86%85%e5%ad%98%e7%bc%93%e5%ad%98%e5%90%88%e5%b9%b6" aria-label="7．内存缓存合并">7．内存缓存合并</a></li>
                <li>
                    <a href="#8%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98" aria-label="8.回收内存">8.回收内存</a></li></ul>
                </li>
                <li>
                    <a href="#383slub%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.8.3　SLUB分配器">3.8.3　SLUB分配器</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-3" aria-label="1．数据结构">1．数据结构</a></li>
                <li>
                    <a href="#2%e7%a9%ba%e9%97%b2%e5%af%b9%e8%b1%a1%e9%93%be%e8%a1%a8-1" aria-label="2．空闲对象链表">2．空闲对象链表</a></li>
                <li>
                    <a href="#3%e8%ae%a1%e7%ae%97slab%e9%95%bf%e5%ba%a6-1" aria-label="3．计算slab长度">3．计算slab长度</a></li>
                <li>
                    <a href="#4%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8slab%e7%bc%93%e5%ad%98" aria-label="4．每处理器slab缓存">4．每处理器slab缓存</a></li>
                <li>
                    <a href="#5%e5%af%b9numa%e7%9a%84%e6%94%af%e6%8c%81" aria-label="5．对NUMA的支持">5．对NUMA的支持</a></li>
                <li>
                    <a href="#6%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98" aria-label="6.回收内存">6.回收内存</a></li>
                <li>
                    <a href="#7%e8%b0%83%e8%af%95" aria-label="7.调试">7.调试</a></li></ul>
                </li>
                <li>
                    <a href="#384slob%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.8.4　SLOB分配器">3.8.4　SLOB分配器</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-4" aria-label="1．数据结构">1．数据结构</a></li>
                <li>
                    <a href="#2%e7%a9%ba%e9%97%b2%e5%af%b9%e8%b1%a1%e9%93%be%e8%a1%a8-2" aria-label="2．空闲对象链表">2．空闲对象链表</a></li>
                <li>
                    <a href="#3%e5%88%86%e9%85%8d%e5%af%b9%e8%b1%a1" aria-label="3．分配对象">3．分配对象</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#39%e4%b8%8d%e8%bf%9e%e7%bb%ad%e9%a1%b5%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.9　不连续页分配器">3.9　不连续页分配器</a><ul>
                        
                <li>
                    <a href="#391%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="3.9.1　编程接口">3.9.1　编程接口</a></li>
                <li>
                    <a href="#392%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="3.9.2　数据结构">3.9.2　数据结构</a></li>
                <li>
                    <a href="#393%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="3.9.3　技术原理">3.9.3　技术原理</a></li></ul>
                </li>
                <li>
                    <a href="#310%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.10　每处理器内存分配器">3.10　每处理器内存分配器</a><ul>
                        
                <li>
                    <a href="#3101%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="3.10.1　编程接口">3.10.1　编程接口</a><ul>
                        
                <li>
                    <a href="#1%e9%9d%99%e6%80%81%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="1.静态每处理器变量">1.静态每处理器变量</a></li>
                <li>
                    <a href="#2%e5%8a%a8%e6%80%81%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="2．动态每处理器变量">2．动态每处理器变量</a></li>
                <li>
                    <a href="#3%e8%ae%bf%e9%97%ae%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="3．访问每处理器变量">3．访问每处理器变量</a></li></ul>
                </li>
                <li>
                    <a href="#3102%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="3.10.2　技术原理">3.10.2　技术原理</a></li></ul>
                </li>
                <li>
                    <a href="#311%e9%a1%b5%e8%a1%a8" aria-label="3.11　页表">3.11　页表</a><ul>
                        
                <li>
                    <a href="#3111%e7%bb%9f%e4%b8%80%e7%9a%84%e9%a1%b5%e8%a1%a8%e6%a1%86%e6%9e%b6" aria-label="3.11.1　统一的页表框架">3.11.1　统一的页表框架</a></li>
                <li>
                    <a href="#3112arm64%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e9%a1%b5%e8%a1%a8" aria-label="3.11.2　ARM64处理器的页表">3.11.2　ARM64处理器的页表</a></li></ul>
                </li>
                <li>
                    <a href="#312%e9%a1%b5%e8%a1%a8%e7%bc%93%e5%ad%98" aria-label="3.12　页表缓存">3.12　页表缓存</a><ul>
                        
                <li>
                    <a href="#3121tlb%e8%a1%a8%e9%a1%b9%e6%a0%bc%e5%bc%8f" aria-label="3.12.1　TLB表项格式">3.12.1　TLB表项格式</a></li>
                <li>
                    <a href="#3122tlb%e7%ae%a1%e7%90%86" aria-label="3.12.2　TLB管理">3.12.2　TLB管理</a></li>
                <li>
                    <a href="#3123%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e6%a0%87%e8%af%86%e7%ac%a6" aria-label="3.12.3　地址空间标识符">3.12.3　地址空间标识符</a></li>
                <li>
                    <a href="#3124%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%87%e8%af%86%e7%ac%a6" aria-label="3.12.4　虚拟机标识符">3.12.4　<strong>虚拟机标识符</strong></a></li></ul>
                </li>
                <li>
                    <a href="#313%e5%b7%a8%e5%9e%8b%e9%a1%b5" aria-label="3.13　巨型页">3.13　巨型页</a><ul>
                        
                <li>
                    <a href="#3131%e5%a4%84%e7%90%86%e5%99%a8%e5%af%b9%e5%b7%a8%e5%9e%8b%e9%a1%b5%e7%9a%84%e6%94%af%e6%8c%81" aria-label="3.13.1　处理器对巨型页的支持">3.13.1　处理器对巨型页的支持</a></li>
                <li>
                    <a href="#3132%e6%a0%87%e5%87%86%e5%b7%a8%e5%9e%8b%e9%a1%b5" aria-label="3.13.2　标准巨型页">3.13.2　标准巨型页</a></li>
                <li>
                    <a href="#3133%e9%80%8f%e6%98%8e%e5%b7%a8%e5%9e%8b%e9%a1%b5" aria-label="3.13.3　透明巨型页">3.13.3　透明巨型页</a></li></ul>
                </li>
                <li>
                    <a href="#314%e9%a1%b5%e9%94%99%e8%af%af%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" aria-label="3.14　页错误异常处理">3.14　页错误异常处理</a><ul>
                        
                <li>
                    <a href="#3141%e5%a4%84%e7%90%86%e5%99%a8%e6%9e%b6%e6%9e%84%e7%89%b9%e5%ae%9a%e9%83%a8%e5%88%86" aria-label="3.14.1　处理器架构特定部分">3.14.1　处理器架构特定部分</a><ul>
                        
                <li>
                    <a href="#1%e7%94%9f%e6%88%90%e9%a1%b5%e9%94%99%e8%af%af%e5%bc%82%e5%b8%b8" aria-label="1.生成页错误异常">1.生成页错误异常</a></li>
                <li>
                    <a href="#2%e5%a4%84%e7%90%86%e9%a1%b5%e9%94%99%e8%af%af%e5%bc%82%e5%b8%b8" aria-label="2.处理页错误异常">2.处理页错误异常</a></li></ul>
                </li>
                <li>
                    <a href="#3142%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e9%a1%b5%e9%94%99%e8%af%af%e5%bc%82%e5%b8%b8" aria-label="3.14.2　用户空间页错误异常">3.14.2　用户空间页错误异常</a><ul>
                        
                <li>
                    <a href="#1%e5%8c%bf%e5%90%8d%e9%a1%b5%e7%9a%84%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8" aria-label="1．匿名页的缺页异常">1．匿名页的缺页异常</a></li>
                <li>
                    <a href="#2%e6%96%87%e4%bb%b6%e9%a1%b5%e7%9a%84%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8" aria-label="2．文件页的缺页异常">2．文件页的缺页异常</a></li>
                <li>
                    <a href="#3%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6" aria-label="3．写时复制">3．写时复制</a></li></ul>
                </li>
                <li>
                    <a href="#3143%e5%86%85%e6%a0%b8%e6%a8%a1%e5%bc%8f%e9%a1%b5%e9%94%99%e8%af%af%e5%bc%82%e5%b8%b8" aria-label="3.14.3　内核模式页错误异常">3.14.3　内核模式页错误异常</a><ul>
                        
                <li>
                    <a href="#1%e5%87%bd%e6%95%b0__do_kernel_fault" aria-label="1.函数__do_kernel_fault">1.函数__do_kernel_fault</a></li>
                <li>
                    <a href="#2%e5%bc%82%e5%b8%b8%e8%a1%a8" aria-label="2.异常表">2.异常表</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#315%e5%8f%8d%e7%a2%8e%e7%89%87%e6%8a%80%e6%9c%af" aria-label="3.15　反碎片技术">3.15　反碎片技术</a><ul>
                        
                <li>
                    <a href="#3151%e8%99%9a%e6%8b%9f%e5%8f%af%e7%a7%bb%e5%8a%a8%e5%8c%ba%e5%9f%9f" aria-label="3.15.1　虚拟可移动区域">3.15.1　虚拟可移动区域</a></li>
                <li>
                    <a href="#3152%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e6%95%b4%e7%90%86" aria-label="3.15.2　内存碎片整理">3.15.2　内存碎片整理</a><ul>
                        
                <li>
                    <a href="#1%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="1.使用方法">1.使用方法</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#316%e9%a1%b5%e5%9b%9e%e6%94%b6" aria-label="3.16　页回收">3.16　页回收</a><ul>
                        
                <li>
                    <a href="#3161%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="3.16.1　数据结构">3.16.1　数据结构</a><ul>
                        
                <li>
                    <a href="#1lru%e9%93%be%e8%a1%a8" aria-label="1．LRU链表">1．LRU链表</a></li></ul>
                </li>
                <li>
                    <a href="#3162%e5%8f%91%e8%b5%b7%e9%a1%b5%e5%9b%9e%e6%94%b6" aria-label="3.16.2　发起页回收">3.16.2　发起页回收</a></li>
                <li>
                    <a href="#3163%e8%ae%a1%e7%ae%97%e6%89%ab%e6%8f%8f%e7%9a%84%e9%a1%b5%e6%95%b0" aria-label="3.16.3　计算扫描的页数">3.16.3　计算扫描的页数</a></li>
                <li>
                    <a href="#3164%e6%94%b6%e7%bc%a9%e6%b4%bb%e5%8a%a8%e9%a1%b5%e9%93%be%e8%a1%a8" aria-label="3.16.4　收缩活动页链表">3.16.4　收缩活动页链表</a></li>
                <li>
                    <a href="#3165%e5%9b%9e%e6%94%b6%e4%b8%8d%e6%b4%bb%e5%8a%a8%e9%a1%b5" aria-label="3.16.5　回收不活动页">3.16.5　回收不活动页</a></li>
                <li>
                    <a href="#3166%e9%a1%b5%e4%ba%a4%e6%8d%a2" aria-label="3.16.6　页交换">3.16.6　页交换</a></li>
                <li>
                    <a href="#3167%e5%9b%9e%e6%94%b6slab%e7%bc%93%e5%ad%98" aria-label="3.16.7　回收slab缓存">3.16.7　回收slab缓存</a></li></ul>
                </li>
                <li>
                    <a href="#317%e5%86%85%e5%ad%98%e8%80%97%e5%b0%bd%e6%9d%80%e6%89%8b" aria-label="3.17　内存耗尽杀手">3.17　内存耗尽杀手</a><ul>
                        
                <li>
                    <a href="#3171%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="3.17.1　使用方法">3.17.1　使用方法</a></li>
                <li>
                    <a href="#3172%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="3.17.2　技术原理">3.17.2　技术原理</a></li></ul>
                </li>
                <li>
                    <a href="#318%e5%86%85%e5%ad%98%e8%b5%84%e6%ba%90%e6%8e%a7%e5%88%b6%e5%99%a8" aria-label="3.18　内存资源控制器">3.18　内存资源控制器</a><ul>
                        
                <li>
                    <a href="#3181%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="3.18.1　使用方法">3.18.1　使用方法</a></li>
                <li>
                    <a href="#3182%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="3.18.2　技术原理">3.18.2　技术原理</a></li></ul>
                </li>
                <li>
                    <a href="#319%e5%a4%84%e7%90%86%e5%99%a8%e7%bc%93%e5%ad%98" aria-label="3.19　处理器缓存">3.19　处理器缓存</a><ul>
                        
                <li>
                    <a href="#3191%e7%bc%93%e5%ad%98%e7%bb%93%e6%9e%84" aria-label="3.19.1　缓存结构">3.19.1　缓存结构</a></li>
                <li>
                    <a href="#3192%e7%bc%93%e5%ad%98%e7%ad%96%e7%95%a5" aria-label="3.19.2　缓存策略">3.19.2　缓存策略</a></li>
                <li>
                    <a href="#3193-%e7%bc%93%e5%ad%98%e7%bb%b4%e6%8a%a4" aria-label="3.19.3 缓存维护">3.19.3 缓存维护</a><ul>
                        
                <li>
                    <a href="#3arm64%e5%a4%84%e7%90%86%e5%99%a8%e7%bc%93%e5%ad%98%e7%bb%b4%e6%8a%a4" aria-label="3.ARM64处理器缓存维护">3.ARM64处理器缓存维护</a></li></ul>
                </li>
                <li>
                    <a href="#3194smp%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="3.19.4　SMP缓存一致性">3.19.4　SMP缓存一致性</a></li></ul>
                </li>
                <li>
                    <a href="#320-%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8" aria-label="3.20 连续内存分配器">3.20 连续内存分配器</a></li>
                <li>
                    <a href="#321-userfaultfd" aria-label="3.21 userfaultfd">3.21 userfaultfd</a></li>
                <li>
                    <a href="#322-%e5%86%85%e5%ad%98%e9%94%99%e8%af%af%e6%a3%80%e6%b5%8b%e5%b7%a5%e5%85%b7kasan" aria-label="3.22 内存错误检测工具KASAN">3.22 内存错误检测工具KASAN</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac4%e7%ab%a0-%e4%b8%ad%e6%96%ad%e5%bc%82%e5%b8%b8%e5%92%8c%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="第4章 中断、异常和系统调用">第4章 中断、异常和系统调用</a><ul>
                        
                <li>
                    <a href="#41-arm64%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" aria-label="4.1 ARM64异常处理">4.1 ARM64异常处理</a><ul>
                        
                <li>
                    <a href="#411-%e5%bc%82%e5%b8%b8%e7%ba%a7%e5%88%ab" aria-label="4.1.1 异常级别">4.1.1 异常级别</a></li>
                <li>
                    <a href="#412-%e5%bc%82%e5%b8%b8%e5%88%86%e7%b1%bb" aria-label="4.1.2 异常分类">4.1.2 异常分类</a></li>
                <li>
                    <a href="#413-%e5%bc%82%e5%b8%b8%e5%90%91%e9%87%8f%e8%a1%a8" aria-label="4.1.3 异常向量表">4.1.3 异常向量表</a></li>
                <li>
                    <a href="#414-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" aria-label="4.1.4 异常处理">4.1.4 异常处理</a></li></ul>
                </li>
                <li>
                    <a href="#42-%e4%b8%ad%e6%96%ad" aria-label="4.2 中断">4.2 中断</a><ul>
                        
                <li>
                    <a href="#421%e4%b8%ad%e6%96%ad%e6%8e%a7%e5%88%b6%e5%99%a8" aria-label="4.2.1　中断控制器">4.2.1　中断控制器</a></li>
                <li>
                    <a href="#422%e4%b8%ad%e6%96%ad%e5%9f%9f" aria-label="4.2.2　中断域">4.2.2　中断域</a><ul>
                        
                <li>
                    <a href="#1%e5%88%9b%e5%bb%ba%e4%b8%ad%e6%96%ad%e5%9f%9f" aria-label="1．创建中断域">1．创建中断域</a></li>
                <li>
                    <a href="#2%e5%88%9b%e5%bb%ba%e6%98%a0%e5%b0%84" aria-label="2．创建映射">2．创建映射</a></li>
                <li>
                    <a href="#3%e6%9f%a5%e6%89%be%e6%98%a0%e5%b0%84" aria-label="3．查找映射">3．查找映射</a></li></ul>
                </li>
                <li>
                    <a href="#423%e4%b8%ad%e6%96%ad%e6%8e%a7%e5%88%b6%e5%99%a8%e9%a9%b1%e5%8a%a8%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="4.2.3　中断控制器驱动初始化">4.2.3　中断控制器驱动初始化</a><ul>
                        
                <li>
                    <a href="#1%e8%ae%be%e5%a4%87%e6%a0%91%e6%ba%90%e6%96%87%e4%bb%b6" aria-label="1．设备树源文件">1．设备树源文件</a></li>
                <li>
                    <a href="#3%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="3.初始化">3.初始化</a></li></ul>
                </li>
                <li>
                    <a href="#424linux%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86" aria-label="4.2.4　Linux中断处理">4.2.4　Linux中断处理</a></li>
                <li>
                    <a href="#425%e4%b8%ad%e6%96%ad%e7%ba%bf%e7%a8%8b%e5%8c%96" aria-label="4.2.5　中断线程化">4.2.5　中断线程化</a></li>
                <li>
                    <a href="#426%e7%a6%81%e6%ad%a2%e5%bc%80%e5%90%af%e4%b8%ad%e6%96%ad" aria-label="4.2.6　禁止/开启中断">4.2.6　禁止/开启中断</a></li>
                <li>
                    <a href="#427%e7%a6%81%e6%ad%a2%e5%bc%80%e5%90%af%e5%8d%95%e4%b8%aa%e4%b8%ad%e6%96%ad" aria-label="4.2.7　禁止/开启单个中断">4.2.7　禁止/开启单个中断</a></li>
                <li>
                    <a href="#428%e4%b8%ad%e6%96%ad%e4%ba%b2%e5%92%8c%e6%80%a7" aria-label="4.2.8　中断亲和性">4.2.8　中断亲和性</a></li>
                <li>
                    <a href="#429%e5%a4%84%e7%90%86%e5%99%a8%e9%97%b4%e4%b8%ad%e6%96%ad" aria-label="4.2.9　处理器间中断">4.2.9　处理器间中断</a></li></ul>
                </li>
                <li>
                    <a href="#43%e4%b8%ad%e6%96%ad%e4%b8%8b%e5%8d%8a%e9%83%a8" aria-label="4.3　中断下半部">4.3　中断下半部</a><ul>
                        
                <li>
                    <a href="#431%e8%bd%af%e4%b8%ad%e6%96%ad" aria-label="4.3.1　软中断">4.3.1　软中断</a><ul>
                        
                <li>
                    <a href="#1%e8%bd%af%e4%b8%ad%e6%96%ad%e7%9a%84%e7%a7%8d%e7%b1%bb" aria-label="1．软中断的种类">1．软中断的种类</a></li>
                <li>
                    <a href="#2%e6%b3%a8%e5%86%8c%e8%bd%af%e4%b8%ad%e6%96%ad%e7%9a%84%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0" aria-label="2．注册软中断的处理函数">2．注册软中断的处理函数</a></li>
                <li>
                    <a href="#3%e8%a7%a6%e5%8f%91%e8%bd%af%e4%b8%ad%e6%96%ad" aria-label="3．触发软中断">3．触发软中断</a></li>
                <li>
                    <a href="#4%e6%89%a7%e8%a1%8c%e8%bd%af%e4%b8%ad%e6%96%ad" aria-label="4.执行软中断">4.执行软中断</a></li>
                <li>
                    <a href="#5%e6%8a%a2%e5%8d%a0%e8%ae%a1%e6%95%b0%e5%99%a8" aria-label="5．抢占计数器">5．抢占计数器</a></li>
                <li>
                    <a href="#6%e7%a6%81%e6%ad%a2%e5%bc%80%e5%90%af%e8%bd%af%e4%b8%ad%e6%96%ad" aria-label="6．禁止/开启软中断">6．禁止/开启软中断</a></li></ul>
                </li>
                <li>
                    <a href="#432-%e5%b0%8f%e4%bb%bb%e5%8a%a1-tasklet" aria-label="4.3.2 小任务 tasklet">4.3.2 小任务 tasklet</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-5" aria-label="1.数据结构">1.数据结构</a></li>
                <li>
                    <a href="#2%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="2．编程接口">2．编程接口</a></li>
                <li>
                    <a href="#3%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="3．技术原理">3．技术原理</a></li></ul>
                </li>
                <li>
                    <a href="#433%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97" aria-label="4.3.3　工作队列">4.3.3　工作队列</a></li></ul>
                </li>
                <li>
                    <a href="#44%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="4.4　系统调用">4.4　系统调用</a><ul>
                        
                <li>
                    <a href="#441-%e5%ae%9a%e4%b9%89%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="4.4.1 定义系统调用">4.4.1 定义系统调用</a></li>
                <li>
                    <a href="#442-%e6%89%a7%e8%a1%8c%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="4.4.2 执行系统调用">4.4.2 执行系统调用</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac5%e7%ab%a0-%e5%86%85%e6%a0%b8%e4%ba%92%e6%96%a5%e6%8a%80%e6%9c%af" aria-label="第5章 内核互斥技术">第5章 内核互斥技术</a><ul>
                        
                <li>
                    <a href="#51-%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="5.1 信号量">5.1 信号量</a></li>
                <li>
                    <a href="#52-%e8%af%bb%e5%86%99%e4%bf%a1%e5%8f%b7%e9%87%8f" aria-label="5.2 读写信号量">5.2 读写信号量</a></li>
                <li>
                    <a href="#53-%e4%ba%92%e6%96%a5%e9%94%81" aria-label="5.3 互斥锁">5.3 互斥锁</a></li>
                <li>
                    <a href="#54-%e5%ae%9e%e6%97%b6%e4%ba%92%e6%96%a5%e9%94%81" aria-label="5.4 实时互斥锁">5.4 实时互斥锁</a></li>
                <li>
                    <a href="#55-%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f" aria-label="5.5 原子变量">5.5 原子变量</a><ul>
                        
                <li>
                    <a href="#arm64%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f%e5%ae%9e%e7%8e%b0" aria-label="ARM64处理器的原子变量实现">ARM64处理器的原子变量实现</a></li></ul>
                </li>
                <li>
                    <a href="#56-%e8%87%aa%e6%97%8b%e9%94%81" aria-label="5.6 自旋锁">5.6 自旋锁</a></li>
                <li>
                    <a href="#57-%e8%af%bb%e5%86%99%e8%87%aa%e6%97%8b%e9%94%81" aria-label="5.7 读写自旋锁">5.7 读写自旋锁</a></li>
                <li>
                    <a href="#58-%e9%a1%ba%e5%ba%8f%e9%94%81" aria-label="5.8 顺序锁">5.8 顺序锁</a><ul>
                        
                <li>
                    <a href="#581%e5%ae%8c%e6%95%b4%e7%89%88%e7%9a%84%e9%a1%ba%e5%ba%8f%e9%94%81" aria-label="5.8.1　完整版的顺序锁">5.8.1　完整版的顺序锁</a></li>
                <li>
                    <a href="#582%e5%8f%aa%e6%8f%90%e4%be%9b%e5%ba%8f%e5%88%97%e5%8f%b7%e7%9a%84%e9%a1%ba%e5%ba%8f%e9%94%81" aria-label="5.8.2　只提供序列号的顺序锁">5.8.2　只提供序列号的顺序锁</a></li></ul>
                </li>
                <li>
                    <a href="#59%e7%a6%81%e6%ad%a2%e5%86%85%e6%a0%b8%e6%8a%a2%e5%8d%a0" aria-label="5.9　禁止内核抢占">5.9　禁止内核抢占</a></li>
                <li>
                    <a href="#510%e8%bf%9b%e7%a8%8b%e5%92%8c%e8%bd%af%e4%b8%ad%e6%96%ad%e4%ba%92%e6%96%a5" aria-label="5.10　进程和软中断互斥">5.10　进程和软中断互斥</a></li>
                <li>
                    <a href="#511%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%a1%ac%e4%b8%ad%e6%96%ad%e4%ba%92%e6%96%a5" aria-label="5.11　进程和硬中断互斥">5.11　进程和硬中断互斥</a></li>
                <li>
                    <a href="#512%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="5.12　每处理器变量">5.12　每处理器变量</a><ul>
                        
                <li>
                    <a href="#5121%e9%9d%99%e6%80%81%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="5.12.1　静态每处理器变量">5.12.1　静态每处理器变量</a></li>
                <li>
                    <a href="#5122%e5%8a%a8%e6%80%81%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="5.12.2　动态每处理器变量">5.12.2　动态每处理器变量</a></li>
                <li>
                    <a href="#5123%e8%ae%bf%e9%97%ae%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%98%e9%87%8f" aria-label="5.12.3　访问每处理器变量">5.12.3　访问每处理器变量</a></li></ul>
                </li>
                <li>
                    <a href="#513%e6%af%8f%e5%a4%84%e7%90%86%e5%99%a8%e8%ae%a1%e6%95%b0%e5%99%a8" aria-label="5.13　每处理器计数器">5.13　每处理器计数器</a></li>
                <li>
                    <a href="#514%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" aria-label="5.14　内存屏障">5.14　内存屏障</a><ul>
                        
                <li>
                    <a href="#5141%e7%bc%96%e8%af%91%e5%99%a8%e5%b1%8f%e9%9a%9c" aria-label="5.14.1　编译器屏障">5.14.1　编译器屏障</a></li>
                <li>
                    <a href="#5142%e5%a4%84%e7%90%86%e5%99%a8%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" aria-label="5.14.2　处理器内存屏障">5.14.2　处理器内存屏障</a></li>
                <li>
                    <a href="#5143-mmio%e5%86%99%e5%b1%8f%e9%9a%9c" aria-label="5.14.3 MMIO写屏障">5.14.3 MMIO写屏障</a></li>
                <li>
                    <a href="#5144%e9%9a%90%e5%90%ab%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" aria-label="5.14.4　隐含内存屏障">5.14.4　隐含内存屏障</a></li>
                <li>
                    <a href="#5145arm64%e5%a4%84%e7%90%86%e5%99%a8%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" aria-label="5.14.5　ARM64处理器内存屏障">5.14.5　ARM64处理器内存屏障</a></li></ul>
                </li>
                <li>
                    <a href="#515rcu" aria-label="5.15　RCU">5.15　RCU</a><ul>
                        
                <li>
                    <a href="#5152%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="5.15.2　技术原理">5.15.2　技术原理</a></li></ul>
                </li>
                <li>
                    <a href="#516%e5%8f%af%e7%9d%a1%e7%9c%a0rcu" aria-label="5.16　可睡眠RCU">5.16　可睡眠RCU</a></li>
                <li>
                    <a href="#517%e6%ad%bb%e9%94%81%e6%a3%80%e6%b5%8b%e5%b7%a5%e5%85%b7lockdep" aria-label="5.17　死锁检测工具lockdep">5.17　死锁检测工具lockdep</a><ul>
                        
                <li>
                    <a href="#5171%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="5.17.1　使用方法">5.17.1　使用方法</a></li>
                <li>
                    <a href="#5172%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86" aria-label="5.17.2　技术原理">5.17.2　技术原理</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac6%e7%ab%a0-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="第6章 文件系统">第6章 文件系统</a><ul>
                        
                <li>
                    <a href="#61%e6%a6%82%e8%bf%b0" aria-label="6.1　概述">6.1　概述</a><ul>
                        
                <li>
                    <a href="#611%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e5%b1%82%e9%9d%a2" aria-label="6.1.1　用户空间层面">6.1.1　用户空间层面</a></li>
                <li>
                    <a href="#612%e7%a1%ac%e4%bb%b6%e5%b1%82%e9%9d%a2" aria-label="6.1.2　硬件层面">6.1.2　硬件层面</a></li>
                <li>
                    <a href="#613%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%b1%82%e9%9d%a2" aria-label="6.1.3　内核空间层面">6.1.3　内核空间层面</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h1 id="内容提纲">内容提纲<a hidden class="anchor" aria-hidden="true" href="#内容提纲">#</a></h1>
<ul>
<li>内核的引导过程U-Boot</li>
<li>内核管理和调度进程</li>
<li>内核管理虚拟内存和物理内存</li>
<li>内核处理异常和中断的技术原理，以及系统调用的实现方式</li>
<li>保护临界区的互斥</li>
<li>虚拟文件系统</li>
</ul>
<h1 id="第1章-内核引导和初始化">第1章 内核引导和初始化<a hidden class="anchor" aria-hidden="true" href="#第1章-内核引导和初始化">#</a></h1>
<p> 处理器上电-&gt;执行引导程序-&gt;加载内核到内存-&gt;执行内核-&gt;内核初始化-&gt;启动用户空间第一个进程
 ARM64处理器到物理地址0取第一条指令</p>
<h2 id="11-引导程序">1.1 引导程序<a hidden class="anchor" aria-hidden="true" href="#11-引导程序">#</a></h2>
<h3 id="111-入口_start">1.1.1 入口_start<a hidden class="anchor" aria-hidden="true" href="#111-入口_start">#</a></h3>
<p> ARM64处理器U-Boot程序执行过程，入口<a href="https://elixir.bootlin.com/u-boot/latest/source/arch/arm/cpu/armv8/start.S#L20"><code>u-boot/arch/arm/cpu/armv8/start.S</code></a>标识<code>_start</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>.globl	_start
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/boot0-linux-kernel-header.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/arch/boot0.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b	reset
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><h3 id="112-reset">1.1.2 <code>reset</code><a hidden class="anchor" aria-hidden="true" href="#112-reset">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>reset:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Allow the board to save important registers */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 允许板卡保存重要的寄存器*/</span>
</span></span><span style="display:flex;"><span>	b	save_boot_params
</span></span><span style="display:flex;"><span>.globl	save_boot_params_ret
</span></span><span style="display:flex;"><span>save_boot_params_ret:
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SYS_RESET_SCTRL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl reset_sctrl   <span style="color:#75715e">// 初始化系统控制寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 异常级别可能是3、2或者1，初始状态：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 小端字节序，禁止MMU，禁止指令/数据缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>    adr  x0, vectors
</span></span><span style="display:flex;"><span>    witch_el x1, <span style="color:#ae81ff">3f</span>, <span style="color:#ae81ff">2f</span>, <span style="color:#ae81ff">1f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>  msr  vbar_el3, x0    <span style="color:#75715e">// 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mrs  x0, scr_el3   <span style="color:#75715e">// 设置安全配置寄存器SCR_EL3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    orr  x0, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>         <span style="color:#75715e">/* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */</span>
</span></span><span style="display:flex;"><span>    msr  scr_el3, x0
</span></span><span style="display:flex;"><span>    msr  cptr_el3, xzr           <span style="color:#75715e">/* 启用浮点和SIMD功能*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef COUNTER_FREQUENCY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>COUNTER_FREQUENCY
</span></span><span style="display:flex;"><span>    msr  cntfrq_el0, x0          <span style="color:#75715e">/* 初始化寄存器CNTFRQ */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>  msr   vbar_el2, x0   		<span style="color:#75715e">// 异常级别2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x33ff</span>
</span></span><span style="display:flex;"><span>    msr  cptr_el2, x0            <span style="color:#75715e">/* 启用浮点和SIMD功能 */</span>
</span></span><span style="display:flex;"><span>    b    <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>  msr    vbar_el1, x0
</span></span><span style="display:flex;"><span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>    msr  cpacr_el1, x0           <span style="color:#75715e">/* 启用浮点和SIMD功能 */</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 应用ARM处理器特定的勘误表*/</span>
</span></span><span style="display:flex;"><span>bl   apply_core_errata
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* 处理器特定的初始化*/</span>
</span></span><span style="display:flex;"><span>bl   lowlevel_init    <span style="color:#75715e">// 执行board_init_f()所需最小初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_ARMV8_SPIN_TABLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    branch_if_master x0, x1, master_cpu
</span></span><span style="display:flex;"><span>    b    spin_table_secondary_jump    <span style="color:#75715e">// arch/arm/cpu/armv8/spin_tabli.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/* 绝对不会返回*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_ARMV8_MULTIENTRY)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>branch_if_master x0, x1, master_cpu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 从处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>slave_cpu:
</span></span><span style="display:flex;"><span>    wfe
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x1, <span style="color:#f92672">=</span>CPU_RELEASE_ADDR 
</span></span><span style="display:flex;"><span>    ldr  x0, [x1]
</span></span><span style="display:flex;"><span>    cbz  x0, slave_cpu
</span></span><span style="display:flex;"><span>    br   x0               <span style="color:#75715e">/* 跳转到指定地址*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_ARMV8_MULTIENTRY */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>master_cpu:
</span></span><span style="display:flex;"><span>    bl   _main  <span style="color:#75715e">// 主处理器执行函数
</span></span></span></code></pre></div><p> U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序</p>
<h3 id="113-函数_main">1.1.3 函数_main<a hidden class="anchor" aria-hidden="true" href="#113-函数_main">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm/lib/crt0_64.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ENTRY</span>(_main)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置初始的C语言运行环境，并且调用board_init_f(0)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>(CONFIG_SPL_STACK)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>(CONFIG_SYS_INIT_SP_ADDR)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bic  sp, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>   <span style="color:#75715e">/* 为了符合应用二进制接口规范，对齐到16字节*/</span>
</span></span><span style="display:flex;"><span>    mov  x0, sp
</span></span><span style="display:flex;"><span>    bl   board_init_f_alloc_reserve <span style="color:#75715e">// 在栈的顶部为结构体global_data分配空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  sp, x0
</span></span><span style="display:flex;"><span>    mov  x18, x0  <span style="color:#75715e">/* 设置gd */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 函数board_init_f_init_reserve，初始化结构体global_data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   board_init_f_init_reserve  
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    bl   board_init_f <span style="color:#75715e">// common/board_f.c 执行数组init_sequence_f中的每个函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if !defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// 设置中间环境（新的栈指针和gd），然后调用函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// relocate_code(addr_moni)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_START_ADDR_SP]    <span style="color:#75715e">/* 把寄存器x0设置为gd-&gt;start_addr_sp */</span>
</span></span><span style="display:flex;"><span>    bic  sp, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>             <span style="color:#75715e">/* 为了符合应用二进制接口规范，对齐到16字节 */</span>
</span></span><span style="display:flex;"><span>    ldr  x18, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_BD]       <span style="color:#75715e">/* 把寄存器x18设置为gd-&gt;bd */</span>
</span></span><span style="display:flex;"><span>    sub  x18, x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_SIZE       <span style="color:#75715e">/* 新的gd在bd的下面 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    adr  lr, relocation_return
</span></span><span style="display:flex;"><span>    ldr  x9, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOC_OFF]    <span style="color:#75715e">/* 把寄存器x9设置为gd-&gt;reloc_off */</span>
</span></span><span style="display:flex;"><span>    add  lr, lr, x9    <span style="color:#75715e">/* 在重定位后新的返回地址 */</span>
</span></span><span style="display:flex;"><span>    ldr  x0, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOCADDR]    <span style="color:#75715e">/* 把寄存器x0设置为gd-&gt;relocaddr */</span>
</span></span><span style="display:flex;"><span>    b    relocate_code
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>relocation_return:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置最终的完整环境
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">/* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/</span>
</span></span><span style="display:flex;"><span>    bl   c_runtime_cpu_setup  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* !CONFIG_SPL_BUILD */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   spl_relocate_stack_gd    <span style="color:#75715e">/* 可能返回空指针 重新定位栈*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行“sp = (x0 != NULL) ? x0 : sp”，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 规避这个约束：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 带条件的mov指令不能把栈指针寄存器作为操作数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  x1, sp
</span></span><span style="display:flex;"><span>    cmp  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    csel x0, x0, x1, ne
</span></span><span style="display:flex;"><span>    mov  sp, x0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用0初始化未初始化数据段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>__bss_start      <span style="color:#75715e">/* 这是自动重定位*/</span>
</span></span><span style="display:flex;"><span>    ldr  x1, <span style="color:#f92672">=</span>__bss_end        <span style="color:#75715e">/* 这是自动重定位*/</span>
</span></span><span style="display:flex;"><span>clear_loop:
</span></span><span style="display:flex;"><span>    str  xzr, [x0], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    cmp  x0, x1
</span></span><span style="display:flex;"><span>    b.lo clear_loop
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 调用函数board_init_r(gd_t *id, ulong dest_addr) */</span>
</span></span><span style="display:flex;"><span>    mov  x0, x18                     <span style="color:#75715e">/* gd_t */</span>
</span></span><span style="display:flex;"><span>    ldr  x1, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOCADDR]    <span style="color:#75715e">/* dest_addr */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */</span>
</span></span><span style="display:flex;"><span>    b    board_init_r   
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* 不会运行到这里，因为函数board_init_r()不会返回*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(_main)
</span></span></code></pre></div><h3 id="114-函数run_main_loop">1.1.4 函数run_main_loop<a hidden class="anchor" aria-hidden="true" href="#114-函数run_main_loop">#</a></h3>
<p> 数组<code>init_sequence_r</code>最后一个函数<code>run_main_loop</code>，函数执行流程；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>run_main_loop
</span></span><span style="display:flex;"><span>    main_loop
</span></span><span style="display:flex;"><span>        bootdely_process <span style="color:#75715e"># 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量)</span>
</span></span><span style="display:flex;"><span>        autoboot_command
</span></span><span style="display:flex;"><span>            abortboot    <span style="color:#75715e"># 等待用户按键</span>
</span></span><span style="display:flex;"><span>            run_command_list  <span style="color:#75715e"># 未等待到按键，自动执行环境变量bootcmd</span>
</span></span></code></pre></div><p> <code>bootm</code>命令处理函数<code>do_bootm</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>do_bootm
</span></span><span style="display:flex;"><span>    do_bootm_states
</span></span><span style="display:flex;"><span>        bootm_start   <span style="color:#75715e"># 初始化全局变量bootm_header_timages</span>
</span></span><span style="display:flex;"><span>        bootm_find_os    <span style="color:#75715e"># 把内核镜像从存储设备读到内存</span>
</span></span><span style="display:flex;"><span>        bootm_find_other    <span style="color:#75715e"># ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件</span>
</span></span><span style="display:flex;"><span>        bootm_load_os  <span style="color:#75715e"># 解压病加载内核到正确位置</span>
</span></span><span style="display:flex;"><span>        bootm_os_get_boot_func  <span style="color:#75715e"># 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux</span>
</span></span><span style="display:flex;"><span>        do_bootm_linux<span style="color:#f92672">(</span>flag<span style="color:#f92672">=</span>BOOTM_STATE_OS_PREP<span style="color:#f92672">)</span>  <span style="color:#75715e"># 调用boot_prep_linux</span>
</span></span><span style="display:flex;"><span>            boot_prep_linux  <span style="color:#75715e"># 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件</span>
</span></span><span style="display:flex;"><span>        boot_selected_os  <span style="color:#75715e"># </span>
</span></span><span style="display:flex;"><span>            do_bootm_linux<span style="color:#f92672">(</span>flag<span style="color:#f92672">=</span>BOOTM_STATE_OS_GO<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                boot_jump_linux  <span style="color:#75715e"># 负责跳转到Linux内核</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>boot_jum_linux
</span></span><span style="display:flex;"><span>    do_nonsec_virt_switch
</span></span><span style="display:flex;"><span>        smp_kick_all_cpus  <span style="color:#75715e"># CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3</span>
</span></span><span style="display:flex;"><span>        dcache_disable  <span style="color:#75715e"># 禁用处理器的缓存和内存管理单元</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1</span>
</span></span><span style="display:flex;"><span>    armv8_switch_to_el2
</span></span><span style="display:flex;"><span>        switch_to_el1
</span></span><span style="display:flex;"><span>            armv8_switch_to_el1
</span></span><span style="display:flex;"><span>                内核入口
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在异常级别2执行内核</span>
</span></span><span style="display:flex;"><span>    armv8_switch_to_el2
</span></span><span style="display:flex;"><span>        内核入口
</span></span></code></pre></div><h2 id="12-内核初始化">1.2 内核初始化<a hidden class="anchor" aria-hidden="true" href="#12-内核初始化">#</a></h2>
<p> 内核初始化分为汇编语言部分和C语言部分</p>
<h3 id="121-汇编语言部分">1.2.1 汇编语言部分<a hidden class="anchor" aria-hidden="true" href="#121-汇编语言部分">#</a></h3>
<p> ARM64架构内核入口<code>_head</code>，直接跳转到标号<code>stext</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_head:
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_EFI   </span><span style="color:#75715e">// 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add  x13, x18, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x16</span>
</span></span><span style="display:flex;"><span>    b    stext
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    stext       <span style="color:#75715e">// 跳转到内核起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .long0           <span style="color:#75715e">// 保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p> <code>stext</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ENTRY</span>(stext)
</span></span><span style="display:flex;"><span>    bl   preserve_boot_args  <span style="color:#75715e">// 把引导程序传递的4个参数保存在全局数组boot_args中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   el2_setup        <span style="color:#75715e">// 降级到异常级别1, 寄存器w0存放cpu_boot_mode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    adrp x23, __PHYS_OFFSET
</span></span><span style="display:flex;"><span>    and  x23, x23, MIN_KIMG_ALIGN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>    <span style="color:#75715e">// KASLR偏移，默认值是0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   set_cpu_boot_mode_flag  <span style="color:#75715e">// __boot_cpu_mode[2] 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   __create_page_tables  <span style="color:#75715e">// 创建页表映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 返回的时候，处理器已经为开启内存管理单元做好准备，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 转换控制寄存器已经设置好。*/</span>
</span></span><span style="display:flex;"><span>    bl    __cpu_setup        <span style="color:#75715e">// 初始化处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    __primary_switch  <span style="color:#75715e">// 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ENDPROC</span>(stext)
</span></span></code></pre></div><br>
<ol>
<li>函数el2_setup</li>
</ol>
<blockquote>
<p>a.如果异常级别是1，那么在异常级别1执行内核。   <br>
b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。    <br>
1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。    \<br>
2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核      \</p>
</blockquote>
<p> 基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。       <br>
 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程           \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 打开KVM字符设备文件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;/dev/kvm&#34;</span>, O_RDWR);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vmfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">ioctl</span>(fd, KVM_CREATE_VM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vcpu_fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">ioctl</span>(vmfd, KVM_CREATE_VCPU, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p> 从QEMU切换到客户操作系统的过程如下。      <br>
 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。     <br>
 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。           <br>
 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。           <br>
 为了提高切换速度，<code>ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核</code>，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2      \</p>
<br>
<ol start="2">
<li>函数__create_page_tables</li>
</ol>
<blockquote>
<p>1）创建恒等映射，虚拟地址=物理地址<code>__enable_mmu</code>开启内存管理单元        <br>
2）为内核镜像创建映射             \</p>
</blockquote>
<p> 映射代码节<code>.idmap.text</code>,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址</p>
<br>
<ol start="3">
<li>函数__primary_switch</li>
</ol>
<blockquote>
<p>1）__enable_mmu开启内存管理单元            <br>
2）__primary_switched      <br>
 __enable_mmu执行流程     <br>
 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址     <br>
 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址        <br>
 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址    <br>
 __primary_switch执行流程      <br>
 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE)           <br>
 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体<code>thread_info</code>的地址(init_task.thread_info)        <br>
 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors)     <br>
 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中     <br>
 5）用0初始化内核的未初始化数据段      <br>
 6）调用C语言函数<code>start_kernel</code>      \</p>
</blockquote>
<br>
<h3 id="122-c语言部分">1.2.2 C语言部分<a hidden class="anchor" aria-hidden="true" href="#122-c语言部分">#</a></h3>
<p> 内核初始化的C语言部分入口是函数<code>start_kernel</code>，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数<code>rest_init</code>。函数rest_init的执行流程如下。   <br>
 （1）创建1号线程，即init线程，线程函数是kernel_init。     <br>
 （2）创建2号线程，即kthreadd线程，负责创建内核线程。     <br>
 （3）0号线程最终变成空闲线程。    \</p>
<p>init线程继续初始化，执行的主要操作如下。    <br>
 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。   <br>
 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。   <br>
 （3）smp_init()：初始化SMP系统，启动所有从处理器。   <br>
 （4）do_initcalls()：执行级别0～7的初始化。 <br>
 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。   <br>
 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。   <br>
 （7）free_initmem()：释放初始化代码和数据占用的内存。   <br>
 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。  \</p>
<p> 级别0～7的初始化，是指使用以下宏注册的初始化函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/init.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define pure_initcall(fn)           __define_initcall(fn, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define core_initcall(fn)           __define_initcall(fn, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define core_initcall_sync(fn)      __define_initcall(fn, 1s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define postcore_initcall(fn)       __define_initcall(fn, 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_initcall(fn)           __define_initcall(fn, 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define subsys_initcall(fn)         __define_initcall(fn, 4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fs_initcall(fn)             __define_initcall(fn, 5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rootfs_initcall(fn)         __define_initcall(fn, rootfs)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define device_initcall(fn)         __define_initcall(fn, 6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define device_initcall_sync(fn)    __define_initcall(fn, 6s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define late_initcall(fn)           __define_initcall(fn, 7)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define late_initcall_sync(fn)      __define_initcall(fn, 7s)
</span></span></span></code></pre></div><h3 id="123-smp系统的引导">1.2.3 SMP系统的引导<a hidden class="anchor" aria-hidden="true" href="#123-smp系统的引导">#</a></h3>
<p> 对称多处理器(Symmetirc Multi-Processor SMP)       <br>
 3种引导从处理器方法      \</p>
<ul>
<li>自旋表</li>
<li>电源状态协调接口</li>
<li>ACPI停车协议</li>
</ul>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/ARM64_SMP_spin_table.png" alt="ARM64架构下SMP系统的自旋表引导过程"  />
</p>
<h2 id="13-init进程">1.3 init进程<a hidden class="anchor" aria-hidden="true" href="#13-init进程">#</a></h2>
<p> init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有<code>sysvinit</code>、busybox init、upstart、<code>systemd</code>和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件<code>/etc/initab</code></p>
<br>
<h1 id="第2章-进程管理">第2章 进程管理<a hidden class="anchor" aria-hidden="true" href="#第2章-进程管理">#</a></h1>
<h2 id="21-进程">2.1 进程<a hidden class="anchor" aria-hidden="true" href="#21-进程">#</a></h2>
<p> Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间       <br>
 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。     <br>
 task_struct结构体是进程描述符，主要成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> state;    <span style="color:#75715e">// 进程状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>stack;            <span style="color:#75715e">// 指向内核栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pid_t</span> pid;              <span style="color:#75715e">// 全局进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pid_t</span> tgid              <span style="color:#75715e">// 全局的线程组标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> pid_link pid[PIDTYPE_MAX];   <span style="color:#75715e">// 进程号，进程组标识符和会话标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct _rcu <span style="color:#f92672">*</span>real_parent;   <span style="color:#75715e">// real_parent指向真实的父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct _rcu <span style="color:#f92672">*</span>parent;        <span style="color:#75715e">// parent指向父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>group_leader;   <span style="color:#75715e">// 指向进村组的组长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred _rcu <span style="color:#f92672">*</span>real_cred;  <span style="color:#75715e">// real_cred指向主题和真实客体证书
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred _rcu <span style="color:#f92672">*</span>cred;       <span style="color:#75715e">// cred指向客体证书
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> comm[TASK_COMM_LEN];           <span style="color:#75715e">// 进程名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> prio, static_prio, nornal_prio; <span style="color:#75715e">// 调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> rt_priority,prolicy<span style="color:#960050;background-color:#1e0010">；</span>  <span style="color:#75715e">// 优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">cpumask_t</span> cpus_allowed;             <span style="color:#75715e">// 允许进程在哪些处理器上运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#f92672">*</span>active_mm;   <span style="color:#75715e">// 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> file_struct <span style="color:#f92672">*</span>files;          <span style="color:#75715e">// 打开文件表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>nsproxy;            <span style="color:#75715e">// 命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>signal;       <span style="color:#75715e">// 信号处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sigband_struct <span style="color:#f92672">*</span>sighand;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sigset_t</span> blocked, real_blocked;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sigset_t</span> saved_sigmask;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sigpending pending;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sysv_sem sysvsem;            <span style="color:#75715e">// UNIx系统5信号量和共享内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sysv_shm sysvshm;
</span></span></code></pre></div><h2 id="22-命名空间">2.2 命名空间<a hidden class="anchor" aria-hidden="true" href="#22-命名空间">#</a></h2>
<p> 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,容器仅仅是通过命名空间隔离？  \</p>
<table>
<thead>
<tr>
<th>命名空间</th>
<th>隔离资源</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>控制组cgroup</td>
<td>控制组根目录</td>
<td></td>
</tr>
<tr>
<td>进程间通信IPC</td>
<td>UNIX系统5进程间通信和POSIx消息队列</td>
<td></td>
</tr>
<tr>
<td>network</td>
<td>网络协议</td>
<td></td>
</tr>
<tr>
<td>挂载mount</td>
<td>挂载点</td>
<td></td>
</tr>
<tr>
<td>PID</td>
<td>进程号</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>用户标识符和组标识符</td>
<td></td>
</tr>
<tr>
<td>UNIX分时系统(UTS)</td>
<td>主机名和网络信息服务NIS域名</td>
<td></td>
</tr>
</tbody>
</table>
<p> 创建新的命名空间方法：   <br>
 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间   <br>
 调用unshare创建新的命名空间    <br>
 进程使用系统调用setns，绑定一个已经存在的命名空间</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/process_namespace.png" alt="进程的命名空间"  />
</p>
<p> 进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。</p>
<h2 id="23-进程标识符">2.3 进程标识符<a hidden class="anchor" aria-hidden="true" href="#23-进程标识符">#</a></h2>
<table>
<thead>
<tr>
<th>标识符</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>进程标识符</td>
<td>命名空间给进程分配标识符</td>
<td></td>
</tr>
<tr>
<td>线程组标识符</td>
<td>线程组中的主进程称为组长，线程组标识符就是组长的进程标识符<br>系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组</td>
<td></td>
</tr>
<tr>
<td>进程组标识符</td>
<td>进程组标识符是组长的进程标识符。<br>进程可以使用系统调用setpgid创建或者加入一个进程组</td>
<td></td>
</tr>
<tr>
<td>会话标识符</td>
<td>进程调用系统调用setsid的时候，创建一个新的会话</td>
<td></td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/pid_mark.png" alt="进程的命名空间"  />
</p>
<p> pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid    \</p>
<p> 进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，</p>
<h2 id="24-进程关系">2.4 进程关系<a hidden class="anchor" aria-hidden="true" href="#24-进程关系">#</a></h2>
<p> 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/process_relative.png" alt="进程的命名空间"  />
</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/tasks_table.png" alt="进程和线程链表"  />
</p>
<h2 id="25-启动程序">2.5 启动程序<a hidden class="anchor" aria-hidden="true" href="#25-启动程序">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 父进程继续执行 */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 子进程装载程序 */</span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">execve</span>(filename, argv, envp);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 创建子进程失败 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="251创建新进程">2.5.1　创建新进程<a hidden class="anchor" aria-hidden="true" href="#251创建新进程">#</a></h3>
<p> 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的
 两个个系统调用创建进程：    \</p>
<ul>
<li>fork：子进程是父进程的副本，用写时复制</li>
<li>clone：可控制子进程和父进程共享哪些资源</li>
<li>vfork：创建子进程，子进程用execve装载程序(已废弃)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 数字表示参数个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SYSCALL_DEFINE0</span>(fork)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏展开 asmlinkage表示C语言函数看被汇编代码调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sys_fork</span>(<span style="color:#66d9ef">void</span>)
</span></span></code></pre></div><p> 创建进程的进程p和被创建进程c三种关系</p>
<ul>
<li>新进程是进程p的子进程</li>
<li>clone传入CLONE_PARENT，兄弟关系</li>
<li>clone传入CLONE_THREAD，同属一个线程组</li>
</ul>
<h4 id="1-_do_fork函数">1. _do_fork函数<a hidden class="anchor" aria-hidden="true" href="#1-_do_fork函数">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">_do_fork</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_start,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_size,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>parent_tidptr,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>child_tidptr,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tls);  <span style="color:#75715e">// tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址
</span></span></span></code></pre></div><p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/_do_fork.png" alt="函数_do_fork的执行流程"  />
</p>
<p> 调用copy_process创建新进程  <br>
 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置   <br>
 wake_up_new_task唤醒新进程</p>
<h4 id="2-copy_process函数">2. copy_process函数<a hidden class="anchor" aria-hidden="true" href="#2-copy_process函数">#</a></h4>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030190536.png" alt="20221030190536"  />
</p>
<ul>
<li><strong>（1）标志组合</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CLONE_NEWNS &amp; CLONE_FS</td>
<td style="text-align:center">新进程属于新挂载命名空间<br>共享文件系统信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWUSER &amp; CLONE_FS</td>
<td style="text-align:center">新进程属于新用户命名空间<br>共享文件系统信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_THREAD <br> 未设置CLONE_SIGHAND</td>
<td style="text-align:center">新进程和当前进程同属一个线程组，<br>但不共享信号处理程序</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_SIGHAND <br> 未设置CLONE_VM</td>
<td style="text-align:center">新进程和当前进程共享信号处理程序，<br>但不共享虚拟内存</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>（2）dup_task_struct函数</strong>
 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈</li>
</ul>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030192206.png" alt="20221030192206"  title="进程的内核栈"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">union</span> thread_union {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct task;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_THREAD_INFO_IN_TASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> thread_info thread_info;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack[THREAD_SIZE<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 内核栈两种布局</p>
<ul>
<li>
<ol>
<li>thread_info在内核栈顶部，成员task指向进程描述符</li>
</ol>
</li>
<li>
<ol start="2">
<li>thread_info未占用内核栈
 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址
 内核栈的长度时<code>THREAD_SIZE</code>，<strong>ARM64架构内核栈长度为16KB</strong>
 thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/thread_info.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> thread_info {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>		flags;		<span style="color:#75715e">/* low level flags 底层标志位 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mm_segment_t</span>		addr_limit;	<span style="color:#75715e">/* address limit 地址限制 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ARM64_SW_TTBR0_PAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	u64			ttbr0;		<span style="color:#75715e">/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    u64		preempt_count;	<span style="color:#75715e">/* 抢占计数器 0 =&gt; preemptible 可抢占, &lt;0 =&gt; bug缺陷 */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>
<p><strong>（3）copy_creds函数</strong>
 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1</p>
</li>
<li>
<p><strong>（4）检查线程数量限制</strong>
 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS</p>
</li>
<li>
<p><strong>（5）sched_fork函数</strong></p>
</li>
</ul>
<p> 为新进程设置调度器相关的参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c  书中为4.x版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_fork</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__sched_fork</span>(clone_flags, p);   <span style="color:#75715e">// 执行基本设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We mark the process as NEW here. This guarantees that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * nobody will actually run it, and a signal or other external
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * event cannot wake it up and insert it on the runqueue either.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> TASK_NEW;    <span style="color:#75715e">// 新进程状态设置为TASK_NEW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Make sure we do not leak PI boosting priority to the child.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>prio <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>normal_prio;  <span style="color:#75715e">// 新进程调度优先级设置为当前进程正常优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">uclamp_fork</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Revert to default priority/policy on fork if requested.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(p<span style="color:#f92672">-&gt;</span>sched_reset_on_fork)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">task_has_dl_policy</span>(p) <span style="color:#f92672">||</span> <span style="color:#a6e22e">task_has_rt_policy</span>(p)) { <span style="color:#75715e">// 限期进程或实时进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">=</span> SCHED_NORMAL;  <span style="color:#75715e">// 调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>static_prio <span style="color:#f92672">=</span> <span style="color:#a6e22e">NICE_TO_PRIO</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// nice值默认值0，静态优先级120
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>rt_priority <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">PRIO_TO_NICE</span>(p<span style="color:#f92672">-&gt;</span>static_prio) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 普通进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>static_prio <span style="color:#f92672">=</span> <span style="color:#a6e22e">NICE_TO_PRIO</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// nice值默认值0，静态优先级120
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>prio <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>normal_prio <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>static_prio;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">set_load_weight</span>(p, false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * We don&#39;t need the reset flag anymore after the fork. It has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * fulfilled its duty:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_reset_on_fork <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dl_prio</span>(p<span style="color:#f92672">-&gt;</span>prio)) <span style="color:#75715e">// 调度优先级是限期调度累的优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;  <span style="color:#75715e">// 不允许限期进程分叉生成新的限期进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rt_prio</span>(p<span style="color:#f92672">-&gt;</span>prio))  <span style="color:#75715e">// 调度优先级是实时调度类优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		p<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rt_sched_class; <span style="color:#75715e">// 调度类设置为实时调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fair_sched_class;  <span style="color:#75715e">// 调度优先级是公平调度类的优先级，调度类设置为公平调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">init_entity_runnable_average</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>se);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SCHED_INFO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#a6e22e">sched_info_on</span>()))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memset</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>sched_info, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(p<span style="color:#f92672">-&gt;</span>sched_info));
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SMP)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>on_cpu <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">init_task_preempt_count</span>(p);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">plist_node_init</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pushable_tasks, MAX_PRIO);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RB_CLEAR_NODE</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pushable_dl_tasks);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>（6）复制或共享资源</strong></li>
</ul>
<p> 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/ipc/sem.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_semundo</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sem_undo_list <span style="color:#f92672">*</span>undo_list;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SYSVSEM) {  <span style="color:#75715e">// CLONE_SYSTEM表示UNIX系统5信号量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		error <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_undo_list</span>(<span style="color:#f92672">&amp;</span>undo_list);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (error)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">refcount_inc</span>(<span style="color:#f92672">&amp;</span>undo_list<span style="color:#f92672">-&gt;</span>refcnt); <span style="color:#75715e">// 5信号量的撤销请求链表，sem_undo_list 计数+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tsk<span style="color:#f92672">-&gt;</span>sysvsem.undo_list <span style="color:#f92672">=</span> undo_list;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		tsk<span style="color:#f92672">-&gt;</span>sysvsem.undo_list <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// 新进程5信号量撤销请求链表为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_files</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> files_struct <span style="color:#f92672">*</span>oldf, <span style="color:#f92672">*</span>newf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * A background process may not have any files ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	oldf <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>files;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>oldf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_FILES) { <span style="color:#75715e">// CLONE_FIELS共享打开文件表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">atomic_inc</span>(<span style="color:#f92672">&amp;</span>oldf<span style="color:#f92672">-&gt;</span>count);  <span style="color:#75715e">// files_struct 计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	newf <span style="color:#f92672">=</span> <span style="color:#a6e22e">dup_fd</span>(oldf, NR_OPEN_MAX, <span style="color:#f92672">&amp;</span>error);  <span style="color:#75715e">// 新进程把当前进程的打开文件表复制一份
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>files <span style="color:#f92672">=</span> newf;
</span></span><span style="display:flex;"><span>	error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息     <br>
  函数copy_fs复制或共享文件系统信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_fs</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> fs_struct <span style="color:#f92672">*</span>fs <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>fs;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_FS) {  <span style="color:#75715e">// CLONE_FS共享文件系统信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">/* tsk-&gt;fs is already what we want */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fs<span style="color:#f92672">-&gt;</span>in_exec) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		fs<span style="color:#f92672">-&gt;</span>users<span style="color:#f92672">++</span>;  <span style="color:#75715e">// fs_struct共享文件系统信息结构体 加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>fs <span style="color:#f92672">=</span> <span style="color:#a6e22e">copy_fs_struct</span>(fs);  <span style="color:#75715e">// 新进程复制当前进程文件系统信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tsk<span style="color:#f92672">-&gt;</span>fs)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 <br>
  函数copy_sighand复制或共享信号处理程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_sighand</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sighand_struct <span style="color:#f92672">*</span>sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SIGHAND) {  <span style="color:#75715e">// CLONE_SIGHAND 表示共享信号处理程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">refcount_inc</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>count); <span style="color:#75715e">// 引用计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程复制当前进程信号处理程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sig <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_cache_alloc</span>(sighand_cachep, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RCU_INIT_POINTER</span>(tsk<span style="color:#f92672">-&gt;</span>sighand, sig);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sig)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">refcount_set</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>count, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_lock_irq</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memcpy</span>(sig<span style="color:#f92672">-&gt;</span>action, current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>action, <span style="color:#66d9ef">sizeof</span>(sig<span style="color:#f92672">-&gt;</span>action));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_unlock_irq</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_CLEAR_SIGHAND)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">flush_signal_handlers</span>(tsk, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 5）信号结构体，同属一个线程组的线程才会共享信号结构体   <br>
  函数copy_signal复制或共享信号结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_signal</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_THREAD)  <span style="color:#75715e">// CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程分配结构体，初始化，继承当前进程资源限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sig <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_cache_zalloc</span>(signal_cachep, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>signal <span style="color:#f92672">=</span> sig;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sig)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>nr_threads <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atomic_set</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>live, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">refcount_set</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>sigcnt, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>thread_head <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> list_head)<span style="color:#a6e22e">LIST_HEAD_INIT</span>(tsk<span style="color:#f92672">-&gt;</span>thread_node);
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>thread_node <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> list_head)<span style="color:#a6e22e">LIST_HEAD_INIT</span>(sig<span style="color:#f92672">-&gt;</span>thread_head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">init_waitqueue_head</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>wait_chldexit);
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>curr_target <span style="color:#f92672">=</span> tsk;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">init_sigpending</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>shared_pending);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">INIT_HLIST_HEAD</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>multiprocess);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">seqlock_init</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>stats_lock);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prev_cputime_init</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>prev_cputime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_POSIX_TIMERS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">INIT_LIST_HEAD</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>posix_timers);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hrtimer_init</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>real_timer.function <span style="color:#f92672">=</span> it_real_fn;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">task_lock</span>(current<span style="color:#f92672">-&gt;</span>group_leader);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memcpy</span>(sig<span style="color:#f92672">-&gt;</span>rlim, current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>rlim, <span style="color:#66d9ef">sizeof</span> sig<span style="color:#f92672">-&gt;</span>rlim);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">task_unlock</span>(current<span style="color:#f92672">-&gt;</span>group_leader);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">posix_cpu_timers_init_group</span>(sig);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tty_audit_fork</span>(sig);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sched_autogroup_fork</span>(sig);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>oom_score_adj <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>oom_score_adj;
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>oom_score_adj_min <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>oom_score_adj_min;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mutex_init</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>cred_guard_mutex);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">init_rwsem</span>(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>exec_update_lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存  \
  函数copy_mm复制或共享虚拟内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/freezer.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_mm</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#f92672">*</span>oldmm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> retval;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>min_flt <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>maj_flt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>nvcsw <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nivcsw <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_DETECT_HUNG_TASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tsk<span style="color:#f92672">-&gt;</span>last_switch_count <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nvcsw <span style="color:#f92672">+</span> tsk<span style="color:#f92672">-&gt;</span>nivcsw;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>last_switch_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Are we cloning a kernel thread?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We need to steal a active VM for that..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	oldmm <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>oldmm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* initialize the new vmacache entries */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">vmacache_flush</span>(tsk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_VM) {  <span style="color:#75715e">// CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">mmget</span>(oldmm);
</span></span><span style="display:flex;"><span>		mm <span style="color:#f92672">=</span> oldmm;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> good_mm;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	retval <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程复制当前进程的虚拟内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mm <span style="color:#f92672">=</span> <span style="color:#a6e22e">dup_mm</span>(tsk, current<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> fail_nomem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>good_mm:
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>mm <span style="color:#f92672">=</span> mm;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fail_nomem:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> retval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 7）命名空间    <br>
  函数copy_namespace创建或共享命名空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/nsproxy.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_namespaces</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>old_ns <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nsproxy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> user_namespace <span style="color:#f92672">*</span>user_ns <span style="color:#f92672">=</span> <span style="color:#a6e22e">task_cred_xxx</span>(tsk, user_ns);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>new_ns;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果共享除了用户以外的所有其他命名空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span>(flags <span style="color:#f92672">&amp;</span> (CLONE_NEWNS <span style="color:#f92672">|</span> CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWIPC <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			      CLONE_NEWPID <span style="color:#f92672">|</span> CLONE_NEWNET <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			      CLONE_NEWCGROUP <span style="color:#f92672">|</span> CLONE_NEWTIME)))) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(old_ns<span style="color:#f92672">-&gt;</span>time_ns_for_children <span style="color:#f92672">==</span> old_ns<span style="color:#f92672">-&gt;</span>time_ns)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">get_nsproxy</span>(old_ns);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">ns_capable</span>(user_ns, CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 进程没有系统管理权限，那么不允许创建新的命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* CLONE_NEWIPC must detach from the undolist: after switching
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * to a new ipc namespace, the semaphore arrays from the old
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * means share undolist with parent, so we must forbid using
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * it along with CLONE_NEWIPC. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ((flags <span style="color:#f92672">&amp;</span> (CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_SYSVSEM)) <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>		(CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_SYSVSEM)) 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建新的命名空间代理，然后创建或者共享命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	new_ns <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_new_namespaces</span>(flags, tsk, user_ns, tsk<span style="color:#f92672">-&gt;</span>fs);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ERR</span>(new_ns))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>  <span style="color:#a6e22e">PTR_ERR</span>(new_ns);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">timens_on_fork</span>(new_ns, tsk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free_nsproxy</span>(new_ns);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>nsproxy <span style="color:#f92672">=</span> new_ns;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 8）I/O上下文    <br>
  函数copy_io创建或共享I/O上下文</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_io</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_BLOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> io_context <span style="color:#f92672">*</span>ioc <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>io_context;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_context <span style="color:#f92672">*</span>new_ioc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ioc)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Share io context with parent, if CLONE_IO is set */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_IO) {  <span style="color:#75715e">// CLONE_IO 共享I/O上小文
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ioc_task_link</span>(ioc);  <span style="color:#75715e">// 计数nr_tasks加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tsk<span style="color:#f92672">-&gt;</span>io_context <span style="color:#f92672">=</span> ioc;  <span style="color:#75715e">// 共享I/O上下文结构体io_context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ioprio_valid</span>(ioc<span style="color:#f92672">-&gt;</span>ioprio)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建新的I/O上下文，初始化，继承当前进程的I/O优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new_ioc <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_task_io_context</span>(tsk, GFP_KERNEL, NUMA_NO_NODE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>new_ioc))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		new_ioc<span style="color:#f92672">-&gt;</span>ioprio <span style="color:#f92672">=</span> ioc<span style="color:#f92672">-&gt;</span>ioprio;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_io_context</span>(new_ioc);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 9）复制寄存器值   <br>
  函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030211811.png" alt="20221030211811"  />
</p>
<p>  ARM64架构copy_thread_tls-&gt;copy_thread</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/process.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_thread</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_start,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stk_sz, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>childregs <span style="color:#f92672">=</span> <span style="color:#a6e22e">task_pt_regs</span>(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memset</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> cpu_context));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* In case p was allocated the same task_struct pointer as some
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * other recently-exited task, make sure p is disassociated from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * any cpu that may have run that now-exited task recently.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Otherwise we could erroneously skip reloading the FPSIMD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * registers for p. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fpsimd_flush_task_state</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ptrauth_thread_init_kernel</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span>(p<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_KTHREAD))) {  <span style="color:#75715e">// 用户进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>childregs <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">current_pt_regs</span>();
</span></span><span style="display:flex;"><span>		childregs<span style="color:#f92672">-&gt;</span>regs[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Read the current TLS pointer from tpidr_el0 as it may be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * out-of-sync with the saved value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 因为它可能和保存的值不一致 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span><span style="color:#a6e22e">task_user_tls</span>(p) <span style="color:#f92672">=</span> <span style="color:#a6e22e">read_sysreg</span>(tpidr_el0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (stack_start) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_compat_thread</span>(<span style="color:#a6e22e">task_thread_info</span>(p)))
</span></span><span style="display:flex;"><span>				childregs<span style="color:#f92672">-&gt;</span>compat_sp <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				childregs<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* If a TLS pointer was passed to clone, use it for the new thread. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SETTLS)
</span></span><span style="display:flex;"><span>			p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.uw.tp_value <span style="color:#f92672">=</span> tls;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 内核线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">memset</span>(childregs, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> pt_regs));
</span></span><span style="display:flex;"><span>		childregs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">=</span> PSR_MODE_EL1h;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_ARM64_UAO) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">cpus_have_const_cap</span>(ARM64_HAS_UAO))
</span></span><span style="display:flex;"><span>			childregs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">|=</span> PSR_UAO_BIT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">spectre_v4_enable_task_mitigation</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">system_uses_irq_prio_masking</span>())
</span></span><span style="display:flex;"><span>			childregs<span style="color:#f92672">-&gt;</span>pmr_save <span style="color:#f92672">=</span> GIC_PRIO_IRQON;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.x19 <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.x20 <span style="color:#f92672">=</span> stk_sz;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.pc <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)ret_from_fork;
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.sp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)childregs;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ptrace_hw_copy_thread</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>（7）设置进程号和进程关系</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __latent_entropy <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">copy_process</span>(
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> pid <span style="color:#f92672">*</span>pid,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> trace,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> node,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> kernel_clone_args <span style="color:#f92672">*</span>args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程分配进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>init_struct_pid) {
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_pid</span>(p<span style="color:#f92672">-&gt;</span>nsproxy<span style="color:#f92672">-&gt;</span>pid_ns_for_children);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ERR</span>(pid)) {
</span></span><span style="display:flex;"><span>            retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">PTR_ERR</span>(pid);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> bad_fork_cleanup_thread;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置新进程退出时发送给父进程的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">pid_nr</span>(pid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_THREAD) {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 新线程退出时不需要发送信号给父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>group_leader <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>group_leader;  <span style="color:#75715e">// group_leader指向同一个组长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>tgid <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>tgid;  <span style="color:#75715e">// tgid存放组长的进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_PARENT) <span style="color:#75715e">// CLONE_PARENT 新进程和当前进程是兄弟关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>group_leader<span style="color:#f92672">-&gt;</span>exit_signal;  <span style="color:#75715e">// 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">// 父子关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> (clone_flags <span style="color:#f92672">&amp;</span> CSIGNAL); <span style="color:#75715e">// 新进程的成员exit_signal是调用者指定的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>group_leader <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>tgid <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>pid;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 控制组的进程数控制器检查是否允许创建新进程：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 从当前进程所属的控制组一直到控制组层级的根，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果其中一个控制组的进程数量大于或等于限制，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 那么不允许使用fork和clone创建新进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cgroup_threadgroup_change_begin</span>(current);
</span></span><span style="display:flex;"><span>    retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">cgroup_can_fork</span>(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (retval)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> bad_fork_free_pid;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_lock_irq</span>(<span style="color:#f92672">&amp;</span>tasklist_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程设置父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> (CLONE_PARENT<span style="color:#f92672">|</span>CLONE_THREAD)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 新进程和当前进程拥有相同的父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>real_parent <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>real_parent;  
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>parent_exec_id <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>parent_exec_id;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>real_parent <span style="color:#f92672">=</span> current;  <span style="color:#75715e">// 新进程的父进程是当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>parent_exec_id <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>self_exec_id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(p<span style="color:#f92672">-&gt;</span>pid)) {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">init_task_pid</span>(p, PIDTYPE_PID, pid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">thread_group_leader</span>(p)) {  <span style="color:#75715e">// true 新进程和当前进程属于同一个进程组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">init_task_pid</span>(p, PIDTYPE_PGID, <span style="color:#a6e22e">task_pgrp</span>(current));  <span style="color:#75715e">// 指向同一个进程组的组长的进程号结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">init_task_pid</span>(p, PIDTYPE_SID, <span style="color:#a6e22e">task_session</span>(current));  <span style="color:#75715e">// 指向同一个会话的控制进程的进程号结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_child_reaper</span>(pid)) {  
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">ns_of_pid</span>(pid)<span style="color:#f92672">-&gt;</span>child_reaper <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>                p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|=</span> SIGNAL_UNKILLABLE;  <span style="color:#75715e">// 1号进程是不能杀死的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>leader_pid <span style="color:#f92672">=</span> pid;
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>tty <span style="color:#f92672">=</span> <span style="color:#a6e22e">tty_kref_get</span>(current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>tty);
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>has_child_subreaper <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span> has_child_subreaper <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                                p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>is_child_subreaper;
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>sibling, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>children);  <span style="color:#75715e">// 新进程添加到父进程的子进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 新进程添加到进程链表中，链表节点是成员tasks，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 头节点是空闲线程的成员tasks（init_task.tasks）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">list_add_tail_rcu</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>tasks, <span style="color:#f92672">&amp;</span>init_task.tasks);  
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">attach_pid</span>(p, PIDTYPE_PGID);  <span style="color:#75715e">// 新进程添加到进程组的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">attach_pid</span>(p, PIDTYPE_SID);  <span style="color:#75715e">// 新进程添加到会话的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">__this_cpu_inc</span>(process_counts);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>nr_threads<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 线程组的线程计数值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">atomic_inc</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>live);  <span style="color:#75715e">// 原子变量线程组的第2个线程计数值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">atomic_inc</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>sigcnt);  <span style="color:#75715e">// 信号结构体的引用计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">list_add_tail_rcu</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>thread_group,    
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>group_leader<span style="color:#f92672">-&gt;</span>thread_group);  <span style="color:#75715e">// 线程加入线程组的线程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">list_add_tail_rcu</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>thread_node,
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>thread_head);  <span style="color:#75715e">// 线程加入线程组的第二条线程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">attach_pid</span>(p, PIDTYPE_PID);  <span style="color:#75715e">// 新进程添加到进程号结构体的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        nr_threads<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 新进程添加到进程号结构体的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    total_forks<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_unlock_irq</span>(<span style="color:#f92672">&amp;</span>tasklist_lock);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">proc_fork_connector</span>(p);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cgroup_post_fork</span>(p);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cgroup_threadgroup_change_end</span>(current);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3唤醒新进程">3.唤醒新进程<a hidden class="anchor" aria-hidden="true" href="#3唤醒新进程">#</a></h4>
<p> wake_up_new_task函数唤醒新进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wake_up_new_task</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq_flags rf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raw_spin_lock_irqsave</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pi_lock, rf.flags);
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> TASK_RUNNING;  <span style="color:#75715e">// 切换TASK_RUNNING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Fork balancing, do it here and not earlier because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  - cpus_ptr can change in the fork path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  - any previously selected CPU might disappear through hotplug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * as we&#39;re not fully set-up yet.*/</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>recent_used_cpu <span style="color:#f92672">=</span> <span style="color:#a6e22e">task_cpu</span>(p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rseq_migrate</span>(p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__set_task_cpu</span>(p, <span style="color:#a6e22e">select_task_rq</span>(p, <span style="color:#a6e22e">task_cpu</span>(p), SD_BALANCE_FORK, <span style="color:#ae81ff">0</span>));  <span style="color:#75715e">// 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	rq <span style="color:#f92672">=</span> <span style="color:#a6e22e">__task_rq_lock</span>(p, <span style="color:#f92672">&amp;</span>rf);  <span style="color:#75715e">// 锁住运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">update_rq_clock</span>(rq);  <span style="color:#75715e">// 更新运行队列的时钟
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">post_init_entity_util_avg</span>(p);  <span style="color:#75715e">// 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">activate_task</span>(rq, p, ENQUEUE_NOCLOCK); <span style="color:#75715e">// 把新进程插入运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">trace_sched_wakeup_new</span>(p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">check_preempt_curr</span>(rq, p, WF_FORK);  <span style="color:#75715e">// 检查新进程是否可以抢占当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_woken) {  <span style="color:#75715e">// 在SMP系统上，调用调度类的task_woken方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Nothing relies on rq-&gt;lock after this, so its fine to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * drop it.*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rq_unpin_lock</span>(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">task_woken</span>(rq, p);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rq_repin_lock</span>(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">task_rq_unlock</span>(rq, p, <span style="color:#f92672">&amp;</span>rf);  <span style="color:#75715e">// 释放运行队列的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="4新进程第一次运行">4.新进程第一次运行<a hidden class="anchor" aria-hidden="true" href="#4新进程第一次运行">#</a></h4>
<p> 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tsk   .req   x28      <span style="color:#75715e">//当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SYM_CODE_START</span>(ret_from_fork)
</span></span><span style="display:flex;"><span>	bl	schedule_tail  <span style="color:#75715e">// 为上一个进程执行清理操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cbz	x19, <span style="color:#ae81ff">1f</span>  <span style="color:#75715e">// not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mov	x0, x20  <span style="color:#75715e">// 内核线程：x19存放线程函数的地址，x20存放线程函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	blr	x19  <span style="color:#75715e">// 调用线程函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>	get_current_task tsk  <span style="color:#75715e">// 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b	ret_to_user  <span style="color:#75715e">// 返回用户模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SYM_CODE_END</span>(ret_from_fork)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">NOKPROBE</span>(ret_from_fork)
</span></span></code></pre></div><p>  copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0   <br>
  </p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage __visible <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">schedule_tail</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__releases</span>(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* New tasks start with FORK_PREEMPT_COUNT, see there and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task_switch() for details.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task_switch() will drop rq-&gt;lock() and lower preempt_count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * and the preempt_enable() will end up enabling preemption (on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * PREEMPT_COUNT kernels).*/</span>
</span></span><span style="display:flex;"><span>	rq <span style="color:#f92672">=</span> <span style="color:#a6e22e">finish_task_switch</span>(prev);  <span style="color:#75715e">// 为上一个进程执行清理操作2.8.6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">balance_callback</span>(rq);  <span style="color:#75715e">// 执行运行队列的所有负载均衡回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">preempt_enable</span>();  <span style="color:#75715e">// 开启内核抢占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>set_child_tid)  <span style="color:#75715e">// pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">put_user</span>(<span style="color:#a6e22e">task_pid_vnr</span>(current), current<span style="color:#f92672">-&gt;</span>set_child_tid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">calculate_sigpending</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="252-装载程序">2.5.2 装载程序<a hidden class="anchor" aria-hidden="true" href="#252-装载程序">#</a></h3>
<p> 调度器调度新进程，新进程从函数<code>ret_from_fork</code>开始，从系统调用<code>fork</code>返回用户空间，返回值0。然后新进程使用系统调用<code>execve</code>装载程序。Linux内核练个装载程序系统调用：    \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 路径名是相对时execve解释为相对调用进程的当前工作目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">execve</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> argv[], <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> envp[]);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 路径名时绝对的，execveat忽略参数dirfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">execveat</span>(<span style="color:#66d9ef">int</span> dirfd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pathname, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> argv[], <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> envp[], <span style="color:#66d9ef">int</span> flags);
</span></span></code></pre></div><p>  参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值</p>
<p> 两个系统调用最终都调用函数do_execveat_common
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221102001015.png" alt="20221102001015"  />
</p>
<p>  函数do_open_execat打开可执行文件。   <br>
  函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器      <br>
  函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-&gt;p指向在栈底保留一个字长（指针长度）后的位置           <br>
  函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？      \
  依次把文件名称、环境字符串和参数字符串压到用户栈         <br>
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221102001840.png" alt="20221102001840"  />

  函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止</p>
<h4 id="1二进制格式">1.二进制格式<a hidden class="anchor" aria-hidden="true" href="#1二进制格式">#</a></h4>
<p> Linux二进制格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/include/linux/binfmts.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> linux_binfmt {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head lh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> module <span style="color:#f92672">*</span>module;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>load_binary)(<span style="color:#66d9ef">struct</span> linux_binprm <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>load_shlib)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>core_dump)(<span style="color:#66d9ef">struct</span> coredump_params <span style="color:#f92672">*</span>cprm);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> min_coredump;	<span style="color:#75715e">/* minimal dump size */</span>
</span></span><span style="display:flex;"><span>} __randomize_layout;
</span></span></code></pre></div><p> 二进制格式提供3个函数        <br>
  (1)load_binary 加载普通程序       <br>
  (2)load_shlib 加载共享库     <br>
  (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度     <br>
 二进制格式使用<code>register_binfmt</code>向内核注册</p>
<h4 id="2装载elf程序">2.装载ELF程序<a hidden class="anchor" aria-hidden="true" href="#2装载elf程序">#</a></h4>
<p> ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 <code>linux-5.10.102/include/uapi/linux/elf.h</code></p>
<ul>
<li>目标文件(可重定位文件)，<code>.o</code>，多个模板文件链接生成可执行文件或共享库</li>
<li>可执行文件</li>
<li>共享库 <code>.so</code></li>
<li>核心转储文件(core dump file)</li>
</ul>
<p> ELF文件分成4部分：<code>ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)</code>，ELF只有首部的位置是固定的。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103105503.png" alt="20221103105503"  />
</p>
<p>  程序首部表就是段表(segment table)，<code>段(segment)是从运行角度描述</code>，<code>节(section)是从链接角度描述</code>。    <br>
 64位ELF文件格式</p>
<p>参考链接：
ELF 格式详解 <a href="https://blog.csdn.net/shanandqiu/article/details/115206426">https://blog.csdn.net/shanandqiu/article/details/115206426</a>     <br>
ELF文件格式简介  <a href="https://blog.csdn.net/GrayOnDream/article/details/124564129">https://blog.csdn.net/GrayOnDream/article/details/124564129</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 查看ELF首部</span>
</span></span><span style="display:flex;"><span>readelf -h &lt;ELF文件&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看程序首部表</span>
</span></span><span style="display:flex;"><span>readelf -l &lt;ELF文件&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看节首部表</span>
</span></span><span style="display:flex;"><span>readelf -S &lt;ELF文件&gt;
</span></span></code></pre></div><p> ELF解析程序  <br>
  <code>linux-5.10.102/fs/binfmt_elf.c</code> 解析64位ELF程序，和处理器架构无关 <br>
  <code>linux-5.10.102/fs/compat_binfmt_elf.c</code>  在64位内核中解析32位ELF程序，和处理器架构无   \</p>
<p> 装载ELF程序函数<code>load_elf_binary</code></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103112822.png" alt="20221103112822"  />
</p>
<p>  1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构
  2）读取程序首部表
  3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。
  4）检查解释器的ELF首部，读取解释器的程序首部表
  5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间
  6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域
  7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈
  8）把可加载段映射到进程的虚拟地址空间
  9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段
  10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口
  11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈
  12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/processor.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread_common</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pc)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memset</span>(regs, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>regs));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">forget_syscall</span>(regs);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">=</span> pc; <span style="color:#75715e">/* 把程序计数器设置为程序的入口 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pc,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start_thread_common</span>(regs, pc);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">=</span> PSR_MODE_EL0t;  <span style="color:#75715e">/* 把处理器状态设置为0，其中异常级别是0 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spectre_v4_enable_task_mitigation</span>(current);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> sp;   <span style="color:#75715e">/*设置用户栈指针 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3装载脚本程序">3.装载脚本程序<a hidden class="anchor" aria-hidden="true" href="#3装载脚本程序">#</a></h4>
<p> 脚本程序前两个字节是<code>#!</code>，后面是解释器程序的名称和参数。解释器用来执行脚本程序
 <code>linux-5.10.102/fs/binfmt_script.c</code>函数<code>load_script</code>负责装载脚本程序</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103141127.png" alt="20221103141127"  />
</p>
<p>  1）检查前两个字节是不是脚本程序的标识符    <br>
  2）解析处解释程序的名称和参数      <br>
  3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈      <br>
  4）调用opens_exec打开解释程序文件       <br>
  5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区        <br>
  6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止     \</p>
<h2 id="26-进程退出">2.6 进程退出<a hidden class="anchor" aria-hidden="true" href="#26-进程退出">#</a></h2>
<p> 进程退出两种情况：进程主动退出和终止进程    <br>
 Linux内核两个主动退出的系统调用       \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exit</span>(<span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个线程组所有线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exit_group</span>(<span style="color:#66d9ef">int</span> status);
</span></span></code></pre></div><p> glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数        <br>
  终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给进程或进程组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kill</span>(<span style="color:#66d9ef">pid_t</span> pid, <span style="color:#66d9ef">int</span> sig);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给线程  已废弃
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tkill</span>(<span style="color:#66d9ef">int</span> tid, <span style="color:#66d9ef">int</span> sig);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tgkill</span>(<span style="color:#66d9ef">int</span> tgid, <span style="color:#66d9ef">int</span> tid, <span style="color:#66d9ef">int</span> sig);
</span></span></code></pre></div><p> 父进程是否关注子进程退出事假，
  1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。进程默认关注子进程退出事件，通过系统调用sigaction对信号SIGHLD设置标志SA_NOCLDWAIT(CLD是child)，子进程退出时不变成僵尸进程或设置忽略信号SIGCHLD    <br>
  2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 <br>
 Linux内核3个系统调用等待子进程状态改变：子进程终止、信号SIGSTOP使子进程停止执行或信号SIGCONT使子进程继续执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">pid_t</span> <span style="color:#a6e22e">waitpid</span>(<span style="color:#66d9ef">pid_t</span> pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>wstatus, <span style="color:#66d9ef">int</span> options);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">waitid</span>(<span style="color:#66d9ef">idtype_t</span> idtype, <span style="color:#66d9ef">id_t</span> id, <span style="color:#66d9ef">siginfo_t</span> <span style="color:#f92672">*</span>infop, <span style="color:#66d9ef">int</span> options);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pit_t</span> <span style="color:#a6e22e">wiat4</span>(<span style="color:#66d9ef">pit_t</span> pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>wstatus, <span style="color:#66d9ef">int</span> options, staruct usage <span style="color:#f92672">*</span>rusage);  <span style="color:#75715e">// 废弃
</span></span></span></code></pre></div><p> 父进程退出时，给子进程寻找领养者
  1）进程属于一个线程组，且还有其他线程，选择任意其他线程   <br>
  2）选择最亲近的充当&quot;替补领养者&quot;的祖先进程，进程使用系统调用prtctl(PR_SET_CHILD_SUBREAPER)设置为替换领养者     <br>
  3）选择所属进程号命名空间的1号进程      <br>
  </p>
<h3 id="261-线程组退出-exit_group">2.6.1 线程组退出 exit_group<a hidden class="anchor" aria-hidden="true" href="#261-线程组退出-exit_group">#</a></h3>
<p>  系统调用exit_group执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103145928.png" alt="20221103145928"  />
</p>
<p> 一个线程组的两个线程，线程1和线程2，线程1调用exit_group使线程组退出，线程1执行流程：
 1）把退出码保存在结构体成员group_exit_code中，传递给线程2    <br>
 2）给线程组设置正在退出标志     <br>
 3）向线程2发送杀死信号，唤醒线程2，线程2处理杀死信号    <br>
 4）线程1调用函数do_exit以退出    <br>
 线程2退出的执行流程，函数do_group_exit执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103151545.png" alt="20221103151545"  />
</p>
<p> 线程2可能发挥用户模式3种情况
 （1）执行完系统调用      <br>
 （2）被中断抢占，中断处理程序执行完    <br>
 （3）执行指令是生成异常，异常处理程序执行完     \</p>
<p> do_exit函数执行流程
 （1）释放各种资源，把资源引用计数减一，如果引用计数变为0，则释放数据结构   <br>
 （2）调用函数exit_notify，为子进程选择领养者，然后把自己死讯通知父进程   <br>
 （3）把进程状态设置为死亡(TASK_DEAD)     <br>
 （4）最后一次调用函数__schedule以调度进程    <br>
 死亡进程调用__schedule时进程调度器处理流程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__schedule</span>() <span style="color:#f92672">--&gt;</span> <span style="color:#a6e22e">context_switch</span>() <span style="color:#f92672">--&gt;</span> <span style="color:#a6e22e">finish_task_switch</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span><span style="color:#a6e22e">finish_task_switch</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">__releases</span>(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	prev_state <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>state;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(prev_state <span style="color:#f92672">==</span> TASK_DEAD)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_dead)
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">task_dead</span>(prev);  <span style="color:#75715e">// 执行调度类task_dead
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果结构体thread_info放在进程描述符里面，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 而不是放在内核栈的顶部，那么释放进程的内核栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">put_task_stack</span>(prev);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">put_task_struct</span>(prev);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="262-终止进程">2.6.2 终止进程<a hidden class="anchor" aria-hidden="true" href="#262-终止进程">#</a></h3>
<p> 系统调用kill向线程组或进程组发送信号linux-5.10.102/kernel/signal.c，执行流程
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103154752.png" alt="20221103154752"  />
</p>
<p> 函数__send_signal主要代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/signal.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__send_signal</span>(<span style="color:#66d9ef">int</span> sig, <span style="color:#66d9ef">struct</span> siginfo <span style="color:#f92672">*</span>info, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>t,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> group, <span style="color:#66d9ef">int</span> from_ancestor_ns)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sigpending <span style="color:#f92672">*</span>pending;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sigqueue <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> override_rlimit;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> TRACE_SIGNAL_IGNORED;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 目标线程忽略信号,不发送信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">prepare_signal</span>(sig, t,
</span></span><span style="display:flex;"><span>			from_ancestor_ns <span style="color:#f92672">||</span> (info <span style="color:#f92672">==</span> SEND_SIG_FORCED)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> ret;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 确定把信号添加到哪个信号队列和集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pending <span style="color:#f92672">=</span> group <span style="color:#f92672">?</span> <span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>shared_pending : <span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>pending;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> TRACE_SIGNAL_ALREADY_PENDING;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 传统信号，并且信号集合已经包含同一个信号,不发送
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">legacy_queue</span>(pending, sig))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断分配信号队列节点时是否可以忽略信号队列长度的限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (sig <span style="color:#f92672">&lt;</span> SIGRTMIN)
</span></span><span style="display:flex;"><span>		override_rlimit <span style="color:#f92672">=</span> (<span style="color:#a6e22e">is_si_special</span>(info) <span style="color:#f92672">||</span> info<span style="color:#f92672">-&gt;</span>si_code <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		override_rlimit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 分配一个信号队列节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	q <span style="color:#f92672">=</span> <span style="color:#a6e22e">__sigqueue_alloc</span>(sig, t, GFP_ATOMIC <span style="color:#f92672">|</span> __GFP_NOTRACK_FALSE_POSITIVE,
</span></span><span style="display:flex;"><span>		override_rlimit);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (q) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>list, <span style="color:#f92672">&amp;</span>pending<span style="color:#f92672">-&gt;</span>list); <span style="color:#75715e">// 添加到信号队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">is_si_special</span>(info)) {
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out_set:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">signalfd_notify</span>(t, sig);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sigaddset</span>(<span style="color:#f92672">&amp;</span>pending<span style="color:#f92672">-&gt;</span>signal, sig);  <span style="color:#75715e">// 信号添加到信号集合中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 在线程组中查找一个没有屏蔽信号的线程，唤醒它，让它处理信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">complete_signal</span>(sig, t, group); 
</span></span><span style="display:flex;"><span>ret:
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="263-查询子进程终止原因">2.6.3 查询子进程终止原因<a hidden class="anchor" aria-hidden="true" href="#263-查询子进程终止原因">#</a></h3>
<p> 系统调用waitid</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">waitid</span>(<span style="color:#66d9ef">idtype_t</span> idtype, <span style="color:#66d9ef">id_t</span> id, <span style="color:#66d9ef">siginfo_t</span> <span style="color:#f92672">*</span>infop, <span style="color:#66d9ef">int</span> options);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pid_t</span> <span style="color:#a6e22e">waitpid</span>(<span style="color:#66d9ef">pid_t</span> pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>wstatus, <span style="color:#66d9ef">int</span> options);
</span></span></code></pre></div><table>
	<tr>
	    <th>参数</th>
	    <th>参数值</th>
	    <th>含义</th>  
	</tr >
	<tr >
	    <td rowspan="3">idtype</td>
	    <td>P_ALL</td>
	    <td>等待任意子进程，忽略参数id</td>
	</tr>
	<tr>
	    <td>P_PID</td>
	    <td>等待进程号为id的子进程</td>
	</tr>
	<tr>
	    <td>P_PGID</td>
	    <td>等待进程组标识符是id的任意子进程</td>
	</tr>
	<tr >
	    <td rowspan="5">options</td>
	    <td>WEXITED</td>
	    <td>等待退出的子进程</td>
	</tr>
	<tr>
	    <td >WSTOPPED</td>
	    <td>等待收到信号SIGSTOP并停止执行的子进程</td>
	</tr>
	<tr>
	    <td >WCONTINUED</td>
	    <td >等待收到信号SIGCONT并继续执行的子进程</td>
	</tr>
	<tr>
	    <td >WNOHANG</td>
	    <td >如果没有子进程退出，立即返回</td>
	</tr>
	<tr>
	    <td >WNOWAIT</td>
	    <td >让子进程处于僵尸状态，以后可以再次查询状态信息</td>
	</tr>
</table>
<p> do_wait函数执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103162302.png" alt="20221103162302"  />
</p>
<h2 id="27-进程状态">2.7 进程状态<a hidden class="anchor" aria-hidden="true" href="#27-进程状态">#</a></h2>
<table>
	<tr>
	    <th>状态</th>
	    <th>state</th>
	    <th>含义</th>  
	</tr >
	<tr >
	    <td>就绪状态</td>
	    <td>TASK_RUNNING</td>
	    <td>正在运行队列中等待调度器调度</td>
	</tr>
	<tr>
	    <td>运行状态</td>
	    <td>TASK_RUNNING</td>
	    <td>被调度器选中，正在处理器上运行</td>
	</tr>
	<tr>
	    <td>轻度睡眠</td>
	    <td>TASK_INTERRUPTIBLE</td>
	    <td>可信号打断的睡眠状态</td>
	</tr>
	<tr >
	    <td>中度睡眠</td>
	    <td>TASK_KILLABLE</td>
	    <td>只能被致命的信号打断</td>
	</tr>
	<tr>
	    <td>深度睡眠</td>
	    <td>TASK_UNINTERRUPTIBLE</td>
	    <td>不可打断的睡眠状态</td>
	</tr>
	<tr>
	    <td>僵尸状态</td>
	    <td>TASK_DEAD</td>
	    <td>被调度器选中，正在处理器上运行</td>
	</tr>
	<tr>
	    <td>死亡状态</td>
	    <td>TASK_DEAD</td>
	    <td>如果父进程不关注子进程退出事件，那么子进程退出时自动消亡</td>
	</tr>
</table>
<p> 进程状态变迁
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103163416.png" alt="20221103163416"  />
</p>
<h2 id="28-进程调度">2.8 进程调度<a hidden class="anchor" aria-hidden="true" href="#28-进程调度">#</a></h2>
<h3 id="281-调度策略">2.8.1 调度策略<a hidden class="anchor" aria-hidden="true" href="#281-调度策略">#</a></h3>
<p> Linux内核支持的调度策略
 （1）限制进程使用限期调度策略(SCHED_DEADLINE)，3个参数：运行时间runtime，截止期限deadline和周期period    <br>
 （2）实时进程支持两种调度策略：先进先出调度(SCHED_FIFO)和轮流调度(SCHED_RR)   <br>
 （3）普通进程两种调度策略：标准轮流分时(SCHED_NORMAL)和空闲(SCHED_BATCH)，Linux内核引入完全公平调度算法后，批量调度策略废弃。     \</p>
<h3 id="282-进程优先级">2.8.2 进程优先级<a hidden class="anchor" aria-hidden="true" href="#282-进程优先级">#</a></h3>
<p> 限期进程的优先级比实时进程高，实时进程的优先级比普通进程高。  <br>
 限期进程的优先级是−1。        <br>
 实时进程的实时优先级是1～99，优先级数值越大，表示优先级越高。    <br>
 普通进程的静态优先级是100～139，优先级数值越小，表示优先级越高，可通过修改nice值（即相对优先级，取值范围是−20～19）改变普通进程的优先级，优先级等于120加上nice值   <br>
 task_struct中，4个成员和优先级有关   \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>sched.h
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> task_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>                  prio;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>                  static_prio;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>                  normal_prio;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>         rt_priority;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><table>
	<tr>
	    <th>优先级</th>
	    <th>限期进程</th>
	    <th>实时进程</th>  
	    <th>普通进程</th>  
	</tr >
	<tr >
	    <td>prio<br>调度优先级(数值越小，表示优先级越高)</td>
	    <td colspan="3">大多数prio等于normal_prio</td>
	</tr>
	<tr>
	    <td>static_prio<br>静态优先级</td>
	    <td>总是0</td>
	    <td>总是0</td>
	    <td>120 + nice值数值越小，<br>表示优先级越高</td>
	</tr>
	<tr>
	    <td>normal_prio<br>正常优先级(数值越小，表示优先级越高)</td>
	    <td>-1</td>
	    <td>99 − rt_priority</td>
	    <td>static_prio</td>
	</tr>
		<tr>
	    <td>实时优先级</td>
	    <td>总是0</td>
	    <td>值越大，优先级越高</td>
	    <td> </td>
	</tr>
</table>
<h3 id="283-调度类">2.8.3 调度类<a hidden class="anchor" aria-hidden="true" href="#283-调度类">#</a></h3>
<p> Linux内核抽象一个调度类<code>sched_class</code>，目前实现5种调度类，优先级从上到下从高到低：</p>
<table>
	<tr>
	    <th>调度类</th>
	    <th>调度策略</th>
	    <th>调度算法</th>  
	    <th>调度对象</th>  
	</tr >
	<tr >
	    <td>停机调度类<br>stop_sched_class</td>
	    <td>无</td>
	    <td>无</td>
	    <td>停机进程</td>
	</tr>
	<tr>
	    <td>限期调度类<br>dl_sched_class</td>
	    <td>SCHED_DEADLINE</td>
	    <td>最早期限优先</td>
	    <td>限期进程</td>
	</tr>
	<tr>
	    <td>实时调度类<br>rt_sched_class</td>
	    <td>SCHED_FIFO<br>SCHED_RR</td>
	    <td>先进先出<br>轮流调度</td>
	    <td>实时进程</td>
	</tr>
		<tr>
	    <td>公平调度类<br>cfs_sched_class</td>
	    <td>SCHED_NORMAL<br>SCHED_IDIE</td>
	    <td>完全公平调度算法</td>
	    <td>普通进程</td>
	</tr>
	</tr>
		<tr>
	    <td>空闲调度类<br>idle_sched_class</td>
	    <td>无</td>
	    <td>无</td>
	    <td>每个处理器上的空闲线程</td>
	</tr>
</table>
<p> 详细信息参考书籍</p>
<h3 id="284-运行队列">2.8.4 运行队列<a hidden class="anchor" aria-hidden="true" href="#284-运行队列">#</a></h3>
<p> 每个处理器有一个运行队列，结构体rq，定义全局变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/cpuacct.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DEFINE_PER_CPU_SHARED_ALIGNED</span>(<span style="color:#66d9ef">struct</span> rq, runqueues);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/sched.h  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> rq { <span style="color:#75715e">// 运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cfs_rq		cfs;  <span style="color:#75715e">// 公平运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> rt_rq		rt;   <span style="color:#75715e">// 实时运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> dl_rq		dl;   <span style="color:#75715e">// 限期运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct	<span style="color:#f92672">*</span>idle;  <span style="color:#75715e">// 空闲线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct	<span style="color:#f92672">*</span>stop;  <span style="color:#75715e">// 迁移线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="285-任务分组">2.8.5 任务分组<a hidden class="anchor" aria-hidden="true" href="#285-任务分组">#</a></h3>
<h4 id="1任务分组方式">1.任务分组方式<a hidden class="anchor" aria-hidden="true" href="#1任务分组方式">#</a></h4>
<table>
	<tr>
	    <th>任务分组方式</th>
	    <th>控制宏</th>
	    <th>配置方式</th>  
	</tr >
	<tr >
	    <td>自动组</td>
	    <td>CONFIG_SCHED_AUTOGROUP</td>
	    <td>/proc/sys/kernel/sched_autogroup_enabled <br>运行过程中开启关闭，默认值1<br>源文件kernel/sched/auto_group.c</td>
	</tr>
	<tr>
	    <td>CPU控制组版本1</td>
	    <td>CONFIG_CGROUPS<br>CONFIG_CGROUP_SCHED</td>
	    <td>mount -t tmpfs cgroup_root /sys/fs/cgroup<br>mkdir /sys/fs/cgroup/cpu<br>mount -t cgroup -o cpu none /sys/fs/cgroup/cpu<br>cd /sys/fs/cgroup/cpu<br>mkdir multimedia  # 创建"multimedia"任务组<br>mkdir browser     # 创建"browser"任务组<br>echo 2048 > multimedia/cpu.shares<br>echo 1024 > browser/cpu.shares<br>echo < pid1> > browser/tasks <br>echo < pid2> > multimedia/tasks<br>echo < pid1> > browser/cgroup.procs<br>echo < pid2> > multimedia/cgroup.procs</td>
	</tr>
	<tr>
	    <td>cgroup版本2</td>
	    <td> </td>
	    <td>mount -t tmpfs cgroup_root /sys/fs/cgroup<br>mount -t cgroup2  none /sys/fs/cgroup<br>cd /sys/fs/cgroup <br>
echo "+cpu" > cgroup.subtree_control<br>mkdir multimedia   # 创建"multimedia"任务组 <br>mkdir browser      # 创建"browser"任务组<br>echo 2048 > multimedia/cpu.weight<br>echo 1024 > browser/cpu.weight<br>echo < pid1> > browser/cgroup.procs<br>echo < pid2> > multimedia/cgroup.procs <br>echo threaded > browser/cgroup.type <br> echo < pid1> > browser/cgroup.threads <br>echo threaded > multimedia/cgroup.type <br>echo < pid2> > multimedia/cgroup.threads
</td>
	</tr>
</table>
<h4 id="2-数据结构">2. 数据结构<a hidden class="anchor" aria-hidden="true" href="#2-数据结构">#</a></h4>
<p> task_group,默认任务组是更任务组(全局变量root_task_group)</p>
<table>
	<tr>
	    <th>成员</th>
	    <th>说明</th>
	</tr >
	<tr >
	    <td>const struct sched_class *sched_class</td>
	    <td>调度类</td>
	</tr>
	<tr >
	    <td>struct sched_entity se</td>
	    <td>公平调度实体</td>
	</tr>
		<tr >
	    <td>struct sched_dl_entity dl</td>
	    <td>限期调度实体</td>
	</tr>
</table>
<p> 任务组在每个处理器上有公平调度实体、公平运行队列、实时调度实体和实时运行队列，根任务组比较特殊：没有公平调度实体和实时调度实体</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221104104612.png" alt="20221104104612"  />
</p>
<p> 每个处理器上，计算任务组的公平调度实体的权重的方法如下（参考源文件“kernel/ sched/fair.c”中的函数update_cfs_shares</p>
<h3 id="286-调度进程">2.8.6 调度进程<a hidden class="anchor" aria-hidden="true" href="#286-调度进程">#</a></h3>
<p> 调度进程的核心函数是<code>__schedule()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>kernel<span style="color:#f92672">/</span>sched<span style="color:#f92672">/</span>core.c
</span></span><span style="display:flex;"><span><span style="color:#75715e">// preempt是否抢占，true抢占调度，false主动调度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __sched notrace <span style="color:#a6e22e">__schedule</span>(<span style="color:#66d9ef">bool</span> preempt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">1.</span> <span style="color:#960050;background-color:#1e0010">调用</span>pick_next_task<span style="color:#960050;background-color:#1e0010">选择下一个进程</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">2.</span> <span style="color:#960050;background-color:#1e0010">调用</span>context_switch<span style="color:#960050;background-color:#1e0010">切换进程</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="1选择下一个进程-函数pick_next_task">1.选择下一个进程 函数pick_next_task<a hidden class="anchor" aria-hidden="true" href="#1选择下一个进程-函数pick_next_task">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pick_next_task</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev, <span style="color:#66d9ef">struct</span> rq_flags <span style="color:#f92672">*</span>rf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sched_class <span style="color:#f92672">*</span>class;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Optimization: we know that if all tasks are in the fair class we can
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * call that function directly, but only if the @prev task wasn&#39;t of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * higher scheduling class, because otherwise those loose the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * opportunity to pull in more work from other CPUs.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 优化：如果所有进程属于公平调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 直接调用公平调度类的pick_next_task方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(prev<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">&amp;</span>fair_sched_class <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		   rq<span style="color:#f92672">-&gt;</span>nr_running <span style="color:#f92672">==</span> rq<span style="color:#f92672">-&gt;</span>cfs.h_nr_running)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		p <span style="color:#f92672">=</span> <span style="color:#a6e22e">pick_next_task_fair</span>(rq, prev, rf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(p <span style="color:#f92672">==</span> RETRY_TASK))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> restart;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 假定公平调度类的下一个调度类是空闲调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">put_prev_task</span>(rq, prev);
</span></span><span style="display:flex;"><span>			p <span style="color:#f92672">=</span> <span style="color:#a6e22e">pick_next_task_idle</span>(rq);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>restart:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_prev_task_balance</span>(rq, prev, rf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">for_each_class</span>(class) {
</span></span><span style="display:flex;"><span>		p <span style="color:#f92672">=</span> class<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">pick_next_task</span>(rq);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (p)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* The idle class should always have a runnable task: */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 空闲调度类应该总是有一个运行的进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">BUG</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>待补充</p>
</blockquote>
<h4 id="2切换进程-context_switch">2.切换进程 context_switch<a hidden class="anchor" aria-hidden="true" href="#2切换进程-context_switch">#</a></h4>
<blockquote>
<p>1）switch_mm_irqs_off负责切换进程的用户虚拟地址空间
2）switch_to切换处理器的寄存器</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">context_switch</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev,
</span></span><span style="display:flex;"><span>	       <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>next, <span style="color:#66d9ef">struct</span> rq_flags <span style="color:#f92672">*</span>rf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prepare_task_switch</span>(rq, prev, next); <span style="color:#75715e">// 准备工作，调用prepare_arch_switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* For paravirt, this is coupled with an exit in switch_to to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * combine the page table reload and the switch backend into
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * one hypercall. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 开始上下文切换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">arch_start_context_switch</span>(prev);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * kernel -&gt; kernel   lazy + transfer active
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   user -&gt; kernel   lazy + mmgrab() active
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * kernel -&gt;   user   switch + mmdrop() active
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   user -&gt;   user   switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next<span style="color:#f92672">-&gt;</span>mm) {                 <span style="color:#75715e">// to kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 通知处理器架构不需要切换用户虚拟地址空间，加速进程切换的技术称为惰性TLB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">enter_lazy_tlb</span>(prev<span style="color:#f92672">-&gt;</span>active_mm, next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		next<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>active_mm;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (prev<span style="color:#f92672">-&gt;</span>mm)     <span style="color:#75715e">// from user 切换进程的用户虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">mmgrab</span>(prev<span style="color:#f92672">-&gt;</span>active_mm);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {                                        <span style="color:#75715e">// to user
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">membarrier_switch_mm</span>(rq, prev<span style="color:#f92672">-&gt;</span>active_mm, next<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * sys_membarrier() requires an smp_mb() between setting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * The below provides this either through switch_mm(), or in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * case &#39;prev-&gt;active_mm == next-&gt;mm&#39; through
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * finish_task_switch()&#39;s mmdrop().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">switch_mm_irqs_off</span>(prev<span style="color:#f92672">-&gt;</span>active_mm, next<span style="color:#f92672">-&gt;</span>mm, next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prev<span style="color:#f92672">-&gt;</span>mm) {                        <span style="color:#75715e">// from kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">/* will mmdrop() in finish_task_switch(). */</span>
</span></span><span style="display:flex;"><span>			rq<span style="color:#f92672">-&gt;</span>prev_mm <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>active_mm;
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rq<span style="color:#f92672">-&gt;</span>clock_update_flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>(RQCF_ACT_SKIP<span style="color:#f92672">|</span>RQCF_REQ_SKIP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prepare_lock_switch</span>(rq, next, rf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Here we just switch the register state and the stack. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 只切换寄存器状态和栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">switch_to</span>(prev, next, prev);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">finish_task_switch</span>(prev);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （1）切换用户虚拟地址空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ARM64架构使用switch_mm_irqs_off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>mmu_context.h
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef switch_mm_irqs_off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define switch_mm_irqs_off switch_mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>  switch_mm函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/mmu_context.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">switch_mm</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>prev, <span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>next,
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (prev <span style="color:#f92672">!=</span> next)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__switch_mm</span>(next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Update the saved TTBR0_EL1 of the scheduled-in task as the previous
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * value may have not been initialised yet (activate_mm caller) or the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * ASID has changed since the last run (following the context switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * of another thread of the same process).*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 更新调入进程保存的寄存器TTBR0_EL1值，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 因为可能还没有初始化（调用者是函数activate_mm），
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 或者ASID自从上次运行以来已经改变（在同一个线程组的另一个线程切换上下文以后）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 避免把保留的寄存器TTBR0_EL1值设置为swapper_pg_dir（init_mm；例如通过函数idle_task_exit）*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">update_saved_ttbr0</span>(tsk, next);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__switch_mm</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>next)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*init_mm.pgd does not contain any user mappings and it is always
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * active for kernel addresses in TTBR1. Just set the reserved TTBR0.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*init_mm.pgd没有包含任何用户虚拟地址的映射，对于TTBR1的内核虚拟地址总是有效的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 只设置保留的TTBR0 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (next <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>init_mm) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cpu_set_reserved_ttbr0</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为进程分配地址空间标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">check_and_switch_context</span>(next);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>待补充</p>
</blockquote>
<p> （2）切换寄存器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/include/asm-generic/switch_to.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define switch_to(prev, next, last)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	do {								\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		((last) = __switch_to((prev), (next)));			\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	} while (0)
</span></span></span></code></pre></div><p> 函数__switch_to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>__notrace_funcgraph <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">__switch_to</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>next)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>last;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fpsimd_thread_switch</span>(next);  <span style="color:#75715e">// 切换浮点寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tls_thread_switch</span>(next);  <span style="color:#75715e">// 切换本地存储相关的寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">hw_breakpoint_thread_switch</span>(next);  <span style="color:#75715e">// 切换吊事寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">contextidr_thread_switch</span>(next);  <span style="color:#75715e">// 把上下文标识符寄存器CONTEXTIDR_EL1设置为下一个进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">entry_task_switch</span>(next);  <span style="color:#75715e">// 使用处理器变量__entry_task记录下一个进程描述符的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">uao_thread_switch</span>(next);  <span style="color:#75715e">// 根据下一个进程可访问的虚拟地址空间上限恢复用户访问覆盖（User Access Override，UAO）状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ssbs_thread_switch</span>(next);  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">erratum_1418040_thread_switch</span>(next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Complete any pending TLB or cache maintenance on this CPU in case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * the thread migrates to a different CPU.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * This full barrier is also required by the membarrier system
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * call.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在这个处理器上执行完前面的所有页表缓存或者缓存维护操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 以防线程迁移到其他处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 数据同步屏障，确保屏障前面的缓存维护操作和页表缓存维护操作执行完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dsb</span>(ish);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* MTE thread switching must happen after the DSB above to ensure that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * any asynchronous tag check faults have been logged in the TFSR*_EL1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * registers.*/</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mte_thread_switch</span>(next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* the actual thread switch */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 实际线程切换  切换通用寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	last <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpu_switch_to</span>(prev, next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> last;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 1）切换浮点寄存器，函数fpsimd_thread_switch负责切换浮点，内核不允许使用浮点数，只有用户空间可以使用浮点数,切换出去的进程把浮点寄存器的值保存在进程描述符的成员thread.fpsimd_state中。ARM64架构实现的linux-5.10.102/arch/arm64/kernel/fpsimd.c函数fpsimd_thread_switch   \
 2）切换通用寄存器，</p>
<ul>
<li>被调用函数负责保存的寄存器x19～x28</li>
<li>寄存器x29，即帧指针（Frame Pointer，FP）寄存器</li>
<li>栈指针（Stack Pointer，SP）寄存器</li>
<li>寄存器x30，即链接寄存器（Link Register，LR），它存放函数的返回地址</li>
<li>用户栈指针寄存器SP_EL0，内核使用它存放当前进程的进程描述符的第一个成员thread_info的地址</li>
</ul>
<p>  cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SYM_FUNC_START</span>(cpu_switch_to)
</span></span><span style="display:flex;"><span>	mov	x10, <span style="color:#960050;background-color:#1e0010">#</span>THREAD_CPU_CONTEXT  <span style="color:#75715e">// cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	add	x8, x0, x10  <span style="color:#75715e">// x8存放上一个进程的进程描述符的成员thread.cpu_context的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mov	x9, sp  <span style="color:#75715e">// x9保存栈指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x19, x20, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>		<span style="color:#75715e">// store callee-saved registers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x21, x22, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 把上一个进程的寄存器x19～x28、x29、SP和LR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x23, x24, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 保存到上一个进程的进程描述符的成员thread.cpu_context中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x25, x26, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x27, x28, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	stp	x29, x9, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  
</span></span><span style="display:flex;"><span>	str	lr, [x8]  <span style="color:#75715e">// LR存放函数的返回地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	add	x8, x1, x10  <span style="color:#75715e">// x8存放下一个进程的进程描述符的成员thread.cpu_context的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x19, x20, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>		<span style="color:#75715e">// restore callee-saved registers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x21, x22, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 使用下一个进程的进程描述符的成员thread.cpu_context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x23, x24, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 保存的值恢复下一个进程的寄存器x19～x28、x29、SP和LR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x25, x26, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	ldp	x27, x28, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	ldp	x29, x9, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	ldr	lr, [x8]
</span></span><span style="display:flex;"><span>	mov	sp, x9
</span></span><span style="display:flex;"><span>	msr	sp_el0, x1  <span style="color:#75715e">// 用户栈指针寄存器SP_EL0设置为下一个进程的进程描述符的第一个成员thread_info的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ptrauth_keys_install_kernel x1, x8, x9, x10
</span></span><span style="display:flex;"><span>	scs_save x0, x8  <span style="color:#75715e">// 函数返回，返回值是寄存器x0的值：上一个进程的进程描述符的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	scs_load x1, x8
</span></span><span style="display:flex;"><span>	ret
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SYM_FUNC_END</span>(cpu_switch_to)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">NOKPROBE</span>(cpu_switch_to)
</span></span></code></pre></div><p>  cpu_switch_to切换通用寄存器的过程，从进程prev切换到进程next。进程prev把通用寄存器的值保存在进程描述符的成员thread.cpu_context中，然后进程next从进程描述符的成员thread.cpu_context恢复通用寄存器的值，使用用户栈指针寄存器SP_EL0存放进程next的进程描述符的成员thread_info的地址    \</p>
<center>ARM64架构切换通用寄存器</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/2022-11-05_21-28.png" alt="2022-11-05_21-28"  />
</p>
<p> 链接寄存器存放函数的返回地址，函数cpu_switch_to把链接寄存器设置为进程描述符的成员thread.cpu_context.pc，进程被调度后从返回地址开始执行   <br>
进程的返回地址分为以下两种情况:</p>
<ul>
<li>创建的新进程，函数copy_thread把进程描述符的成员thread.cpu_context.pc设置为函数ret_from_fork的地址</li>
<li>其他情况，返回地址是函数context_switch中调用函数cpu_switch_to之后的一行代码：“last = 函数cpu_switch_to的返回值”，返回地址记录在进程描述符的成员thread.cpu_context.pc中</li>
</ul>
<p> （3）清理工作
  函数finish_task_switch在从进程prev切换到进程next后为进程prev执行清理工作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span><span style="color:#a6e22e">finish_task_switch</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__releases</span>(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq <span style="color:#f92672">=</span> <span style="color:#a6e22e">this_rq</span>();  <span style="color:#75715e">// rq是当前处理器的运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> rq<span style="color:#f92672">-&gt;</span>prev_mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">long</span> prev_state;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*  The previous task will have left us with a preempt_count of 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * because it left us after:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	schedule()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	  preempt_disable();			// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	  __schedule()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Also, see FORK_PREEMPT_COUNT.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">WARN_ONCE</span>(<span style="color:#a6e22e">preempt_count</span>() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>PREEMPT_DISABLE_OFFSET,
</span></span><span style="display:flex;"><span>		      <span style="color:#e6db74">&#34;corrupted preempt_count: %s/%d/0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>		      current<span style="color:#f92672">-&gt;</span>comm, current<span style="color:#f92672">-&gt;</span>pid, <span style="color:#a6e22e">preempt_count</span>()))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">preempt_count_set</span>(FORK_PREEMPT_COUNT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rq<span style="color:#f92672">-&gt;</span>prev_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* A task struct has one reference for the use as &#34;current&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * schedule one last time. The schedule call will never return, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * the scheduled task must drop that reference.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task), otherwise a concurrent wakeup can get prev
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * running on another CPU and we could rave with its RUNNING -&gt; DEAD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * transition, resulting in a double drop.*/</span>
</span></span><span style="display:flex;"><span>	prev_state <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>state;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">vtime_task_switch</span>(prev);  <span style="color:#75715e">// 计算进程prev的时间统计
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">perf_event_task_sched_in</span>(prev, current);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">finish_task</span>(prev);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把prev-&gt;on_cpu设置为0，表示进程prev没有在处理器上运行；然后释放运行队列的锁，开启硬中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">finish_lock_switch</span>(rq); 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">finish_arch_post_lock_switch</span>(); <span style="color:#75715e">// 执行处理器架构特定的清理工作,ARM64为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kcov_finish_switch</span>(current);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fire_sched_in_preempt_notifiers</span>(current);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* When switching through a kernel thread, the loop in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * membarrier_{private,global}_expedited() may have observed that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * kernel thread and not issued an IPI. It is therefore possible to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * schedule between user-&gt;kernel-&gt;user threads without passing though
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * switch_mm(). Membarrier requires a barrier after storing to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * rq-&gt;curr, before returning to userspace, so provide them here:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   provided by mmdrop(),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * - a sync_core for SYNC_CORE.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (mm) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">membarrier_mm_sync_core_before_usermode</span>(mm);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mmdrop</span>(mm);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(prev_state <span style="color:#f92672">==</span> TASK_DEAD)) { <span style="color:#75715e">// 进程主动退出或者被终止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_dead)
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">task_dead</span>(prev); <span style="color:#75715e">// 所属调度类的task_dead方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* * Remove function-return probe instances associated with this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * task and put them back on the free list.*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">kprobe_flush_task</span>(prev);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Task is done with its stack. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*释放进程的内核栈 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_task_stack</span>(prev);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">put_task_struct_rcu_user</span>(prev);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tick_nohz_task_switch</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> rq;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="287-调度时机">2.8.7 调度时机<a hidden class="anchor" aria-hidden="true" href="#287-调度时机">#</a></h3>
<blockquote>
<p>调度进程的时机: <br>
（1）进程主动调用<code>schedule()</code>函数
（2）周期性地调度，抢占当前进程，强迫当前进程让出处理器
（3）唤醒进程的时候，被唤醒的进程可能抢占当前进程
（4）创建新进程的时候，新进程可能抢占当前进程。</p>
</blockquote>
<h4 id="1主动调度">1.主动调度<a hidden class="anchor" aria-hidden="true" href="#1主动调度">#</a></h4>
<p> 内核中3种主动调度方式：
 （1）直接调用<code>schedule()</code>函数来调度进程
 （2）调用有条件重调度函数cond_resched()。非抢占式内核中，函数cond_resched()判断当前进程是否设置了需要重新调度的标志，如果设置了，就调度进程；抢占式内核中，cond_resched()为空
 （3）如果需要等待某个资源，例如互斥锁或信号量，那么把进程的状态设置为睡眠状态，然后调用schedule()函数以调度进程</p>
<h4 id="2周期调度">2.周期调度<a hidden class="anchor" aria-hidden="true" href="#2周期调度">#</a></h4>
<p> 周期调度的函数是scheduler_tick()，它调用当前进程所属调度类的task_tick方法。
 （1）限期调度类的周期调度   <br>
 task_tick &ndash;&gt; task_tick_dl &ndash;&gt; update_curr_dl</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/deadline.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_curr_dl</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>curr <span style="color:#f92672">=</span> rq<span style="color:#f92672">-&gt;</span>curr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_dl_entity <span style="color:#f92672">*</span>dl_se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>curr<span style="color:#f92672">-&gt;</span>dl;
</span></span><span style="display:flex;"><span>	u64 delta_exec, scaled_delta_exec;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	delta_exec <span style="color:#f92672">=</span> now <span style="color:#f92672">-</span> curr<span style="color:#f92672">-&gt;</span>se.exec_start;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>((s64)delta_exec <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(dl_se<span style="color:#f92672">-&gt;</span>dl_yielded))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> throttle;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	dl_se<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">-=</span> scaled_delta_exec; <span style="color:#75715e">// 计算限期进程的剩余运行时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>throttle:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// // 如果限期进程用完了运行时间或者主动让出处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dl_runtime_exceeded</span>(dl_se) <span style="color:#f92672">||</span> dl_se<span style="color:#f92672">-&gt;</span>dl_yielded) { 
</span></span><span style="display:flex;"><span>		dl_se<span style="color:#f92672">-&gt;</span>dl_throttled <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 设置节流标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* If requested, inform the user about runtime overruns. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dl_runtime_exceeded</span>(dl_se) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    (dl_se<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SCHED_FLAG_DL_OVERRUN))
</span></span><span style="display:flex;"><span>			dl_se<span style="color:#f92672">-&gt;</span>dl_overrun <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__dequeue_task_dl</span>(rq, curr, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">is_dl_boosted</span>(dl_se) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">start_dl_timer</span>(curr)))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">enqueue_task_dl</span>(rq, curr, ENQUEUE_REPLENISH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">is_leftmost</span>(curr, <span style="color:#f92672">&amp;</span>rq<span style="color:#f92672">-&gt;</span>dl))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">resched_curr</span>(rq);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （2）实时调度类的周期调度   \</p>
<p> 实时调度类的task_tick方法是函数task_tick_rt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/rt.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task_tick_rt</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> queued)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_rt_entity <span style="color:#f92672">*</span>rt_se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>rt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">!=</span> SCHED_RR) <span style="color:#75715e">// 调度策略不是轮流调度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把时间片减一，如果没用完时间片，那么返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>p<span style="color:#f92672">-&gt;</span>rt.time_slice)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 用完了时间片，那么重新分配时间片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>rt.time_slice <span style="color:#f92672">=</span> sched_rr_timeslice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Requeue to the end of queue if we (and all of our ancestors) are not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * the only element on the queue */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">for_each_sched_rt_entity</span>(rt_se) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (rt_se<span style="color:#f92672">-&gt;</span>run_list.prev <span style="color:#f92672">!=</span> rt_se<span style="color:#f92672">-&gt;</span>run_list.next) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">requeue_task_rt</span>(rq, p, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">resched_curr</span>(rq);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （3）公平调度类的周期调度     <br>
 公平调度类的task_tick方法是函数task_tick_fair</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task_tick_fair</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>curr, <span style="color:#66d9ef">int</span> queued)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>curr<span style="color:#f92672">-&gt;</span>se;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">for_each_sched_entity</span>(se) {
</span></span><span style="display:flex;"><span>		cfs_rq <span style="color:#f92672">=</span> <span style="color:#a6e22e">cfs_rq_of</span>(se);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">entity_tick</span>(cfs_rq, se, queued);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">entity_tick</span>(<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq, <span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>curr, <span style="color:#66d9ef">int</span> queued)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cfs_rq<span style="color:#f92672">-&gt;</span>nr_running <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 公平运行队列的进程数量超过1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">check_preempt_tick</span>(cfs_rq, curr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">check_preempt_tick</span>(<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq, <span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>curr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> ideal_runtime, delta_exec;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se;
</span></span><span style="display:flex;"><span>	s64 delta;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ideal_runtime <span style="color:#f92672">=</span> <span style="color:#a6e22e">sched_slice</span>(cfs_rq, curr);
</span></span><span style="display:flex;"><span>	delta_exec <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>sum_exec_runtime <span style="color:#f92672">-</span> curr<span style="color:#f92672">-&gt;</span>prev_sum_exec_runtime;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta_exec <span style="color:#f92672">&gt;</span> ideal_runtime) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">resched_curr</span>(<span style="color:#a6e22e">rq_of</span>(cfs_rq));
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* The current task ran long enough, ensure it doesn&#39;t get
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * re-elected due to buddy favours.*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">clear_buddies</span>(cfs_rq, curr);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Ensure that a task that missed wakeup preemption by a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * narrow margin doesn&#39;t have to wait for a full slice.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * This also mitigates buddy induced latencies under load.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta_exec <span style="color:#f92672">&lt;</span> sysctl_sched_min_granularity)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	se <span style="color:#f92672">=</span> <span style="color:#a6e22e">__pick_first_entity</span>(cfs_rq);
</span></span><span style="display:flex;"><span>	delta <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>vruntime <span style="color:#f92672">-</span> se<span style="color:#f92672">-&gt;</span>vruntime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta <span style="color:#f92672">&gt;</span> ideal_runtime)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">resched_curr</span>(<span style="color:#a6e22e">rq_of</span>(cfs_rq));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （4）中断返回时调度。
 ARM64架构的中断处理程序的入口是e10_irq，中断处理程序执行完以后，跳转到标号ret_to_user以返回用户模式。标号ret_to_user判断当前进程的进程描述符的成员thread_info.flags有没有设置标志位集合_TIF_WORK_MASK中的任何一个标志位，如果设置了其中一个标志位，那么跳转到标号work_pending，标号work_pending调用函数do_notify_resume</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S  5.10.102 代码中没有？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ret_to_user:
</span></span><span style="display:flex;"><span>     disable_irq                   <span style="color:#75715e">// 禁止中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ldr  x1, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]
</span></span><span style="display:flex;"><span>     and  x2, x1, <span style="color:#960050;background-color:#1e0010">#</span>_TIF_WORK_MASK
</span></span><span style="display:flex;"><span>     cbnz x2, work_pending
</span></span><span style="display:flex;"><span>finish_ret_to_user:
</span></span><span style="display:flex;"><span>     enable_step_tsk x1, x2
</span></span><span style="display:flex;"><span>     kernel_exit <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(ret_to_user)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>work_pending:
</span></span><span style="display:flex;"><span>     mov  x0, sp
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      * 寄存器x0存放第一个参数regs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      * 寄存器x1存放第二个参数task_struct.thread_info.flags
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      */</span>
</span></span><span style="display:flex;"><span>     bl  do_notify_resume
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_TRACE_IRQFLAGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     bl  trace_hardirqs_on         <span style="color:#75715e">// 在用户空间执行时开启中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ldr x1, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]  <span style="color:#75715e">// 重新检查单步执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     b   finish_ret_to_user
</span></span></code></pre></div><p> 函数do_notify_resume判断当前进程的进程描述符的成员thread_info.flags有没有设置需要重新调度的标志位_TIF_NEED_RESCHED，如果设置了，那么调用函数schedule()以调度进程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/signal.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_notify_resume</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>                         <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> thread_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_NEED_RESCHED) {
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">schedule</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">local_irq_disable</span>();
</span></span><span style="display:flex;"><span>        thread_flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">READ_ONCE</span>(<span style="color:#a6e22e">current_thread_info</span>()<span style="color:#f92672">-&gt;</span>flags);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_WORK_MASK);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3唤醒进程时抢占">3.唤醒进程时抢占<a hidden class="anchor" aria-hidden="true" href="#3唤醒进程时抢占">#</a></h4>
<p> 唤醒进程的时候，被唤醒的进程可能抢占当前进程</p>
<center>唤醒进程时抢占</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106214732.png" alt="20221106214732"  />
</p>
<p> （1）如果被唤醒的进程和当前进程属于相同的调度类，那么调用调度类的check_preempt_curr方法以检查是否可以抢占当前进程   <br>
 （2）如果被唤醒的进程所属调度类的优先级高于当前进程所属调度类的优先级，那么给当前进程设置需要重新调度的标志</p>
<table>
	<tr>
	    <th>调度类</th>
	    <th>check_preempt_curr方法是函数</th>
	    <th>算法</th>  
	</tr >
	<tr >
	    <td>停机调度类</td>
	    <td>check_preempt_curr_stop</td>
	    <td>空函数</td>
	</tr>
	<tr >
	    <td>限期调度类</td>
	    <td>check_preempt_curr_dl</td>
	    <td>如果被唤醒的进程的绝对截止期限比当前进程的绝对截止期限小，那么给当前进程设置需要重新调度的标志</td>
	</tr>
	<tr >
	    <td>实时调度类</td>
	    <td>check_preempt_curr_rt</td>
	    <td>优先级比当前进程的优先级高，那么给当前进程设置需要重新调度的标志</td>
	</tr>
	<tr >
	    <td>公平调度类</td>
	    <td>check_preempt_wakeup</td>
	    <td></td>
	</tr>
	<tr >
	    <td>空闲调度类</td>
	    <td>check_preempt_curr_idle</td>
	    <td>无条件抢占，给当前进程设置需要重新调度的标志</td>
	</tr>
</table>
<p> check_preempt_wakeup函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">check_preempt_wakeup</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> wake_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前进程的调度策略是SCHED_IDLE，被唤醒的进程的调度策略是SCHED_NORMAL或者SCHED_BATCH，那么允许抢占，给当前进程设置需要重新调度的标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>curr <span style="color:#f92672">=</span> rq<span style="color:#f92672">-&gt;</span>curr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>curr<span style="color:#f92672">-&gt;</span>se, <span style="color:#f92672">*</span>pse <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>se;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">task_has_idle_policy</span>(curr)) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">task_has_idle_policy</span>(p)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> preempt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">!=</span> SCHED_NORMAL) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">sched_feat</span>(WAKEUP_PREEMPTION))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为当前进程和被唤醒的进程找到两个兄弟调度实体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">find_matching_se</span>(<span style="color:#f92672">&amp;</span>se, <span style="color:#f92672">&amp;</span>pse);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">update_curr</span>(<span style="color:#a6e22e">cfs_rq_of</span>(se));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUG_ON</span>(<span style="color:#f92672">!</span>pse);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wakeup_preempt_entity</span>(se, pse) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) { <span style="color:#75715e">// 判断是否可以抢占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 允许抢占，给当前进程设置需要重新调度的标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		...
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> preempt;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>preempt:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">resched_curr</span>(rq);
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wakeup_preempt_entity</span>(<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>curr, <span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s64 gran, vdiff <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>vruntime <span style="color:#f92672">-</span> se<span style="color:#f92672">-&gt;</span>vruntime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vdiff <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	gran <span style="color:#f92672">=</span> <span style="color:#a6e22e">wakeup_gran</span>(se);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vdiff <span style="color:#f92672">&gt;</span> gran)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4创建新进程时抢占">4.创建新进程时抢占<a hidden class="anchor" aria-hidden="true" href="#4创建新进程时抢占">#</a></h4>
<p> 使用系统调用fork、clone和 vfork创建新进程使，新进程可抢占当前进程；使用韩式kernel_thread创建新的内核线程是，新内核线程可抢占当前进程
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106220629.png" alt="20221106220629"  />
</p>
<h4 id="5内核抢占">5.内核抢占<a hidden class="anchor" aria-hidden="true" href="#5内核抢占">#</a></h4>
<p> 内核抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，需要打开配置宏CONFIG_PREEMPT。抢占式内核和非抢占式内核。进程tthread_info结构体一个类型为int的成员preempt_count为抢占计数器。</p>
<blockquote>
<p>待补充</p>
</blockquote>
<h4 id="6高精度调度时钟">6.高精度调度时钟<a hidden class="anchor" aria-hidden="true" href="#6高精度调度时钟">#</a></h4>
<p> 高精度时钟的精度是纳秒,需要通过配置宏启用。</p>
<h3 id="288-带宽管理">2.8.8 带宽管理<a hidden class="anchor" aria-hidden="true" href="#288-带宽管理">#</a></h3>
<p> 调度类管理进程占用的处理器带宽的方法</p>
<h4 id="1限期调度类的带框管理">1.限期调度类的带框管理<a hidden class="anchor" aria-hidden="true" href="#1限期调度类的带框管理">#</a></h4>
<p> 每个限期进程有自己的带宽，内核把限期进程的运行时间统计到根实时任务组的运行时间里面了，限期进程共享实时进程的带宽</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/deadline.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_curr_dl</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rt_bandwidth_enabled</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> rt_rq <span style="color:#f92672">*</span>rt_rq <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rq<span style="color:#f92672">-&gt;</span>rt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">raw_spin_lock</span>(<span style="color:#f92672">&amp;</span>rt_rq<span style="color:#f92672">-&gt;</span>rt_runtime_lock);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">sched_rt_bandwidth_account</span>(rt_rq))
</span></span><span style="display:flex;"><span>                  rt_rq<span style="color:#f92672">-&gt;</span>rt_time <span style="color:#f92672">+=</span> delta_exec;
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">raw_spin_unlock</span>(<span style="color:#f92672">&amp;</span>rt_rq<span style="color:#f92672">-&gt;</span>rt_runtime_lock);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2实时调度类的带宽管理">2.实时调度类的带宽管理<a hidden class="anchor" aria-hidden="true" href="#2实时调度类的带宽管理">#</a></h4>
<p> 指定实时进程的带宽有以下两种方式
 （1）指定全局带宽：带宽包含的两个参数是周期和运行时间，即指定在每个周期内所有实时进程的运行时间总和。   <br>
 默认的周期是1秒，默认的运行时间是0.95秒。可以借助文件“/proc/sys/kernel/sched_rt_period_us”设置周期，借助文件“/proc/sys/kernel/sched_rt_runtime_us”设置运行时间        <br>
 配置宏CONFIG_RT_GROUP_SCHED，即支持实时任务组，那么全局带宽指定了所有实时任务组的总带宽
 （2）指定每个实时任务组的带宽：在每个指定的周期，允许一个实时任务组最多执行长时间。当实时任务组在一个周期用完了带宽时，这个任务组将会被节流，不允许继续运行，直到下一个周期。可以使用cgroup设置一个实时任务组的周期和运行时间，cgroup版本1的配置方法如下</p>
<details>
<summary>cgroup版本1的配置方法</summary>
<br>
1）cpu.rt_period_us：周期，默认值是1秒。   <br>
2）cpu.rt_runtime_us：运行时间，默认值是0，把运行时间设置为非零值以后才允许把实时进程加入任务组，设置为−1表示没有带宽限制。
cgroup版本1的配置示例如下。 <br>
1）挂载cgroup文件系统，把CPU控制器关联到控制组层级树。   <br>
mount -t cgroup -o cpu none /sys/fs/cgroup/cpu      <br>
2）创建一个任务组。     <br>
cd /sys/fs/cgroup/cpu      <br>
mkdir browser   # 创建"browser"任务组       <br>
3）把实时运行时间设置为10毫秒。         <br>
echo 10000 > browser/cpu.rt_runtime_us      <br>
4）把一个实时进程加入任务组。         <br>
echo <pid> > browser/cgroup.procs      <br>
</details>
<p> cgroup版本2从内核4.15版本开始支持CPU控制器，暂时不支持实时进程。</p>
<p> 一个处理器用完了实时运行时间，可以从其他处理器借用实时运行时间，称为实时运行时间共享，对应调度特性RT_RUNTIME_SHARE，默认开启。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>kernel<span style="color:#f92672">/</span>sched<span style="color:#f92672">/</span>features.h
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SCHED_FEAT</span>(RT_RUNTIME_SHARE, true)
</span></span></code></pre></div><p>实时任务组的带宽存放在结构体task_group的成员rt_bandwidth中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_group {
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_RT_GROUP_SCHED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> rt_bandwidth rt_bandwidth;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 节流</p>
<blockquote>
<p>书中详细解释</p>
</blockquote>
<h4 id="3公平调度类的带宽管理">3.公平调度类的带宽管理<a hidden class="anchor" aria-hidden="true" href="#3公平调度类的带宽管理">#</a></h4>
<p> 使用周期和限额指定一个公平任务组的带宽    <br>
 使用cgroup设置一个公平任务组的周期和限额，cgroup版本1的配置  \</p>
<details>
<summary>cgroup版本1的配置方法</summary>
</details>
&emsp;cgroup版本2的配置示例  \
<details>
<summary>cgroup版本2的配置方法</summary>
</details>
<p> （1）节流：在以下两种情况下，调度器会检查公平运行队列是否用完运行时间。
 1）put_prev_task_fair：调度器把当前正在运行的普通进程放回公平运行队列。
 2）pick_next_task_fair：当前正在运行的进程属于公平调度类，调度器选择下一个普通进程。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106231743.png" alt="20221106231743"  />
</p>
<p> （2）周期定时器：在每个周期的开始，重新填充任务组的带宽，把带宽分配给节流的公平运行队列。周期定时器的处理函数是sched_cfs_period_timer，它把主要工作委托给函数do_sched_cfs_period_timer</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106232422.png" alt="20221106232422"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_sched_cfs_period_timer</span>(<span style="color:#66d9ef">struct</span> cfs_bandwidth <span style="color:#f92672">*</span>cfs_b, <span style="color:#66d9ef">int</span> overrun)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	throttled <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">list_empty</span>(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>throttled_cfs_rq);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__refill_cfs_bandwidth_runtime</span>(cfs_b); <span style="color:#75715e">// 新填充任务组的带宽
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>throttled) {
</span></span><span style="display:flex;"><span>		cfs_b<span style="color:#f92672">-&gt;</span>idle <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (throttled <span style="color:#f92672">&amp;&amp;</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		runtime <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">raw_spin_unlock</span>(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把任务组的可用运行时间分配给节流的公平运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		runtime <span style="color:#f92672">=</span> <span style="color:#a6e22e">distribute_cfs_runtime</span>(cfs_b, runtime,
</span></span><span style="display:flex;"><span>								runtime_expires);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">raw_spin_lock</span>(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		throttled <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">list_empty</span>(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>throttled_cfs_rq);
</span></span><span style="display:flex;"><span>		cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">-=</span> <span style="color:#a6e22e">min</span>(runtime, cfs_b<span style="color:#f92672">-&gt;</span>runtime);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数__refill_cfs_bandwidth_runtime负责重新填充任务组的带宽：“把可用运行时间设置成限额，把运行时间的到期时间设置成当前时间加上1个周期”</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__refill_cfs_bandwidth_runtime</span>(<span style="color:#66d9ef">struct</span> cfs_bandwidth <span style="color:#f92672">*</span>cfs_b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     u64 now;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (cfs_b<span style="color:#f92672">-&gt;</span>quota <span style="color:#f92672">==</span> RUNTIME_INF)
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     now <span style="color:#f92672">=</span> <span style="color:#a6e22e">sched_clock_cpu</span>(<span style="color:#a6e22e">smp_processor_id</span>());
</span></span><span style="display:flex;"><span>     cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>quota;
</span></span><span style="display:flex;"><span>     cfs_b<span style="color:#f92672">-&gt;</span>runtime_expires <span style="color:#f92672">=</span> now <span style="color:#f92672">+</span> <span style="color:#a6e22e">ktime_to_ns</span>(cfs_b<span style="color:#f92672">-&gt;</span>period);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数distribute_cfs_runtime负责把任务组的可用运行时间分配给节流的公平运行队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">distribute_cfs_runtime</span>(<span style="color:#66d9ef">struct</span> cfs_bandwidth <span style="color:#f92672">*</span>cfs_b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq;
</span></span><span style="display:flex;"><span>	u64 runtime, remaining <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_lock</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">list_for_each_entry_rcu</span>(cfs_rq, <span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>throttled_cfs_rq,
</span></span><span style="display:flex;"><span>				throttled_list) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq <span style="color:#f92672">=</span> <span style="color:#a6e22e">rq_of</span>(cfs_rq);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rq_flags rf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rq_lock_irqsave</span>(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">cfs_rq_throttled</span>(cfs_rq))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* By the above check, this should never be true */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">SCHED_WARN_ON</span>(cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">raw_spin_lock</span>(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* cfs_rq-&gt;runtime_remaining是公平运行队列的剩余运行时间 */</span>
</span></span><span style="display:flex;"><span>		runtime <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (runtime <span style="color:#f92672">&gt;</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime)
</span></span><span style="display:flex;"><span>			runtime <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime;
</span></span><span style="display:flex;"><span>		cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">-=</span> runtime;
</span></span><span style="display:flex;"><span>		remaining <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">raw_spin_unlock</span>(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">+=</span> runtime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* we check whether we&#39;re throttled above */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 上面检查过是否被节流 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">unthrottle_cfs_rq</span>(cfs_rq);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>next:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rq_unlock_irqrestore</span>(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>remaining)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （3）取有余补不足：</p>
<h2 id="29-smp调度">2.9 SMP调度<a hidden class="anchor" aria-hidden="true" href="#29-smp调度">#</a></h2>
<p> SMP系统进程调度器特性:
 （1）使每个处理器负载尽可能均衡
 （2）设置进程的处理器亲和性(affinity)，即允许进程在哪些处理器上执行
 （3）进程从一个处理器迁移到另一个处理器</p>
<h3 id="291-进程的处理器亲和性">2.9.1 进程的处理器亲和性<a hidden class="anchor" aria-hidden="true" href="#291-进程的处理器亲和性">#</a></h3>
<p> 进程描述符增加两个成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>               nr_cpus_allowed;   <span style="color:#75715e">// 保存允许的处理器掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">cpumask_t</span>         cpus_allowed;		<span style="color:#75715e">// 保存允许的处理器数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="1应用编程接口">1.应用编程接口<a hidden class="anchor" aria-hidden="true" href="#1应用编程接口">#</a></h4>
<p> 内核系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// sched_setaffinity用来设置进程的处理器亲和性掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_setaffinity</span>(<span style="color:#66d9ef">pid_t</span> pid, <span style="color:#66d9ef">size_t</span> cpusetsize, <span style="color:#66d9ef">cpu_set_t</span> <span style="color:#f92672">*</span>mask);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// sched_getaffinity用来获取进程的处理器亲和性掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_getaffinity</span>(<span style="color:#66d9ef">pid_t</span> pid, <span style="color:#66d9ef">size_t</span> cpusetsize, <span style="color:#66d9ef">cpu_set_t</span> <span style="color:#f92672">*</span>mask);
</span></span></code></pre></div><p> 内核线程函数设置处理器亲和性掩码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kthread_bind用来把一个刚刚创建的内核线程绑定到一个处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kthread_bind</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpu);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// set_cpus_allowed_ptr用来设置内核线程的处理器亲和性掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">set_cpus_allowed_ptr</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cpumask <span style="color:#f92672">*</span>new_mask);
</span></span></code></pre></div><h4 id="2使用cpuset配置">2.使用cpuset配置<a hidden class="anchor" aria-hidden="true" href="#2使用cpuset配置">#</a></h4>
<p> cpuset在单独使用的时候，可以使用cpuset伪文件系统配置，配置方法</p>
<h3 id="292-对调度器的扩展">2.9.2 对调度器的扩展<a hidden class="anchor" aria-hidden="true" href="#292-对调度器的扩展">#</a></h3>
<p> SMP系统上，调度类增加方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sched_class {
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 为进程选择运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span>  (<span style="color:#f92672">*</span>select_task_rq)(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> task_cpu, <span style="color:#66d9ef">int</span> sd_flag, <span style="color:#66d9ef">int</span> flags);  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在进程被迁移到新的处理器之前调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>migrate_task_rq)(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 用来在进程被唤醒以后调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>task_woken) (<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>this_rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>task);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置处理器亲和性的时候执行调度类的特殊处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>set_cpus_allowed)(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cpumask <span style="color:#f92672">*</span>newmask);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 进程在内存和缓存中的数据是最少的，是有价值的实现负载均衡的机会：1）创建新进程，2）调用execve装载程序</p>
<center>创建新进程时负载均衡</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106235035.png" alt="20221106235035"  />
</p>
<center>装载程序时负载均衡</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106235110.png" alt="20221106235110"  />
</p>
<h3 id="293-限期调度类的处理器负载均衡">2.9.3 限期调度类的处理器负载均衡<a hidden class="anchor" aria-hidden="true" href="#293-限期调度类的处理器负载均衡">#</a></h3>
<h3 id="294-实时调度类的处理器负载均衡">2.9.4 实时调度类的处理器负载均衡<a hidden class="anchor" aria-hidden="true" href="#294-实时调度类的处理器负载均衡">#</a></h3>
<h3 id="295-公平调度类的处理器负载均衡">2.9.5 公平调度类的处理器负载均衡<a hidden class="anchor" aria-hidden="true" href="#295-公平调度类的处理器负载均衡">#</a></h3>
<h3 id="296-迁移线程">2.9.6 迁移线程<a hidden class="anchor" aria-hidden="true" href="#296-迁移线程">#</a></h3>
<p> 每个处理器有一个迁移线程，线程名称是“migration/&lt;cpu_id&gt;”，属于停机调度类，可以抢占所有其他进程，其他进程不可以抢占它。迁移线程有两个作用   <br>
 （1）调度器发出迁移请求，迁移线程处理迁移请求，把进程迁移到目标处理器。
 （2）执行主动负载均衡。</p>
<h3 id="297-隔离处理器">2.9.7 隔离处理器<a hidden class="anchor" aria-hidden="true" href="#297-隔离处理器">#</a></h3>
<h2 id="210-进程的上下文安全">2.10 进程的上下文安全<a hidden class="anchor" aria-hidden="true" href="#210-进程的上下文安全">#</a></h2>
<h1 id="第3章-内存管理">第3章 内存管理<a hidden class="anchor" aria-hidden="true" href="#第3章-内存管理">#</a></h1>
<h2 id="31-内存管理子系统架构">3.1 内存管理子系统架构<a hidden class="anchor" aria-hidden="true" href="#31-内存管理子系统架构">#</a></h2>
<p> 用户空间、内核空间和硬件3个层面
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221107001723.png" alt="20221107001723"  />
</p>
<h4 id="1用户空间">1.用户空间<a hidden class="anchor" aria-hidden="true" href="#1用户空间">#</a></h4>
<p> 应用程序使用<code>malloc()</code>申请内存，使用<code>free()</code>释放内存。 <br>
 malloc()和free()是glibc库的内存分配器<code>ptmalloc</code>提供的接口，ptmalloc使用系统调用<code>brk</code>或<code>mmap</code>向内核以页为单位申请内存，然后划分成小内存块分配给应用程序    <br>
 用户空间的内存分配器，除了glibc库的ptmalloc，还有谷歌的tcmalloc和FreeBSD的<code>jemalloc</code></p>
<h4 id="2内核空间">2.内核空间<a hidden class="anchor" aria-hidden="true" href="#2内核空间">#</a></h4>
<p>（1）内核空间的基本功能   <br>
 虚拟内存管理负责从进程的虚拟地址空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页   <br>
 内核使用延迟分配物理内存的策略，进程第一次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页   <br>
 页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 <br>
 内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口kmalloc()和释放内存的接口kfree()，支持3种块分配器：SLAB分配器、SLUB分配器和SLOB分配器。   \</p>
<p>（2）内核空间的扩展功能。 \</p>
<p> 不连续页分配器提供了分配内存的接口vmalloc和释放内存的接口vfree  <br>
 连续内存分配器（Contiguous Memory Allocator，CMA）用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用  \</p>
<h4 id="3硬件层面">3.硬件层面<a hidden class="anchor" aria-hidden="true" href="#3硬件层面">#</a></h4>
<p> 处理器包含一个称为内存管理单元（Memory Management Unit，MMU）的部件，负责把虚拟地址转换成物理地址   <br>
 内存管理单元包含一个称为页表缓存（Translation Lookaside Buffer，TLB）的部件，保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表   \</p>
<h2 id="32-虚拟地址空间布局">3.2 虚拟地址空间布局<a hidden class="anchor" aria-hidden="true" href="#32-虚拟地址空间布局">#</a></h2>
<h3 id="321-虚拟地址空间划分">3.2.1 虚拟地址空间划分<a hidden class="anchor" aria-hidden="true" href="#321-虚拟地址空间划分">#</a></h3>
<p> ARM64处理器不支持完全的64位虚拟地址，ARMv8.2 标准的大虚拟地址(Large Virtual Address，LVA)支持，并且页长度是64KB，那么虚拟地址的最大宽度是52位    <br>
 可以为虚拟地址配置比最大宽度小的宽度，并且可以为内核虚拟地址和用户虚拟地址配置不同的宽度。转换控制寄存器（Translation Control Register）TCR_EL1的字段T0SZ定义了必须是全0的最高位的数量，字段T1SZ定义了必须是全1的最高位的数量，用户虚拟地址的宽度是（64-TCR_EL1.T0SZ），内核虚拟地址的宽度是（64-TCR_EL1.T1SZ）   \</p>
<table>
	<tr>
	    <th>页长度</th>
	    <th>虚拟地址宽度</th>
	</tr >
	<tr >
	    <td>4KB</td>
	    <td>39</td>
	</tr>
	<tr >
	    <td>16KB</td>
	    <td>47</td>
	</tr>
	<tr >
	    <td>64KB</td>
	    <td>42</td>
	</tr>
	<tr >
	    <td colspan="2">可选择48位虚拟地址</td>
	</tr>
</table>
<h3 id="322-用户虚拟地址空间布局">3.2.2 用户虚拟地址空间布局<a hidden class="anchor" aria-hidden="true" href="#322-用户虚拟地址空间布局">#</a></h3>
<p> 进程的用户虚拟地址空间的起始地址是0，长度是TASK_SIZE，ARM64架构下TASK_SIZE下  <br>
 （1）32位用户空间程序：TASK_SIZE值是TASK_SIZE_32，即0x100000000，4GB    <br>
 （2）64位用户空间程序：TASK_SIZE值是TASK_SIZE_64，即 <code>2^VA_BITS</code>，VA_BITS是编译内核时选择的虚拟地址位数。   \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//arch/arm64/include/asm/memory.h    linux4.x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define VA_BITS          (CONFIG_ARM64_VA_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE_64     (UL(1) &lt;&lt; VA_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_COMPAT    </span><span style="color:#75715e">/* 支持执行32位用户空间程序 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE_32     UL(0x100000000)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* test_thread_flag(TIF_32BIT)判断用户空间程序是不是32位 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE       (test_thread_flag(TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  TASK_SIZE_32 : TASK_SIZE_64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE_OF(tsk)  (test_tsk_thread_flag(tsk, TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  TASK_SIZE_32 : TASK_SIZE_64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE    TASK_SIZE_64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_COMPAT */</span><span style="color:#75715e">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/memory.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define VA_BITS			(CONFIG_ARM64_VA_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _PAGE_OFFSET(va)	(-(UL(1) &lt;&lt; (va)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PAGE_OFFSET		(_PAGE_OFFSET(VA_BITS))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define KIMAGE_VADDR		(MODULES_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BPF_JIT_REGION_START	(KASAN_SHADOW_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BPF_JIT_REGION_SIZE	(SZ_128M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BPF_JIT_REGION_END	(BPF_JIT_REGION_START + BPF_JIT_REGION_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MODULES_END		(MODULES_VADDR + MODULES_VSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MODULES_VADDR		(BPF_JIT_REGION_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MODULES_VSIZE		(SZ_128M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define VMEMMAP_START		(-VMEMMAP_SIZE - SZ_2M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define VMEMMAP_END		(VMEMMAP_START + VMEMMAP_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PCI_IO_END		(VMEMMAP_START - SZ_2M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PCI_IO_START		(PCI_IO_END - PCI_IO_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FIXADDR_TOP		(PCI_IO_START - SZ_2M)
</span></span></span></code></pre></div><p> 进程的用户虚拟地址空间包含：    <br>
 （1）代码段、数据段和未初始化数据段    <br>
 （2）动态库代码段、数据段和初始化数据段    <br>
 （3）存放动态生成的数据的堆      <br>
 （4）存放局部变量和实现函数调用的栈   <br>
 （5）存放在栈底部的环境变量和参数字符串   <br>
 （6）把文件区间映射到虚拟地址空间的内存映射区域   <br>
 内核使用内存描述符<code>mm_struct</code>描述进程的用户虚拟地址空间，内存描述符主要成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">atomic_t</span> mm_users;  <span style="color:#75715e">// 共享同一个用户虚拟地址空间进程的数量，即线程组包含的进程的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">atomic_t</span> mm_count;  <span style="color:#75715e">// 内存描述符的引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>mmap;  <span style="color:#75715e">// 虚拟内存区域链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> rb_root mm_rb;  <span style="color:#75715e">// 虚拟内存区域红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">long</span>(<span style="color:#f92672">*</span>get_unmapped_area)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pgoff, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);  <span style="color:#75715e">// 在内存映射区域找到一个没有映射的区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span>pgd;  <span style="color:#75715e">// 指向页全局目录，即第一级页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> mmap_base;  <span style="color:#75715e">// 内存映射区的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> task_size;  <span style="color:#75715e">// 用户虚拟地址空间的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_code, end_code;  <span style="color:#75715e">// 代码段的起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_data, end_data;  <span style="color:#75715e">// 数据段的起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_brk, brk;  <span style="color:#75715e">// 堆的起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_stack;  <span style="color:#75715e">// 栈的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg_start, arg_end;  <span style="color:#75715e">// 参数字符串起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> env_start, env_end;  <span style="color:#75715e">// 环境变量的起始地址和结束地址
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm;  <span style="color:#75715e">// 进程mm指向一个内存描述符，内核线程mm为空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> mm_struct<span style="color:#960050;background-color:#1e0010">　</span><span style="color:#f92672">*</span>active_mm;  <span style="color:#75715e">// 进程的active_mm和mm总是指向同一个内存描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符
</span></span></span></code></pre></div><p> 进程地址空间随机化：  <br>
 （1）进程描述符成员personality是否设置ADDR_NO_RANDOMIZE   <br>
 （2）全局变量<code>randomize_va_spce</code>：0表示关闭虚拟地址空间随机化，1表示内存映射区和栈起始地址随机化，2表示内存映射区、栈和堆起始地址随机化，文件<code>/proc/sys/kernel/randomize_va_space</code>修改 \</p>
<p> 栈向下增长，起始地址STACK_TOP，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/processor.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define STACK_TOP_MAX         TASK_SIZE_64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_COMPAT  </span><span style="color:#75715e">/* 支持执行32位用户空间程序 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define AARCH32_VECTORS_BASE  0xffff0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_TOP   (test_thread_flag(TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                 AARCH32_VECTORS_BASE : STACK_TOP_MAX)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_TOP    STACK_TOP_MAX
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_COMPAT */</span><span style="color:#75715e">
</span></span></span></code></pre></div><p> 内存映射区域的起始地址是内存描述符的成员 mmap_base</p>
<center>用户虚拟地址空间两种布局</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109013928.png" alt="20221109013928"  />
</p>
<p> 新布局：内存映射区域自顶向下增长，起始地址是(STACK_TOP − 栈的最大长度 − 间隙)，默认启用内存映射区域随机化，需要把起始地址减去一个随机值   \</p>
<p> 进程调用execve以装载ELF文件的时候，函数load_elf_binary将会创建进程的用户虚拟地址空间   \</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109014232.png" alt="20221109014232"  />
</p>
<p> 函数arch_pick_mmap_layout负责选择内存映射区域的布局。ARM64架构定义的函数arch_pick_mmap_layout</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/mm/util.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arch_pick_mmap_layout</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">struct</span> rlimit <span style="color:#f92672">*</span>rlim_stack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> random_factor <span style="color:#f92672">=</span> <span style="color:#ae81ff">0UL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_RANDOMIZE)
</span></span><span style="display:flex;"><span>		random_factor <span style="color:#f92672">=</span> <span style="color:#a6e22e">arch_mmap_rnd</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mmap_is_legacy</span>(rlim_stack)) { <span style="color:#75715e">// 自底向上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mm<span style="color:#f92672">-&gt;</span>mmap_base <span style="color:#f92672">=</span> TASK_UNMAPPED_BASE <span style="color:#f92672">+</span> random_factor;
</span></span><span style="display:flex;"><span>		mm<span style="color:#f92672">-&gt;</span>get_unmapped_area <span style="color:#f92672">=</span> arch_get_unmapped_area;  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 自顶向下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mm<span style="color:#f92672">-&gt;</span>mmap_base <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap_base</span>(random_factor, rlim_stack);
</span></span><span style="display:flex;"><span>		mm<span style="color:#f92672">-&gt;</span>get_unmapped_area <span style="color:#f92672">=</span> arch_get_unmapped_area_topdown;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mmap_is_legacy</span>(<span style="color:#66d9ef">struct</span> rlimit <span style="color:#f92672">*</span>rlim_stack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>personality <span style="color:#f92672">&amp;</span> ADDR_COMPAT_LAYOUT)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (rlim_stack<span style="color:#f92672">-&gt;</span>rlim_cur <span style="color:#f92672">==</span> RLIM_INFINITY)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> sysctl_legacy_va_layout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 内存映射区域的起始地址的计算</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/efi.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_COMPAT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_RND_MASK			(test_thread_flag(TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">						0x7ff &gt;&gt; (PAGE_SHIFT - 12) : \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">						0x3ffff &gt;&gt; (PAGE_SHIFT - 12))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_RND_MASK			(0x3ffff &gt;&gt; (PAGE_SHIFT - 12))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/mmap.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MIN_GAP (SZ_128M + ((STACK_RND_MASK &lt;&lt; PAGE_SHIFT) + 1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_GAP (STACK_TOP/6*5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">mmap_base</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rnd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> gap <span style="color:#f92672">=</span> <span style="color:#a6e22e">rlimit</span>(RLIMIT_STACK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (gap <span style="color:#f92672">&lt;</span> MIN_GAP)
</span></span><span style="display:flex;"><span>           gap <span style="color:#f92672">=</span> MIN_GAP;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (gap <span style="color:#f92672">&gt;</span> MAX_GAP)
</span></span><span style="display:flex;"><span>           gap <span style="color:#f92672">=</span> MAX_GAP;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">PAGE_ALIGN</span>(STACK_TOP <span style="color:#f92672">-</span> gap <span style="color:#f92672">-</span> rnd);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数load_elf_binary：函数setup_arg_pages把栈顶设置为STACK_TOP减去随机值，然后把环境变量和参数从临时栈移到最终的用户栈；函数set_brk设置堆的起始地址，如果启用堆随机化，把堆的起始地址加上随机值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// fs/binfmt_elf.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">load_elf_binary</span>(<span style="color:#66d9ef">struct</span> linux_binprm <span style="color:#f92672">*</span>bprm)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">setup_arg_pages</span>(bprm, <span style="color:#a6e22e">randomize_stack_top</span>(STACK_TOP),
</span></span><span style="display:flex;"><span>                     executable_stack);
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">set_brk</span>(elf_bss, elf_brk, bss_prot);
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> ((current<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_RANDOMIZE) <span style="color:#f92672">&amp;&amp;</span> (randomize_va_space <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>           current<span style="color:#f92672">-&gt;</span>mm<span style="color:#f92672">-&gt;</span>brk <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>mm<span style="color:#f92672">-&gt;</span>start_brk <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">arch_randomize_brk</span>(current<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="323-内核地址空间布局">3.2.3 内核地址空间布局<a hidden class="anchor" aria-hidden="true" href="#323-内核地址空间布局">#</a></h3>
<center>ARM64处理器架构内核地址空间布局</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109225722.png" alt="20221109225722"  />
</p>
<p> (1)先行映射区范围[PAGE_OFFSET, 2^64-1]，起始地址PAGE_OFFSET = (OxFFFF FFFF FFFF FFFF &laquo; (VA_BITS-1))，长度为内核虚拟地址空间的一半，虚拟地址和物理地址是线性关系  \
 虚拟地址 = ((物理地址-PHYS_OFFSET)+PAGE_OFFSET)，PHY_OFFSET是内存起始物理地址
 (2)vmemmap 区域的范围是[VMEMMAP_START, PAGE_OFFSET)，长度是VMEMMAP_SIZE =（线性映射区域的长度 / 页长度 * page结构体的长度上限）
 (3)PCI I/O区域的范围是[PCI_IO_START, PCI_IO_END)，长度是16MB，结束地址是PCI_IO_END = (VMEMMAP_START − 2MB)。外围组件互联（Peripheral Component Interconnect，PCI）是一种总线标准，PCI I/O区域是PCI设备的I/O地址空间
 (4)定映射区域的范围是[FIXADDR_START, FIXADDR_TOP)，长度是FIXADDR_SIZE，结束地址是FIXADDR_TOP = (PCI_IO_START − 2MB)
 (5)vmalloc区域的范围是[VMALLOC_START, VMALLOC_END），起始地址是VMALLOC_START，等于内核模块区域的结束地址，结束地址是VMALLOC_END = (PAGE_OFFSET − PUD_SIZE − VMEMMAP_SIZE − 64KB)，其中PUD_SIZE是页上级目录表项映射的地址空间的长度   <br>
 vmalloc区域是函数vmalloc使用的虚拟地址空间，内核镜像在vmalloc区域，起始虚拟地址是(KIMAGE_VADDR + TEXT_OFFSET) ，其中KIMAGE_VADDR是内核镜像的虚拟地址的基准值，等于内核模块区域的结束地址MODULES_END；TEXT_OFFSET是内存中的内核镜像相对内存起始位置的偏移      <br>
 (6)内核模块区域的范围是[MODULES_VADDR, MODULES_END)，长度是128MB，起始地址是MODULES_VADDR =（内核虚拟地址空间的起始地址 + KASAN影子区域的长度）。内核模块区域是内核模块使用的虚拟地址空间    <br>
 (7)KASAN影子区域的起始地址是内核虚拟地址空间的起始地址，长度是内核虚拟地址空间长度的1/8。内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具       \</p>
<h2 id="33-物理地址空间">3.3 物理地址空间<a hidden class="anchor" aria-hidden="true" href="#33-物理地址空间">#</a></h2>
<p> 处理器通过外围设备控制器的寄存器访问外围设备，寄存器分为控制寄存器、状态寄存器和数据寄存器三大类，外围设备的寄存器通常被连续地编址。处理器对外围设备寄存器的编址方式有两种：     <br>
 （1）I/O映射方式(I/O-mapped)  <br>
 （2）内存映射方式(memroy-mapped)：精简指令集的处理器通常只实现一个物理地址空间，外围设备和物理内存使用统一的物理地址空间，处理器可以像访问一个内存单元那样访问外围设备，不需要提供专门的I/O指令     \</p>
<p> 程序通过虚拟地址访问外设寄存器，内核函数把外设寄存器物理地址映射到虚拟地址空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ioremap()把外设寄存器物理地址映射到内核虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">ioremap</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> phys_addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// io_remap_pfn_range()函数把外设寄存器的物理地址映射到进程的用户虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_remap_pfn_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, <span style="color:#66d9ef">pgprot_t</span> prot);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// iounmap()删除函数ioremap()创建映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iounmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span></code></pre></div><p> ARM64架构两种内存类型：
 （1）正常内存(Normal Memory)：包括物理内存和只读存储器(ROM)，共享属性和可缓存     <br>
 （2）设备内存(Device Memory)：指分配给外围设备寄存器的物理地址区域，外部共享，不可缓存  <br>
 ARM64架构3种属性把设备分为4种类型:      <br>
 （1）Device-nGnRnE          <br>
 （2）Device-nGnRE。          <br>
 （3）Device-nGRE。       <br>
 （4）Device-GRE         \</p>
<p> 寄存器TCR_EL1（Translation Control Register for Exception Level 1，异常级别1的转换控制寄存器）的字段IPS（Intermediate Physical Address Size，中间物理地址长度）控制物理地址的宽度，IPS字段的长度是3位</p>
<h2 id="34内存映射">3.4　内存映射<a hidden class="anchor" aria-hidden="true" href="#34内存映射">#</a></h2>
<p> 进程在虚拟地址空间中创建映射：
 （1）文件映射，把文件一个区间映射到进程虚拟地址空间，数据源是存储设备上的文件，文件页   <br>
 （2）匿名映射，把物理内存映射到进程虚拟地址空间，无数据源，匿名页   <br>
 修改对其他进程可见和释放传递底层文件，内存映射分为共享映射和私有映射。
&amp;ensp；（1）共享映射：修改数据时映射相同区域的其他进程可以看见，如果是文件支持的映射，修改会传递到底层文件。   <br>
 （2）私有映射：第一次修改数据时会从数据源复制一个副本，然后修改副本，其他进程看不见，不影响数据源    <br>
  两个进程可以使用共享的文件映射实现共享内存，进程间通信？。匿名映射通常是私有映射，共享的匿名映射只可能出现在父进程和子进程之间。    <br>
 进程的虚拟地址空间中，代码段和数据段是私有的文件映射，未初始化数据段、堆和栈是私有的匿名映射
 内存映射的原理。   <br>
 （1）创建内存映射的时候，在进程的用户虚拟地址空间中分配一个虚拟内存区域。  <br>
 （2）Linux内核采用延迟分配物理内存的策略，在进程第一次访问虚拟页的时候，产生缺页异常。如果是文件映射，那么分配物理页，把文件指定区间的数据读到物理页中，然后在页表中把虚拟页映射到物理页；如果是匿名映射，那么分配物理页，然后在页表中把虚拟页映射到物理页</p>
<h4 id="341-应用编程接口">3.4.1 应用编程接口<a hidden class="anchor" aria-hidden="true" href="#341-应用编程接口">#</a></h4>
<p> 系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 1.mmap()创建内存映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">size_t</span> length, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> flags, in fd, <span style="color:#66d9ef">off_t</span> offset);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. mremap()扩大或缩小内存映射，可移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mreemap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>old_address, <span style="color:#66d9ef">size_t</span> old_size, <span style="color:#66d9ef">size_t</span> new_size, <span style="color:#66d9ef">int</span> flags, ... <span style="color:#75715e">/*void *new_address */</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3. munmap() 删除内存印刷
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">munmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">size_t</span> length);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4. brk() 设置堆上界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">brk</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 6. mprotect()设置虚拟内存区域的访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mprotect</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">int</span> prot);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 7. madvise 箱内核体术内存使用建议，配合内核预读和缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">madvise</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">size_t</span> length, <span style="color:#66d9ef">int</span> advice);
</span></span></code></pre></div><p> 内核空间函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 1. remap_pfn_range把内存的物理页映射到进程的虚拟地址空间，实现进程和内核共享内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">remap_pfn_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, <span style="color:#66d9ef">pgprot_t</span> prot);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2.io_remap_pfn_range把外设寄存器的物理地址映射到进程的虚拟地址空间，进程可以直接访问外设寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_remap_pfn_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, <span style="color:#66d9ef">pgprot_t</span> prot);
</span></span></code></pre></div><p> 应用程序通常使用C标准库提供的函数malloc()申请内存。glibc库的内存分配器ptmalloc使用brk或mmap向内核以页为单位申请虚拟内存，然后把页划分成小内存块分配给应用程序。默认的阈值是128KB，如果应用程序申请的内存长度小于阈值，ptmalloc分配器使用brk向内核申请虚拟内存，否则ptmalloc分配器使用mmap向内核申请虚拟内存   \</p>
<p> 应用程序可以直接使用mmap向内核申请虚拟内存
系统调用mmap()  <br>
系统调用mprotect()  <br>
系统调用madvise()</p>
<h3 id="342-数据结构">3.4.2 数据结构<a hidden class="anchor" aria-hidden="true" href="#342-数据结构">#</a></h3>
<h4 id="1-虚拟内存区域">1. 虚拟内存区域<a hidden class="anchor" aria-hidden="true" href="#1-虚拟内存区域">#</a></h4>
<p> 内核使用结构体<code>vm_area_struct</code>描述虚拟内存区域</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_area_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* The first cache line has the info for VMA tree walking. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Our start address within vm_mm. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_start;	  <span style="color:#75715e">// 起始地址 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* The first byte after our end address within vm_mm. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_end;  <span style="color:#75715e">// 结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* linked list of VM areas per task, sorted by address */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 虚拟内存区域链表，按起始地址排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vm_next, <span style="color:#f92672">*</span>vm_prev;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 	红黑树节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> rb_node vm_rb;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Largest free memory gap in bytes to the left of this VMA.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * get_unmapped_area find a free area of the right size.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rb_subtree_gap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Second cache line starts here. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 指向内存描述符，即虚拟内存区域所属的用户虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>vm_mm;	<span style="color:#75715e">/* The address space we belong to. */</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Access permissions of this VMA.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * See vmf_insert_mixed_prot() for discussion.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 保护位，即访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">pgprot_t</span> vm_page_prot;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags;		<span style="color:#75715e">/* Flags, see mm.h. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* For areas with an address space and backing store,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * linkage into the address_space-&gt;i_mmap interval tree.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为了支持查询一个文件区间被映射到哪些虚拟内存区域，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 把一个文件映射到的所有虚拟内存区域加入该文件的地址空间结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// address_space的成员i_mmap指向的区间树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rb_node rb;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rb_subtree_last;
</span></span><span style="display:flex;"><span>	} shared;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*  file&#39;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * or brk vma (with NULL file) can only be in an anon_vma list.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把虚拟内存区域关联的所有anon_vma实例串联起来。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 一个虚拟内存区域会关联到父进程的anon_vma实例和自己的anon_vma实例 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> list_head anon_vma_chain; <span style="color:#75715e">/* Serialized by mmap_lock &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">					  * page_table_lock */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 指向一个anon_vma实例，结构体anon_vma用来组织匿名页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 被映射到的所有虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> anon_vma <span style="color:#f92672">*</span>anon_vma;	<span style="color:#75715e">/* Serialized by page_table_lock */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Function pointers to deal with this struct. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 虚拟内存操作集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> vm_operations_struct <span style="color:#f92672">*</span>vm_ops;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Information about our backing store: */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 文件偏移，单位是页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_pgoff;		<span style="color:#75715e">/* Offset (within vm_file) in PAGE_SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">					   units */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 文件，如果是私有的匿名映射，该成员是空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span> vm_file;		<span style="color:#75715e">/* File we map to (can be NULL). */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> vm_private_data;		<span style="color:#75715e">/* was vm_pte (shared mem) */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SWAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">atomic_long_t</span> swap_readahead_info;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_MMU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> vm_region <span style="color:#f92672">*</span>vm_region;	<span style="color:#75715e">/* NOMMU mapping region */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mempolicy <span style="color:#f92672">*</span>vm_policy;	<span style="color:#75715e">/* NUMA policy for the VMA */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> vm_userfaultfd_ctx vm_userfaultfd_ctx;
</span></span><span style="display:flex;"><span>} __randomize_layout;
</span></span></code></pre></div><center>文件映射的虚拟内存区域</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221111234010.png" alt="20221111234010"  />
</p>
<p> （1）成员vm_file指向文件的一个打开实例（file）。索引节点代表一个文件，描述文件的属性。    <br>
 （2）成员vm_pgoff存放文件的以页为单位的偏移。   <br>
 （3）成员vm_ops指向虚拟内存操作集合，创建文件映射的时候调用文件操作集合中的mmap方法（file-&gt;f_op-&gt;mmap）以注册虚拟内存操作集合。例如：假设文件属于EXT4文件系统，文件操作集合中的mmap方法是函数ext4_file_mmap，该函数把虚拟内存区域的成员vm_ops设置为ext4_file_vm_ops</p>
<center>共享匿名映射的虚拟内存区域</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221111234048.png" alt="20221111234048"  />
</p>
<p> （1）成员vm_file指向文件的一个打开实例（file）。   <br>
 （2）成员vm_pgoff存放文件的以页为单位的偏移。   <br>
 （3）成员vm_ops指向共享内存的虚拟内存操作集合shmem_vm_ops。</p>
<center>私有匿名映射的虚拟内存区域</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221112001338.png" alt="20221112001338"  />
</p>
<p> （1）页保护位（vm_area_struct.vm_page_prot）：描述虚拟内存区域的访问权限。内核定义了一个保护位映射数组，把VM_READ、VM_WRITE、VM_EXEC和VM_SHARED这4个标志转换成保护位组合        <br>
 P代表私有（Private），S代表共享（Shared），后面的3个数字分别表示可读、可写和可执行，例如__P000表示私有、不可读、不可写和不可执行，__S111表示共享、可读、可写和可执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/mmap.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pgprot_t</span> protection_map[<span style="color:#ae81ff">16</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,
</span></span><span style="display:flex;"><span>    __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pgprot_t</span> <span style="color:#a6e22e">vm_get_page_prot</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__pgprot</span>(<span style="color:#a6e22e">pgprot_val</span>(protection_map[vm_flags <span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>                (VM_READ<span style="color:#f92672">|</span>VM_WRITE<span style="color:#f92672">|</span>VM_EXEC<span style="color:#f92672">|</span>VM_SHARED)]) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">pgprot_val</span>(<span style="color:#a6e22e">arch_vm_get_page_prot</span>(vm_flags)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mman.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef arch_vm_get_page_prot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_vm_get_page_prot(vm_flags) __pgprot(0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p> 虚拟内存区域标志：结构体vm_area_struct的成员vm_flags存放虚拟内存区域的标志，头文件“include/linux/mm.h”定义了各种标志         <br>
VM_READ、VM_WRITE、VM_EXEC、VM_SHARED、VM_GROWSDOWN、VM_DONTEXPAND、VM_ACCOUNT、VM_NORESERVE、VM_HUGETLB、VM_ARCH_1、VM_ARCH_2、VM_HUGEPAGE、VM_MERGEABLE</p>
<p> 虚拟内存操作集合（vm_operations_struct）：定义了虚拟内存区域的各种操作方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mm.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> vm_operations_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在创建虚拟内存区域时调用open方法，通常不使用，设置为空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>open)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> area);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在删除虚拟内存区域时调用close方法，通常不使用，设置为空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>close)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> area);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用系统调用mremap移动虚拟内存区域时调用mremap方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>mremap)(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span> area);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用系统调用mremap移动虚拟内存区域时调用mremap方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fault)(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// huge_fault方法针对使用透明巨型页的文件映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>huge_fault)(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf, <span style="color:#66d9ef">enum</span> page_entry_size pe_size);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 读文件映射的虚拟页时，如果没有映射到物理页，生成缺页异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>map_pages)(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">pgoff_t</span> start_pgoff, <span style="color:#66d9ef">pgoff_t</span> end_pgoff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 通知以前的只读页即将变成可写，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* 如果返回一个错误，将会发送信号SIGBUS给进程*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>page_mkwrite)(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 使用VM_PFNMAP或者VM_MIXEDMAP时调用，功能和page_mkwrite相同*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>pfn_mkwrite)(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2链表和树">2.链表和树<a hidden class="anchor" aria-hidden="true" href="#2链表和树">#</a></h4>
<center>虚拟内存区域的链表和树</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221114005059.png" alt="20221114005059"  />

 (1)双向链表，mm_struct.mmap指向第一个vm_area_struct实例   <br>
 (2)红黑树，mm_struct.mm_rb指向红黑树的根    \</p>
<h3 id="343-创建内存映射">3.4.3 创建内存映射<a hidden class="anchor" aria-hidden="true" href="#343-创建内存映射">#</a></h3>
<p> C标准库封装了函数mmap用来创建内存映射</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>asmlinkage <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sys_mmap</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len, 
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> prot, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, 
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> fd, <span style="color:#66d9ef">off_t</span> off); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asmlinkage <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sys_mmap2</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len, 
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> prot, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, 
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> fd, <span style="color:#66d9ef">off_t</span> off); 
</span></span></code></pre></div><p> ARM64架构只实现系统调用mmap</p>
<center>系统调用sys_mmap执行流程</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221114010335.png" alt="20221114010335"  />
</p>
<center>do_mmap的执行流程</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221114010503.png" alt="20221114010503"  />
</p>
<p>待补充</p>
<h3 id="344-虚拟内存过量提交策略">3.4.4 虚拟内存过量提交策略<a hidden class="anchor" aria-hidden="true" href="#344-虚拟内存过量提交策略">#</a></h3>
<p> 虚拟内存过量提交，是指所有进程提交的虚拟内存的总和超过物理内存的容量，内存管理子系统支持3种虚拟内存过量    <br>
 （1）OVERCOMMIT_GUESS(0)：猜测，估算可用内存的数量，因为没法准确计算可用内存的数量，所以说是猜测。   <br>
 （2）OVERCOMMIT_ALWAYS(1)：总是允许过量提交。   <br>
 （3）OVERCOMMIT_NEVER(2)：不允许过量提交。     <br>
 <code>/proc/sys/vm/overcommit_memory</code>修改策略
 在创建新的内存映射时，调用函数__vm_enough_memory根据虚拟内存过量提交策略判断内存是否足够</p>
<h3 id="345-删除内存映射">3.4.5 删除内存映射<a hidden class="anchor" aria-hidden="true" href="#345-删除内存映射">#</a></h3>
<p> 系统调用munmap用来删除内存映射，它有两个参数：起始地址和长度，<code>mm/mmap.c</code>中的函数do_munmap</p>
<center>系统调用munmap执行流程</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221114231356.png" alt="20221114231356"  />
</p>
<h2 id="35-物理内存组织">3.5 物理内存组织<a hidden class="anchor" aria-hidden="true" href="#35-物理内存组织">#</a></h2>
<h3 id="351-体系结构">3.5.1 体系结构<a hidden class="anchor" aria-hidden="true" href="#351-体系结构">#</a></h3>
<p> 多处理器系统两种体系结构：
 (1)非一致内存访问(Non-Uniform Memory Access NUMA)：内存为多个内存节点多处理器系统  <br>
 (2)对称多处理器(Symmetric Multi-Process SMP)：一直内存访问(UMA)</p>
<h3 id="352-内存模型">3.5.2 内存模型<a hidden class="anchor" aria-hidden="true" href="#352-内存模型">#</a></h3>
<p> 内存管理子系统支持3种内存模型
 (1)平坦内存(Flat Memory)：内存物理地址空间是连续的   <br>
 (2)不连续内存(Discontiguous Memory)：内存物理地址空间存在空洞
 (3)系数内存(Sparse Memory)：内存物理地址空间存在空洞</p>
<h3 id="353-三级结构">3.5.3 三级结构<a hidden class="anchor" aria-hidden="true" href="#353-三级结构">#</a></h3>
<p> 内存管理子系统使用节点(node)、区域(zone)和页(page)三级结构描述物理内存。   \</p>
<h4 id="1内存节点">1.内存节点<a hidden class="anchor" aria-hidden="true" href="#1内存节点">#</a></h4>
<p> 内存节点两种情况：
 （1）NUMA系统内存节点  <br>
 （2）具有不连续内存的UMA系统  <br>
 内存节点使用<code>pglist_data</code>结构体描述内存布局，内核定义宏NODE_DATA(nid)，获取节点的pglist_data实例。平坦内存模型，只有一个pglist_data实例contig_page_data</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221114233416.png" alt="20221114233416"  />
</p>
<center>内存节点的pglist_data实例</center>
<p> pglist_data结构主要成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mmzone.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> pglist_data {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> zone node_zones[MAX_NR_ZONES];          <span style="color:#75715e">/* 内存区域数组 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> zonelist node_zonelists[MAX_ZONELISTS]; <span style="color:#75715e">/* 备用区域列表 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nr_zones;                                  <span style="color:#75715e">/* 该节点包含的内存区域数量 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_FLAT_NODE_MEM_MAP                    </span><span style="color:#75715e">/* 除了稀疏内存模型以外 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>node_mem_map;                     <span style="color:#75715e">/* 页描述符数组 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_PAGE_EXTENSION
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> page_ext <span style="color:#f92672">*</span>node_page_ext;                <span style="color:#75715e">/* 页的扩展属性 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_start_pfn;                  <span style="color:#75715e">/* 该节点的起始物理页号 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_present_pages;              <span style="color:#75715e">/* 物理页总数 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node_spanned_pages;              <span style="color:#75715e">/* 物理页范围的总长度，包括空洞 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> node_id;                                   <span style="color:#75715e">/* 节点标识符 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">pg_data_t</span>;
</span></span></code></pre></div><h4 id="2内存区域">2.内存区域<a hidden class="anchor" aria-hidden="true" href="#2内存区域">#</a></h4>
<p> 内核定义内存节点区域</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mmzone.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> zone_type {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ZONE_DMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ZONE_DMA,  <span style="color:#75715e">// 直接内存访问区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ZONE_DMA32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ZONE_DMA32,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 内核虚拟地址和物理地址是线性映射的关系，即虚拟地址 =（物理地址 + 常量）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ZONE_NORMAL,  <span style="color:#75715e">// 直接映射区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_HIGHMEM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ZONE_HIGHMEM,  <span style="color:#75715e">// 高端内存区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ZONE_MOVABLE,  <span style="color:#75715e">// 可移动区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_ZONE_DEVICE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ZONE_DEVICE,  <span style="color:#75715e">// 设备区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     __MAX_NR_ZONES
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 每个内存区域用一个zone结构体描述</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mmzone.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> zone {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> watermark[NR_WMARK];        <span style="color:#75715e">/* 页分配器使用的水线 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">long</span> lowmem_reserve[MAX_NR_ZONES];         <span style="color:#75715e">/* 页分配器使用，当前区域保留多少页不能借给  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">											高的区域类型 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> pglist_data  <span style="color:#f92672">*</span>zone_pgdat;          <span style="color:#75715e">/* 指向内存节点的pglist_data实例 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> per_cpu_pageset __percpu <span style="color:#f92672">*</span>pageset;  <span style="color:#75715e">/* 每处理器页集合 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>     zone_start_pfn;         <span style="color:#75715e">/* 当前区域的起始物理页号 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>     managed_pages;          <span style="color:#75715e">/* 伙伴分配器管理的物理页的数量 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>     spanned_pages;          <span style="color:#75715e">/* 当前区域跨越的总页数，包括空洞 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>     present_pages;          <span style="color:#75715e">/* 当前区域存在的物理页的数量，不包括空洞 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span>        <span style="color:#f92672">*</span>name;                  <span style="color:#75715e">/* 区域名称 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>   
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> free_area  free_area[MAX_ORDER];    <span style="color:#75715e">/* 不同长度的空闲区域 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3物理页">3.物理页<a hidden class="anchor" aria-hidden="true" href="#3物理页">#</a></h4>
<p> 每个物理页对应一个page结构体，称为页描述符，内存节点的pglist_data实例的成员node_mem_map指向该内存节点包含的所有物理页的页描述符注册的数组。   <br>
 结构体page成员flags布局  <br>
| [SECTION] | [NODE] | ZONE | [LAST_CPUPID] | &hellip; | FLAGS |  <br>
 SECTION是稀疏内存模型中的段编号，NODE是节点编号，ZONE是区域类型，FLAGS是标志位    <br>
 头文件<code>include/linux/mm_types.h</code>定义了page结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mm.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 得到物理页所属的内存节点的编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">page_to_nid</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> (page<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&gt;&gt;</span> NODES_PGSHIFT) <span style="color:#f92672">&amp;</span> NODES_MASK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 得到物理页所属的内存区域的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">enum</span> zone_type <span style="color:#a6e22e">page_zonenum</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> (page<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&gt;&gt;</span> ZONES_PGSHIFT) <span style="color:#f92672">&amp;</span> ZONES_MASK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="36-引导内存分配器">3.6 引导内存分配器<a hidden class="anchor" aria-hidden="true" href="#36-引导内存分配器">#</a></h2>
<p> 在内核初始化的过程中需要分配内存，内核提供了临时的引导内存分配器，在页分配器和块分配器初始化完毕后，把空闲的物理页交给页分配器管理，丢弃引导内存分配器，开启配置宏CONFIG_NO_BOOTMEM，<code>memblock</code>就会取代bootmem。
 </p>
<h3 id="361-bootmem分配器">3.6.1 bootmem分配器<a hidden class="anchor" aria-hidden="true" href="#361-bootmem分配器">#</a></h3>
<h3 id="362-memblock分配器">3.6.2 memblock分配器<a hidden class="anchor" aria-hidden="true" href="#362-memblock分配器">#</a></h3>
<h4 id="1数据结构">1.数据结构<a hidden class="anchor" aria-hidden="true" href="#1数据结构">#</a></h4>
<p> memblock分配器数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/memblock.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> memblock {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> bottom_up;  <span style="color:#75715e">/* 表示分配内存的方式 是从下向上的方向？ */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">phys_addr_t</span> current_limit;  <span style="color:#75715e">// 可分配内存的最大物理地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> memblock_type memory;  <span style="color:#75715e">// 存类型（包括已分配的内存和未分配的内存）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> memblock_type reserved;  <span style="color:#75715e">// 预留类型（已分配的内存）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> memblock_type physmem;  <span style="color:#75715e">// 物理内存类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p> 内存块类型的数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/memblock.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> memblock_type {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> cnt;        <span style="color:#75715e">/* 内存块区域数量 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> max;        <span style="color:#75715e">/* 已分配数组的大小 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">phys_addr_t</span> total_size;    <span style="color:#75715e">/* 内存块区域的总长度 所有区域的长度 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> memblock_region <span style="color:#f92672">*</span>regions;  <span style="color:#75715e">// 指向内存块区域数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;  <span style="color:#75715e">// 存块类型的名称
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p> 内存块区域的数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/memblock.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> memblock_region {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">phys_addr_t</span> base;  <span style="color:#75715e">// 起始物理地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">phys_addr_t</span> size;  <span style="color:#75715e">// 长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;  <span style="color:#75715e">// 标志 MEMBLOCK_NONE或其他标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> nid;  <span style="color:#75715e">// 节点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* memblock标志位的定义. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> {
</span></span><span style="display:flex;"><span>	MEMBLOCK_NONE      <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>,   <span style="color:#75715e">/* 无特殊要求 */</span>
</span></span><span style="display:flex;"><span>	MEMBLOCK_HOTPLUG   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1</span>,   <span style="color:#75715e">/* 可热插拔区域 */</span>
</span></span><span style="display:flex;"><span>	MEMBLOCK_MIRROR    <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2</span>,   <span style="color:#75715e">/* 镜像区域 */</span>
</span></span><span style="display:flex;"><span>	MEMBLOCK_NOMAP     <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4</span>,   <span style="color:#75715e">/* 不添加到内核直接映射 */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="2初始化">2.初始化<a hidden class="anchor" aria-hidden="true" href="#2初始化">#</a></h4>
<p> 源文件“mm/memblock.c”定义了全局变量memblock，把成员bottom_up初始化为假，表示从高地址向下分配。   <br>
 ARM64内核初始化memblock分配器的过程是：    <br>
 （1）解析设备树二进制文件中的节点“/memory”，把所有物理内存范围添加到memblock. memory，具体过程参考3.6.3节。    <br>
 （2）在函数arm64_memblock_init中初始化memblock。    <br>
 arm64_memblock_init主要流程：</p>
<blockquote>
<p>start_kernel() &ndash;&gt; setup_arch() &ndash;&gt; arm64_memblock_init()</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/init.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> __init <span style="color:#a6e22e">arm64_memblock_init</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> s64 linear_region_size <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>(s64)PAGE_OFFSET;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解析设备树二进制文件中节点“/chosen”的属性“linux,usable-memory-range”，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 得到可用内存的范围，把超出这个范围的物理内存范围从memblock.memory中删除。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fdt_enforce_memory_region</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 局变量memstart_addr记录内存的起始物理地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	memstart_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">round_down</span>(<span style="color:#a6e22e">memblock_start_of_DRAM</span>(),
</span></span><span style="display:flex;"><span>					ARM64_MEMSTART_ALIGN);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把线性映射区域不能覆盖的物理内存范围从memblock.memory中删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memblock_remove</span>(<span style="color:#66d9ef">max_t</span>(u64, memstart_addr <span style="color:#f92672">+</span> linear_region_size,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">__pa_symbol</span>(_end)), ULLONG_MAX);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (memstart_addr <span style="color:#f92672">+</span> linear_region_size <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">memblock_end_of_DRAM</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 确保memstart_addr严格对齐 */</span>
</span></span><span style="display:flex;"><span>		memstart_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">round_up</span>(<span style="color:#a6e22e">memblock_end_of_DRAM</span>() <span style="color:#f92672">-</span> linear_region_size,
</span></span><span style="display:flex;"><span>						ARM64_MEMSTART_ALIGN);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memblock_remove</span>(<span style="color:#ae81ff">0</span>, memstart_addr);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (memory_limit <span style="color:#f92672">!=</span> (<span style="color:#66d9ef">phys_addr_t</span>)ULLONG_MAX) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memblock_mem_limit_remove_map</span>(memory_limit);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memblock_add</span>(<span style="color:#a6e22e">__pa_symbol</span>(_text), (u64)(_end <span style="color:#f92672">-</span> _text));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把内核镜像占用的物理内存范围添加到memblock.reserved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memblock_reserve</span>(<span style="color:#a6e22e">__pa_symbol</span>(_text), _end <span style="color:#f92672">-</span> _text);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从设备树二进制文件中的内存保留区域和节点“/reserved-memory”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 读取保留的物理内存范围，添加到memblock.reserved中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">early_init_fdt_scan_reserved_mem</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3编程接口">3.编程接口<a hidden class="anchor" aria-hidden="true" href="#3编程接口">#</a></h4>
<p> memblock分配器接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 添加新的内存块区域到memblock.memory中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>memblock_add
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除内存块区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>memblock_remove
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>memblock_alloc
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>memblock_free
</span></span></code></pre></div><h4 id="4算法">4.算法<a hidden class="anchor" aria-hidden="true" href="#4算法">#</a></h4>
<p> memblock分配器把所有内存添加到memblock.memory中，把分配出去的内存块添加到memblock.reserved中   <br>
 函数memblock_alloc负责分配内存，主要为函数memblock_alloc_range_nid  <br>
 (1)memblock_find_in_range_node函数memblock_find_in_range_node   <br>
 (2)memblock_reserve函数把分配出去的内存块区域添加到memblock.reserved中  \</p>
<h3 id="363-物理内存信息">3.6.3 物理内存信息<a hidden class="anchor" aria-hidden="true" href="#363-物理内存信息">#</a></h3>
<p> 内核初始化的过程中，引导内存分配器负责分配内存。ARM64架构使用扁平设备树（Flattened Device Tree，FDT）描述板卡的硬件信息。驱动开发者编写设备树源文件（Device Tree Source，DTS），存放在目录“arch/arm64/boot/dts”下，然后使用设备树编译器（Device Tree Compiler，DTC）把设备树源文件转换成设备树二进制文件（Device Tree Blob，DTB），接着把设备树二进制文件写到存储设备上。设备启动时，引导程序把设备树二进制文件从存储设备读到内存中，引导内核的时候把设备树二进制文件的起始地址传给内核，内核解析设备树二进制文件后得到硬件信息   \</p>
<p>  设备树源文件<code>.dts</code>,描述物理内存布局</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">/</span> {  <span style="color:#75715e">// “/”根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#address-cells = &lt;2&gt;;   </span><span style="color:#75715e">// 地址的单元数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#size-cells = &lt;2&gt;;  </span><span style="color:#75715e">// 一个长度的单元数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memory<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#ae81ff">80000000</span> {  <span style="color:#75715e">// 描述物理内存布局
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       device_type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;memory&#34;</span>;  <span style="color:#75715e">// 设备类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	   <span style="color:#75715e">// 物理内存范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       reg <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000000</span> <span style="color:#ae81ff">0x80000000</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0x80000000</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000008</span> <span style="color:#ae81ff">0x80000000</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0x80000000</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 内核在初始化的时候调用函数early_init_dt_scan_nodes以解析设备树二进制文件，从而得到物理内存信息   \</p>
<blockquote>
<p>start_kernel() &ndash;&gt; setup_arch() &ndash;&gt; setup_machine_fdt() &ndash;&gt; early_init_dt_scan_nodes()</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// drivers/of/fdt.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> __init <span style="color:#a6e22e">early_init_dt_scan_nodes</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 初始化size-cells和address-cells信息 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// early_init_dt_scan_root，解析根节点的属性“#address-cells”得到地址的单元数量，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 保存在全局变量dt_root_addr_cells中；解析根节点的属性“#size-cells”得到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 长度的单元数量，保存在全局变量dt_root_size_cells中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">of_scan_flat_dt</span>(early_init_dt_scan_root, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 调用函数early_init_dt_add_memory_arch设置内存 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">of_scan_flat_dt</span>(early_init_dt_scan_memory, NULL);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> early_init_dt_scan_memory解析memory节点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// drivers/of/fdt.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">early_init_dt_scan_memory</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> node, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>uname,
</span></span><span style="display:flex;"><span>                      <span style="color:#66d9ef">int</span> depth, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解析节点的属性“device_type”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>type <span style="color:#f92672">=</span> <span style="color:#a6e22e">of_get_flat_dt_prop</span>(node, <span style="color:#e6db74">&#34;device_type&#34;</span>, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> __be32 <span style="color:#f92672">*</span>reg, <span style="color:#f92672">*</span>endp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> l;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 只扫描 &#34;memory&#34; 节点 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 如果没有属性“device_type”，判断节点名称是不是“memory@0”*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_PPC32) <span style="color:#f92672">||</span> depth <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">strcmp</span>(uname, <span style="color:#e6db74">&#34;memory@0&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strcmp</span>(type, <span style="color:#e6db74">&#34;memory&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 描述物理内存信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">of_get_flat_dt_prop</span>(node, <span style="color:#e6db74">&#34;linux,usable-memory&#34;</span>, <span style="color:#f92672">&amp;</span>l);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">of_get_flat_dt_prop</span>(node, <span style="color:#e6db74">&#34;reg&#34;</span>, <span style="color:#f92672">&amp;</span>l);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	endp <span style="color:#f92672">=</span> reg <span style="color:#f92672">+</span> (l <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(__be32));
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> ((endp <span style="color:#f92672">-</span> reg) <span style="color:#f92672">&gt;=</span> (dt_root_addr_cells <span style="color:#f92672">+</span> dt_root_size_cells)) {
</span></span><span style="display:flex;"><span>		u64 base, size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		base <span style="color:#f92672">=</span> <span style="color:#a6e22e">dt_mem_next_cell</span>(dt_root_addr_cells, <span style="color:#f92672">&amp;</span>reg);
</span></span><span style="display:flex;"><span>		size <span style="color:#f92672">=</span> <span style="color:#a6e22e">dt_mem_next_cell</span>(dt_root_size_cells, <span style="color:#f92672">&amp;</span>reg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">early_init_dt_add_memory_arch</span>(base, size);
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 解析出每块内存的起始地址和大小后，调用函数early_init_dt_add_memory_arch</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// drivers/of/fdt.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> __init __weak <span style="color:#a6e22e">early_init_dt_add_memory_arch</span>(u64 base, u64 size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> u64 phys_offset <span style="color:#f92672">=</span> MIN_MEMBLOCK_ADDR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">PAGE_ALIGNED</span>(base)) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;</span> PAGE_SIZE <span style="color:#f92672">-</span> (base <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>PAGE_MASK)) {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">pr_warn</span>(<span style="color:#e6db74">&#34;Ignoring memory block 0x%llx - 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>                  base, base <span style="color:#f92672">+</span> size);
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         size <span style="color:#f92672">-=</span> PAGE_SIZE <span style="color:#f92672">-</span> (base <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>PAGE_MASK);
</span></span><span style="display:flex;"><span>         base <span style="color:#f92672">=</span> <span style="color:#a6e22e">PAGE_ALIGN</span>(base);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">&amp;=</span> PAGE_MASK;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (base <span style="color:#f92672">&gt;</span> MAX_MEMBLOCK_ADDR) {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">pr_warning</span>(<span style="color:#e6db74">&#34;Ignoring memory block 0x%llx - 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>                  base, base <span style="color:#f92672">+</span> size);
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (base <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> MAX_MEMBLOCK_ADDR) {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">pr_warning</span>(<span style="color:#e6db74">&#34;Ignoring memory range 0x%llx - 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>                  ((u64)MAX_MEMBLOCK_ADDR) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, base <span style="color:#f92672">+</span> size);
</span></span><span style="display:flex;"><span>         size <span style="color:#f92672">=</span> MAX_MEMBLOCK_ADDR <span style="color:#f92672">-</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (base <span style="color:#f92672">+</span> size <span style="color:#f92672">&lt;</span> phys_offset) {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">pr_warning</span>(<span style="color:#e6db74">&#34;Ignoring memory block 0x%llx - 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>                base, base <span style="color:#f92672">+</span> size);
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (base <span style="color:#f92672">&lt;</span> phys_offset) {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">pr_warning</span>(<span style="color:#e6db74">&#34;Ignoring memory range 0x%llx - 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>                base, phys_offset);
</span></span><span style="display:flex;"><span>         size <span style="color:#f92672">-=</span> phys_offset <span style="color:#f92672">-</span> base;
</span></span><span style="display:flex;"><span>         base <span style="color:#f92672">=</span> phys_offset;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把物理内存范围添加到memblock.memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memblock_add</span>(base, size);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="37-伙伴分配器">3.7 伙伴分配器<a hidden class="anchor" aria-hidden="true" href="#37-伙伴分配器">#</a></h2>
<p> 内核初始化完毕后，使用页分配器管理物理页，当前使用的页分配器是伙伴分配器buddy allocato</p>
<h3 id="371-基本的伙伴分配器">3.7.1 基本的伙伴分配器<a hidden class="anchor" aria-hidden="true" href="#371-基本的伙伴分配器">#</a></h3>
<p> 连续的物理页称为页块（page block）。阶（order）是伙伴分配器的一个术语，是页的数量单位，2n个连续页称为n阶页块。满足以下条件的两个n阶页块称为伙伴（buddy）   <br>
 伙伴分配器分配和释放物理页的数量单位是阶</p>
<h3 id="372-分区的伙伴分配器">3.7.2 分区的伙伴分配器<a hidden class="anchor" aria-hidden="true" href="#372-分区的伙伴分配器">#</a></h3>
<h4 id="1数据结构-1">1.数据结构<a hidden class="anchor" aria-hidden="true" href="#1数据结构-1">#</a></h4>
<p> 分区的伙伴分配器专注于某个内存节点的某个区域。内存区域的结构体成员free_area用来维护空闲页块，数组下标对应页块的阶数。结构体free_area的成员free_list是空闲页块的链表nr_free是空闲页块的数量。内存区域的结构体成员managed_pages是伙伴分配器管理的物理页的数量，不包括引导内存分配器分配的物理页</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>mmzone.h
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> zone {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 不同长度的空闲区域 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> free_area   free_area[MAX_ORDER];  <span style="color:#75715e">// MAX_ORDER是最大阶数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>      managed_pages;
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} ____cacheline_internodealigned_in_smp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> free_area {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> list_head  free_list[MIGRATE_TYPES];
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>     nr_free;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mmzone.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* 空闲内存管理-分区的伙伴分配器 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_FORCE_MAX_ZONEORDER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_ORDER   11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_ORDER   CONFIG_FORCE_MAX_ZONEORDER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><h4 id="2根据分配标志得到首选区域类型">2．根据分配标志得到首选区域类型<a hidden class="anchor" aria-hidden="true" href="#2根据分配标志得到首选区域类型">#</a></h4>
<h4 id="3-备用区域列表">3. 备用区域列表<a hidden class="anchor" aria-hidden="true" href="#3-备用区域列表">#</a></h4>
<h4 id="4区域水线">4．区域水线<a hidden class="anchor" aria-hidden="true" href="#4区域水线">#</a></h4>
<h4 id="5防止过度借用">5．防止过度借用<a hidden class="anchor" aria-hidden="true" href="#5防止过度借用">#</a></h4>
<h3 id="373根据可移动性分组">3.7.3　根据可移动性分组<a hidden class="anchor" aria-hidden="true" href="#373根据可移动性分组">#</a></h3>
<h3 id="374每处理器页集合">3.7.4　每处理器页集合<a hidden class="anchor" aria-hidden="true" href="#374每处理器页集合">#</a></h3>
<p> 内核针对分配单页做了性能优化，为了减少处理器之间的锁竞争，在内存区域增加 1个每处理器页集合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>mmzone.h
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> zone {
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> per_cpu_pageset __percpu <span style="color:#f92672">*</span>pageset;  <span style="color:#75715e">/* 在每个处理器上有一个页集合 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} ____cacheline_internodealigned_in_smp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> per_cpu_pageset {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> per_cpu_pages pcp;
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> per_cpu_pages {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> count;      <span style="color:#75715e">/* 链表里面页的数量 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> high;       <span style="color:#75715e">/* 如果页的数量达到高水线，需要返还给伙伴分配器 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> batch;      <span style="color:#75715e">/* 批量添加或删除的页数量 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> list_head lists[MIGRATE_PCPTYPES]; <span style="color:#75715e">/* 每种迁移类型一个页链表 */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="375分配页">3.7.5　分配页<a hidden class="anchor" aria-hidden="true" href="#375分配页">#</a></h3>
<h4 id="1分配接口">1．分配接口<a hidden class="anchor" aria-hidden="true" href="#1分配接口">#</a></h4>
<p> 页分配器分配页接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 求分配一个阶数为order的页块，返回一个page实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">alloc_pages</span>(gfp_mask, order)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在阶数为0情况下的简化形式，只分配一页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">alloc_page</span>(gfp_mask)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只能从低端内存区域分配页，并且返回虚拟地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__get_free_pages</span>(gfp_mask, order)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在阶数为0情况下的简化形式，只分配一页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__get_free_page</span>(gfp_mask)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数gfp_mask设置了标志位__GFP_ZERO且阶数为0情况下的简化形式，只分配一页，并且用零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">get_zeroed_page</span>(gfp_mask)
</span></span></code></pre></div><h4 id="2分配标志位">2．分配标志位<a hidden class="anchor" aria-hidden="true" href="#2分配标志位">#</a></h4>
<p> 分配页的函数都带一个分配标志位参数，分配标志位分为以下5类
 (1)区域修饰符</p>
<p> (2)页移动性和位置提示</p>
<p> (3)水线修饰符</p>
<p> (4)回收修饰符</p>
<p> (5)行动修饰符</p>
<h4 id="3复合页">3．复合页<a hidden class="anchor" aria-hidden="true" href="#3复合页">#</a></h4>
<p> 如果设置了标志位__GFP_COMP并且分配了一个阶数大于0的页块，页分配器会把页块组成复合页（compound page）。复合页最常见的用处是创建巨型页。  <br>
 复合页的第一页叫首页（head page），其他页都叫尾页（tail page）</p>
<center>复合页的结构</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116001100.png" alt="20221116001100"  />
</p>
<h4 id="4对高阶原子分配的优化处理">4．对高阶原子分配的优化处理<a hidden class="anchor" aria-hidden="true" href="#4对高阶原子分配的优化处理">#</a></h4>
<h4 id="5核心函数的实现">5．核心函数的实现<a hidden class="anchor" aria-hidden="true" href="#5核心函数的实现">#</a></h4>
<h3 id="376释放页">3.7.6　释放页<a hidden class="anchor" aria-hidden="true" href="#376释放页">#</a></h3>
<p> 页分配器提供了以下释放页的接口       <br>
 （1）void __free_pages(struct page *page, unsigned int order)，第一个参数是第一个物理页的page实例的地址，第二个参数是阶数   <br>
 （2）void free_pages(unsigned long addr, unsigned int order)，第一个参数是第一个物理页的起始内核虚拟地址，第二个参数是阶数    \</p>
<h2 id="38块分配器">3.8　块分配器<a hidden class="anchor" aria-hidden="true" href="#38块分配器">#</a></h2>
<p> Linux内核提供了块分配器，处理小块内存分配问题，最早为SLAB分配器。大量物理内存的大型计算机上SLUB分配器，小内存的嵌入式设备上SLOB   \</p>
<h3 id="381-编程接口">3.8.1 编程接口<a hidden class="anchor" aria-hidden="true" href="#381-编程接口">#</a></h3>
<p> 3种块分配器提供了统一的编程接口，块分配器在初始化的时候创建了一些通用的内存缓存，从普通区域分配页的内存缓存的名称是<code>kmalloc-&lt;size&gt;</code>，DMA区域分配页的内存缓存的名称是<code>dma-kmalloc-&lt;size&gt;</code>，执行命令<code>cat /proc/slabinfo</code>可以看到这些通用的内存缓存   \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kmalloc</span>(<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">gfp_t</span> flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 重新分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">krealloc</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">size_t</span> new_size, <span style="color:#66d9ef">gfp_t</span> flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kfree</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>objp);
</span></span></code></pre></div><p> 创建专用的内存缓存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 创建内存缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span><span style="color:#a6e22e">kmem_cache_create</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">size_t</span> align, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>ctor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从指定的内存缓存分配对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kmem_cache_alloc</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep, <span style="color:#66d9ef">gfp_t</span> flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kmem_cache_free</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>objp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 销毁内存缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kmem_cache_destroy</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s);
</span></span></code></pre></div><h3 id="382-slab分配器">3.8.2 SLAB分配器<a hidden class="anchor" aria-hidden="true" href="#382-slab分配器">#</a></h3>
<h4 id="1数据结构-2">1.数据结构<a hidden class="anchor" aria-hidden="true" href="#1数据结构-2">#</a></h4>
<center>内存缓存的数据结构</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116233943.png" alt="20221116233943"  />
</p>
<p> （1）每个内存缓存对应一个kmem_cache实例    \</p>
<p> （2）每个内存节点对应一个kmem_cache_node实例</p>
<p> page结构体的成员   <br>
 1)flags设置标志位PG_slab，表示页属于SLAB分配器      <br>
 2)s_mem存放slab第一个对象的地址   <br>
 3)active表示已分配对象的数量   <br>
 4)lru作为链表节点加入其中一条slab链表   <br>
 5)slab_cache指向kmem_cache实例   <br>
 6)freelist指向空闲对象链表   \</p>
<p> （3）kmem_cache实例的成员cpu_slab指向array_cache实例，</p>
<h4 id="2空闲对象链表">2.空闲对象链表<a hidden class="anchor" aria-hidden="true" href="#2空闲对象链表">#</a></h4>
<p> 每个slab需要一个空闲对象链表，从而把所有空闲对象链接起来，空闲对象链表是用数组实现的，page-&gt;freelist指向空闲对象链表</p>
<center>使用对象存放空闲对象链表-初始状态</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116234847.png" alt="20221116234847"  />
</p>
<center>使用对象存放空闲对象链表-分配最后一个空闲对象</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116235027.png" alt="20221116235027"  />
</p>
<center>空闲对象链表在slab外面</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116235136.png" alt="20221116235136"  />
</p>
<h4 id="3计算slab长度">3.计算slab长度<a hidden class="anchor" aria-hidden="true" href="#3计算slab长度">#</a></h4>
<p> 函数calculate_slab_order负责计算slab长度，从0阶到kmalloc()函数支持的最大阶数（KMALLOC_MAX_ORDER）</p>
<h4 id="4着色">4.着色<a hidden class="anchor" aria-hidden="true" href="#4着色">#</a></h4>
<h4 id="5每处理器数组缓存">5．每处理器数组缓存<a hidden class="anchor" aria-hidden="true" href="#5每处理器数组缓存">#</a></h4>
<p> 内存缓存为每个处理器创建了一个数组缓存（结构体array_cache）。释放对象时，把对象存放到当前处理器对应的数组缓存中</p>
<center>每处理器数组缓冲</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116235443.png" alt="20221116235443"  />
</p>
<h4 id="6对numa的支持">6．对NUMA的支持<a hidden class="anchor" aria-hidden="true" href="#6对numa的支持">#</a></h4>
<center>SLAB分配器支持NUMA</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116235608.png" alt="20221116235608"  />
</p>
<h4 id="7内存缓存合并">7．内存缓存合并<a hidden class="anchor" aria-hidden="true" href="#7内存缓存合并">#</a></h4>
<p> 减少内存开销和增加对象的缓存热度，块分配器会合并相似的内存缓存</p>
<h4 id="8回收内存">8.回收内存<a hidden class="anchor" aria-hidden="true" href="#8回收内存">#</a></h4>
<p> 所有对象空闲的slab，没有立即释放，而是放在空闲slab链表中。只有内存节点上空闲对象的数量超过限制，才开始回收空闲slab，直到空闲对象的数量小于或等于限制    <br>
 结构体kmem_cache_node的成员slabs_free是空闲slab链表的头节点，成员free_objects是空闲对象的数量，成员free_limit是空闲对象的数量限制    \</p>
<center>回收空闲slab</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221116235852.png" alt="20221116235852"  />
</p>
<h3 id="383slub分配器">3.8.3　SLUB分配器<a hidden class="anchor" aria-hidden="true" href="#383slub分配器">#</a></h3>
<h4 id="1数据结构-3">1．数据结构<a hidden class="anchor" aria-hidden="true" href="#1数据结构-3">#</a></h4>
<center>SLUB分配器内存缓存的数据结构</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117000104.png" alt="20221117000104"  />
</p>
<h4 id="2空闲对象链表-1">2．空闲对象链表<a hidden class="anchor" aria-hidden="true" href="#2空闲对象链表-1">#</a></h4>
<center>空闲对象链表的初始状态</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117000219.png" alt="20221117000219"  />
</p>
<center>分配一个对象以后的空闲对象链表</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117000252.png" alt="20221117000252"  />
</p>
<h4 id="3计算slab长度-1">3．计算slab长度<a hidden class="anchor" aria-hidden="true" href="#3计算slab长度-1">#</a></h4>
<p> SLUB分配器在创建内存缓存的时候计算了两种slab长度：最优slab和最小slab</p>
<h4 id="4每处理器slab缓存">4．每处理器slab缓存<a hidden class="anchor" aria-hidden="true" href="#4每处理器slab缓存">#</a></h4>
<center>SLUB分配器的每处理器slab缓存</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/2022-11-17_00-04.png" alt="2022-11-17_00-04"  />
</p>
<h4 id="5对numa的支持">5．对NUMA的支持<a hidden class="anchor" aria-hidden="true" href="#5对numa的支持">#</a></h4>
<p> （1）内存缓存针对每个内存节点创建一个kmem_cache_node实例   <br>
 （2）分配对象时，如果当前处理器的slab缓存是空的，需要重填当前处理器的slab缓存   \</p>
<h4 id="6回收内存">6.回收内存<a hidden class="anchor" aria-hidden="true" href="#6回收内存">#</a></h4>
<p> 对于所有对象空闲的slab，如果内存节点的部分空闲slab的数量大于或等于最小部分空闲slab数量，那么直接释放，否则放在部分空闲slab链表的尾部</p>
<h4 id="7调试">7.调试<a hidden class="anchor" aria-hidden="true" href="#7调试">#</a></h4>
<h3 id="384slob分配器">3.8.4　SLOB分配器<a hidden class="anchor" aria-hidden="true" href="#384slob分配器">#</a></h3>
<h4 id="1数据结构-4">1．数据结构<a hidden class="anchor" aria-hidden="true" href="#1数据结构-4">#</a></h4>
<center>SLOB分配器内存缓存的数据结构</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117223330.png" alt="20221117223330"  />
</p>
<h4 id="2空闲对象链表-2">2．空闲对象链表<a hidden class="anchor" aria-hidden="true" href="#2空闲对象链表-2">#</a></h4>
<center>空闲对象链表的初始状态</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117223614.png" alt="20221117223614"  />
</p>
<center>分配一个对象以后的空闲对象链表</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117223707.png" alt="20221117223707"  />
</p>
<h4 id="3分配对象">3．分配对象<a hidden class="anchor" aria-hidden="true" href="#3分配对象">#</a></h4>
<p> 分配对象时，根据对象长度选择不同的策略</p>
<h2 id="39不连续页分配器">3.9　不连续页分配器<a hidden class="anchor" aria-hidden="true" href="#39不连续页分配器">#</a></h2>
<h3 id="391编程接口">3.9.1　编程接口<a hidden class="anchor" aria-hidden="true" href="#391编程接口">#</a></h3>
<p> 不连续页分配器提供了以下编程接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// vmalloc函数：分配不连续的物理页并且把物理页映射到连续的虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">vmalloc</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// vfree函数：释放vmalloc分配的物理页和虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vfree</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// vmap函数：把已经分配的不连续物理页映射到连续的虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pages是page指针数组，count是page指针数组大小，flags标志位，prot页保护位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">vmap</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">**</span>pages, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">pgprot_t</span> prot);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// vunmap函数：释放使用vmap分配的虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vunmap</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kvmalloc函数：先尝试使用kmalloc分配内存块，如果失败，那么使用vmalloc函数分配不连续的物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kvmalloc</span>(<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">gfp_t</span> flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kvfree函数：如果内存块是使用vmalloc分配的，那么使用vfree释放，否则使用kfree释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kvfree</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span></code></pre></div><h3 id="392数据结构">3.9.2　数据结构<a hidden class="anchor" aria-hidden="true" href="#392数据结构">#</a></h3>
<center>不连续页分配器的数据结构</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/2022-11-17_22-53_1.png" alt="2022-11-17_22-53_1"  />
</p>
<center>使用vmap函数分配虚拟内存区域</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221117225854.png" alt="20221117225854"  />
</p>
<h3 id="393技术原理">3.9.3　技术原理<a hidden class="anchor" aria-hidden="true" href="#393技术原理">#</a></h3>
<p> vmalloc虚拟地址空间的范围是[VMALLOC_START, VMALLOC_END)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/pgtable.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define VMALLOC_START        (MODULES_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define VMALLOC_END       (PAGE_OFFSET - PUD_SIZE - VMEMMAP_SIZE - SZ_64K)
</span></span></span></code></pre></div><p> MODULES_END是内核模块区域的结束地址，PAGE_OFFSET是线性映射区域的起始地址，PUD_SIZE是一个页上层目录表项映射的地址空间长度，VMEMMAP_SIZE是vmemmap区域的长度。    <br>
 vmalloc虚拟地址空间的起始地址等于内核模块区域的结束地址。   <br>
 vmalloc虚拟地址空间的结束地址等于（线性映射区域的起始地址−一个页上层目录表项映射的地址空间长度−vmemmap区域的长度−64KB）   <br>
 函数vmalloc的执行过程分为3步       <br>
 （1）分配虚拟内存区域          <br>
 分配vm_struct实例和vmap_area实例    <br>
 （2） 分配物理页        <br>
 vm_struct实例的成员nr_pages存放页数n；分配page指针数组   <br>
 （3）在内核的页表中把虚拟页映射到物理页    <br>
 内核的页表就是0号内核线程的页表。0号内核线程的进程描述符是全局变量init_task，成员active_mm指向全局变量init_mm，init_mm的成员pgd指向页全局目录swapper_pg_dir</p>
<h2 id="310每处理器内存分配器">3.10　每处理器内存分配器<a hidden class="anchor" aria-hidden="true" href="#310每处理器内存分配器">#</a></h2>
<p> 多处理器系统中，每处理器变量为每个处理器生成一个变量的副本</p>
<h3 id="3101编程接口">3.10.1　编程接口<a hidden class="anchor" aria-hidden="true" href="#3101编程接口">#</a></h3>
<p> 每处理器变量分为静态和动态两种</p>
<h4 id="1静态每处理器变量">1.静态每处理器变量<a hidden class="anchor" aria-hidden="true" href="#1静态每处理器变量">#</a></h4>
<p> 宏“DEFINE_PER_CPU(type, name)”定义普通的静态每处理器变量，使用宏“DECLARE_PER_CPU(type, name)”声明普通的静态每处理器变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 宏“DEFINE_PER_CPU(type, name)”展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 静态每处理器变量存放在“.data..percpu”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__attribute__</span>((<span style="color:#a6e22e">section</span>(<span style="color:#e6db74">&#34;.data..percpu&#34;</span>)))  <span style="color:#a6e22e">__typeof__</span>(type)  name
</span></span></code></pre></div><h4 id="2动态每处理器变量">2．动态每处理器变量<a hidden class="anchor" aria-hidden="true" href="#2动态每处理器变量">#</a></h4>
<p> 为动态每处理器变量分配内存的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// __alloc_percpu_gfp为动态每处理器变量分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> __percpu <span style="color:#f92672">*</span><span style="color:#a6e22e">__alloc_percpu_gfp</span>(<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">size_t</span> align, <span style="color:#66d9ef">gfp_t</span> gfp);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏alloc_percpu_gfp(type, gfp)是函数__alloc_percpu_gfp的简化形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏alloc_percpu_gfp(type, gfp)是函数__alloc_percpu_gfp的简化形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> __percpu <span style="color:#f92672">*</span><span style="color:#a6e22e">__alloc_percpu</span>(<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">size_t</span> align);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// free_percpu释放动态每处理器变量的内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_percpu</span>(<span style="color:#66d9ef">void</span> __percpu <span style="color:#f92672">*</span>__pdata);
</span></span></code></pre></div><h4 id="3访问每处理器变量">3．访问每处理器变量<a hidden class="anchor" aria-hidden="true" href="#3访问每处理器变量">#</a></h4>
<p> 宏“this_cpu_ptr(ptr)”用来得到当前处理器的变量副本的地址，宏“get_cpu_var(var)”用来得到当前处理器的变量副本的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 宏this_cpu_ptr(ptr)展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> __ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>__ptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (ptr);
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">typeof</span>(ptr)) (__ptr <span style="color:#f92672">+</span> <span style="color:#a6e22e">per_cpu_offset</span>(<span style="color:#a6e22e">raw_smp_processor_id</span>()));
</span></span></code></pre></div><p> 宏“per_cpu_ptr(ptr, cpu)”用来得到指定处理器的变量副本的地址，宏“per_cpu(var, cpu)”用来得到指定处理器的变量副本的值。     <br>
 宏“get_cpu_ptr(var)”禁止内核抢占并且返回当前处理器的变量副本的地址，宏“put_cpu_ptr(var)”开启内核抢占，这两个宏成对使用    <br>
 宏“get_cpu_var(var)”禁止内核抢占并且返回当前处理器的变量副本的值，宏“put_cpu_var(var)”开启内核抢占，这两个宏成对使用    \</p>
<h3 id="3102技术原理">3.10.2　技术原理<a hidden class="anchor" aria-hidden="true" href="#3102技术原理">#</a></h3>
<p> 每处理器区域是按块（chunk）分配的    <br>
 分配块的方式有两种:   <br>
 (1)分配块的方式有两种   <br>
 (2)分配块的方式有两种   \</p>
<center>基于vmalloc区域的每处理器内存分配器</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221118000310.png" alt="20221118000310"  />

每个块对应一个pcpu_chunk实例</p>
<p> </p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221118000525.png" alt="20221118000525"  />
</p>
<center>基于内核内存的每处理器内存分配器</center>
<h2 id="311页表">3.11　页表<a hidden class="anchor" aria-hidden="true" href="#311页表">#</a></h2>
<h3 id="3111统一的页表框架">3.11.1　统一的页表框架<a hidden class="anchor" aria-hidden="true" href="#3111统一的页表框架">#</a></h3>
<p> 页表用来把虚拟页映射到物理页，并且存放页的保护位，即访问权限     <br>
 Linux 4.11版本以前，Linux内核把页表分为4级    <br>
 (1)页全局目录(Page Global Directory PGD)   <br>
 (2)页上层目录(Page Upper DIrectory PUD)    <br>
 (3)页中间目录(Page Middle Directory PMD)   <br>
 (4)直接页表(Page Table PT)      <br>
 4.11版本把页表扩展到五级，在页全局目录和页上层目录之间增加了页四级目录(Page 4th Directory，P4D)    \</p>
<p> 内核也有一个页表，0号内核线程的进程描述符init_task的成员active_mm指向内存描述符init_mm，内存描述符init_mm的成员pgd指向内核的页全局目录swapper_pg_dir   <br>
 虚拟地址被分解为6个部分：页全局目录索引、页四级目录索引、页上层目录索引、页中间目录索引、直接页表索引和页内偏移   \</p>
<h3 id="3112arm64处理器的页表">3.11.2　ARM64处理器的页表<a hidden class="anchor" aria-hidden="true" href="#3112arm64处理器的页表">#</a></h3>
<p> ARM64处理器把页表称为转换表(translation table)，最多4级。ARM64处理器支持3 种页长度：4KB、16KB和64KB。   、
 页长度是4KB：使用4级转换表，转换表和内核的页表术语的对应关系是：0级转换表对应页全局目录，1级转换表对应页上层目录，2级转换表对应页中间目录，3级转换表对应直接页表  \</p>
<h2 id="312页表缓存">3.12　页表缓存<a hidden class="anchor" aria-hidden="true" href="#312页表缓存">#</a></h2>
<p> 处理器的内存管理单元（Memory Management Unit，MMU）负责把虚拟地址转换成物理地址。
 TLB（Translation Lookaside Buffer）的高速缓存，TLB直译为转换后备缓冲区，意译为页表缓存，缓存最近使用过的页表项。两级页表缓存：第一级TLB分为指令TLB和数据TLB，好处是取指令和取数据可以并行执行；第二级TLB是统一TLB（Unified TLB），即指令和数据共用的TLB</p>
<h3 id="3121tlb表项格式">3.12.1　TLB表项格式<a hidden class="anchor" aria-hidden="true" href="#3121tlb表项格式">#</a></h3>
<p> ARM64处理器的每条TLB表项不仅包含虚拟地址和物理地址，也包含属性：内存类型、缓存策略、访问权限、地址空间标识符（Address Space Identifier，ASID）和虚拟机标识符（Virtual Machine Identifier，VMID）。地址空间标识符区分不同进程的页表项，虚拟机标识符区分不同虚拟机的页表项   \</p>
<h3 id="3122tlb管理">3.12.2　TLB管理<a hidden class="anchor" aria-hidden="true" href="#3122tlb管理">#</a></h3>
<p> 页表改变以后冲刷TLB的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 使所有TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_tlb_all</span>(<span style="color:#66d9ef">void</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使指定用户地址空间的某个范围的TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数vma是虚拟内存区域，start是起始地址，end是结束地址（不包括）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_tlb_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> end);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使指定用户地址空间里面的指定虚拟页的TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数vma是虚拟内存区域，uaddr是一个虚拟页中的任意虚拟地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_tlb_page</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> uaddr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使内核的某个虚拟地址范围的TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数start是起始地址，end是结束地址（不包括）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_tlb_kernel_range</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> end);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 修改页表项以后把页表项设置到页表缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 由软件管理页表缓存的处理器必须实现该函数，例如MIPS处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ARM64处理器的内存管理单元可以访问内存中的页表，把页表项复制到页表缓存，所以ARM64架构的函数update_mmu_cache什么都不用做
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_mmu_cache</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address, <span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>ptep);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 内核把进程从一个处理器迁移到另一个处理器以后，调用该函数以更新页表缓存或上下文特定信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tlb_migrate_finish</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm);
</span></span></code></pre></div><p> ARM64架构没有提供写TLB的指令。   <br>
 ARM64架构提供了一条TLB失效指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>TLBI <span style="color:#f92672">&lt;</span>type<span style="color:#f92672">&gt;&lt;</span>level<span style="color:#f92672">&gt;</span>{IS} {, <span style="color:#f92672">&lt;</span>Xt<span style="color:#f92672">&gt;</span>}
</span></span></code></pre></div><p> ARM64内核flush_tlb_all函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/tlbflush.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_tlb_all</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dsb数据同步屏障
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dsb</span>(ishst);  <span style="color:#75715e">// ishst中的ish表示共享域是内部共享
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">__tlbi</span>(vmalle1is);  <span style="color:#75715e">// 使所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dsb</span>(ish);  <span style="color:#75715e">// ish表示数据同步屏障指令对所有核起作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">isb</span>();  <span style="color:#75715e">// 指令同步屏障
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_tlb_all</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dsb确保屏障前面的存储指令执行完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// ishst中的ish表示共享域是内部共享
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// st表示存储（store），ishst表示数据同步屏障指令对所有核的存储指令起作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;dsb ishst&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使所有核上匹配当前VMID、阶段1和异常级别1的所有TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">asm</span> (<span style="color:#e6db74">&#34;tlbi vmalle1is&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 确保前面的TLB失效指令执行完。ish表示数据同步屏障指令对所有核起作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;dsb ish&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// isb是指令同步屏障,冲刷处理器的流水线，重新读取屏障指令后面的所有指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;isb&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> ARM64内核实现了函数local_flush_tlb_all，用来使当前核的所有TLB表项失效</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/tlbflush.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">local_flush_tlb_all</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">dsb</span>(nshst);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">__tlbi</span>(vmalle1);  <span style="color:#75715e">// 仅仅使当前核的TLB表项失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">dsb</span>(nsh);  <span style="color:#75715e">// nsh是非共享,数据同步屏障指令仅仅在当前核起作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">isb</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3123地址空间标识符">3.12.3　地址空间标识符<a hidden class="anchor" aria-hidden="true" href="#3123地址空间标识符">#</a></h3>
<p> ARM64处理器的页表缓存使用非全局(not global，nG)位区分内核和进程的页表项(nG位为0表示内核的页表项)，使用地址空间标识符(Address Space Identifier，ASID)区分不同进程的页表项   <br>
 ARM64处理器的ASID长度8位或者16位，寄存器ID_AA64MMFR0_EL1段ASIDBits存放处理器支持的ASID长度。16位ASID使用寄存器TCR_EL1的AS(ASID Size)位控制实际使用的ASID长度，AS 0为8位ASID，AS 1为16位ASID   <br>
 寄存器TCR_EL1的A1位决定使用哪个寄存器存放当前进程的ASID,寄存器TTBR0_EL1 用户0或TTBR1_EL1内核？存放当前进程ASID      <br>
 内存描述符的成员context存放架构特定的内存管理上下文，数据类型是结构体mm_context_t，ARM64架构定义的结构体     <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/mmu.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">atomic64_t</span>   id;  <span style="color:#75715e">// 成员id存放内核给进程分配的软件ASID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">mm_context_t</span>;
</span></span></code></pre></div><p> 全局变量asid_bits保存ASID长度，全局变量asid_generation的高56位保存全局ASID版本号，位图asid_map记录哪些ASID被分配     <br>
 当全局ASID版本号加1时，每个处理器需要清空页表缓存，位图tlb_flush_pending保存需要清空页表缓存的处理器集合       <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/context.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> u32 asid_bits;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">atomic64_t</span> asid_generation;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>asid_map;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#a6e22e">DEFINE_PER_CPU</span>(<span style="color:#66d9ef">atomic64_t</span>, active_asids);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#a6e22e">DEFINE_PER_CPU</span>(u64, reserved_asids);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">cpumask_t</span> tlb_flush_pending;
</span></span></code></pre></div><p> 进程被调度时，函数check_and_switch_context负责检查是否需要给进程重新分配ASID     <br></p>
<blockquote>
<p>__schedule() -&gt; context_switch() -&gt; switch_mm_irqs_off() -&gt; switch_mm() -&gt; check_and_switch_context()</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/context.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">check_and_switch_context</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>	u64 asid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic64_read</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>context.id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>((asid <span style="color:#f92672">^</span> <span style="color:#a6e22e">atomic64_read</span>(<span style="color:#f92672">&amp;</span>asid_generation)) <span style="color:#f92672">&gt;&gt;</span> asid_bits)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic64_xchg_relaxed</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">per_cpu</span>(active_asids, cpu), asid))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> switch_mm_fastpath;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raw_spin_lock_irqsave</span>(<span style="color:#f92672">&amp;</span>cpu_asid_lock, flags);
</span></span><span style="display:flex;"><span>	asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic64_read</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>context.id);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((asid <span style="color:#f92672">^</span> <span style="color:#a6e22e">atomic64_read</span>(<span style="color:#f92672">&amp;</span>asid_generation)) <span style="color:#f92672">&gt;&gt;</span> asid_bits) {
</span></span><span style="display:flex;"><span>		asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">new_context</span>(mm, cpu);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">atomic64_set</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>context.id, asid);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cpumask_test_and_clear_cpu</span>(cpu, <span style="color:#f92672">&amp;</span>tlb_flush_pending))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">local_flush_tlb_all</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atomic64_set</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">per_cpu</span>(active_asids, cpu), asid);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raw_spin_unlock_irqrestore</span>(<span style="color:#f92672">&amp;</span>cpu_asid_lock, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	switch_mm_fastpath:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">system_uses_ttbr0_pan</span>())
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cpu_switch_mm</span>(mm<span style="color:#f92672">-&gt;</span>pgd, mm);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数new_context负责分配ASID</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/context.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> u64 <span style="color:#a6e22e">new_context</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> u32 cur_idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	u64 asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic64_read</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>context.id);
</span></span><span style="display:flex;"><span>	u64 generation <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic64_read</span>(<span style="color:#f92672">&amp;</span>asid_generation);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (asid <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			u64 newasid <span style="color:#f92672">=</span> generation <span style="color:#f92672">|</span> (asid <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>ASID_MASK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">check_update_reserved_asid</span>(asid, newasid))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> newasid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		asid <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>ASID_MASK;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">__test_and_set_bit</span>(asid, asid_map))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> newasid;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_next_zero_bit</span>(asid_map, NUM_USER_ASIDS, cur_idx);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (asid <span style="color:#f92672">!=</span> NUM_USER_ASIDS)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> set_asid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	generation <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic64_add_return_relaxed</span>(ASID_FIRST_VERSION,
</span></span><span style="display:flex;"><span>							<span style="color:#f92672">&amp;</span>asid_generation);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">flush_context</span>(cpu);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_next_zero_bit</span>(asid_map, NUM_USER_ASIDS, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	set_asid:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__set_bit</span>(asid, asid_map);
</span></span><span style="display:flex;"><span>	cur_idx <span style="color:#f92672">=</span> asid;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> asid <span style="color:#f92672">|</span> generation;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数flush_context负责重新初始化ASID分配状态</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/context.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flush_context</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	u64 asid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bitmap_clear</span>(asid_map, <span style="color:#ae81ff">0</span>, NUM_USER_ASIDS);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">smp_wmb</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">for_each_possible_cpu</span>(i) {
</span></span><span style="display:flex;"><span>		asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic64_xchg_relaxed</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">per_cpu</span>(active_asids, i), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (asid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			asid <span style="color:#f92672">=</span> <span style="color:#a6e22e">per_cpu</span>(reserved_asids, i);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__set_bit</span>(asid <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>ASID_MASK, asid_map);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">per_cpu</span>(reserved_asids, i) <span style="color:#f92672">=</span> asid;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cpumask_setall</span>(<span style="color:#f92672">&amp;</span>tlb_flush_pending);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3124虚拟机标识符">3.12.4　<strong>虚拟机标识符</strong><a hidden class="anchor" aria-hidden="true" href="#3124虚拟机标识符">#</a></h3>
<p> 虚拟机里面运行的客户操作系统的虚拟地址转换成物理地址分两个阶段：  <br>
 第 1 阶段把虚拟地址转换成中间物理地址  <br>
 第 2 阶段把中间物理地址转换成物理地址  <br>
 第 1 阶段转换由客户操作系统的内核控制，和非虚拟化的转换过程相同。第 2 阶段转换由虚拟机监控器控制，虚拟机监控器为每个虚拟机维护一个转换表，分配一个虚拟机标识符(Virtual Machine Identifier，VMID)，寄存器VTTBR_EL2(虚拟化转换表基准寄存器，Virtualization Translation Table Base Register)存放当前虚拟机的阶段2转换表的物理地址</p>
<h2 id="313巨型页">3.13　巨型页<a hidden class="anchor" aria-hidden="true" href="#313巨型页">#</a></h2>
<p> 使用长度为2MB甚至更大的巨型页，可以大幅减少TLB未命中和缺页异常的数量，大幅提高应用程序的性能   <br>
 (1)使用hugetlbfs伪文件系统实现巨型页   <br>
 (2)透明巨型页    <br></p>
<h3 id="3131处理器对巨型页的支持">3.13.1　处理器对巨型页的支持<a hidden class="anchor" aria-hidden="true" href="#3131处理器对巨型页的支持">#</a></h3>
<p> ARM64处理器支持巨型页的方式有两种  <br>
 (1)通过块描述符支持  <br>
 (2)通过页/块描述符的连续位支持   <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221119224359.png" alt="20221119224359"  />
</p>
<center>页长度为4KB时通过块描述符支持巨型页</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221119224113.png" alt="20221119224113"  />
</p>
<center>页长度为4KB时通过页/块描述符的连续位支持巨型页</center>
<h3 id="3132标准巨型页">3.13.2　标准巨型页<a hidden class="anchor" aria-hidden="true" href="#3132标准巨型页">#</a></h3>
<p> 编译内核时需要打开配置宏CONFIG_HUGETLBFS和CONFIG_HUGETLB_PAGE  <br>
 文件“/proc/sys/vm/nr_hugepages”指定巨型页池中永久巨型页的数量  <br></p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 待补充 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>
<h3 id="3133透明巨型页">3.13.3　透明巨型页<a hidden class="anchor" aria-hidden="true" href="#3133透明巨型页">#</a></h3>
<p> (1)分配透明巨型页   <br>
 函数handle_mm_fault是页错误异常处理程序的核心函数，如果触发异常的虚拟内存区域使用普通页或透明巨型页，把主要工作委托给函数__handle_mm_fault
<img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221119224843.png" alt="20221119224843"  />
</p>
<center>透明巨型页的页错误异常处理</center>
<p> 函数create_huge_pmd负责分配页中间目录级别的巨型页
<img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221119225521.png" alt="20221119225521"  />
</p>
<h2 id="314页错误异常处理">3.14　页错误异常处理<a hidden class="anchor" aria-hidden="true" href="#314页错误异常处理">#</a></h2>
<p> 虚拟页没有映射到物理页，或者没有访问权限，处理器将生成页错误异常  <br>
 缺页异常,虚拟页没有映射到物理页   <br>
 (1)访问用户栈的时候，超出了当前用户栈的范围，需要扩大用户栈  <br>
 (2)进程申请虚拟内存区域的时候，通常没有分配物理页，进程第一次访问的时候触发页错误异常  <br>
 (3)内存不足的时候，内核把进程的匿名页换出到交换区   <br>
 (4)一个文件页被映射到进程的虚拟地址空间，内存不足的时候  <br>
 (5)程序错误，访问没有分配给进程的虚拟内存区域  <br></p>
<p> 没有访问权限，两种情况  <br>
 (1)写时复制(Copy on Write，CoW)    页错误异常处理程序成功地把虚拟页映射到物理页  <br>
 (2)程序错误，发送段违法(SIGSEGV)信号以杀死进程  <br></p>
<h3 id="3141处理器架构特定部分">3.14.1　处理器架构特定部分<a hidden class="anchor" aria-hidden="true" href="#3141处理器架构特定部分">#</a></h3>
<h4 id="1生成页错误异常">1.生成页错误异常<a hidden class="anchor" aria-hidden="true" href="#1生成页错误异常">#</a></h4>
<p> ARM64处理器在取指令或数据，需把虚拟地址转换成物理地址，分两种情况  <br>
 (1)虚拟地址的高16位不是全1或全0，是非法地址，生成页错误异常   <br>
 (2)虚拟地址的高16位是全1或全0，内存管理单元根据关键字{地址空间标识符，虚拟地址}查找TLB   <br></p>
<blockquote>
<p>寄存器TTBR1_EL1存放内核的页全局目录的物理地址，寄存器TTBR0_EL1存放进程的页全局目录的物理地址  <br></p>
</blockquote>
<p> 命中了TLB表项，从TLB表项读取访问权限，检查访问权限，如果没有访问权限，生成页错误异常   <br>
 没有命中TLB表项，内存管理单元将会查询内存中的页表，称为转换表遍历（translation table walk），分两种情况   <br>
 （1）虚拟地址的高16位全部是1，是内核虚拟地址，查询内核的页表，从寄存器TTBR1_EL1取内核的页全局目录的物理地址  <br>
 （2）虚拟地址的高16位全部是0，用户虚拟地址，查询进程的页表，从寄存器TTBR0_EL1取进程的页全局目录的物理地址  <br></p>
<h4 id="2处理页错误异常">2.处理页错误异常<a hidden class="anchor" aria-hidden="true" href="#2处理页错误异常">#</a></h4>
<p> ARM64架构的内核异常向量表，起始地址是vectors（源文件arch/arm64/ kernel/entry.S），每个异常向量的长度是128字节，在Linux内核中每个异常向量只有一条指令：跳转到对应的处理程序。异常向量表的虚拟地址存放在异常级别1的向量基准地址寄存器(Vector Base Address Register for Exception Level 1，VBAR_EL1)中</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221119231907.png" alt="20221119231907"  />
</p>
<center>ARM64处理器处理页错误异常</center>
<p> (1)异常类型是异常级别1生成的同步异常，异常向量的偏移是0x200，异常向量跳转到函数el1_sync  <br>
 (2)异常类型是64位用户程序在异常级别0生成的同步异常，异常向量的偏移是0x400，异常向量跳转到函数el0_sync <br>
 (3)异常类型是32位用户程序在异常级别0生成的同步异常，异常向量的偏移是0x600，异常向量跳转到函数el0_sync_compat   <br></p>
<p> 函数el0_sync根据异常级别1的异常症状寄存器的异常类别字段处理  <br>
 (1)异常类别是异常级别0生成的数据中止(data abort)，即在异常级别0访问数据时生成页错误异常，调用函数el0_da   <br>
 (2)异常类别是异常级别0生成的指令中止(instruction abort)，即在异常级别0取指令时生成页错误异常，调用函数el0_ia  <br>
 ARM64处理器，异常级别1的异常症状寄存器(ESR_EL1，Exception Syndrome Register for Exception Level 1)用来存放异常的症状信息   <br>
 EC：异常类别(Exception Class)，指示引起异常的原因   <br>
 ISS：指令特定症状  <br></p>
<p> <strong>（1）do_mem_abort函数</strong>
 do_mem_abort函数根据异常症状寄存器的指令特定症状字段的指令错误状态码，调用数组fault_info中处理函数   <Br>
 指令错误状态码和处理函数的对应关系</p>
<table>
	<tr>
	    <th>指令错误状态码</th>
	    <th>说　　明</th>
	    <th>处 理 函 数</th>
	</tr >
	<tr >
	    <td>4</td>
	    <td>0级转换错误</td>
	    <td>do_translation_fault</td>
	</tr>
	<tr >
	    <td>5</td>
	    <td>1级转换错误</td>
	    <td>do_translation_fault</td>
	</tr>
	<tr >
	    <td>6</td>
	    <td>2级转换错误</td>
	    <td>do_translation_fault</td>
	</tr>
	<tr >
	    <td>7</td>
	    <td>3级转换错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>9</td>
	    <td>1级访问标志错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>10</td>
	    <td>2级访问标志错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>11</td>
	    <td>3级访问标志错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>13</td>
	    <td>1级权限错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>14</td>
	    <td>2级权限错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>15</td>
	    <td>3级权限错误</td>
	    <td>do_page_fault</td>
	</tr>
	<tr >
	    <td>33</td>
	    <td>对齐错误</td>
	    <td>do_alignment_fault</td>
	</tr>
	<tr >
	    <td>其他</td>
	    <td>其他错误</td>
	    <td>do_bad</td>
	</tr>
</table>
<p> <strong>（2）do_translation_fault函数</strong>
 do_translation_fault处理在0级、1级或2级转换表中匹配的表项是无效描述符</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221121233805.png" alt="20221121233805"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/fault.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// addr触发异常的虚拟地址 esr异常症状状态寄存器值 regs指向内核栈中保存的被打断的进程的寄存器集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __kprobes <span style="color:#a6e22e">do_translation_fault</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> esr, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (addr <span style="color:#f92672">&lt;</span> TASK_SIZE)  
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_page_fault</span>(addr, esr, regs); <span style="color:#75715e">// 虚拟地址是用户虚拟地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 异常虚拟地址是内核虚拟地址或不规范地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">do_bad_area</span>(addr, esr, regs); 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> do_bad_area</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/fault.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_bad_area</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> esr, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>active_mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> fault_info <span style="color:#f92672">*</span>inf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">user_mode</span>(regs)) {
</span></span><span style="display:flex;"><span>		inf <span style="color:#f92672">=</span> <span style="color:#a6e22e">esr_to_fault_info</span>(esr);  <span style="color:#75715e">// 异常是在用户模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">__do_user_fault</span>(tsk, addr, esr, inf<span style="color:#f92672">-&gt;</span>sig, inf<span style="color:#f92672">-&gt;</span>code, regs);  <span style="color:#75715e">// 发送信号以杀死进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__do_kernel_fault</span>(mm, addr, esr, regs);   <span style="color:#75715e">// 异常是在内核模式下生成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p> <strong>（3）函数do_page_fault</strong></p>
<center>函数do_page_fault的执行流</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221121234626.png" alt="20221121234626"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/fault.c   linux4.x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __kprobes <span style="color:#a6e22e">do_page_fault</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> esr,
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fault, sig, code;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags <span style="color:#f92672">=</span> VM_READ <span style="color:#f92672">|</span> VM_WRITE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> mm_flags <span style="color:#f92672">=</span> FAULT_FLAG_ALLOW_RETRY <span style="color:#f92672">|</span> FAULT_FLAG_KILLABLE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	tsk <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>	mm  <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>mm;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 禁止执行页错误异常处理程序，或者处于原子上下文，或者当前进程是内核线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">faulthandler_disabled</span>() <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>mm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> no_context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">user_mode</span>(regs))
</span></span><span style="display:flex;"><span>		mm_flags <span style="color:#f92672">|=</span> FAULT_FLAG_USER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_el0_instruction_abort</span>(esr)) {
</span></span><span style="display:flex;"><span>		vm_flags <span style="color:#f92672">=</span> VM_EXEC;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ((esr <span style="color:#f92672">&amp;</span> ESR_ELx_WNR) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(esr <span style="color:#f92672">&amp;</span> ESR_ELx_CM)) {
</span></span><span style="display:flex;"><span>		vm_flags <span style="color:#f92672">=</span> VM_WRITE;
</span></span><span style="display:flex;"><span>		mm_flags <span style="color:#f92672">|=</span> FAULT_FLAG_WRITE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (addr <span style="color:#f92672">&lt;</span> USER_DS <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">is_permission_fault</span>(esr, regs, addr)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 如果从异常级别0进入，regs-&gt;orig_addr_limit可能是0 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (regs<span style="color:#f92672">-&gt;</span>orig_addr_limit <span style="color:#f92672">==</span> KERNEL_DS)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">die</span>(<span style="color:#e6db74">&#34;Accessing user space memory with fs=KERNEL_DS&#34;</span>, regs, esr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_el1_instruction_abort</span>(esr))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">die</span>(<span style="color:#e6db74">&#34;Attempting to execute userspace memory&#34;</span>, regs, esr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">search_exception_tables</span>(regs<span style="color:#f92672">-&gt;</span>pc))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">die</span>(<span style="color:#e6db74">&#34;Accessing user space memory outside uaccess.h routines&#34;</span>, regs, esr);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">down_read_trylock</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>mmap_sem)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">user_mode</span>(regs) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">search_exception_tables</span>(regs<span style="color:#f92672">-&gt;</span>pc))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> no_context;
</span></span><span style="display:flex;"><span>	retry:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">down_read</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>mmap_sem);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">might_sleep</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fault <span style="color:#f92672">=</span> <span style="color:#a6e22e">__do_page_fault</span>(mm, addr, mm_flags, vm_flags, tsk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((fault <span style="color:#f92672">&amp;</span> VM_FAULT_RETRY) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">fatal_signal_pending</span>(current))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (mm_flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_ALLOW_RETRY) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fault <span style="color:#f92672">&amp;</span> VM_FAULT_MAJOR) {
</span></span><span style="display:flex;"><span>			tsk<span style="color:#f92672">-&gt;</span>maj_flt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			tsk<span style="color:#f92672">-&gt;</span>min_flt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fault <span style="color:#f92672">&amp;</span> VM_FAULT_RETRY) {
</span></span><span style="display:flex;"><span>			mm_flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>FAULT_FLAG_ALLOW_RETRY;
</span></span><span style="display:flex;"><span>			mm_flags <span style="color:#f92672">|=</span> FAULT_FLAG_TRIED;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">up_read</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>mmap_sem);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span>(fault <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_BADMAP <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>				VM_FAULT_BADACCESS))))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">user_mode</span>(regs))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> no_context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fault <span style="color:#f92672">&amp;</span> VM_FAULT_OOM) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pagefault_out_of_memory</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fault <span style="color:#f92672">&amp;</span> VM_FAULT_SIGBUS) {
</span></span><span style="display:flex;"><span>		sig <span style="color:#f92672">=</span> SIGBUS;
</span></span><span style="display:flex;"><span>		code <span style="color:#f92672">=</span> BUS_ADRERR;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		sig <span style="color:#f92672">=</span> SIGSEGV;
</span></span><span style="display:flex;"><span>		code <span style="color:#f92672">=</span> fault <span style="color:#f92672">==</span> VM_FAULT_BADACCESS <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>			SEGV_ACCERR : SEGV_MAPERR;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__do_user_fault</span>(tsk, addr, esr, sig, code, regs);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	no_context:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__do_kernel_fault</span>(mm, addr, esr, regs);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 原子上下文：执行硬中断、执行软中断、禁止硬中断、禁止软中断和禁止内核抢占这五种情况不允许睡眠，称为原子上下文  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122000428.png" alt="20221122000428"  />
</p>
<center>函数__do_page_fault的执行流程</center>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/fault.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__do_page_fault</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> mm_flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags,
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fault;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	vma <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_vma</span>(mm, addr);
</span></span><span style="display:flex;"><span>	fault <span style="color:#f92672">=</span> VM_FAULT_BADMAP;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>vma))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(vma<span style="color:#f92672">-&gt;</span>vm_start <span style="color:#f92672">&gt;</span> addr))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> check_stack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	good_area:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> vm_flags)) {
</span></span><span style="display:flex;"><span>		fault <span style="color:#f92672">=</span> VM_FAULT_BADACCESS;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">handle_mm_fault</span>(vma, addr <span style="color:#f92672">&amp;</span> PAGE_MASK, mm_flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	check_stack:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_GROWSDOWN <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">expand_stack</span>(vma, addr))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> good_area;
</span></span><span style="display:flex;"><span>	out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> fault;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3142用户空间页错误异常">3.14.2　用户空间页错误异常<a hidden class="anchor" aria-hidden="true" href="#3142用户空间页错误异常">#</a></h3>
<p> 函数handle_mm_fault处理用户空间的页错误异常，两种情况：  <br>
 (1)进程在用户模式下访问用户虚拟地址，生成页错误异常   <br>
 (2)进程在内核模式下访问用户虚拟地址，生成页错误异常。进程通过系统调用进入内核模式，系统调用传入用户空间的缓冲区，进程在内核模式下访问用户空间的缓冲区    <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">handle_mm_fault</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address,
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">is_vm_hugetlb_page</span>(vma))) 
</span></span><span style="display:flex;"><span>         ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">hugetlb_fault</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, vma, address, flags);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>         ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">__handle_mm_fault</span>(vma, address, flags);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122001007.png" alt="20221122001007"  />
</p>
<p> 巨型页函数hugetlb_fault，普通页__handle_mm_fault</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__handle_mm_fault</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_fault vmf <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>		.vma <span style="color:#f92672">=</span> vma,
</span></span><span style="display:flex;"><span>		.address <span style="color:#f92672">=</span> address <span style="color:#f92672">&amp;</span> PAGE_MASK,
</span></span><span style="display:flex;"><span>		.flags <span style="color:#f92672">=</span> flags,
</span></span><span style="display:flex;"><span>		.pgoff <span style="color:#f92672">=</span> <span style="color:#a6e22e">linear_page_index</span>(vma, address),
</span></span><span style="display:flex;"><span>		.gfp_mask <span style="color:#f92672">=</span> <span style="color:#a6e22e">__get_fault_gfp_mask</span>(vma),
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> vma<span style="color:#f92672">-&gt;</span>vm_mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span>pgd;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">p4d_t</span> <span style="color:#f92672">*</span>p4d;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在页全局目录中查找虚拟地址对应的表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pgd <span style="color:#f92672">=</span> <span style="color:#a6e22e">pgd_offset</span>(mm, address);
</span></span><span style="display:flex;"><span>	p4d <span style="color:#f92672">=</span> <span style="color:#a6e22e">p4d_alloc</span>(mm, pgd, address);  <span style="color:#75715e">// 在页四级目录中查找虚拟地址对应的表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p4d)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在页上层目录中查找虚拟地址对应的表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vmf.pud <span style="color:#f92672">=</span> <span style="color:#a6e22e">pud_alloc</span>(mm, p4d, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf.pud)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在页中间目录中查找虚拟地址对应的表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vmf.pmd <span style="color:#f92672">=</span> <span style="color:#a6e22e">pmd_alloc</span>(mm, vmf.pud, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf.pmd)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 到达直接页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">handle_pte_fault</span>(<span style="color:#f92672">&amp;</span>vmf);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122001438.png" alt="20221122001438"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">handle_pte_fault</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> entry;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 直接页表中查找虚拟地址对应的表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">pmd_none</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pmd))) {
</span></span><span style="display:flex;"><span>		vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_map</span>(vmf<span style="color:#f92672">-&gt;</span>pmd, vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>		vmf<span style="color:#f92672">-&gt;</span>orig_pte <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pte_none</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">pte_unmap</span>(vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>			vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 页表项不存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf<span style="color:#f92672">-&gt;</span>pte) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">vma_is_anonymous</span>(vmf<span style="color:#f92672">-&gt;</span>vma))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_anonymous_page</span>(vmf); 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 页表项存在，但是页不在物理内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_present</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_swap_page</span>(vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	vmf<span style="color:#f92672">-&gt;</span>ptl <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_lockptr</span>(vmf<span style="color:#f92672">-&gt;</span>vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>pmd);  <span style="color:#75715e">// 获取页表锁的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spin_lock</span>(vmf<span style="color:#f92672">-&gt;</span>ptl);  <span style="color:#75715e">// 锁住页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	entry <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>orig_pte;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_same</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte, entry)))  <span style="color:#75715e">// 重新读取页表项的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">goto</span> unlock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_write</span>(entry))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_wp_page</span>(vmf);   <span style="color:#75715e">// 执行写时复制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_mkdirty</span>(entry); <span style="color:#75715e">// 页表项有写权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_mkyoung</span>(entry);  <span style="color:#75715e">// 设置页表项的访问标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ptep_set_access_flags</span>(vmf<span style="color:#f92672">-&gt;</span>vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte, entry,
</span></span><span style="display:flex;"><span>				vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE)) { <span style="color:#75715e">// 设置页表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">update_mmu_cache</span>(vmf<span style="color:#f92672">-&gt;</span>vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte); <span style="color:#75715e">// 更新处理器的内存管理单元的页表缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">flush_tlb_fix_spurious_fault</span>(vmf<span style="color:#f92672">-&gt;</span>vma, vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	unlock: <span style="color:#75715e">// 释放页表的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pte_unmap_unlock</span>(vmf<span style="color:#f92672">-&gt;</span>pte, vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="1匿名页的缺页异常">1．匿名页的缺页异常<a hidden class="anchor" aria-hidden="true" href="#1匿名页的缺页异常">#</a></h4>
<p> 函数do_anonymous_page处理私有匿名页的缺页异常</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122002143.png" alt="20221122002143"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_anonymous_page</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> entry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 没有“-&gt;vm_ops”的文件映射？ */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_SHARED)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_SIGBUS;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 直接页表不存在，分配页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pte_alloc</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>pmd, vmf<span style="color:#f92672">-&gt;</span>address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 如果是读操作，映射到零页 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">!</span><span style="color:#a6e22e">mm_forbids_zeropage</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm)) {
</span></span><span style="display:flex;"><span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_mkspecial</span>(<span style="color:#a6e22e">pfn_pte</span>(<span style="color:#a6e22e">my_zero_pfn</span>(vmf<span style="color:#f92672">-&gt;</span>address),
</span></span><span style="display:flex;"><span>							vma<span style="color:#f92672">-&gt;</span>vm_page_prot));
</span></span><span style="display:flex;"><span>		vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_map_lock</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>pmd,
</span></span><span style="display:flex;"><span>				vmf<span style="color:#f92672">-&gt;</span>address, <span style="color:#f92672">&amp;</span>vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_none</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> unlock;
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> setpte;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 分配我们自己的私有页 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">anon_vma_prepare</span>(vma)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> oom;
</span></span><span style="display:flex;"><span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_zeroed_user_highpage_movable</span>(vma, vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> oom;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__SetPageUptodate</span>(page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">mk_pte</span>(page, vma<span style="color:#f92672">-&gt;</span>vm_page_prot);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_WRITE)
</span></span><span style="display:flex;"><span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_mkwrite</span>(<span style="color:#a6e22e">pte_mkdirty</span>(entry));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_map_lock</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>pmd, vmf<span style="color:#f92672">-&gt;</span>address,
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&amp;</span>vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_none</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> release;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc_mm_counter_fast</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, MM_ANONPAGES);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">page_add_new_anon_rmap</span>(page, vma, vmf<span style="color:#f92672">-&gt;</span>address, false);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lru_cache_add_active_or_unevictable</span>(page, vma);
</span></span><span style="display:flex;"><span>	setpte:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">set_pte_at</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte, entry);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 不需要从页表缓存删除页表项，因为以前虚拟页没有映射到物理页 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">update_mmu_cache</span>(vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>	unlock:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pte_unmap_unlock</span>(vmf<span style="color:#f92672">-&gt;</span>pte, vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	release:
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_page</span>(page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> unlock;
</span></span><span style="display:flex;"><span>	oom_free_page:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_page</span>(page);
</span></span><span style="display:flex;"><span>	oom:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2文件页的缺页异常">2．文件页的缺页异常<a hidden class="anchor" aria-hidden="true" href="#2文件页的缺页异常">#</a></h4>
<p> 触发文件页的缺页异常:  <br>
 (1)启动程序时，第一次访问的时候触发文件页的缺页异常  <br>
 (2)进程使用mmap创建文件映射，第一次访问的时候触发文件页的缺页异常   <br></p>
<p> 函数do_fault处理文件页和共享匿名页的缺页异常
<img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122002649.png" alt="20221122002649"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_fault</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 这个vm_area_struct结构体在执行mmap()的时候没有完全填充，或者缺少标志位VM_DONTEXPAND。 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vma<span style="color:#f92672">-&gt;</span>vm_ops<span style="color:#f92672">-&gt;</span>fault)
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> VM_FAULT_SIGBUS;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE))  <span style="color:#75715e">// 缺页异常是由读文件页触发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">do_read_fault</span>(vmf);  <span style="color:#75715e">// 处理读文件页错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_SHARED))  <span style="color:#75715e">// 缺页异常是由写私有文件页触发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">do_cow_fault</span>(vmf);  <span style="color:#75715e">// 写私有文件页错误, 执行写时复制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span>  <span style="color:#75715e">// 缺页异常是由写共享文件页触发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">do_shared_fault</span>(vmf);  <span style="color:#75715e">// 处理写共享文件页错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （1）处理读文件页错误  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122003030.png" alt="20221122003030"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_read_fault</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 全局变量fault_around_bytes控制总长度，默认值是64KB。如果页长度是4KB，就一次读取16页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (vma<span style="color:#f92672">-&gt;</span>vm_ops<span style="color:#f92672">-&gt;</span>map_pages <span style="color:#f92672">&amp;&amp;</span> fault_around_bytes <span style="color:#f92672">&gt;&gt;</span> PAGE_SHIFT <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">do_fault_around</span>(vmf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 文件页读到文件的页缓存中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">__do_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE <span style="color:#f92672">|</span> VM_FAULT_RETRY)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 虚拟页映射到文件的页缓存中的物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ret <span style="color:#f92672">|=</span> <span style="color:#a6e22e">finish_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlock_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE <span style="color:#f92672">|</span> VM_FAULT_RETRY)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数finish_fault负责设置页表项，把主要工作委托给函数alloc_set_pte</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221122003336.png" alt="20221122003336"  />
</p>
<center>函数finish_fault的执行流程</center>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">alloc_set_pte</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf, <span style="color:#66d9ef">struct</span> mem_cgroup <span style="color:#f92672">*</span>memcg,
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> write <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> entry;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf<span style="color:#f92672">-&gt;</span>pte) {  <span style="color:#75715e">// 直接页表不存在，分配直接页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_alloc_one_map</span>(vmf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 锁住页表后重新检查 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_none</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_NOPAGE;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 直接页表不存在，那么分配直接页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">flush_icache_page</span>(vma, page);
</span></span><span style="display:flex;"><span>	entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">mk_pte</span>(page, vma<span style="color:#f92672">-&gt;</span>vm_page_prot);  <span style="color:#75715e">// 使用页帧号和访问权限生成页表项的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (write)  <span style="color:#75715e">// 写访问，设置页表项的脏标志位和写权限位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">maybe_mkwrite</span>(<span style="color:#a6e22e">pte_mkdirty</span>(entry), vma);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 写时复制的页 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (write <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_SHARED)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">inc_mm_counter_fast</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, MM_ANONPAGES);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">page_add_new_anon_rmap</span>(page, vma, vmf<span style="color:#f92672">-&gt;</span>address, false);
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">lru_cache_add_active_or_unevictable</span>(page, vma);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">inc_mm_counter_fast</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, <span style="color:#a6e22e">mm_counter_file</span>(page));
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">page_add_file_rmap</span>(page, false);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">set_pte_at</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte, entry);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 不需要使无效：一个不存在的页不会被缓存 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">update_mmu_cache</span>(vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221123012105.png" alt="20221123012105"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_cow_fault</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">anon_vma_prepare</span>(vma)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 关联一个anon_vma实例到虚拟内存区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vmf<span style="color:#f92672">-&gt;</span>cow_page <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_page_vma</span>(GFP_HIGHUSER_MOVABLE, vma, vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf<span style="color:#f92672">-&gt;</span>cow_page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">__do_fault</span>(vmf);  <span style="color:#75715e">// 把文件页读到文件的页缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE <span style="color:#f92672">|</span> VM_FAULT_RETRY)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> uncharge_out;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&amp;</span> VM_FAULT_DONE_COW)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把文件的页缓存中物理页的数据复制到副本物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">copy_user_highpage</span>(vmf<span style="color:#f92672">-&gt;</span>cow_page, vmf<span style="color:#f92672">-&gt;</span>page, vmf<span style="color:#f92672">-&gt;</span>address, vma);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__SetPageUptodate</span>(vmf<span style="color:#f92672">-&gt;</span>cow_page);  <span style="color:#75715e">// 设置副本页描述符的标志位PG_uptodate，表示物理页包含有效的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 设置页表项，把虚拟页映射到副本物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ret <span style="color:#f92672">|=</span> <span style="color:#a6e22e">finish_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlock_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE <span style="color:#f92672">|</span> VM_FAULT_RETRY)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> uncharge_out;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	uncharge_out:
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_page</span>(vmf<span style="color:#f92672">-&gt;</span>cow_page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221123012433.png" alt="20221123012433"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_shared_fault</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, tmp;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把文件页读到文件的页缓存中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">__do_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE <span style="color:#f92672">|</span> VM_FAULT_RETRY)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vma<span style="color:#f92672">-&gt;</span>vm_ops<span style="color:#f92672">-&gt;</span>page_mkwrite) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>		tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">do_page_mkwrite</span>(vmf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>tmp <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>					(tmp <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE)))) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">put_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置页表项，把虚拟页映射到文件的页缓存中的物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ret <span style="color:#f92672">|=</span> <span style="color:#a6e22e">finish_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">&amp;</span> (VM_FAULT_ERROR <span style="color:#f92672">|</span> VM_FAULT_NOPAGE <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>						VM_FAULT_RETRY))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_page</span>(vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置页的脏标志位，表示页的数据被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fault_dirty_shared_page</span>(vma, vmf<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3写时复制">3．写时复制<a hidden class="anchor" aria-hidden="true" href="#3写时复制">#</a></h4>
<p> 两种情况会执行写时复制(Copy on Write，CoW)   <br>
 (1)进程分叉生成子进程的时候，为了避免复制物理页，子进程和父进程以只读方式共享所有私有的匿名页和文件页  <br>
 (2)进程创建私有的文件映射，然后读访问，触发页错误异常   <br>
 函数do_wp_page处理写时复制</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221123012905.png" alt="20221123012905"  />
</p>
<p> 函数wp_page_copy执行写时复制</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221123234243.png" alt="20221123234243"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/memory.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">wp_page_copy</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> vma<span style="color:#f92672">-&gt;</span>vm_mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>old_page <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>new_page <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> entry;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> page_copied <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> mmun_start <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>address <span style="color:#f92672">&amp;</span> PAGE_MASK;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> mmun_end <span style="color:#f92672">=</span> mmun_start <span style="color:#f92672">+</span> PAGE_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mem_cgroup <span style="color:#f92672">*</span>memcg;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 关联一个anon_vma实例到虚拟内存区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">anon_vma_prepare</span>(vma)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> oom;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_zero_pfn</span>(<span style="color:#a6e22e">pte_pfn</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte))) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 是零页，分配一个物理页，然后用零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new_page <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_zeroed_user_highpage_movable</span>(vma,vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>new_page)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> oom;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 不是零页，分配一个物理页，然后把数据复制到新的物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new_page <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_page_vma</span>(GFP_HIGHUSER_MOVABLE, vma,
</span></span><span style="display:flex;"><span>					vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>new_page)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> oom;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cow_user_page</span>(new_page, old_page, vmf<span style="color:#f92672">-&gt;</span>address, vma);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 不是零页，那么分配一个物理页，然后把数据复制到新的物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">__SetPageUptodate</span>(new_page); <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mmu_notifier_invalidate_range_start</span>(mm, mmun_start, mmun_end);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_map_lock</span>(mm, vmf<span style="color:#f92672">-&gt;</span>pmd, vmf<span style="color:#f92672">-&gt;</span>address, <span style="color:#f92672">&amp;</span>vmf<span style="color:#f92672">-&gt;</span>ptl);  <span style="color:#75715e">// 锁住页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#a6e22e">pte_same</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte, vmf<span style="color:#f92672">-&gt;</span>orig_pte))) {
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">flush_cache_page</span>(vma, vmf<span style="color:#f92672">-&gt;</span>address, <span style="color:#a6e22e">pte_pfn</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte));  <span style="color:#75715e">// 从缓存中冲刷页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 使用新的物理页和访问权限生成页表项的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">mk_pte</span>(new_page, vma<span style="color:#f92672">-&gt;</span>vm_page_prot);
</span></span><span style="display:flex;"><span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">maybe_mkwrite</span>(<span style="color:#a6e22e">pte_mkdirty</span>(entry), vma);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把页表项清除，并且冲刷页表缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ptep_clear_flush_notify</span>(vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 建立新物理页到虚拟页的反向映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">page_add_new_anon_rmap</span>(new_page, vma, vmf<span style="color:#f92672">-&gt;</span>address, false);
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把物理页添加到活动LRU链表或不可回收LRU链表中，页回收算法需要从LRU链表中选择需要回收的物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">lru_cache_add_active_or_unevictable</span>(new_page, vma);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 修改页表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">set_pte_at_notify</span>(mm, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte, entry);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 更新页表缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">update_mmu_cache</span>(vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (old_page) { <span style="color:#75715e">// 删除旧物理页到虚拟页的反向映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">page_remove_rmap</span>(old_page, false);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 释放旧的物理页 */</span>
</span></span><span style="display:flex;"><span>		new_page <span style="color:#f92672">=</span> old_page;
</span></span><span style="display:flex;"><span>		page_copied <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (new_page)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_page</span>(new_page);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放页表的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pte_unmap_unlock</span>(vmf<span style="color:#f92672">-&gt;</span>pte, vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mmu_notifier_invalidate_range_end</span>(mm, mmun_start, mmun_end);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (old_page) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (page_copied <span style="color:#f92672">&amp;&amp;</span> (vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_LOCKED)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">lock_page</span>(old_page);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">PageMlocked</span>(old_page))
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">munlock_vma_page</span>(old_page);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">unlock_page</span>(old_page);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_page</span>(old_page);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page_copied <span style="color:#f92672">?</span> VM_FAULT_WRITE : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	oom_free_new:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_page</span>(new_page);
</span></span><span style="display:flex;"><span>	oom:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (old_page)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">put_page</span>(old_page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3143内核模式页错误异常">3.14.3　内核模式页错误异常<a hidden class="anchor" aria-hidden="true" href="#3143内核模式页错误异常">#</a></h3>
<p> 内核使用线性映射区域的虚拟地址，在内存管理子系统初始化的时把虚拟地址映射到物理地址，运行过程中使用vmalloc()函数从vmalloc区域分配虚拟内存区域，vmalloc()函数会分配并且映射到物理页    <br>
 有些系统调用会传入用户空间的缓冲区，内核必须使用头文件“uaccess.h”定义的专用函数访问用户空间的缓冲区，专用函数在异常表中添加了可能触发异常的指令地址和异常修正程序的地址。如果访问用户空间的缓冲区时生成页错误异常，页错误异常处理程序发现用户虚拟地址没有被分配给进程，就在异常表中查找指令地址对应的异常修正程序，如果找到了，使用异常修正程序修正异常，避免内核崩溃  <br></p>
<p> 在内核模式下执行时触发页错误异常，ARM64架构内核的处理流程，3种处理方式  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221123235909.png" alt="20221123235909"  />
</p>
<p> (1)不允许内核执行用户空间治疗，内核模式执行用户态指令，内核崩溃   <br>
 (2)内核模式下访问用户虚拟地址，先使用函数__do_page_fault处理，处理失败使用__do_kernel_fault处理   <br>
 (3)其他情况 __do_kernel_fault处理  <br></p>
<h4 id="1函数__do_kernel_fault">1.函数__do_kernel_fault<a hidden class="anchor" aria-hidden="true" href="#1函数__do_kernel_fault">#</a></h4>
<p> 访问数据生成的异常，函数__do_kernel_fault尝试在异常表中查找异常修正程序  <br>
 找到异常修正程序，把保存在内核栈中的异常链接寄存器(ELR_EL1，Exception Link Register for Exception Level 1)的值修改为异常修正程序的虚拟地址。当异常处理程序返回的时候，处理器把程序计数器设置成异常链接寄存器的值，执行异常修正程序 <br>
 如果没有找到异常修正程序，内核崩溃   <br>
 函数__do_kernel_fault</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/fault.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__do_kernel_fault</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> esr, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果异常是由访问数据生成的，那么在异常表中查找异常修复程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">is_el1_instruction_abort</span>(esr) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">fixup_exception</span>(regs))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 清除任何可能阻止在终端打印信息的自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bust_spinlocks</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_permission_fault</span>(esr, regs, addr)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (esr <span style="color:#f92672">&amp;</span> ESR_ELx_WNR)
</span></span><span style="display:flex;"><span>			msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;write to read-only memory&#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;read from unreadable memory&#34;</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (addr <span style="color:#f92672">&lt;</span> PAGE_SIZE) {
</span></span><span style="display:flex;"><span>		msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;NULL pointer dereference&#34;</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;paging request&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 打印触发页错误异常的原因
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pr_alert</span>(<span style="color:#e6db74">&#34;Unable to handle kernel %s at virtual address %08lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, msg,
</span></span><span style="display:flex;"><span>		addr);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 打印页表信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">show_pte</span>(mm, addr);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">die</span>(<span style="color:#e6db74">&#34;Oops&#34;</span>, regs, esr);  <span style="color:#75715e">// 调用函数die()以打印寄存器信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bust_spinlocks</span>(<span style="color:#ae81ff">0</span>);  <span style="color:#75715e">// 停止清除任何可能阻止打印信息的自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">do_exit</span>(SIGKILL);  <span style="color:#75715e">// 终止当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p> 函数fixup_exception根据指令地址在异常表中查找，然后把保存在内核栈中的异常链接寄存器的值修改为异常修正程序的虚拟地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/extable.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fixup_exception</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> exception_table_entry <span style="color:#f92672">*</span>fixup;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fixup <span style="color:#f92672">=</span> <span style="color:#a6e22e">search_exception_tables</span>(<span style="color:#a6e22e">instruction_pointer</span>(regs));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fixup)
</span></span><span style="display:flex;"><span>          regs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)<span style="color:#f92672">&amp;</span>fixup<span style="color:#f92672">-&gt;</span>fixup <span style="color:#f92672">+</span> fixup<span style="color:#f92672">-&gt;</span>fixup;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> fixup <span style="color:#f92672">!=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 异常表项中存储的指令地址是相对地址：fixup-&gt;insn =（指令的虚拟地址 − &amp;fixup-&gt;insn） <br>
 异常表项中存储的异常修正程序的地址是相对地址：fixup-&gt;fixup =（异常修正程序的虚拟地址 − &amp;fixup-&gt;fixup）  <br>
 regs-&gt;pc是保存在内核栈中的异常链接寄存器的值  <br></p>
<p> 函数search_exception_tables根据指令地址在异常表中查找表项</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/extable.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> exception_table_entry <span style="color:#f92672">*</span><span style="color:#a6e22e">search_exception_tables</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> exception_table_entry <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在内核的异常表中查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">search_extable</span>(__start___ex_table, __stop___ex_table<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, addr); 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>e)  <span style="color:#75715e">// 在内核的异常表中没有找到，根据触发异常的指令的虚拟地址找到内核模块，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		e <span style="color:#f92672">=</span> <span style="color:#a6e22e">search_module_extables</span>(addr);  <span style="color:#75715e">// 在内核模块的异常表中查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> e;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2异常表">2.异常表<a hidden class="anchor" aria-hidden="true" href="#2异常表">#</a></h4>
<p> 进程在内核模式下运行的时候，访问用户虚拟地址时，应用程序通常是不可信任的，不能保证传入的用户虚拟地址是合法的，采取措施保护内核。使用异常表，每条表项有两个字段  <br>
 (1)触发异常的指令的虚拟地址   <br>
 (2)异常修正程序的起始虚拟地址   <br></p>
<p> 异常表项定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/extable.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> exception_table_entry
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> insn, fixup;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 内核有一张异常表，全局变量__start___ex_table存放异常表的起始地址，__stop___ex_table存放异常表的结束地址  <br>
 进程在内核模式下访问用户虚拟地址的时候，只允许使用头文件“uaccess.h”声明的函数，以函数get_user为例，函数get_user从用户空间读取C语言标准类型的数据，ARM64架构实现  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/uaccess.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define get_user(x, ptr)                              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">({                                                    \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    __typeof__(*(ptr)) __user *__p = (ptr);            \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    might_fault();                                    \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    access_ok(VERIFY_READ, __p, sizeof(*__p)) ?        \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        __get_user((x), __p) :                         \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        ((x) = 0, -EFAULT);                           \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">})
</span></span></span></code></pre></div><p> 在64位内核中长整数的长度是8字节，把“__get_user((x), __p)”展开</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(                              \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;1: ldr %x1, [%2]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,                      \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;2:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                                     \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .section .fixup, </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">ax</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>            \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .align    2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                        \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;3:  mov    %w0, %3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                     \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    mov    %1, #0</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                      \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    b    2b</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                            \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .previous</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                          \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .pushsection    __ex_table, </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">a</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>   \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .align    3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                        \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .long    (1b  - .), (3b - .)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>       \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;    .popsection</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;+r&#34;</span> (err), <span style="color:#e6db74">&#34;=&amp;r&#34;</span> (x)                    \
</span></span><span style="display:flex;"><span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;r&#34;</span> (__p), <span style="color:#e6db74">&#34;i&#34;</span> (<span style="color:#f92672">-</span>EFAULT))
</span></span></code></pre></div><p> 链接脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/vmlinux.lds.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    . <span style="color:#f92672">=</span> <span style="color:#a6e22e">ALIGN</span>(SEGMENT_ALIGN);
</span></span><span style="display:flex;"><span>    _etext <span style="color:#f92672">=</span> .;          <span style="color:#75715e">/* 代码段的结束地址 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RO_DATA</span>(PAGE_SIZE)   <span style="color:#75715e">/* 从这里到 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">EXCEPTION_TABLE</span>(<span style="color:#ae81ff">8</span>)   <span style="color:#75715e">/* __init_begin将被标记为只读和不可执行 */</span>
</span></span><span style="display:flex;"><span>    NOTES
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏EXCEPTION_TABLE的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// include/asm-generic/vmlinux.lds.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 异常表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EXCEPTION_TABLE(align)                         \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    . = ALIGN(align);                                  \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {    \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        VMLINUX_SYMBOL(__start___ex_table) = .;          \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        KEEP(*(__ex_table))                             \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        VMLINUX_SYMBOL(__stop___ex_table) = .;           \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span></code></pre></div><p> 内核的全局变量__start___ex_table存放异常表节（__ex_table）的起始地址，__stop___ex_table存放异常表节的结束地址  <br></p>
<h2 id="315反碎片技术">3.15　反碎片技术<a hidden class="anchor" aria-hidden="true" href="#315反碎片技术">#</a></h2>
<p> 反碎片技术  <br>
 (1)2.6.23版本引入了虚拟可移动区域  <br>
 (2)3.5版本内存碎片整理技术   <br>
 (3).6.24版本引入了根据可移动性分组的技术  <br>
 (4).6.35版本引入了内存碎片整理技术   <br></p>
<h3 id="3151虚拟可移动区域">3.15.1　虚拟可移动区域<a hidden class="anchor" aria-hidden="true" href="#3151虚拟可移动区域">#</a></h3>
<p> 可移动区域(ZONE_MOVABLE)是一个伪内存区域：把物理内存分为两个区域，一个区域用于分配不可移动的页，另一个区域用于分配可移动的页</p>
<h3 id="3152内存碎片整理">3.15.2　内存碎片整理<a hidden class="anchor" aria-hidden="true" href="#3152内存碎片整理">#</a></h3>
<p> 内存碎片整理(memory compaction，意译为“内存碎片整理”)：从内存区域的底部扫描已分配的可移动页，从内存区域的顶部扫描空闲页，把底部的可移动页移到顶部的空闲页，在底部形成连续的空闲页   <br></p>
<h4 id="1使用方法">1.使用方法<a hidden class="anchor" aria-hidden="true" href="#1使用方法">#</a></h4>
<p> 内存碎片整理功能，必须开启配置文件“mm/Kconfig”定义的配置宏CONFIG_COMPACTION，默认开启</p>
<h2 id="316页回收">3.16　页回收<a hidden class="anchor" aria-hidden="true" href="#316页回收">#</a></h2>
<p> 申请分配页的时候，页分配器首先尝试使用低水线分配页。如果使用低水线分配失败，说明内存轻微不足，页分配器将会唤醒内存节点的页回收内核线程，异步回收页，然后尝试使用最低水线分配页。如果使用最低水线分配失败，说明内存严重不足，页分配器将会直接回收页  <br></p>
<p> 内核使用LRU（Least Recently Used，最近最少使用）算法选择最近最少使用的物理页</p>
<h3 id="3161数据结构">3.16.1　数据结构<a hidden class="anchor" aria-hidden="true" href="#3161数据结构">#</a></h3>
<h4 id="1lru链表">1．LRU链表<a hidden class="anchor" aria-hidden="true" href="#1lru链表">#</a></h4>
<p> 页回收算法使用LRU算法选择回收的页。每个内存节点的pglist_data实例有一个成员lruvec，称为LRU向量，LRU向量包含5条LRU链表  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221124004231.png" alt="20221124004231"  />
</p>
<p>待补充</p>
<h3 id="3162发起页回收">3.16.2　发起页回收<a hidden class="anchor" aria-hidden="true" href="#3162发起页回收">#</a></h3>
<p> 申请分配页的时候，页分配器首先尝试使用低水线分配页。如果使用低水线分配失败，说明内存轻微不足，页分配器将会唤醒所有符合分配条件的内存节点的页回收线程，异步回收页，然后尝试使用最低水线分配页。如果分配失败，说明内存严重不足，页分配器将会直接回收页。如果直接回收页失败，那么判断是否应该重新尝试回收页    <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221124004637.png" alt="20221124004637"  />
</p>
<h3 id="3163计算扫描的页数">3.16.3　计算扫描的页数<a hidden class="anchor" aria-hidden="true" href="#3163计算扫描的页数">#</a></h3>
<h3 id="3164收缩活动页链表">3.16.4　收缩活动页链表<a hidden class="anchor" aria-hidden="true" href="#3164收缩活动页链表">#</a></h3>
<h3 id="3165回收不活动页">3.16.5　回收不活动页<a hidden class="anchor" aria-hidden="true" href="#3165回收不活动页">#</a></h3>
<h3 id="3166页交换">3.16.6　页交换<a hidden class="anchor" aria-hidden="true" href="#3166页交换">#</a></h3>
<h3 id="3167回收slab缓存">3.16.7　回收slab缓存<a hidden class="anchor" aria-hidden="true" href="#3167回收slab缓存">#</a></h3>
<h2 id="317内存耗尽杀手">3.17　内存耗尽杀手<a hidden class="anchor" aria-hidden="true" href="#317内存耗尽杀手">#</a></h2>
<p> 当内存严重不足的时候，页分配器在多次尝试直接页回收失败以后，就会调用内存耗尽杀手（OOM killer，OOM是“Out of Memory”的缩写），选择进程杀死，释放内存</p>
<div align=center>
<div class="mermaid">
  
 flowchart LR
    __alloc_pages_showpath[Hard edge] -->|Link text| __alloc_pages_may_oom(Round edge)
    __alloc_pages_may_oom --> out_of_memeory{Decision}

</div>
</div>
<h3 id="3171使用方法">3.17.1　使用方法<a hidden class="anchor" aria-hidden="true" href="#3171使用方法">#</a></h3>
<h3 id="3172技术原理">3.17.2　技术原理<a hidden class="anchor" aria-hidden="true" href="#3172技术原理">#</a></h3>
<h2 id="318内存资源控制器">3.18　内存资源控制器<a hidden class="anchor" aria-hidden="true" href="#318内存资源控制器">#</a></h2>
<p> 控制组(cgroup)的内存资源控制器用来控制一组进程的内存使用量，启用内存资源控制器的控制组简称内存控制组（memcg）。控制组把各种资源控制器称为子系统，内存资源控制器也称为内存子系统</p>
<h3 id="3181使用方法">3.18.1　使用方法<a hidden class="anchor" aria-hidden="true" href="#3181使用方法">#</a></h3>
<h3 id="3182技术原理">3.18.2　技术原理<a hidden class="anchor" aria-hidden="true" href="#3182技术原理">#</a></h3>
<h2 id="319处理器缓存">3.19　处理器缓存<a hidden class="anchor" aria-hidden="true" href="#319处理器缓存">#</a></h2>
<p> 处理器和内存之间增加了缓存。缓存和内存的区别   <br>
 (1)缓存是静态随机访问存储器(Static Random Access Memory，SRAM)   <br>
 (2)内存是动态随机访问存储器(Dynamic Random Access Memory，DRAM)  <br></p>
<p> 一级缓存分为一级指令缓存(i-cache，instruction cache)和一级数据数据(d-cache，data cache)。二级缓存是指令和数据共享的统一缓存(unified cache)  <br></p>
<h3 id="3191缓存结构">3.19.1　缓存结构<a hidden class="anchor" aria-hidden="true" href="#3191缓存结构">#</a></h3>
<p> 32KB四路组相连缓存(32KB 4-way set associative cache)  <br>
 缓存的结构  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221124010057.png" alt="20221124010057"  />
</p>
<p> 缓存由多个容量相同的子缓存并联组成，每个子缓存称为路(Way)，四路表示4个子缓存并联</p>
<p> ARM64处理器的指令缓存有3种类型  <br>
 (1)PIPT缓存 ： 物理地址生成索引和标签的缓存<br>
 (2)VPIPT（VMID-aware PIPT）缓存  <br>
 (3)VIPT：虚拟地址生成索引、从物理地址生成标签<br></p>
<h3 id="3192缓存策略">3.19.2　缓存策略<a hidden class="anchor" aria-hidden="true" href="#3192缓存策略">#</a></h3>
<p> 缓存分配有两种策略  <br>
 (1)写分配(write allocation)  <br>
 (2)读分配(read allocation)  <br>
 缓存更新有两种策略  <br>
 (1)写回(write back)  <br>
 (2)写透(write-through)  <br></p>
<h3 id="3193-缓存维护">3.19.3 缓存维护<a hidden class="anchor" aria-hidden="true" href="#3193-缓存维护">#</a></h3>
<h4 id="3arm64处理器缓存维护">3.ARM64处理器缓存维护<a hidden class="anchor" aria-hidden="true" href="#3arm64处理器缓存维护">#</a></h4>
<p> ARM64处理器支持3种缓存操作。  <br>
 （1）使缓存行失效（invalidate）：清除缓存行的有效位。  <br>
 （2）清理（clean）缓存行：首先把标记为脏的缓存行里面的数据写到下一级缓存或内存，然后清除缓存行的有效位。只适用于使用写回策略的数据缓存。  <br>
 （3）清零（zero）：把缓存里面的一个内存块清零，不需要先从内存读数据到缓存中。只适用于数据缓存   <br></p>
<h3 id="3194smp缓存一致性">3.19.4　SMP缓存一致性<a hidden class="anchor" aria-hidden="true" href="#3194smp缓存一致性">#</a></h3>
<p> 原生的MESI协议有4种状态。MESI是4种状态的首字母缩写，缓存行的4种状态</p>
<h2 id="320-连续内存分配器">3.20 连续内存分配器<a hidden class="anchor" aria-hidden="true" href="#320-连续内存分配器">#</a></h2>
<p> 连续内存分配器（Contiguous Memory Allocator，CMA）:保留一块大的内存区域，当设备驱动不使用的时候，内核的其他模块可以使用</p>
<h2 id="321-userfaultfd">3.21 userfaultfd<a hidden class="anchor" aria-hidden="true" href="#321-userfaultfd">#</a></h2>
<p> userfaultfd（用户页错误文件描述符）用来拦截和处理用户空间的页错误异常，内核通过文件描述符将页错误异常的信息传递给用户空间，然后由用户空间决定要往虚拟页写入的数据。传统的页错误异常由内核独自处理，现在改为由内核和用户空间一起控制。  <br>
 userfaultfd是为了解决QEMU/KVM虚拟机动态迁移的问题而出现的。所谓动态迁移，就是将虚拟机从一端迁移到另一端，而在迁移的过程中虚拟机能够继续提供服务，有两种实现方案</p>
<h2 id="322-内存错误检测工具kasan">3.22 内存错误检测工具KASAN<a hidden class="anchor" aria-hidden="true" href="#322-内存错误检测工具kasan">#</a></h2>
<p> 内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具，为发现“释放后使用”和“越界访问”这两类缺陷提供了快速和综合的解决方案  <br>
 KASAN使用编译时插桩（compile-time instrumentation）检查每个内存访问</p>
<h1 id="第4章-中断异常和系统调用">第4章 中断、异常和系统调用<a hidden class="anchor" aria-hidden="true" href="#第4章-中断异常和系统调用">#</a></h1>
<h2 id="41-arm64异常处理">4.1 ARM64异常处理<a hidden class="anchor" aria-hidden="true" href="#41-arm64异常处理">#</a></h2>
<h3 id="411-异常级别">4.1.1 异常级别<a hidden class="anchor" aria-hidden="true" href="#411-异常级别">#</a></h3>
<p> ARM64处理器4个异常级别：0~3</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221124233511.png" alt="20221124233511"  />
</p>
<center>ARM64处理器的异常级别</center>
<p> 虚拟机里面运行一个操作系统，运行虚拟机的操作系统称为宿主操作系统(host OS)，虚拟机里面的操作系统称为客户操作系统(guest OS)   <br>
 开源虚拟机管理软件是QEMU，QEMU支持基于内核的虚拟机(Kernel-based Virtual Machine，KVM)。KVM直接在处理器上执行客户操作系统，虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。  <br>
 ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要从异常级别1切换到异常级别2。  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221124234127.png" alt="20221124234127"  />
</p>
<p> ARM64架构的安全扩展定义了两种安全状态：正常世界和安全世界。通过异常级别3的安全监控器切换</p>
<h3 id="412-异常分类">4.1.2 异常分类<a hidden class="anchor" aria-hidden="true" href="#412-异常分类">#</a></h3>
<p> ARM64体系结构中，异常分为同步异常和异步异常   <br>
 同步异常包括：
 (1)系统调用，异常级别0使用svc(Supervisor Call)指令陷入异常级别1，异常级别1使用hvc(Hypervisor Call)指令陷入异常级别2，异常级别2使用smc(Secure Monitor Call)指令陷入异常级别3  <br>
 (2)数据中止，即访问数据时的页错误异常，无映射，无写权限  <br>
 (3)指令中止，取指令时的页错误异常，无映射，无执行权限   <br>
 (4)栈指针或指令地址没有对齐   <br>
 (5)没有定义的指令  <br>
 (6)调试异常  <br>
 异步异常包括:  <br>
 (1)中断(normal priority interrupt，IRQ)，即普通优先级的中断。  <br>
 (2)快速中断(fast interrupt FIQ)，高优先级中断  <br>
 (3)系统错误(System Error SError)，硬件错误触发的异常  <br></p>
<h3 id="413-异常向量表">4.1.3 异常向量表<a hidden class="anchor" aria-hidden="true" href="#413-异常向量表">#</a></h3>
<p> 存储异常处理程序的内存位置称为异常向量，ARM64处理器的异常级别1、2和3，每个异常级别都有自己的异常向量表，异常向量表的起始虚拟地址存放在寄存器VBAR_ELn(向量基准地址寄存器，Vector Based Address Register)中   <br></p>
<table>
	<tr>
	    <th>地址</th>
	    <th>异常类型</th>
	    <th>含义</th>  
	</tr >
	<tr >
	    <td>VBAR_ELn + 0x000</td>
	    <td>同步异常</td>
	    <td rowspan="4">当前异常级别生成的异常，使用异常级别0的栈指针寄存器SP_EL0</td>
	</tr>
	<tr >
	    <td>　 　　　 + 0x080</td>
	    <td>中断</td>
	</tr>
	<tr >
	    <td>　 　　　 + 0x100</td>
	    <td>快速中断</td>
	</tr>
	<tr >
	    <td>　 　　　 + 0x180</td>
	    <td>系统错误</td>
	</tr>
	<tr >
	    <td>　 　　　 + 0x200</td>
	    <td>同步异常</td>
	     <td rowspan="4">当前异常级别生成的异常，使用当前异常级别的栈指针寄存器SP_ELn</td>
	</tr>
	<tr >
	    <td>　 　　　 + 0x280</td>
	    <td>中断</td>
	</tr>
		<tr >
	    <td>　 　　　 + 0x300</td>
	    <td>快速中断</td>
	</tr>
	<tr>
	    <td>　 　　　 + 0x380</td>
	    <td>系统错误</td>
	</tr>
		<tr>
	    <td>　 　　　 + 0x400</td>
	    <td>同步异常</td>
	    <td rowspan="4">64位应用程序在异常级别（n−1）生成的异常</td>
	</tr>
	<tr>
	    <td>　 　　　 + 0x480</td>
	    <td>中断</td>
	</tr>
		<tr >
	    <td>　 　　　 + 0x500</td>
	    <td>快速中断</td>
	</tr>
		<tr >
	    <td>　 　　　 + 0x580</td>
	    <td>系统错误</td>
	</tr>
	<tr>
	    <td>　 　　　 + 0x600</td>
	    <td>同步异常</td>
	    <td rowspan="4">32位应用程序在异常级别（n−1）生成的异常</td>
	</tr>
	<tr>
	    <td>　 　　　 + 0x680</td>
	    <td>中断</td>
	</tr>
	<tr>
	    <td>　 　　 　+ 0x700</td>
	    <td>快速中断</td>
	</tr>
	<tr>
	    <td> 　　　 + 0x780</td>
	    <td>系统错误</td>
	</tr>
</table>
<p> ARM64架构内核定义的异常级别1的异常向量表  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ach/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      .align    <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENTRY</span>(vectors)
</span></span><span style="display:flex;"><span>   ventry el1_sync_invalid    <span style="color:#75715e">// 异常级别1生成的同步异常，使用栈指针寄存器SP_EL0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry el1_irq_invalid     <span style="color:#75715e">// 异常级别1生成的中断，使用栈指针寄存器SP_EL0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry el1_fiq_invalid     <span style="color:#75715e">// 异常级别1生成的快速中断，使用栈指针寄存器SP_EL0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry el1_error_invalid   <span style="color:#75715e">// 异常级别1生成的系统错误，使用栈指针寄存器SP_EL0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>   ventry el1_sync            <span style="color:#75715e">// 异常级别1生成的同步异常，使用栈指针寄存器SP_EL1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry el1_irq             <span style="color:#75715e">// 异常级别1生成的中断，使用栈指针寄存器SP_EL1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry el1_fiq_invalid     <span style="color:#75715e">// 异常级别1生成的快速中断，使用栈指针寄存器SP_EL1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry el1_error_invalid   <span style="color:#75715e">// 异常级别1生成的系统错误，使用栈指针寄存器SP_EL1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>   ventry    el0_sync         <span style="color:#75715e">// 64位应用程序在异常级别0生成的同步异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_irq          <span style="color:#75715e">// 64位应用程序在异常级别0生成的中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_fiq_invalid  <span style="color:#75715e">// 64位应用程序在异常级别0生成的快速中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_error_invalid<span style="color:#75715e">// 64位应用程序在异常级别0生成的系统错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_COMPAT          </span><span style="color:#75715e">/* 表示支持执行32位程序 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_sync_compat  <span style="color:#75715e">// 32位应用程序在异常级别0生成的同步异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_irq_compat   <span style="color:#75715e">// 32位应用程序在异常级别0生成的中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_fiq_invalid_compat <span style="color:#75715e">// 32位应用程序在异常级别0生成的快速中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_error_invalid_compat<span style="color:#75715e">// 32位应用程序在异常级别0生成的系统错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_sync_invalid <span style="color:#75715e">// 32位应用程序在异常级别0生成的同步异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_irq_invalid  <span style="color:#75715e">// 32位应用程序在异常级别0生成的中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_fiq_invalid  <span style="color:#75715e">// 32位应用程序在异常级别0生成的快速中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   ventry    el0_error_invalid<span style="color:#75715e">// 32位应用程序在异常级别0生成的系统错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">END</span>(vectors)
</span></span></code></pre></div><p> ventry是一个宏，参数是跳转标号，即异常处理程序的标号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/assembler.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     .macro    ventry    label
</span></span><span style="display:flex;"><span>    .align <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>    b    <span style="color:#960050;background-color:#1e0010">\</span>label
</span></span><span style="display:flex;"><span>    .endm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ventry el1_sync展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>.align <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>b  el1_sync
</span></span></code></pre></div><p> 启动过程中，0号处理器称为引导处理器，其他处理器称为从处理器。引导处理器在函数__primary_switched()中把寄存器VBAR_EL1设置为异常级别1的异常向量表的起始虚拟地址  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">_head</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">stext</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">__primary_switch</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">__primary_switched</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>__primary_switched:
</span></span><span style="display:flex;"><span>   <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>   adr_l x8, vectors
</span></span><span style="display:flex;"><span>   msr   vbar_el1, x8        <span style="color:#75715e">// 把寄存器VBAR_EL1设置为异常向量表的起始虚拟地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   isb
</span></span><span style="display:flex;"><span>   <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>   b  start_kernel
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(__primary_switched)
</span></span></code></pre></div><p> 从处理器在函数__secondary_switched()中把寄存器VBAR_EL1设置为异常级别1的异常向量表的起始虚拟地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">secondary_entry</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">secondary_startup</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">__secondary_switched</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>__secondary_switched:
</span></span><span style="display:flex;"><span>    adr_l    x5, vectors
</span></span><span style="display:flex;"><span>    msr    vbar_el1, x5
</span></span><span style="display:flex;"><span>    isb
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    b  secondary_start_kernel
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(__secondary_switched)
</span></span></code></pre></div><h3 id="414-异常处理">4.1.4 异常处理<a hidden class="anchor" aria-hidden="true" href="#414-异常处理">#</a></h3>
<p> 处理器取出异常处理的时候，自动执行的操作  <br>
 (1)把当前的处理器状态（Processor State，PSTATE）保存在寄存器SPSR_EL1（保存程序状态寄存器，Saved Program Status Register）中  <br>
 (2)把返回地址保存在寄存器ELR_EL1（异常链接寄存器，Exception Link Register）中   <br>
 系统调用，那么返回地址是系统调用指令后面的指令  <br>
 除系统调用外的同步异常，那么返回地址是生成异常的指令  <br>
 异步异常，那么返回地址是没有执行的第一条指令  <br>
 (3)把处理器状态的DAIF这4个异常掩码位都设置为1，禁止这4种异常，D是调试掩码位（Debug mask bit），A是系统错误掩码位（SError mask bit），I是中断掩码位（IRQ mask bit），F是快速中断掩码位（FIQ mask bit）  <br>
 (4)同步异常或系统错误异常，把生成异常的原因保存在寄存器ESR_EL1（异常症状寄存器，Exception Syndrome Register）中 <br>
 (5)同步异常，把错误地址保存在寄存器FAR_EL1（错误地址寄存器，Fault Address Register）中  <br>
 (6)处理器处于用户模式（异常级别0），那么把异常级别提升到1  <br>
 (7)根据向量基准地址寄存器VBAR_EL1、异常类型和生成异常的异常级别计算出异常向量的虚拟地址，执行异常向量  <br>
 对于64位应用程序在用户模式（异常级别0）下生成的同步异常，入口是el0_sync</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>el0_sync:
</span></span><span style="display:flex;"><span>	kernel_entry <span style="color:#ae81ff">0</span>  <span style="color:#75715e">// 把所有通用寄存器的值保存在当前进程的内核栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mrs  x25, esr_el1                 <span style="color:#75715e">// 读异常症状寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	lsr  x24, x25, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SHIFT  <span style="color:#75715e">// 异常类别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SVC64       <span style="color:#75715e">// 64位系统调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_svc  <span style="color:#75715e">// 系统调用，调用函数el0_svc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_DABT_LOW    <span style="color:#75715e">// 异常级别0的数据中止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_da  <span style="color:#75715e">// 访问数据时的页错误异常，调用函数el0_da
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_IABT_LOW    <span style="color:#75715e">// 异常级别0的指令中止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_ia  <span style="color:#75715e">// 取指令时的页错误异常，调用函数el0_ia
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_FP_ASIMD    <span style="color:#75715e">// 访问浮点或者高级SIMD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_fpsimd_acc  <span style="color:#75715e">// 访问浮点或高级SIMD，调用函数el0_fpsimd_acc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_FP_EXC64    <span style="color:#75715e">// 浮点或者高级SIMD异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_fpsimd_exc  <span style="color:#75715e">// 浮点或高级SIMD异常，调用函数el0_fpsimd_exc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SYS64       <span style="color:#75715e">// 可配置陷入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_sys  <span style="color:#75715e">// 可配置陷入，调用函数el0_sys
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SP_ALIGN    <span style="color:#75715e">// 栈对齐异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_sp_pc
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_PC_ALIGN    <span style="color:#75715e">// 指令地址对齐异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_sp_pc
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_UNKNOWN     <span style="color:#75715e">// 异常级别0的未知异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_undef
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_BREAKPT_LOW <span style="color:#75715e">// 异常级别0的调试异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.ge el0_dbg
</span></span><span style="display:flex;"><span>	b    el0_inv
</span></span></code></pre></div><p> 可配置陷入，调用函数el0_sys</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>el1_sync:
</span></span><span style="display:flex;"><span>	kernel_entry <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	mrs  x1, esr_el1                  <span style="color:#75715e">// 读异常症状寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	lsr  x24, x1, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SHIFT   <span style="color:#75715e">// 异常类别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_DABT_CUR    <span style="color:#75715e">// 异常级别1的数据中止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el1_da
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_IABT_CUR    <span style="color:#75715e">// 异常级别1的指令中止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el1_ia
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SYS64       <span style="color:#75715e">// 可配置陷入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el1_undef
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SP_ALIGN    <span style="color:#75715e">// 栈对齐异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el1_sp_pc
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_PC_ALIGN    <span style="color:#75715e">// 指令地址对齐异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el1_sp_pc
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_UNKNOWN     <span style="color:#75715e">// 异常级别1的未知异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el1_undef
</span></span><span style="display:flex;"><span>	cmp  x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_BREAKPT_CUR <span style="color:#75715e">// 异常级别1的调试异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.ge el1_dbg
</span></span><span style="display:flex;"><span>	b    el1_inv
</span></span></code></pre></div><p> 以64位应用程序在用户模式（异常级别0）下访问数据时生成的页错误异常为例，处理函数是el0_da</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>el0_da:
</span></span><span style="display:flex;"><span>	mrs   x26, far_el1  <span style="color:#75715e">// 获取数据的虚拟地址，存放在寄存器x26
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	enable_dbg_and_irq   <span style="color:#75715e">// msr   daifclr, #(8 | 2) 开启调试异常和中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	clear_address_tag x0, x26
</span></span><span style="display:flex;"><span>	mov  x1, x25
</span></span><span style="display:flex;"><span>	mov  x2, sp
</span></span><span style="display:flex;"><span>	bl   do_mem_abort  <span style="color:#75715e">// 调用C语言函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b    ret_to_user
</span></span></code></pre></div><p> 内核模式（异常级别1）下访问数据时生成的页错误异常为例说明，处理函数是el1_da</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>el1_da:
</span></span><span style="display:flex;"><span>	mrs   x3, far_el1
</span></span><span style="display:flex;"><span>	enable_dbg
</span></span><span style="display:flex;"><span>	tbnz   x23, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1f</span>
</span></span><span style="display:flex;"><span>	enable_irq
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	clear_address_tag x0, x3
</span></span><span style="display:flex;"><span>	mov   x2, sp            <span style="color:#75715e">// 结构体 pt_regs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	bl   do_mem_abort
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	disable_irq
</span></span><span style="display:flex;"><span>	kernel_exit <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p> 异常处理程序执行完的时候，调用kernel_exit返回。kernel_exit是一个宏，参数el是返回的异常级别，0表示返回异常级别0，1表示返回异常级别1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .macro  kernel_exit, el
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    ldp  x21, x22, [sp, <span style="color:#960050;background-color:#1e0010">#</span>S_PC]    <span style="color:#75715e">//加载保存的寄存器ELR_EL1和SPSR_EL1的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#66d9ef">if</span>  <span style="color:#960050;background-color:#1e0010">\</span>el <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>                 <span style="color:#75715e">/* 如果返回用户模式（异常级别0）*/</span>
</span></span><span style="display:flex;"><span>    ldr  x23, [sp, <span style="color:#960050;background-color:#1e0010">#</span>S_SP]
</span></span><span style="display:flex;"><span>    msr  sp_el0, x23              <span style="color:#75715e">/* 恢复异常级别0的栈指针寄存器 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    .endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    msr  elr_el1, x21
</span></span><span style="display:flex;"><span>    msr  spsr_el1, x22
</span></span><span style="display:flex;"><span>    ldp  x0, x1, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    ldp  x2, x3, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    ldp  x4, x5, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>    ldp  x6, x7, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>    ldp  x8, x9, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>    ldp  x10, x11, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>    ldp  x12, x13, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>    ldp  x14, x15, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">7</span>]
</span></span><span style="display:flex;"><span>    ldp  x16, x17, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>    ldp  x18, x19, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">9</span>]
</span></span><span style="display:flex;"><span>    ldp  x20, x21, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>]
</span></span><span style="display:flex;"><span>    ldp  x22, x23, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">11</span>]
</span></span><span style="display:flex;"><span>    ldp  x24, x25, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">12</span>]
</span></span><span style="display:flex;"><span>    ldp  x26, x27, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">13</span>]
</span></span><span style="display:flex;"><span>    ldp  x28, x29, [sp, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">14</span>]
</span></span><span style="display:flex;"><span>    ldr  lr, [sp, <span style="color:#960050;background-color:#1e0010">#</span>S_LR]
</span></span><span style="display:flex;"><span>    add  sp, sp, <span style="color:#960050;background-color:#1e0010">#</span>S_FRAME_SIZE
</span></span><span style="display:flex;"><span>    eret
</span></span><span style="display:flex;"><span>    .endm
</span></span></code></pre></div><p> 执行指令eret的时候，处理器自动使用寄存器SPSR_EL1保存的值恢复处理器状态，使用寄存器ELR_EL1保存的返回地址恢复程序计数器（Program Counter，PC）</p>
<h2 id="42-中断">4.2 中断<a hidden class="anchor" aria-hidden="true" href="#42-中断">#</a></h2>
<p> 中断是外围设备通知处理器的一种机制</p>
<h3 id="421中断控制器">4.2.1　中断控制器<a hidden class="anchor" aria-hidden="true" href="#421中断控制器">#</a></h3>
<p> ARM标准的中断控制器，称为通用中断控制器（Generic Interrupt Controller，GIC）  <br>
 软件 GIC v2控制器有两个主要的功能块   <br>
 1）分发器（Distributor）  <br>
 2）处理器接口（CPU Interface）   <br></p>
<p> 中断有以下4种类型:SGI、PPI、SPI、LPI   <br>
 SGI  软件生成的中断 0~15  <br>
 PPI  私有外设中断 16~31  <br>
 SPI  共享外设中断 32~1020   <br>
 LPI  局部特点外设中断</p>
<p> 边沿触发、电平触发  <br></p>
<p> 中断有以下4种状态。  <br>
 （1）Inactive：中断源没有发送中断。<br>
 （2）Pending：中断源已经发送中断，等待处理器处理。<br>
 （3）Active：处理器已经确认中断，正在处理。 <br>
 （4）Active and pending：处理器正在处理中断，相同的中断源又发送了一个中断。  <br></p>
<p>GIC v2控制器描述符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// drivers/irqchip/irq-gic.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> irq_chip gic_chip <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>      .irq_mask            <span style="color:#f92672">=</span> gic_mask_irq,
</span></span><span style="display:flex;"><span>      .irq_unmask          <span style="color:#f92672">=</span> gic_unmask_irq,
</span></span><span style="display:flex;"><span>      .irq_eoi             <span style="color:#f92672">=</span> gic_eoi_irq,
</span></span><span style="display:flex;"><span>      .irq_set_type        <span style="color:#f92672">=</span> gic_set_type,
</span></span><span style="display:flex;"><span>      .irq_get_irqchip_state <span style="color:#f92672">=</span> gic_irq_get_irqchip_state,
</span></span><span style="display:flex;"><span>      .irq_set_irqchip_state <span style="color:#f92672">=</span> gic_irq_set_irqchip_state,
</span></span><span style="display:flex;"><span>      .flags               <span style="color:#f92672">=</span> IRQCHIP_SET_TYPE_MASKED <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>                           IRQCHIP_SKIP_SET_WAKE <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>                           IRQCHIP_MASK_ON_SUSPEND,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="422中断域">4.2.2　中断域<a hidden class="anchor" aria-hidden="true" href="#422中断域">#</a></h3>
<p> 每个中断控制器本地的硬件中断号映射到全局唯一的Linux中断号（也称为虚拟中断号），内核定义了中断域irq_domain，每个中断控制器有自己的中断域  <br></p>
<h4 id="1创建中断域">1．创建中断域<a hidden class="anchor" aria-hidden="true" href="#1创建中断域">#</a></h4>
<p> 中断控制器的驱动程序使用分配函数irq_domain_add_*()创建和注册中断域，调用者给分配函数提供irq_domain_ops结构体，分配函数在执行成功的时候返回irq_domain的指针<br>
 分配主要为函数__irq_domain_add()。函数__irq_domain_add()的执行过程是：分配一个irq_domain结构体，初始化成员，然后把中断域添加到全局链表irq_domain_list中  <br></p>
<h4 id="2创建映射">2．创建映射<a hidden class="anchor" aria-hidden="true" href="#2创建映射">#</a></h4>
<p> 向中断域添加硬件中断号到Linux中断号的映射，内核提供了函数irq_create_mapping</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">irq_create_mapping</span>(<span style="color:#66d9ef">struct</span> irq_domain <span style="color:#f92672">*</span>domain, <span style="color:#66d9ef">irq_hw_number_t</span> hwirq);
</span></span></code></pre></div><h4 id="3查找映射">3．查找映射<a hidden class="anchor" aria-hidden="true" href="#3查找映射">#</a></h4>
<p>中断处理程序需要根据硬件中断号查找Linux中断号，内核提供了函数irq_find_mapping：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">irq_find_mapping</span>(<span style="color:#66d9ef">struct</span> irq_domain <span style="color:#f92672">*</span>domain, <span style="color:#66d9ef">irq_hw_number_t</span> hwirq);
</span></span></code></pre></div><p>输入参数是中断域和硬件中断号，返回Linux中断号</p>
<h3 id="423中断控制器驱动初始化">4.2.3　中断控制器驱动初始化<a hidden class="anchor" aria-hidden="true" href="#423中断控制器驱动初始化">#</a></h3>
<p> ARM64架构使用扁平设备树（Flattened Device Tree，FDT）描述板卡的硬件信息。编写设备树源文件（Device Tree Source，DTS），存放在目录“arch/arm64/boot/dts”下，然后使用设备树编译器（Device Tree Compiler，DTC）把设备树源文件转换成设备树二进制文件（Device Tree Blob，DTB），最后把设备树二进制文件写到存储设备上</p>
<h4 id="1设备树源文件">1．设备树源文件<a hidden class="anchor" aria-hidden="true" href="#1设备树源文件">#</a></h4>
<h4 id="3初始化">3.初始化<a hidden class="anchor" aria-hidden="true" href="#3初始化">#</a></h4>
<p>函数irqchip_init &ndash;&gt; of_irq_init &ndash;&gt; __irqchip_of_table  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">start_kernel</span>() 
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">init_IRQ</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">irqchip_init</span>()
</span></span><span style="display:flex;"><span>	 <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">of_irq_init</span>()
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">gic_of_init</span>()
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">__gic_init_bases</span>()
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">__irqchip_of_table</span>()
</span></span></code></pre></div><h3 id="424linux中断处理">4.2.4　Linux中断处理<a hidden class="anchor" aria-hidden="true" href="#424linux中断处理">#</a></h3>
<p> 向中断域添加硬件中断号到Linux中断号的映射时，内核分配一个Linux中断号和一个中断描述符irq_desc  <br>
 中断描述符有两个层次的中断处理函数</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221128230127.png" alt="20221128230127"  />
</p>
<p> 存储Linux中断号到中断描述符的映射关系  <br>
 (1)中断编号是稀疏的（即不连续），那么使用基数树（radix tree）存储  <br>
 (2)中断编号是连续的，那么使用数组存储</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/irq/irqdesc.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SPARSE_IRQ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#a6e22e">RADIX_TREE</span>(irq_desc_tree, GFP_KERNEL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>     [<span style="color:#ae81ff">0</span> ... NR_IRQS<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]  <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            .handle_irq <span style="color:#f92672">=</span> handle_bad_irq,
</span></span><span style="display:flex;"><span>            .depth      <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>            .lock       <span style="color:#f92672">=</span> <span style="color:#a6e22e">__RAW_SPIN_LOCK_UNLOCKED</span>(irq_desc<span style="color:#f92672">-&gt;</span>lock),
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">handle_irq</span>()
</span></span><span style="display:flex;"><span> <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">gic_irq_domain_map</span>()
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 硬件中断号小于32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">handle_percpu_devid_irq</span>()
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 中断号大于或等于32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">handle_fasteoi_irq</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">irq_create_mapping</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">irq_domain_associate</span>() <span style="color:#f92672">-&gt;</span> domain<span style="color:#f92672">-&gt;</span>ops<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">map</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// drivers/irqchip/irq-gic.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gic_irq_domain_map</span>(<span style="color:#66d9ef">struct</span> irq_domain <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq,
</span></span><span style="display:flex;"><span>                     <span style="color:#66d9ef">irq_hw_number_t</span> hw)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> gic_chip_data <span style="color:#f92672">*</span>gic <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>host_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (hw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">32</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">irq_set_percpu_devid</span>(irq);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">irq_domain_set_info</span>(d, irq, hw, <span style="color:#f92672">&amp;</span>gic<span style="color:#f92672">-&gt;</span>chip, d<span style="color:#f92672">-&gt;</span>host_data,
</span></span><span style="display:flex;"><span>                         handle_percpu_devid_irq, NULL, NULL);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">irq_set_status_flags</span>(irq, IRQ_NOAUTOEN);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">irq_domain_set_info</span>(d, irq, hw, <span style="color:#f92672">&amp;</span>gic<span style="color:#f92672">-&gt;</span>chip, d<span style="color:#f92672">-&gt;</span>host_data,
</span></span><span style="display:flex;"><span>                         handle_fasteoi_irq, NULL, NULL);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">irq_set_probe</span>(irq);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221128230716.png" alt="20221128230716"  />
</p>
<center>Linux中断处理流程</center>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   .align   <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>  el0_irq:
</span></span><span style="display:flex;"><span>   kernel_entry <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  el0_irq_naked:
</span></span><span style="display:flex;"><span>   enable_dbg
</span></span><span style="display:flex;"><span>   <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>   irq_handler
</span></span><span style="display:flex;"><span>   <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>   b   ret_to_user
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ENDPROC</span>(el0_irq)
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>   .macro   irq_handler
</span></span><span style="display:flex;"><span>   ldr_l   x1, handle_arch_irq
</span></span><span style="display:flex;"><span>   mov   x0, sp
</span></span><span style="display:flex;"><span>   irq_stack_entry
</span></span><span style="display:flex;"><span>   blr   x1
</span></span><span style="display:flex;"><span>   irq_stack_exit
</span></span><span style="display:flex;"><span>   .endm
</span></span></code></pre></div><p> 函数handle_irq_event，执行设备驱动程序注册的处理函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// handle_irq_event()  -&gt;  handle_irq_event_percpu()  -&gt;  __handle_irq_event_percpu()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>kernel<span style="color:#f92672">/</span>irq<span style="color:#f92672">/</span>handle.c
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">irqreturn_t</span>  <span style="color:#a6e22e">__handle_irq_event_percpu</span>(<span style="color:#66d9ef">struct</span> irq_desc <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">irqreturn_t</span> retval <span style="color:#f92672">=</span> IRQ_NONE;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq <span style="color:#f92672">=</span> desc<span style="color:#f92672">-&gt;</span>irq_data.irq;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> irqaction <span style="color:#f92672">*</span>action;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">for_each_action_of_desc</span>(desc, action) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">irqreturn_t</span> res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>         res <span style="color:#f92672">=</span> action<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">handler</span>(irq, action<span style="color:#f92672">-&gt;</span>dev_id);
</span></span><span style="display:flex;"><span>         <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">switch</span> (res) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">case</span> IRQ_WAKE_THREAD:
</span></span><span style="display:flex;"><span>             <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">__irq_wake_thread</span>(desc, action);
</span></span><span style="display:flex;"><span>             <span style="color:#75715e">/*继续往下走，把“action-&gt;flags”作为生成随机数的一个因子 */</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">case</span> IRQ_HANDLED:
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">*</span>flags <span style="color:#f92672">|=</span> action<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         retval <span style="color:#f92672">|=</span> res;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> retval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="425中断线程化">4.2.5　中断线程化<a hidden class="anchor" aria-hidden="true" href="#425中断线程化">#</a></h3>
<p> 内核提供的函数request_threaded_irq()用来注册线程化的中断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">request_threaded_irq</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">irq_handler_t</span> handler,
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">irq_handler_t</span> thread_fn,
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev);
</span></span></code></pre></div><p> 每个中断处理描述符（irqaction）对应一个内核线程，成员thread指向内核线程的进程描述符，成员thread_fn指向线程处理函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/interrupt.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> irqaction {
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">irq_handler_t</span>      thread_fn;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span><span style="color:#66d9ef">thread</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} ____cacheline_internodealigned_in_smp;
</span></span></code></pre></div><p> 中断处理线程是优先级为50、调度策略是SCHED_FIFO的实时内核线程，名称是“irq/”后面跟着Linux中断号，线程处理函数是irq_thread()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">request_threaded_irq</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">__setup_irq</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">setup_irq_thread</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kernel/irq/manage.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">setup_irq_thread</span>(<span style="color:#66d9ef">struct</span> irqaction <span style="color:#f92672">*</span>new, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">bool</span> secondary)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> sched_param param <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>          .sched_priority <span style="color:#f92672">=</span> MAX_USER_RT_PRIO<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>     };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>secondary) {
</span></span><span style="display:flex;"><span>           t <span style="color:#f92672">=</span> <span style="color:#a6e22e">kthread_create</span>(irq_thread, new, <span style="color:#e6db74">&#34;irq/%d-%s&#34;</span>, irq,
</span></span><span style="display:flex;"><span>                        new<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>     } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>           t <span style="color:#f92672">=</span> <span style="color:#a6e22e">kthread_create</span>(irq_thread, new, <span style="color:#e6db74">&#34;irq/%d-s-%s&#34;</span>, irq,
</span></span><span style="display:flex;"><span>                      new<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>           param.sched_priority <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">sched_setscheduler_nocheck</span>(t, SCHED_FIFO, <span style="color:#f92672">&amp;</span>param);
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">handle_fasteoi_irq</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">handle_irq_event</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">handle_irq_event_percpu</span>()  <span style="color:#f92672">-&gt;</span>  <span style="color:#a6e22e">__handle_irq_event_percpu</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kernel/irq/handle.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">irqreturn_t</span>  <span style="color:#a6e22e">__handle_irq_event_percpu</span>(<span style="color:#66d9ef">struct</span> irq_desc <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">irqreturn_t</span> retval <span style="color:#f92672">=</span> IRQ_NONE;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq <span style="color:#f92672">=</span> desc<span style="color:#f92672">-&gt;</span>irq_data.irq;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> irqaction <span style="color:#f92672">*</span>action;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">for_each_action_of_desc</span>(desc, action) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">irqreturn_t</span> res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>          res <span style="color:#f92672">=</span> action<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">handler</span>(irq, action<span style="color:#f92672">-&gt;</span>dev_id);
</span></span><span style="display:flex;"><span>          <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">switch</span> (res) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> IRQ_WAKE_THREAD:
</span></span><span style="display:flex;"><span>               <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>               <span style="color:#a6e22e">__irq_wake_thread</span>(desc, action);
</span></span><span style="display:flex;"><span>               <span style="color:#75715e">/*继续往下走，把“action-&gt;flags”作为生成随机数的一个因子*/</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> IRQ_HANDLED:
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">*</span>flags <span style="color:#f92672">|=</span> action<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          retval <span style="color:#f92672">|=</span> res;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> retval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 中断处理线程的处理函数是irq_thread()，调用函数irq_thread_fn()，然后函数irq_thread_fn()调用注册的线程处理函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/irq/manage.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">irq_thread</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> callback_head on_exit_work;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> irqaction <span style="color:#f92672">*</span>action <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> irq_desc <span style="color:#f92672">*</span>desc <span style="color:#f92672">=</span> <span style="color:#a6e22e">irq_to_desc</span>(action<span style="color:#f92672">-&gt;</span>irq);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">irqreturn_t</span> (<span style="color:#f92672">*</span>handler_fn)(<span style="color:#66d9ef">struct</span> irq_desc <span style="color:#f92672">*</span>desc,
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">struct</span> irqaction <span style="color:#f92672">*</span>action);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (force_irqthreads <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">test_bit</span>(IRQTF_FORCED_THREAD,
</span></span><span style="display:flex;"><span>                         <span style="color:#f92672">&amp;</span>action<span style="color:#f92672">-&gt;</span>thread_flags))
</span></span><span style="display:flex;"><span>          handler_fn <span style="color:#f92672">=</span> irq_forced_thread_fn;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>          handler_fn <span style="color:#f92672">=</span> irq_thread_fn;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">irq_wait_for_interrupt</span>(action)) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">irqreturn_t</span> action_ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>          action_ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">handler_fn</span>(desc, action);
</span></span><span style="display:flex;"><span>          <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">irqreturn_t</span>  <span style="color:#a6e22e">irq_thread_fn</span>(<span style="color:#66d9ef">struct</span> irq_desc <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">struct</span> irqaction <span style="color:#f92672">*</span>action)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">irqreturn_t</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      ret <span style="color:#f92672">=</span> action<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">thread_fn</span>(action<span style="color:#f92672">-&gt;</span>irq, action<span style="color:#f92672">-&gt;</span>dev_id);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">irq_finalize_oneshot</span>(desc, action);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="426禁止开启中断">4.2.6　禁止/开启中断<a hidden class="anchor" aria-hidden="true" href="#426禁止开启中断">#</a></h3>
<p> 软件可以禁止中断，使处理器不响应所有中断请求，但是不可屏蔽中断（Non Maskable Interrupt，NMI）是个例外，接口：  <br>
 (1)local_irq_disable()   <br>
 (2)local_irq_save(flags) 先把中断状态保存在参数flags中，然后禁止中断 <br></p>
<p> 开启中断的接口 <br>
 (1)local_irq_enable()  <br>
 (2)local_irq_restore(flags)  恢复本地处理器的中断状态  <br></p>
<p> ARM64架构禁止中断的函数local_irq_disable()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">local_irq_disable</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">raw_local_irq_disable</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">arch_local_irq_disable</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/irqflags.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 中断掩码位设置成1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arch_local_irq_disable</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;msr       daifset, #2       // arch_local_irq_disable&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> ARM64架构开启中断的函数local_irq_enable()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">local_irq_enable</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">raw_local_irq_enable</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">arch_local_irq_enable</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/irqflags.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 中断掩码位设置成0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arch_local_irq_enable</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;msr       daifclr, #2     // arch_local_irq_enable&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="427禁止开启单个中断">4.2.7　禁止/开启单个中断<a hidden class="anchor" aria-hidden="true" href="#427禁止开启单个中断">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 禁止单个中断的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">disable_irq</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开启单个中断的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">enable_irq</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq);
</span></span></code></pre></div><h3 id="428中断亲和性">4.2.8　中断亲和性<a hidden class="anchor" aria-hidden="true" href="#428中断亲和性">#</a></h3>
<p> 设置中断亲和性，允许中断控制器把某个中断转发给哪些处理器，有两种配置方法  <br>
 (1)写文件“/proc/irq/IRQ#/smp_affinity”，参数是位掩码  <br>
 (2)文件“/proc/irq/IRQ#/smp_affinity_list”，参数是处理器列表  <br></p>
<h3 id="429处理器间中断">4.2.9　处理器间中断<a hidden class="anchor" aria-hidden="true" href="#429处理器间中断">#</a></h3>
<p> 多处理器系统中，一个处理器可以向其他处理器发送中断  <br></p>
<p> 处理处理器间中断的执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221128232922.png" alt="20221128232922"  />
</p>
<center>处理处理器间中断</center>
<h2 id="43中断下半部">4.3　中断下半部<a hidden class="anchor" aria-hidden="true" href="#43中断下半部">#</a></h2>
<p> 中断处理程序分为两部分，上半部（top half，th）在关闭中断的情况下执行，只做对时间非常敏感、与硬件相关或者不能被其他中断打断的工作；下半部（bottom half，bh）在开启中断的情况下执行，可以被其他中断打断  <br>
 上半部称为硬中断（hardirq），下半部有3种：软中断（softirq）、小任务（tasklet）和工作队列（workqueue） <br></p>
<h3 id="431软中断">4.3.1　软中断<a hidden class="anchor" aria-hidden="true" href="#431软中断">#</a></h3>
<p> 内核定义了一张软中断向量表，每种软中断有一个唯一的编号，对应一个softirq_action实例，softirq_action实例的成员action是处理函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/interrupt.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> softirq_action
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>action)(<span style="color:#66d9ef">struct</span> softirq_action <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="1软中断的种类">1．软中断的种类<a hidden class="anchor" aria-hidden="true" href="#1软中断的种类">#</a></h4>
<p> 内核定义了10种软中断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/interrupt.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      HI_SOFTIRQ<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,    <span style="color:#75715e">// 高优先级的小任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      TIMER_SOFTIRQ,   <span style="color:#75715e">// 定时器软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      NET_TX_SOFTIRQ,  <span style="color:#75715e">// 网络栈发送报文的软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      NET_RX_SOFTIRQ,  <span style="color:#75715e">// 网络栈接收报文的软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      BLOCK_SOFTIRQ,   <span style="color:#75715e">// 块设备软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      IRQ_POLL_SOFTIRQ, <span style="color:#75715e">// 支持I/O轮询的块设备软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      TASKLET_SOFTIRQ,  <span style="color:#75715e">// 低优先级的小任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      SCHED_SOFTIRQ,    <span style="color:#75715e">// 调度软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      HRTIMER_SOFTIRQ, <span style="color:#75715e">/* 没有使用，但是保留，因为有些工具依赖这个编号 */</span>
</span></span><span style="display:flex;"><span>      RCU_SOFTIRQ,     <span style="color:#75715e">/* RCU软中断应该总是最后一个软中断 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      NR_SOFTIRQS
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="2注册软中断的处理函数">2．注册软中断的处理函数<a hidden class="anchor" aria-hidden="true" href="#2注册软中断的处理函数">#</a></h4>
<p> open_softirq()用来注册软中断的处理函数，在软中断向量表中为指定的软中断编号设置处理函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">open_softirq</span>(<span style="color:#66d9ef">int</span> nr, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>action)(<span style="color:#66d9ef">struct</span> softirq_action <span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     softirq_vec[nr].action <span style="color:#f92672">=</span> action;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3触发软中断">3．触发软中断<a hidden class="anchor" aria-hidden="true" href="#3触发软中断">#</a></h4>
<p>函数raise_softirq用来触发软中断，参数是软中断编号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">raise_softirq</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> nr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raise_softirq</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">raise_softirq_irqoff</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">__raise_softirq_irqoff</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__raise_softirq_irqoff</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> nr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">or_softirq_pending</span>(<span style="color:#ae81ff">1UL</span> <span style="color:#f92672">&lt;&lt;</span> nr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏or_softirq_pending展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>irq_stat[<span style="color:#a6e22e">smp_processor_id</span>()].__softirq_pending <span style="color:#f92672">|=</span> (<span style="color:#ae81ff">1UL</span> <span style="color:#f92672">&lt;&lt;</span> nr);
</span></span></code></pre></div><h4 id="4执行软中断">4.执行软中断<a hidden class="anchor" aria-hidden="true" href="#4执行软中断">#</a></h4>
<p> 中断处理程序的后半部分，调用函数irq_exit()以退出中断上下文，处理软中断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">irq_exit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">preempt_count_sub</span>(HARDIRQ_OFFSET);
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">in_interrupt</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">local_softirq_pending</span>())
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">invoke_softirq</span>();
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">invoke_softirq</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ksoftirqd_running</span>())
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>force_irqthreads) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__do_softirq</span>();
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wakeup_softirqd</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数__do_softirq是执行软中断的核心函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MAX_SOFTIRQ_TIME  msecs_to_jiffies(2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_SOFTIRQ_RESTART 10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage __visible <span style="color:#66d9ef">void</span> __softirq_entry <span style="color:#a6e22e">__do_softirq</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> end <span style="color:#f92672">=</span> jiffies <span style="color:#f92672">+</span> MAX_SOFTIRQ_TIME;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> old_flags <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max_restart <span style="color:#f92672">=</span> MAX_SOFTIRQ_RESTART;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> softirq_action <span style="color:#f92672">*</span>h;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> in_hardirq;
</span></span><span style="display:flex;"><span>	__u32 pending;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> softirq_bit;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	pending <span style="color:#f92672">=</span> <span style="color:#a6e22e">local_softirq_pending</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__local_bh_disable_ip</span>(_RET_IP_, SOFTIRQ_OFFSET);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	restart:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">set_softirq_pending</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	h <span style="color:#f92672">=</span> softirq_vec;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> ((softirq_bit <span style="color:#f92672">=</span> <span style="color:#a6e22e">ffs</span>(pending))) {
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		h <span style="color:#f92672">+=</span> softirq_bit <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">action</span>(h);
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		h<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		pending <span style="color:#f92672">&gt;&gt;=</span> softirq_bit;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">local_irq_disable</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	pending <span style="color:#f92672">=</span> <span style="color:#a6e22e">local_softirq_pending</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pending) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">time_before</span>(jiffies, end) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">need_resched</span>() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">--</span>max_restart)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> restart;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wakeup_softirqd</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__local_bh_enable</span>(SOFTIRQ_OFFSET);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="5抢占计数器">5．抢占计数器<a hidden class="anchor" aria-hidden="true" href="#5抢占计数器">#</a></h4>
<p> 进程的thread_info结构体有一个抢占计数器：int preempt_count，它用来表示当前进程能不能被抢占,可通过抢占计数器判断处在什么场景  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// nclude/linux/preempt.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define in_irq()             (hardirq_count())  </span><span style="color:#75715e">// 正在执行硬中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define in_softirq()         (softirq_count())  </span><span style="color:#75715e">// 禁止软中断和正在执行软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define in_interrupt()       (irq_count())  </span><span style="color:#75715e">// 正在执行不可屏蔽中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define in_serving_softirq() (softirq_count() &amp; SOFTIRQ_OFFSET)  </span><span style="color:#75715e">// 正在执行软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define in_nmi()             (preempt_count() &amp; NMI_MASK)  </span><span style="color:#75715e">// 不可屏蔽中断场景
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define in_task()            (!(preempt_count() &amp; \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                             (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))  </span><span style="color:#75715e">// 进程上下文
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define softirq_count() (preempt_count() &amp; SOFTIRQ_MASK)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define irq_count()     (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                    | NMI_MASK))
</span></span></span></code></pre></div><h4 id="6禁止开启软中断">6．禁止/开启软中断<a hidden class="anchor" aria-hidden="true" href="#6禁止开启软中断">#</a></h4>
<p> 禁止软中断的函数是local_bh_disable()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>bottom_half.h
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">local_bh_disable</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">__local_bh_disable_ip</span>(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__local_bh_disable_ip</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> ip, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cnt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">preempt_count_add</span>(cnt);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>preempt.h
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SOFTIRQ_DISABLE_OFFSET    (2 * SOFTIRQ_OFFSET)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开启软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">local_bh_enable</span>()
</span></span></code></pre></div><h3 id="432-小任务-tasklet">4.3.2 小任务 tasklet<a hidden class="anchor" aria-hidden="true" href="#432-小任务-tasklet">#</a></h3>
<p> 小任务（tasklet）是基于软中断实现</p>
<h4 id="1数据结构-5">1.数据结构<a hidden class="anchor" aria-hidden="true" href="#1数据结构-5">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/interrupt.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> tasklet_struct
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> tasklet_struct <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> state;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">atomic_t</span> count;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>func)(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>);
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="2编程接口">2．编程接口<a hidden class="anchor" aria-hidden="true" href="#2编程接口">#</a></h4>
<h4 id="3技术原理">3．技术原理<a hidden class="anchor" aria-hidden="true" href="#3技术原理">#</a></h4>
<h3 id="433工作队列">4.3.3　工作队列<a hidden class="anchor" aria-hidden="true" href="#433工作队列">#</a></h3>
<h2 id="44系统调用">4.4　系统调用<a hidden class="anchor" aria-hidden="true" href="#44系统调用">#</a></h2>
<p> 系统调用是内核给用户程序提供的编程接口。用户程序调用系统调用，通常使用glibc库针对单个系统调用封装的函数。glibc库没有针对某个系统调用封装函数，用户程序可通用的封装函数syscall()  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/syscall.h&gt;   /* 定义 SYS_xxx */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">syscall</span>(<span style="color:#66d9ef">long</span> number, ...);  <span style="color:#75715e">// number系统调用号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回值  0成功，-1错误，错误号在errno
</span></span></span></code></pre></div><p> 应用程序使用系统调用fork()创建子进程，有两种调用方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">syscall</span>(SYS_fork);
</span></span></code></pre></div><p> ARM64处理器提供的系统调用指令是svc  <br>
 (1)64位应用程序使用寄存器x8传递系统调用号  <br>
 (2)寄存器x0～x6最多可以传递7个参数  <br>
 (3)系统调用执行完的时候，使用寄存器x0存放返回值  <br></p>
<h3 id="441-定义系统调用">4.4.1 定义系统调用<a hidden class="anchor" aria-hidden="true" href="#441-定义系统调用">#</a></h3>
<p> Linux内核使用宏SYSCALL_DEFINE定义系统调用，创建子进程的系统调用fork <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SYSCALL_DEFINE0</span>(fork)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MMU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_do_fork</span>(SIGCHLD, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, NULL, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#75715e">/* 如果处理器没有内存管理单元，那么不支持 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SYSCALL_DEFINE0(fork) 展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sys_fork</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// asmlinkage 表示C语言函数可以被汇编代码调用
</span></span></span></code></pre></div><p> ARM64架构定义的系统调用表sys_call_table</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/sys.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#undef __SYSCALL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __SYSCALL(nr, sym)     [nr] = sym,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> sys_call_table[__NR_syscalls] <span style="color:#a6e22e">__aligned</span>(<span style="color:#ae81ff">4096</span>) <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>     [<span style="color:#ae81ff">0</span> ... __NR_syscalls <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sys_ni_syscall,
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>ARM64架构，头文件“asm/unistd.h”是“arch/arm64/include/asm/unistd.h”。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/unistd.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;uapi/asm/unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/uapi/asm/unistd.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm-generic/unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/asm-generic/unistd.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;uapi/asm-generic/unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/uapi/asm-generic/unistd.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define __NR_io_setup 0                                    </span><span style="color:#75715e">/* 系统调用号0 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__SC_COMP</span>(__NR_io_setup, sys_io_setup, compat_sys_io_setup) <span style="color:#75715e">/* [0] = sys_io_setup, */</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define __NR_fork 1079                </span><span style="color:#75715e">/* 系统调用号1079 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MMU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__SYSCALL</span>(__NR_fork, sys_fork)        <span style="color:#75715e">/* [1079] = sys_fork, */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__SYSCALL</span>(__NR_fork, sys_ni_syscall)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_MMU */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#undef __NR_syscalls
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __NR_syscalls (__NR_fork+1)
</span></span></span></code></pre></div><h3 id="442-执行系统调用">4.4.2 执行系统调用<a hidden class="anchor" aria-hidden="true" href="#442-执行系统调用">#</a></h3>
<p> ARM64处理器把系统调用划分到同步异常，在异常级别1的异常向量表中，系统调用的入口，64位应用程序执行系统调用指令svc，系统调用入口 el0_sync</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>.align   <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>el0_sync:
</span></span><span style="display:flex;"><span>	kernel_entry <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	mrs   x25, esr_el1                 <span style="color:#75715e">// 读异常症状寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	lsr   x24, x25, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SHIFT  <span style="color:#75715e">// 异常类别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cmp   x24, <span style="color:#960050;background-color:#1e0010">#</span>ESR_ELx_EC_SVC64       <span style="color:#75715e">// 64位系统调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.eq el0_svc
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span></code></pre></div><p> el0_svc负责执行系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 这些是系统调用处理程序使用的寄存器，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 允许我们理论上最多传递7个参数给一个函数 – x0～x6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * x7保留，用于32位模式的系统调用号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>sc_nr .req x25           <span style="color:#75715e">// 系统调用的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>scno      .req  x26      <span style="color:#75715e">// 系统调用号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stbl      .req  x27      <span style="color:#75715e">// 系统调用表的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tsk       .req  x28      <span style="color:#75715e">// 当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>.align   <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>el0_svc:
</span></span><span style="display:flex;"><span>	adrp    stbl, sys_call_table      <span style="color:#75715e">// 加载系统调用表的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	uxtw    scno, w8         <span style="color:#75715e">// 寄存器w8里面的系统调用号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mov     sc_nr, <span style="color:#960050;background-color:#1e0010">#</span>__NR_syscalls
</span></span><span style="display:flex;"><span>el0_svc_naked:               <span style="color:#75715e">// 32位系统调用的入口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp   x0, scno, [sp, <span style="color:#960050;background-color:#1e0010">#</span>S_ORIG_X0]   <span style="color:#75715e">// 保存原来的x0和系统调用号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	enable_dbg_and_irq
</span></span><span style="display:flex;"><span>	ct_user_exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ptrace跟踪系统调用，跳转到__sys_trace处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldr   x16, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]   <span style="color:#75715e">// 检查系统调用钩子 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tst   x16, <span style="color:#960050;background-color:#1e0010">#</span>_TIF_SYSCALL_WORK
</span></span><span style="display:flex;"><span>	b.ne      __sys_trace
</span></span><span style="display:flex;"><span>	cmp     scno, sc_nr         <span style="color:#75715e">// 检查系统调用号是否超过上限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b.hs      ni_sys
</span></span><span style="display:flex;"><span>	ldr   x16, [stbl, scno, lsl <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">3</span>]   <span style="color:#75715e">// 系统调用表表项的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	blr   x16                         <span style="color:#75715e">// 调用sys_*函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b   ret_fast_syscall
</span></span><span style="display:flex;"><span>	ni_sys:
</span></span><span style="display:flex;"><span>	mov   x0, sp
</span></span><span style="display:flex;"><span>	bl   do_ni_syscall
</span></span><span style="display:flex;"><span>	b   ret_fast_syscall
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(el0_svc) 
</span></span></code></pre></div><p> ret_fast_syscall从系统调用返回用户空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> ret_fast_syscall:
</span></span><span style="display:flex;"><span>	disable_irq
</span></span><span style="display:flex;"><span>	str   x0, [sp, <span style="color:#960050;background-color:#1e0010">#</span>S_X0]   <span style="color:#75715e">/* DEFINE(S_X0, offsetof(struct pt_regs, regs[0])); */</span>
</span></span><span style="display:flex;"><span>	ldr   x1, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]
</span></span><span style="display:flex;"><span>	and   x2, x1, <span style="color:#960050;background-color:#1e0010">#</span>_TIF_SYSCALL_WORK
</span></span><span style="display:flex;"><span>	cbnz    x2, ret_fast_syscall_trace
</span></span><span style="display:flex;"><span>	and   x2, x1, <span style="color:#960050;background-color:#1e0010">#</span>_TIF_WORK_MASK
</span></span><span style="display:flex;"><span>	cbnz    x2, work_pending
</span></span><span style="display:flex;"><span>	enable_step_tsk x1, x2
</span></span><span style="display:flex;"><span>	kernel_exit <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	ret_fast_syscall_trace:
</span></span><span style="display:flex;"><span>	enable_irq                       <span style="color:#75715e">// 开启中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b   __sys_trace_return_skipped    <span style="color:#75715e">// 我们已经保存了x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>work_pending:
</span></span><span style="display:flex;"><span>	mov   x0, sp                     <span style="color:#75715e">// &#39;regs&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	bl   do_notify_resume
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_TRACE_IRQFLAGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 	bl   trace_hardirqs_on           <span style="color:#75715e">// 在用户空间执行时开启中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldr   x1, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]   <span style="color:#75715e">// 重新检查单步执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b   finish_ret_to_user
</span></span><span style="display:flex;"><span>ret_to_user:
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>finish_ret_to_user:
</span></span><span style="display:flex;"><span>	enable_step_tsk x1, x2
</span></span><span style="display:flex;"><span>	kernel_exit <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ENDPROC</span>(ret_to_user)
</span></span></code></pre></div><p> work_pending调用函数do_notify_resume</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/signal.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_notify_resume</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> thread_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_NEED_RESCHED) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">schedule</span>();
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_UPROBE)
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">uprobe_notify_resume</span>(regs);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_SIGPENDING)
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">do_signal</span>(regs);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_NOTIFY_RESUME) {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">clear_thread_flag</span>(TIF_NOTIFY_RESUME);
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">tracehook_notify_resume</span>(regs);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_FOREIGN_FPSTATE)
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">fpsimd_restore_current_state</span>();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">local_irq_disable</span>();
</span></span><span style="display:flex;"><span>		thread_flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">READ_ONCE</span>(<span style="color:#a6e22e">current_thread_info</span>()<span style="color:#f92672">-&gt;</span>flags);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_WORK_MASK);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第5章-内核互斥技术">第5章 内核互斥技术<a hidden class="anchor" aria-hidden="true" href="#第5章-内核互斥技术">#</a></h1>
<p> 临界区的执行时间比较长或者可能睡眠互斥技术  <br>
 (1)信号量  <br>
 (2)读写信号量  <br>
 (3)互斥锁   <br>
 (4)实时互斥锁   <br>
 临界区的执行时间很短，并且不会睡眠 互斥技术 <br>
 (1)原子变量   <br>
 (2)自旋锁   <br>
 (3)读写锁   <br>
 (4)顺序锁   <br>
 进程互斥技术  <br>
 (1)禁止内核抢占  <br>
 (2)禁止软中断   <br>
 (3)禁止硬中断    <br>
 免使用锁的互斥技术  <br>
 (1)每处理器变量  <br>
 (2)每处理器计数器  <br>
 (3)内存屏障   <br>
 (4)读-复制更新(Read-Copy Update RCU)  <br>
 (5)可睡眠RCU  <br></p>
<p> 内核提供了死锁检测工具lockdep <br></p>
<h2 id="51-信号量">5.1 信号量<a hidden class="anchor" aria-hidden="true" href="#51-信号量">#</a></h2>
<p> 信号量允许多个进程同时进入临界区，信号量的计数值设置为1，即二值信号量，这种信号量称为互斥信号量，适合保护比较长的临界区    <br>
 内核使用的信号量定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/semaphore.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> semaphore {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">raw_spinlock_t</span>   lock;  <span style="color:#75715e">// 自旋锁，保护信号量其他成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>     count;  <span style="color:#75715e">// 计数值，允许多少个进程进入临界区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">struct</span> list_head wait_list;  <span style="color:#75715e">// 等待进入临界区进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p> </p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 获取信号量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down</span>(<span style="color:#66d9ef">struct</span> semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_interruptible</span>(<span style="color:#66d9ef">struct</span> semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_killable</span>(<span style="color:#66d9ef">struct</span> semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_trylock</span>(<span style="color:#66d9ef">struct</span> semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_timeout</span>(<span style="color:#66d9ef">struct</span> semaphore <span style="color:#f92672">*</span>sem, <span style="color:#66d9ef">long</span> jiffies);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放信号量函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">struct</span> semaphore <span style="color:#f92672">*</span>sem);
</span></span></code></pre></div><h2 id="52-读写信号量">5.2 读写信号量<a hidden class="anchor" aria-hidden="true" href="#52-读写信号量">#</a></h2>
<p> 读写信号量,适合在以读为主</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/rwsem.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> rw_semaphore {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">atomic_long_t</span> count;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head wait_list;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">raw_spinlock_t</span> wait_lock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>owner;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>初始化，使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 初始化静态读写信号量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DECLARE_RWSEM</span>(name);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时动态初始化读写信号量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">init_rwsem</span>(sem);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 申请读锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down_read</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_read_trylock</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放读锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up_read</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 申请写锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down_write</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_write_killable</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">down_write_trylock</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写锁降级为读锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">downgrade_write</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放写锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up_write</span>(<span style="color:#66d9ef">struct</span> rw_semaphore <span style="color:#f92672">*</span>sem);
</span></span></code></pre></div><h2 id="53-互斥锁">5.3 互斥锁<a hidden class="anchor" aria-hidden="true" href="#53-互斥锁">#</a></h2>
<p> 互斥锁只允许一个进程进入临界区，适合保护比较长的临界区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/mutex.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> mutex {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">atomic_long_t</span>  owner;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">spinlock_t</span>     wait_lock;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MUTEX_SPIN_ON_OWNER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> optimistic_spin_queue osq; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> list_head wait_list;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 使用互斥锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 初始化静态互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DEFINE_MUTEX</span>(mutexname);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时动态初始化互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mutex_init</span>(mutex);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 申请互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mutex_lock</span>(<span style="color:#66d9ef">struct</span> mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mutex_lock_interruptible</span>(<span style="color:#66d9ef">struct</span> mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mutex_lock_killable</span>(<span style="color:#66d9ef">struct</span> mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mutex_trylock</span>(<span style="color:#66d9ef">struct</span> mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mutex_unlock</span>(<span style="color:#66d9ef">struct</span> mutex <span style="color:#f92672">*</span>lock);
</span></span></code></pre></div><h2 id="54-实时互斥锁">5.4 实时互斥锁<a hidden class="anchor" aria-hidden="true" href="#54-实时互斥锁">#</a></h2>
<p> 实时互斥锁是对互斥锁的改进，实现了优先级继承(priority inheritance)，解决了优先级反转(priority inversion)问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/rtmutex.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> rt_mutex {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">raw_spinlock_t</span>     wait_lock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_root     waiters;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node     <span style="color:#f92672">*</span>waiters_leftmost;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct    <span style="color:#f92672">*</span>owner;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 初始化，使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 初始化静态实时互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DEFINE_RT_MUTEX</span>(mutexname);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时动态初始化实时互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rt_mutex_init</span>(mutex);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 申请实时互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rt_mutex_lock</span>(<span style="color:#66d9ef">struct</span> rt_mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rt_mutex_lock_interruptible</span>(<span style="color:#66d9ef">struct</span> rt_mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rt_mutex_timed_lock</span>(<span style="color:#66d9ef">struct</span> rt_mutex <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">struct</span> hrtimer_sleeper <span style="color:#f92672">*</span>timeout);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rt_mutex_trylock</span>(<span style="color:#66d9ef">struct</span> rt_mutex <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放实时互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rt_mutex_unlock</span>(<span style="color:#66d9ef">struct</span> rt_mutex <span style="color:#f92672">*</span>lock);
</span></span></code></pre></div><h2 id="55-原子变量">5.5 原子变量<a hidden class="anchor" aria-hidden="true" href="#55-原子变量">#</a></h2>
<p> 原子变量用来实现对整数的互斥访问，通常用来实现计数器  <br>
 内核定义了3种原子变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 整数原子变量，数据类型是atomic_t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> counter;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">atomic_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 长整数原子变量，数据类型是atomic_long_t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 64位整数原子变量，数据类型是atomic64_t
</span></span></span></code></pre></div><p> 原子变量使用方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 初始化静态原子变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">&lt;</span>name<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ATOMINC_INIT</span>(n);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 动态初始化原子变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_set</span>(v, i);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读取原子变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_read</span>(v)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 原子变量加i，并返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_add_return</span>(i, v)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 原子变量v加i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_add</span>(i, v)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 原子变量加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_inc</span>(v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 原子变量v减i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_sub</span>(i, v)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 原子变量减1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">atomic_dec</span>(v)
</span></span></code></pre></div><h3 id="arm64处理器的原子变量实现">ARM64处理器的原子变量实现<a hidden class="anchor" aria-hidden="true" href="#arm64处理器的原子变量实现">#</a></h3>
<p> ARM64处理器原子变量指令支持  <br>
 (1)独占加载指令ldxr (load Exclusive Register)  <br>
 (2)独占存储指令stxr (Store Exclusive Register) <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 独占加载指令加载32位数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ldxr <span style="color:#f92672">&lt;</span>Wt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>{,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>}]
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 独占存储指令存储32位数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stxr <span style="color:#f92672">&lt;</span>Ws<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">&lt;</span>Wt<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>{,<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>}]
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 原子加法指令stadd操作32位数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stadd <span style="color:#f92672">&lt;</span>Ws<span style="color:#f92672">&gt;</span>, [<span style="color:#f92672">&lt;</span>Xn<span style="color:#f92672">|</span>SP<span style="color:#f92672">&gt;</span>]
</span></span></code></pre></div><p> 函数atomic_add(i, v)实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/atomic_ll_sc.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_add</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tmp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> result;   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;// atomic_add </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                    \
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   prfm   pstl1strm, %2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                         \
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;1:   ldxr   %w0, %2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                             \
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   &#34;</span> add <span style="color:#e6db74">&#34;   %w0, %w0, %w3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                      \
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   stxr   %w1, %w0, %2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>                          \
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   cbnz   %w1, 1b&#34;</span>                                 \
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=&amp;r&#34;</span> (result), <span style="color:#e6db74">&#34;=&amp;r&#34;</span> (tmp), <span style="color:#e6db74">&#34;+Q&#34;</span> (v<span style="color:#f92672">-&gt;</span>counter)   \
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ir&#34;</span> (i));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 原子加法指令stadd实现的函数atomic_add(i, v)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/atomic_lse.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">atomic_add</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">register</span> <span style="color:#66d9ef">int</span> w0 <span style="color:#66d9ef">asm</span> (<span style="color:#e6db74">&#34;w0&#34;</span>) <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">register</span> <span style="color:#66d9ef">atomic_t</span> <span style="color:#f92672">*</span>x1 <span style="color:#66d9ef">asm</span> (<span style="color:#e6db74">&#34;x1&#34;</span>) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34; stadd    %w[i], %[v]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>     \
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">:</span> [i] <span style="color:#e6db74">&#34;+r&#34;</span> (w0), [v] <span style="color:#e6db74">&#34;+Q&#34;</span> (v<span style="color:#f92672">-&gt;</span>counter)   \
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;r&#34;</span> (x1)                               \
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">:</span> );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="56-自旋锁">5.6 自旋锁<a hidden class="anchor" aria-hidden="true" href="#56-自旋锁">#</a></h2>
<p> 自旋锁用于处理器之间的互斥，适合保护很短的临界区，不允许在临界区睡眠</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/spinlock_types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> spinlock {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> raw_spinlock rlock;
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">spinlock_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> raw_spinlock {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">arch_spinlock_t</span> raw_lock;
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">raw_spinlock_t</span>;
</span></span></code></pre></div><p> Linux内核有一个实时内核分支（开启配置宏CONFIG_PREEMPT_RT）来支持硬实时特性，内核主线只支持软实时  <br>
 数据类型arch_spinlock_t，ARM64架构的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/spinlock_types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __AARCH64EB__     </span><span style="color:#75715e">/* 大端字节序（高位存放在低地址） */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     u16 next;
</span></span><span style="display:flex;"><span>     u16 owner;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else                    </span><span style="color:#75715e">/* 小端字节序（低位存放在低地址） */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     u16 owner;
</span></span><span style="display:flex;"><span>     u16 next;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#a6e22e">__aligned</span>(<span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">arch_spinlock_t</span>;
</span></span></code></pre></div><p> 自旋锁使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 初始化自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DEFINE_SPINLOCK</span>(x);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时初始化自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">spin_lock_init</span>(x);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 申请自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock_bh</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_lock_irq</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">spin_lock_irqsave</span>(lock, flags);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">spin_trylock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock_bh</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock_irq</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spin_unlock_irqrestore</span>(<span style="color:#66d9ef">spinlock_t</span> <span style="color:#f92672">*</span>lock, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);
</span></span></code></pre></div><p> 原始自旋锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 初始化原始自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DEFINE_RAW_SPINLOCK</span>(x);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时初始化原始自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">raw_spin_lock_init</span> (x);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 申请原始自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">raw_spin_lock</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_lock_bh</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_lock_irq</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_lock_irqsave</span>(lock, flags)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_trylock</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放原始自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">raw_spin_unlock</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_unlock_bh</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_unlock_irq</span>(lock)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">raw_spin_unlock_irqrestore</span>(lock, flags)
</span></span></code></pre></div><p> 函数spin_lock()负责申请自旋锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// spin_lock() -&gt; raw_spin_lock() -&gt; _raw_spin_lock() -&gt; __raw_spin_lock()  -&gt; do_raw_spin_lock() -&gt; arch_spin_lock()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>arch<span style="color:#f92672">/</span>arm64<span style="color:#f92672">/</span>include<span style="color:#f92672">/</span><span style="color:#66d9ef">asm</span><span style="color:#f92672">/</span>spinlock.h
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arch_spin_lock</span>(<span style="color:#66d9ef">arch_spinlock_t</span> <span style="color:#f92672">*</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> tmp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">arch_spinlock_t</span> lockval, newval;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">asm</span> <span style="color:#a6e22e">volatile</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ARM64_LSE_ATOMIC_INSN</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* LL/SC */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   prfm    pstl1strm, %3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;1:   ldaxr   %w0, %3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   add   %w1, %w0, %w5</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   stxr   %w2, %w1, %3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   cbnz   %w2, 1b</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 大系统扩展的原子指令 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   mov   %w2, %w5</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   ldadda   %w2, %w0, %3</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__nops</span>(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 我们得到锁了吗？*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   eor   %w1, %w0, %w0, ror #16</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   cbz   %w1, 3f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   sevl</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;2:   wfe</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   ldaxrh   %w2, %4</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   eor   %w1, %w2, %w0, lsr #16</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;   cbnz   %w1, 2b</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 得到锁，临界区从这里开始*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;3:&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=&amp;r&#34;</span> (lockval), <span style="color:#e6db74">&#34;=&amp;r&#34;</span> (newval), <span style="color:#e6db74">&#34;=&amp;r&#34;</span> (tmp), <span style="color:#e6db74">&#34;+Q&#34;</span> (<span style="color:#f92672">*</span>lock)
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Q&#34;</span> (lock<span style="color:#f92672">-&gt;</span>owner), <span style="color:#e6db74">&#34;I&#34;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> TICKET_SHIFT)
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;memory&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="57-读写自旋锁">5.7 读写自旋锁<a hidden class="anchor" aria-hidden="true" href="#57-读写自旋锁">#</a></h2>
<p> 读写自旋锁(通常简称读写锁)是自旋锁的改进，区分读者和写者，允许多个读者同时进入临界区，读者和写者互斥，写者和写者互斥  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/rwlock_types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">arch_rwlock_t</span> raw_lock;
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">rwlock_t</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/spinlock_types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> lock;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">arch_rwlock_t</span>;
</span></span></code></pre></div><h2 id="58-顺序锁">5.8 顺序锁<a hidden class="anchor" aria-hidden="true" href="#58-顺序锁">#</a></h2>
<p> 顺序锁区分读者和写者</p>
<h3 id="581完整版的顺序锁">5.8.1　完整版的顺序锁<a hidden class="anchor" aria-hidden="true" href="#581完整版的顺序锁">#</a></h3>
<p> 顺序锁区分读者和写者</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/seqlock.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> seqcount seqcount;  <span style="color:#75715e">// 序列号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">spinlock_t</span> lock;  <span style="color:#75715e">// 自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">seqlock_t</span>;
</span></span></code></pre></div><h3 id="582只提供序列号的顺序锁">5.8.2　只提供序列号的顺序锁<a hidden class="anchor" aria-hidden="true" href="#582只提供序列号的顺序锁">#</a></h3>
<h2 id="59禁止内核抢占">5.9　禁止内核抢占<a hidden class="anchor" aria-hidden="true" href="#59禁止内核抢占">#</a></h2>
<p> 每个进程的thread_info结构体有一个抢占计数器：“int preempt_count”，其中第0～7位是抢占计数，第8～15位是软中断计数，第16～19位是硬中断计数，第20位是不可屏蔽中断计数  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 禁止内核抢占的编程接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">preempt_disable</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开启内核抢占的编程接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">preempt_enable</span>()
</span></span></code></pre></div><p> 申请自旋锁的函数包含了禁止内核抢占</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">spin_lock</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">raw_spin_lock</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">_raw_spin_lock</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">__raw_spin_lock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/spinlock_api_smp.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__raw_spin_lock</span>(<span style="color:#66d9ef">raw_spinlock_t</span> <span style="color:#f92672">*</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">preempt_disable</span>();
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">LOCK_CONTENDED</span>(lock, do_raw_spin_trylock, do_raw_spin_lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 释放自旋锁的函数包含了开启内核抢占</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">spin_unlock</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">raw_spin_unlock</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">_raw_spin_unlock</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">__raw_spin_unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/spinlock_api_smp.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__raw_spin_unlock</span>(<span style="color:#66d9ef">raw_spinlock_t</span> <span style="color:#f92672">*</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">do_raw_spin_unlock</span>(lock);
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">preempt_enable</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="510进程和软中断互斥">5.10　进程和软中断互斥<a hidden class="anchor" aria-hidden="true" href="#510进程和软中断互斥">#</a></h2>
<p> 每个进程的thread_info结构体有一个抢占计数器“int preempt_count”，其中第8～15位是软中断计数  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 禁止软中断的接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">local_bh_disable</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开启软中断的接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">local_bh_enable</span>()
</span></span></code></pre></div><h2 id="511进程和硬中断互斥">5.11　进程和硬中断互斥<a hidden class="anchor" aria-hidden="true" href="#511进程和硬中断互斥">#</a></h2>
<p> 进程和硬中断可能访问同一个对象，那么进程和硬中断需要互斥，进程需要禁止硬中断  <br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 禁止硬中断的接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">local_irq_disable</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">local_irq_save</span>(flags)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开启硬中断接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">local_irq_enable</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">local_irq_restore</span>(flags)
</span></span></code></pre></div><h2 id="512每处理器变量">5.12　每处理器变量<a hidden class="anchor" aria-hidden="true" href="#512每处理器变量">#</a></h2>
<p> 多处理器系统中，每处理器变量为每个处理器生成一个变量的副本 <br>
 每处理器变量分为静态和动态两种 <br></p>
<h3 id="5121静态每处理器变量">5.12.1　静态每处理器变量<a hidden class="anchor" aria-hidden="true" href="#5121静态每处理器变量">#</a></h3>
<h3 id="5122动态每处理器变量">5.12.2　动态每处理器变量<a hidden class="anchor" aria-hidden="true" href="#5122动态每处理器变量">#</a></h3>
<h3 id="5123访问每处理器变量">5.12.3　访问每处理器变量<a hidden class="anchor" aria-hidden="true" href="#5123访问每处理器变量">#</a></h3>
<h2 id="513每处理器计数器">5.13　每处理器计数器<a hidden class="anchor" aria-hidden="true" href="#513每处理器计数器">#</a></h2>
<p> 原子变量作为计数器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/percpu_counter.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> percpu_counter {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">raw_spinlock_t</span> lock;
</span></span><span style="display:flex;"><span>	s64 count;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	s32 __percpu <span style="color:#f92672">*</span>counters;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="514内存屏障">5.14　内存屏障<a hidden class="anchor" aria-hidden="true" href="#514内存屏障">#</a></h2>
<p> 内存屏障（memory barrier）是一种保证内存访问顺序的方法，解决内存访问乱序问题  <br>
 (1)    <br>
 (2)    <br>
 (3)    <br></p>
<p> 内核支持3种内存屏障  <br>
 (1)编译器屏障  <br>
 (2)处理器内存屏障  <br>
 (3)内存映射I/O (Memory Mapping I/O MMIO)写屏障   <br></p>
<h3 id="5141编译器屏障">5.14.1　编译器屏障<a hidden class="anchor" aria-hidden="true" href="#5141编译器屏障">#</a></h3>
<p> 编译器屏障</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// GCC编译器定义的宏“barrier()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// include/linux/compiler-gcc.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define barrier() __asm__ __volatile__(&#34;&#34;: : :&#34;memory&#34;)
</span></span></span></code></pre></div><h3 id="5142处理器内存屏障">5.14.2　处理器内存屏障<a hidden class="anchor" aria-hidden="true" href="#5142处理器内存屏障">#</a></h3>
<p> 处理器内存屏障用来解决处理器之间的内存访问乱序问题和处理器访问外围设备的乱序问题  <br></p>
<table>
	<tr>
	    <th>内存屏障类型</th>
	    <th>强制性内存屏障</th>
	    <th>SMP内存屏障</th>  
	</tr >
	<tr >
	    <td >通用内存屏障</td>
	    <td>mb()</td>
	    <td>smp_mb()</td>
	</tr>
	<tr >
	    <td >写内存屏障</td>
	    <td>wmb()</td>
	    <td>smp_wmb()</td>
	</tr>
	<tr >
	    <td >读内存屏障</td>
	    <td>rmb()</td>
	    <td>smp_rmb()</td>
	</tr>
	<tr >
	    <td >数据依赖屏障</td>
	    <td>read_barrier_depends()</td>
	    <td>smp_read_barrier_depends()</td>
	</tr>
</table>
<h3 id="5143-mmio写屏障">5.14.3 MMIO写屏障<a hidden class="anchor" aria-hidden="true" href="#5143-mmio写屏障">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 内核为内存映射I/O写操作提供了一个特殊的屏障
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mmiowb</span>();
</span></span></code></pre></div><h3 id="5144隐含内存屏障">5.14.4　隐含内存屏障<a hidden class="anchor" aria-hidden="true" href="#5144隐含内存屏障">#</a></h3>
<p> 内核的有些函数隐含内存屏障  <br>
 （1）获取和释放函数。  <br>
 （2）中断禁止函数。  <br></p>
<h3 id="5145arm64处理器内存屏障">5.14.5　ARM64处理器内存屏障<a hidden class="anchor" aria-hidden="true" href="#5145arm64处理器内存屏障">#</a></h3>
<p> ARM64处理器提供了3种内存屏障  <br>
 (1)指令同步屏障(Instruction Synchronization Barrier ISB),指令是isb <br>
 (2)数据内存屏障(Data Memory Barrier DMB)，指令是dmb  <br>
 (3)数据同步屏障(Data Synchronization Barrier DSb)，指令是dsb  <br></p>
<h2 id="515rcu">5.15　RCU<a hidden class="anchor" aria-hidden="true" href="#515rcu">#</a></h2>
<p> RCU(Read-Copy Update)读-复制更新  <br></p>
<h3 id="5152技术原理">5.15.2　技术原理<a hidden class="anchor" aria-hidden="true" href="#5152技术原理">#</a></h3>
<h2 id="516可睡眠rcu">5.16　可睡眠RCU<a hidden class="anchor" aria-hidden="true" href="#516可睡眠rcu">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"></code></pre></div><h2 id="517死锁检测工具lockdep">5.17　死锁检测工具lockdep<a hidden class="anchor" aria-hidden="true" href="#517死锁检测工具lockdep">#</a></h2>
<p> 死锁有以下4种情况  <br>
 1）进程重复申请同一个锁，称为AA死锁  <br>
 2）进程申请自旋锁时没有禁止硬中断，进程获取自旋锁以后，硬中断抢占，申请同一个自旋锁  <br>
 3）两个进程都要获取锁L1和L2，进程1持有锁L1，再去获取锁L2，如果这个时候进程2持有锁L2并且正在尝试获取锁L1，那么进程1和进程2就会死锁，称为AB-BA死锁  <br>
 4）在一个处理器上进程1持有锁L1，再去获取锁L2，在另一个处理器上进程2持有锁L2，硬中断抢占进程2以后获取锁L1  <br></p>
<h3 id="5171使用方法">5.17.1　使用方法<a hidden class="anchor" aria-hidden="true" href="#5171使用方法">#</a></h3>
<p> 死锁检测工具lockdep的配置宏</p>
<h3 id="5172技术原理">5.17.2　技术原理<a hidden class="anchor" aria-hidden="true" href="#5172技术原理">#</a></h3>
<h1 id="第6章-文件系统">第6章 文件系统<a hidden class="anchor" aria-hidden="true" href="#第6章-文件系统">#</a></h1>
<h2 id="61概述">6.1　概述<a hidden class="anchor" aria-hidden="true" href="#61概述">#</a></h2>
<p> Linux系统中，一切皆文件  <br></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zainll/PictureBed/main/blogs/pictures/20221201002338.png" alt="20221201002338"  />
</p>
<center>Linux文件系统的架构</center>
<h3 id="611用户空间层面">6.1.1　用户空间层面<a hidden class="anchor" aria-hidden="true" href="#611用户空间层面">#</a></h3>
<p> 应用程序可以直接使用内核提供的系统调用访问文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 挂载文件系统
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mount
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 卸载目录下挂载的文件系统
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>umount
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打开文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>open
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>close
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>write
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置文件偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>lseek
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 文件修改过的属性和数据立即写到存储设备
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fsync
</span></span></code></pre></div><p> glibc库封装的标准I/O流函数访问文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 打开流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fopen
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fclose
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 读流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fread
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fwrite
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置文件偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fseek
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 冲刷流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fflush
</span></span></code></pre></div><h3 id="612硬件层面">6.1.2　硬件层面<a hidden class="anchor" aria-hidden="true" href="#612硬件层面">#</a></h3>
<p> 外部存储设备分为块设备、闪存和NVDIMM设备3类  <br></p>
<p> 闪存按存储结构分为NAND闪存和NOR闪存  <br></p>
<h3 id="613内核空间层面">6.1.3　内核空间层面<a hidden class="anchor" aria-hidden="true" href="#613内核空间层面">#</a></h3>
<p> 使不同的文件系统实现能够共存，内核实现了一个抽象层，称为虚拟文件系统（Virtual File System，VFS），也称为虚拟文件系统切换（Virtual Filesystem Switch，VFS）   <br>
 文件系统分为以下4种  <br></p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://liuz0123.gitee.io/zain/img/wechat_pay.jpg" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://liuz0123.gitee.io/zain/img/alipay.jpg" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://liuz0123.gitee.io/zain/posts/na/%E9%81%93%E6%AD%89/">
    <span class="title">« 上一页</span>
    <br>
    <span>请求娜的原谅</span>
  </a>
  <a class="next" href="https://liuz0123.gitee.io/zain/posts/blog/git/">
    <span class="title">下一页 »</span>
    <br>
    <span>git</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou', 
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2022 
        <a href="https://liuz0123.gitee.io/zain/" style="color:#939393;">zain&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号申请中</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="填自己的公安图标链接" style="float:left;margin: 0px 5px 0px 0px;"/>
             公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
