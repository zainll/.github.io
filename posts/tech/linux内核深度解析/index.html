<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux内核深度解析 | zain&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区">
<meta name="author" content="
&nbsp;Zain">
<link rel="canonical" href="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">
<link crossorigin="anonymous" href="/zain/assets/css/stylesheet.6bbe4903eaf247f5c3db656a51fd7b09d982ab42029edfdc123f359e2748dc03.css" integrity="sha256-a75JA&#43;ryR/XD22VqUf17CdmCq0ICnt/cEj81nidI3AM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/zain/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="apple-touch-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="mask-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Linux内核深度解析" />
<meta property="og:description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-05T00:17:58&#43;08:00" />
<meta property="article:modified_time" content="2022-10-05T00:17:58&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux内核深度解析"/>
<meta name="twitter:description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://liuz0123.gitee.io/zain/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Linux内核深度解析",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux内核深度解析",
  "name": "Linux内核深度解析",
  "description": "内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区",
  "keywords": [
    ""
  ],
  "articleBody": "内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区的互斥 虚拟文件系统 第1章 内核引导和初始化 处理器上电-\u003e执行引导程序-\u003e加载内核到内存-\u003e执行内核-\u003e内核初始化-\u003e启动用户空间第一个进程 ARM64处理器到物理地址0取第一条指令\n1.1 引导程序 1.1.1 入口_start ARM64处理器U-Boot程序执行过程，入口u-boot/arch/arm/cpu/armv8/start.S标识_start\n.globl\t_start _start: #if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER) #include #elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) #include #else b\treset #endif 1.1.2 reset reset: /* Allow the board to save important registers */ /* 允许板卡保存重要的寄存器*/ b\tsave_boot_params .globl\tsave_boot_params_ret save_boot_params_ret: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl // 初始化系统控制寄存器 #endif /* * 异常级别可能是3、2或者1，初始状态： * 小端字节序，禁止MMU，禁止指令/数据缓存 */ adr x0, vectors witch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 // 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址 mrs x0, scr_el3 // 设置安全配置寄存器SCR_EL3 orr x0, x0, #0xf /* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */ msr scr_el3, x0 msr cptr_el3, xzr /* 启用浮点和SIMD功能*/ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* 初始化寄存器CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 // 异常级别2 mov x0, #0x33ff msr cptr_el2, x0 /* 启用浮点和SIMD功能 */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u003c\u003c 20 msr cpacr_el1, x0 /* 启用浮点和SIMD功能 */ 0: … /* 应用ARM处理器特定的勘误表*/ bl apply_core_errata /* 处理器特定的初始化*/ bl lowlevel_init // 执行board_init_f()所需最小初始化 #if defined(CONFIG_ARMV8_SPIN_TABLE) \u0026\u0026 !defined(CONFIG_SPL_BUILD) branch_if_master x0, x1, master_cpu b spin_table_secondary_jump // arch/arm/cpu/armv8/spin_tabli.c /* 绝对不会返回*/ #elif defined(CONFIG_ARMV8_MULTIENTRY) branch_if_master x0, x1, master_cpu /* * 从处理器 */ slave_cpu: wfe // 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数 ldr x1, =CPU_RELEASE_ADDR ldr x0, [x1] cbz x0, slave_cpu br x0 /* 跳转到指定地址*/ #endif /* CONFIG_ARMV8_MULTIENTRY */ master_cpu: bl _main // 主处理器执行函数 U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序\n1.1.3 函数_main // arch/arm/lib/crt0_64.S ENTRY(_main) // 设置初始的C语言运行环境，并且调用board_init_f(0)。 #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节*/ mov x0, sp bl board_init_f_alloc_reserve // 在栈的顶部为结构体global_data分配空间 mov sp, x0 mov x18, x0 /* 设置gd */ // 函数board_init_f_init_reserve，初始化结构体global_data bl board_init_f_init_reserve mov x0, #0 bl board_init_f // common/board_f.c 执行数组init_sequence_f中的每个函数 #if !defined(CONFIG_SPL_BUILD) // 设置中间环境（新的栈指针和gd），然后调用函数 // relocate_code(addr_moni) ldr x0, [x18, #GD_START_ADDR_SP] /* 把寄存器x0设置为gd-\u003estart_addr_sp */ bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节 */ ldr x18, [x18, #GD_BD] /* 把寄存器x18设置为gd-\u003ebd */ sub x18, x18, #GD_SIZE /* 新的gd在bd的下面 */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* 把寄存器x9设置为gd-\u003ereloc_off */ add lr, lr, x9 /* 在重定位后新的返回地址 */ ldr x0, [x18, #GD_RELOCADDR] /* 把寄存器x0设置为gd-\u003erelocaddr */ b relocate_code relocation_return: // 设置最终的完整环境 /* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/ bl c_runtime_cpu_setup #endif /* !CONFIG_SPL_BUILD */ #if defined(CONFIG_SPL_BUILD) bl spl_relocate_stack_gd /* 可能返回空指针 重新定位栈*/ // 执行“sp = (x0 != NULL) ? x0 : sp”， // 规避这个约束： // 带条件的mov指令不能把栈指针寄存器作为操作数 mov x1, sp cmp x0, #0 csel x0, x0, x1, ne mov sp, x0 #endif // 用0初始化未初始化数据段 ldr x0, =__bss_start /* 这是自动重定位*/ ldr x1, =__bss_end /* 这是自动重定位*/ clear_loop: str xzr, [x0], #8 cmp x0, x1 b.lo clear_loop /* 调用函数board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ /* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */ b board_init_r /* 不会运行到这里，因为函数board_init_r()不会返回*/ ENDPROC(_main) 1.1.4 函数run_main_loop 数组init_sequence_r最后一个函数run_main_loop，函数执行流程；\nrun_main_loop main_loop bootdely_process # 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量) autoboot_command abortboot # 等待用户按键 run_command_list # 未等待到按键，自动执行环境变量bootcmd bootm命令处理函数do_bootm\ndo_bootm do_bootm_states bootm_start # 初始化全局变量bootm_header_timages bootm_find_os # 把内核镜像从存储设备读到内存 bootm_find_other # ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件 bootm_load_os # 解压病加载内核到正确位置 bootm_os_get_boot_func # 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux do_bootm_linux(flag=BOOTM_STATE_OS_PREP) # 调用boot_prep_linux boot_prep_linux # 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件 boot_selected_os # do_bootm_linux(flag=BOOTM_STATE_OS_GO) boot_jump_linux # 负责跳转到Linux内核 boot_jum_linux do_nonsec_virt_switch smp_kick_all_cpus # CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3 dcache_disable # 禁用处理器的缓存和内存管理单元 # 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el2 switch_to_el1 armv8_switch_to_el1 内核入口 # 在异常级别2执行内核 armv8_switch_to_el2 内核入口 1.2 内核初始化 内核初始化分为汇编语言部分和C语言部分\n1.2.1 汇编语言部分 ARM64架构内核入口_head，直接跳转到标号stext\n// linux-4.14.295/arch/arm64/kernel/head.S _head: #ifdef CONFIG_EFI // 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS add x13, x18, #0x16 b stext #else b stext // 跳转到内核起始位置 .long0 // 保留 #endif stext\n// linux-4.14.295/arch/arm64/kernel/head.S ENTRY(stext) bl preserve_boot_args // 把引导程序传递的4个参数保存在全局数组boot_args中 bl el2_setup // 降级到异常级别1, 寄存器w0存放cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR偏移，默认值是0 bl set_cpu_boot_mode_flag // __boot_cpu_mode[2] 数组 bl __create_page_tables // 创建页表映射 /* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。 * 返回的时候，处理器已经为开启内存管理单元做好准备， * 转换控制寄存器已经设置好。*/ bl __cpu_setup // 初始化处理器 b __primary_switch // 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel ENDPROC(stext) 函数el2_setup a.如果异常级别是1，那么在异常级别1执行内核。 b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。 1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。 \\\n2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核 \\\n基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程 \\\n// 打开KVM字符设备文件。 fd = open(\"/dev/kvm\", O_RDWR); // 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。 vmfd = ioctl(fd, KVM_CREATE_VM, 0); // KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符 vcpu_fd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 从QEMU切换到客户操作系统的过程如下。 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。 为了提高切换速度，ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2 \\\n函数__create_page_tables 1）创建恒等映射，虚拟地址=物理地址__enable_mmu开启内存管理单元 2）为内核镜像创建映射 \\\n映射代码节.idmap.text,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址\n函数__primary_switch 1）__enable_mmu开启内存管理单元 2）__primary_switched __enable_mmu执行流程 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址 __primary_switch执行流程 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE) 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体thread_info的地址(init_task.thread_info) 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors) 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中 5）用0初始化内核的未初始化数据段 6）调用C语言函数start_kernel \\\n1.2.2 C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。 （1）创建1号线程，即init线程，线程函数是kernel_init。 （2）创建2号线程，即kthreadd线程，负责创建内核线程。 （3）0号线程最终变成空闲线程。 \\\ninit线程继续初始化，执行的主要操作如下。 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。 （3）smp_init()：初始化SMP系统，启动所有从处理器。 （4）do_initcalls()：执行级别0～7的初始化。 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。 （7）free_initmem()：释放初始化代码和数据占用的内存。 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。 \\\n级别0～7的初始化，是指使用以下宏注册的初始化函数：\n// include/linux/init.h #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 1.2.3 SMP系统的引导 对称多处理器(Symmetirc Multi-Processor SMP) 3种引导从处理器方法 \\\n自旋表 电源状态协调接口 ACPI停车协议 1.3 init进程 init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有sysvinit、busybox init、upstart、systemd和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件/etc/initab\n第2章 进程管理 2.1 进程 Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。 task_struct结构体是进程描述符，主要成员\nvolatile long state; // 进程状态 void *stack; // 指向内核栈 pid_t pid; // 全局进程号 pid_t tgid // 全局的线程组标识符 struct pid_link pid[PIDTYPE_MAX]; // 进程号，进程组标识符和会话标识符 struct task_struct _rcu *real_parent; // real_parent指向真实的父进程 struct task_struct _rcu *parent; // parent指向父进程 struct task_struct *group_leader; // 指向进村组的组长 const struct cred _rcu *real_cred; // real_cred指向主题和真实客体证书 const struct cred _rcu *cred; // cred指向客体证书 char comm[TASK_COMM_LEN]; // 进程名 int prio, static_prio, nornal_prio; // 调度策略 unsigned int rt_priority,prolicy； // 优先级 cpumask_t cpus_allowed; // 允许进程在哪些处理器上运行 struct mm_struct *mm, *active_mm; // 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符 struct file_struct *files; // 打开文件表 struct nsproxy *nsproxy; // 命名空间 struct signal_struct *signal; // 信号处理 struct sigband_struct *sighand; sigset_t blocked, real_blocked; sigset_t saved_sigmask; struct sigpending pending; struct sysv_sem sysvsem; // UNIx系统5信号量和共享内存 struct sysv_shm sysvshm; 2.2 命名空间 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,容器仅仅是通过命名空间隔离？ \\\n命名空间 隔离资源 控制组cgroup 控制组根目录 进程间通信IPC UNIX系统5进程间通信和POSIx消息队列 network 网络协议 挂载mount 挂载点 PID 进程号 user 用户标识符和组标识符 UNIX分时系统(UTS) 主机名和网络信息服务NIS域名 创建新的命名空间方法： 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间 调用unshare创建新的命名空间 进程使用系统调用setns，绑定一个已经存在的命名空间\n进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。\n2.3 进程标识符 标识符 进程标识符 命名空间给进程分配标识符 线程组标识符 线程组中的主进程称为组长，线程组标识符就是组长的进程标识符\n系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组 进程组标识符 进程组标识符是组长的进程标识符。\n进程可以使用系统调用setpgid创建或者加入一个进程组 会话标识符 进程调用系统调用setsid的时候，创建一个新的会话 pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid \\\n进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，\n2.4 进程关系 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。\n2.5 启动程序 ret = fork(); if (ret \u003e 0) { /* 父进程继续执行 */ } else if (ret == 0) { /* 子进程装载程序 */ ret = execve(filename, argv, envp); } else { /* 创建子进程失败 */ } 2.5.1　创建新进程 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的 两个个系统调用创建进程： \\\nfork：子进程是父进程的副本，用写时复制 clone：可控制子进程和父进程共享哪些资源 vfork：创建子进程，子进程用execve装载程序(已废弃) // 数字表示参数个数 SYSCALL_DEFINE0(fork) // 宏展开 asmlinkage表示C语言函数看被汇编代码调用 asmlinkage long sys_fork(void) 创建进程的进程p和被创建进程c三种关系\n新进程是进程p的子进程 clone传入CLONE_PARENT，兄弟关系 clone传入CLONE_THREAD，同属一个线程组 1. _do_fork函数 // kernel/fork.c long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); // tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址 调用copy_process创建新进程 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置 wake_up_new_task唤醒新进程\n2. copy_process函数 （1）标志组合 CLONE_NEWNS \u0026 CLONE_FS 新进程属于新挂载命名空间\n共享文件系统信息 CLONE_NEWUSER \u0026 CLONE_FS 新进程属于新用户命名空间\n共享文件系统信息 CLONE_THREAD 未设置CLONE_SIGHAND 新进程和当前进程同属一个线程组，\n但不共享信号处理程序 CLONE_SIGHAND 未设置CLONE_VM 新进程和当前进程共享信号处理程序，\n但不共享虚拟内存 （2）dup_task_struct函数 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈 // include/linux/sched.h union thread_union { #ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK struct task_struct task; #endif #ifndef CONFIG_THREAD_INFO_IN_TASK struct thread_info thread_info; #endif unsigned long stack[THREAD_SIZE/sizeof(long)]; }; 内核栈两种布局\nthread_info在内核栈顶部，成员task指向进程描述符 thread_info未占用内核栈 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址 内核栈的长度时THREAD_SIZE，ARM64架构内核栈长度为16KB thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体 // arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long\tflags;\t/* low level flags 底层标志位 */ mm_segment_t\taddr_limit;\t/* address limit 地址限制 */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN u64\tttbr0;\t/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */ #endif u64\tpreempt_count;\t/* 抢占计数器 0 =\u003e preemptible 可抢占, \u003c0 =\u003e bug缺陷 */ }; （3）copy_creds函数 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1\n（4）检查线程数量限制 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS\n（5）sched_fork函数\n为新进程设置调度器相关的参数\n// linux-5.10.102/kernel/sched/core.c 书中为4.x版本 int sched_fork(unsigned long clone_flags, struct task_struct *p) { __sched_fork(clone_flags, p); // 执行基本设置 /* * We mark the process as NEW here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u003estate = TASK_NEW; // 新进程状态设置为TASK_NEW /* * Make sure we do not leak PI boosting priority to the child. */ p-\u003eprio = current-\u003enormal_prio; // 新进程调度优先级设置为当前进程正常优先级 uclamp_fork(p); /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u003esched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { // 限期进程或实时进程 p-\u003epolicy = SCHED_NORMAL; // 调度策略 p-\u003estatic_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u003ert_priority = 0; } else if (PRIO_TO_NICE(p-\u003estatic_prio) \u003c 0) // 普通进程 p-\u003estatic_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u003eprio = p-\u003enormal_prio = p-\u003estatic_prio; set_load_weight(p, false); /* * We don't need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u003esched_reset_on_fork = 0; } if (dl_prio(p-\u003eprio)) // 调度优先级是限期调度累的优先级 return -EAGAIN; // 不允许限期进程分叉生成新的限期进程 else if (rt_prio(p-\u003eprio)) // 调度优先级是实时调度类优先级 p-\u003esched_class = \u0026rt_sched_class; // 调度类设置为实时调度类 else p-\u003esched_class = \u0026fair_sched_class; // 调度优先级是公平调度类的优先级，调度类设置为公平调度类 init_entity_runnable_average(\u0026p-\u003ese); #ifdef CONFIG_SCHED_INFO if (likely(sched_info_on())) memset(\u0026p-\u003esched_info, 0, sizeof(p-\u003esched_info)); #endif #if defined(CONFIG_SMP) p-\u003eon_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026p-\u003epushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026p-\u003epushable_dl_tasks); #endif return 0; } （6）复制或共享资源 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数\n// linux-4.14.295/ipc/sem.c int copy_semundo(unsigned long clone_flags, struct task_struct *tsk) { struct sem_undo_list *undo_list; int error; if (clone_flags \u0026 CLONE_SYSVSEM) { // CLONE_SYSTEM表示UNIX系统5信号量 error = get_undo_list(\u0026undo_list); if (error) return error; refcount_inc(\u0026undo_list-\u003erefcnt); // 5信号量的撤销请求链表，sem_undo_list 计数+1 tsk-\u003esysvsem.undo_list = undo_list; } else tsk-\u003esysvsem.undo_list = NULL; // 新进程5信号量撤销请求链表为空 return 0; } 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表\n// linux-5.10.102/kernel/fork.c static int copy_files(unsigned long clone_flags, struct task_struct *tsk) { struct files_struct *oldf, *newf; int error = 0; /* * A background process may not have any files ... */ oldf = current-\u003efiles; if (!oldf) goto out; if (clone_flags \u0026 CLONE_FILES) { // CLONE_FIELS共享打开文件表 atomic_inc(\u0026oldf-\u003ecount); // files_struct 计数加1 goto out; } newf = dup_fd(oldf, NR_OPEN_MAX, \u0026error); // 新进程把当前进程的打开文件表复制一份 if (!newf) goto out; tsk-\u003efiles = newf; error = 0; out: return error; } 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息 函数copy_fs复制或共享文件系统信息\n// linux-5.10.102/kernel/fork.c static int copy_fs(unsigned long clone_flags, struct task_struct *tsk) { struct fs_struct *fs = current-\u003efs; if (clone_flags \u0026 CLONE_FS) { // CLONE_FS共享文件系统信息 /* tsk-\u003efs is already what we want */ spin_lock(\u0026fs-\u003elock); if (fs-\u003ein_exec) { spin_unlock(\u0026fs-\u003elock); return -EAGAIN; } fs-\u003eusers++; // fs_struct共享文件系统信息结构体 加1 spin_unlock(\u0026fs-\u003elock); return 0; } tsk-\u003efs = copy_fs_struct(fs); // 新进程复制当前进程文件系统信息 if (!tsk-\u003efs) return -ENOMEM; return 0; } 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 函数copy_sighand复制或共享信号处理程序\n// static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk) { struct sighand_struct *sig; if (clone_flags \u0026 CLONE_SIGHAND) { // CLONE_SIGHAND 表示共享信号处理程序 refcount_inc(\u0026current-\u003esighand-\u003ecount); // 引用计数加1 return 0; } // 新进程复制当前进程信号处理程序 sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL); RCU_INIT_POINTER(tsk-\u003esighand, sig); if (!sig) return -ENOMEM; refcount_set(\u0026sig-\u003ecount, 1); spin_lock_irq(\u0026current-\u003esighand-\u003esiglock); memcpy(sig-\u003eaction, current-\u003esighand-\u003eaction, sizeof(sig-\u003eaction)); spin_unlock_irq(\u0026current-\u003esighand-\u003esiglock); /* Reset all signal handler not set to SIG_IGN to SIG_DFL. */ if (clone_flags \u0026 CLONE_CLEAR_SIGHAND) flush_signal_handlers(tsk, 0); return 0; } 5）信号结构体，同属一个线程组的线程才会共享信号结构体 函数copy_signal复制或共享信号结构体\n// linux-5.10.102/kernel/fork.c static int copy_signal(unsigned long clone_flags, struct task_struct *tsk) { struct signal_struct *sig; if (clone_flags \u0026 CLONE_THREAD) // CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct return 0; // 为新进程分配结构体，初始化，继承当前进程资源限制 sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL); tsk-\u003esignal = sig; if (!sig) return -ENOMEM; sig-\u003enr_threads = 1; atomic_set(\u0026sig-\u003elive, 1); refcount_set(\u0026sig-\u003esigcnt, 1); /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */ sig-\u003ethread_head = (struct list_head)LIST_HEAD_INIT(tsk-\u003ethread_node); tsk-\u003ethread_node = (struct list_head)LIST_HEAD_INIT(sig-\u003ethread_head); init_waitqueue_head(\u0026sig-\u003ewait_chldexit); sig-\u003ecurr_target = tsk; init_sigpending(\u0026sig-\u003eshared_pending); INIT_HLIST_HEAD(\u0026sig-\u003emultiprocess); seqlock_init(\u0026sig-\u003estats_lock); prev_cputime_init(\u0026sig-\u003eprev_cputime); #ifdef CONFIG_POSIX_TIMERS INIT_LIST_HEAD(\u0026sig-\u003eposix_timers); hrtimer_init(\u0026sig-\u003ereal_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); sig-\u003ereal_timer.function = it_real_fn; #endif task_lock(current-\u003egroup_leader); memcpy(sig-\u003erlim, current-\u003esignal-\u003erlim, sizeof sig-\u003erlim); task_unlock(current-\u003egroup_leader); posix_cpu_timers_init_group(sig); tty_audit_fork(sig); sched_autogroup_fork(sig); sig-\u003eoom_score_adj = current-\u003esignal-\u003eoom_score_adj; sig-\u003eoom_score_adj_min = current-\u003esignal-\u003eoom_score_adj_min; mutex_init(\u0026sig-\u003ecred_guard_mutex); init_rwsem(\u0026sig-\u003eexec_update_lock); return 0; } 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存 \\ 函数copy_mm复制或共享虚拟内存\n// linux-5.10.102/kernel/freezer.c static int copy_mm(unsigned long clone_flags, struct task_struct *tsk) { struct mm_struct *mm, *oldmm; int retval; tsk-\u003emin_flt = tsk-\u003emaj_flt = 0; tsk-\u003envcsw = tsk-\u003enivcsw = 0; #ifdef CONFIG_DETECT_HUNG_TASK tsk-\u003elast_switch_count = tsk-\u003envcsw + tsk-\u003enivcsw; tsk-\u003elast_switch_time = 0; #endif tsk-\u003emm = NULL; tsk-\u003eactive_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ oldmm = current-\u003emm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); if (clone_flags \u0026 CLONE_VM) { // CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct mmget(oldmm); mm = oldmm; goto good_mm; } retval = -ENOMEM; // 新进程复制当前进程的虚拟内存 mm = dup_mm(tsk, current-\u003emm); if (!mm) goto fail_nomem; good_mm: tsk-\u003emm = mm; tsk-\u003eactive_mm = mm; return 0; fail_nomem: return retval; } 7）命名空间 函数copy_namespace创建或共享命名空间\n// linux-5.10.102/kernel/nsproxy.c int copy_namespaces(unsigned long flags, struct task_struct *tsk) { struct nsproxy *old_ns = tsk-\u003ensproxy; struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns); struct nsproxy *new_ns; int ret; // 如果共享除了用户以外的所有其他命名空间， // 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1 if (likely(!(flags \u0026 (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWCGROUP | CLONE_NEWTIME)))) { if (likely(old_ns-\u003etime_ns_for_children == old_ns-\u003etime_ns)) { get_nsproxy(old_ns); return 0; } } else if (!ns_capable(user_ns, CAP_SYS_ADMIN)) // 进程没有系统管理权限，那么不允许创建新的命名空间 return -EPERM; /* CLONE_NEWIPC must detach from the undolist: after switching * to a new ipc namespace, the semaphore arrays from the old * namespace are unreachable. In clone parlance, CLONE_SYSVSEM * means share undolist with parent, so we must forbid using * it along with CLONE_NEWIPC. */ // 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的 if ((flags \u0026 (CLONE_NEWIPC | CLONE_SYSVSEM)) == (CLONE_NEWIPC | CLONE_SYSVSEM)) return -EINVAL; // 创建新的命名空间代理，然后创建或者共享命名空间 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-\u003efs); if (IS_ERR(new_ns)) return PTR_ERR(new_ns); ret = timens_on_fork(new_ns, tsk); if (ret) { free_nsproxy(new_ns); return ret; } tsk-\u003ensproxy = new_ns; return 0; } 8）I/O上下文 函数copy_io创建或共享I/O上下文\n// linux-5.10.102/kernel/fork.c static int copy_io(unsigned long clone_flags, struct task_struct *tsk) { #ifdef CONFIG_BLOCK struct io_context *ioc = current-\u003eio_context; struct io_context *new_ioc; if (!ioc) return 0; /* Share io context with parent, if CLONE_IO is set */ if (clone_flags \u0026 CLONE_IO) { // CLONE_IO 共享I/O上小文 ioc_task_link(ioc); // 计数nr_tasks加1 tsk-\u003eio_context = ioc; // 共享I/O上下文结构体io_context } else if (ioprio_valid(ioc-\u003eioprio)) { // 创建新的I/O上下文，初始化，继承当前进程的I/O优先级 new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE); if (unlikely(!new_ioc)) return -ENOMEM; new_ioc-\u003eioprio = ioc-\u003eioprio; put_io_context(new_ioc); } #endif return 0; } 9）复制寄存器值 函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct\nARM64架构copy_thread_tls-\u003ecopy_thread\n// linux-5.10.102/arch/arm64/kernel/process.c int copy_thread(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz, struct task_struct *p, unsigned long tls) { struct pt_regs *childregs = task_pt_regs(p); // 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值 memset(\u0026p-\u003ethread.cpu_context, 0, sizeof(struct cpu_context)); /* In case p was allocated the same task_struct pointer as some * other recently-exited task, make sure p is disassociated from * any cpu that may have run that now-exited task recently. * Otherwise we could erroneously skip reloading the FPSIMD * registers for p. */ fpsimd_flush_task_state(p); ptrauth_thread_init_kernel(p); if (likely(!(p-\u003eflags \u0026 PF_KTHREAD))) { // 用户进程 *childregs = *current_pt_regs(); childregs-\u003eregs[0] = 0; /* Read the current TLS pointer from tpidr_el0 as it may be * out-of-sync with the saved value. * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址， * 因为它可能和保存的值不一致 */ *task_user_tls(p) = read_sysreg(tpidr_el0); if (stack_start) { if (is_compat_thread(task_thread_info(p))) childregs-\u003ecompat_sp = stack_start; else childregs-\u003esp = stack_start; } /* If a TLS pointer was passed to clone, use it for the new thread. * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/ if (clone_flags \u0026 CLONE_SETTLS) p-\u003ethread.uw.tp_value = tls; } else { // 内核线程 memset(childregs, 0, sizeof(struct pt_regs)); childregs-\u003epstate = PSR_MODE_EL1h; if (IS_ENABLED(CONFIG_ARM64_UAO) \u0026\u0026 cpus_have_const_cap(ARM64_HAS_UAO)) childregs-\u003epstate |= PSR_UAO_BIT; spectre_v4_enable_task_mitigation(p); if (system_uses_irq_prio_masking()) childregs-\u003epmr_save = GIC_PRIO_IRQON; p-\u003ethread.cpu_context.x19 = stack_start; p-\u003ethread.cpu_context.x20 = stk_sz; } p-\u003ethread.cpu_context.pc = (unsigned long)ret_from_fork; p-\u003ethread.cpu_context.sp = (unsigned long)childregs; ptrace_hw_copy_thread(p); return 0; } （7）设置进程号和进程关系 static __latent_entropy struct task_struct *copy_process( struct pid *pid, int trace, int node, struct kernel_clone_args *args) { // 为新进程分配进程号 // pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号 if (pid != \u0026init_struct_pid) { pid = alloc_pid(p-\u003ensproxy-\u003epid_ns_for_children); if (IS_ERR(pid)) { retval = PTR_ERR(pid); goto bad_fork_cleanup_thread; } } … // 设置新进程退出时发送给父进程的信号 p-\u003epid = pid_nr(pid); if (clone_flags \u0026 CLONE_THREAD) { p-\u003eexit_signal = -1; // 新线程退出时不需要发送信号给父进程 p-\u003egroup_leader = current-\u003egroup_leader; // group_leader指向同一个组长 p-\u003etgid = current-\u003etgid; // tgid存放组长的进程号 } else { if (clone_flags \u0026 CLONE_PARENT) // CLONE_PARENT 新进程和当前进程是兄弟关系 p-\u003eexit_signal = current-\u003egroup_leader-\u003eexit_signal; // 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal else // 父子关系 p-\u003eexit_signal = (clone_flags \u0026 CSIGNAL); // 新进程的成员exit_signal是调用者指定的信号 p-\u003egroup_leader = p; p-\u003etgid = p-\u003epid; } // 控制组的进程数控制器检查是否允许创建新进程： // 从当前进程所属的控制组一直到控制组层级的根， // 如果其中一个控制组的进程数量大于或等于限制， // 那么不允许使用fork和clone创建新进程 cgroup_threadgroup_change_begin(current); retval = cgroup_can_fork(p); if (retval) goto bad_fork_free_pid; write_lock_irq(\u0026tasklist_lock); // 为新进程设置父进程 if (clone_flags \u0026 (CLONE_PARENT|CLONE_THREAD)) { // 新进程和当前进程拥有相同的父进程 p-\u003ereal_parent = current-\u003ereal_parent; p-\u003eparent_exec_id = current-\u003eparent_exec_id; } else { p-\u003ereal_parent = current; // 新进程的父进程是当前进程 p-\u003eparent_exec_id = current-\u003eself_exec_id; } … spin_lock(\u0026current-\u003esighand-\u003esiglock); … if (likely(p-\u003epid)) { … init_task_pid(p, PIDTYPE_PID, pid); if (thread_group_leader(p)) { // true 新进程和当前进程属于同一个进程组 init_task_pid(p, PIDTYPE_PGID, task_pgrp(current)); // 指向同一个进程组的组长的进程号结构体 init_task_pid(p, PIDTYPE_SID, task_session(current)); // 指向同一个会话的控制进程的进程号结构体 if (is_child_reaper(pid)) { ns_of_pid(pid)-\u003echild_reaper = p; p-\u003esignal-\u003eflags |= SIGNAL_UNKILLABLE; // 1号进程是不能杀死的 } p-\u003esignal-\u003eleader_pid = pid; p-\u003esignal-\u003etty = tty_kref_get(current-\u003esignal-\u003etty); p-\u003esignal-\u003ehas_child_subreaper = p-\u003ereal_parent-\u003esignal-\u003e has_child_subreaper || p-\u003ereal_parent-\u003esignal-\u003eis_child_subreaper; list_add_tail(\u0026p-\u003esibling, \u0026p-\u003ereal_parent-\u003echildren); // 新进程添加到父进程的子进程链表 // 新进程添加到进程链表中，链表节点是成员tasks， // 头节点是空闲线程的成员tasks（init_task.tasks） list_add_tail_rcu(\u0026p-\u003etasks, \u0026init_task.tasks); attach_pid(p, PIDTYPE_PGID); // 新进程添加到进程组的进程链表 attach_pid(p, PIDTYPE_SID); // 新进程添加到会话的进程链表 __this_cpu_inc(process_counts); } else { // 创建线程 current-\u003esignal-\u003enr_threads++; // 线程组的线程计数值加1 atomic_inc(\u0026current-\u003esignal-\u003elive); // 原子变量线程组的第2个线程计数值加1 atomic_inc(\u0026current-\u003esignal-\u003esigcnt); // 信号结构体的引用计数加1 list_add_tail_rcu(\u0026p-\u003ethread_group, \u0026p-\u003egroup_leader-\u003ethread_group); // 线程加入线程组的线程链表 list_add_tail_rcu(\u0026p-\u003ethread_node, \u0026p-\u003esignal-\u003ethread_head); // 线程加入线程组的第二条线程链表 } attach_pid(p, PIDTYPE_PID); // 新进程添加到进程号结构体的进程链表 nr_threads++; // 新进程添加到进程号结构体的进程链表 } total_forks++; spin_unlock(\u0026current-\u003esighand-\u003esiglock); … write_unlock_irq(\u0026tasklist_lock); proc_fork_connector(p); cgroup_post_fork(p); cgroup_threadgroup_change_end(current); … return p; } 3.唤醒新进程 wake_up_new_task函数唤醒新进程\n// linux-5.10.102/kernel/sched/core.c void wake_up_new_task(struct task_struct *p) { struct rq_flags rf; struct rq *rq; raw_spin_lock_irqsave(\u0026p-\u003epi_lock, rf.flags); p-\u003estate = TASK_RUNNING; // 切换TASK_RUNNING #ifdef CONFIG_SMP /* Fork balancing, do it here and not earlier because: * - cpus_ptr can change in the fork path * - any previously selected CPU might disappear through hotplug * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq, * as we're not fully set-up yet.*/ p-\u003erecent_used_cpu = task_cpu(p); rseq_migrate(p); __set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); // 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器 #endif rq = __task_rq_lock(p, \u0026rf); // 锁住运行队列 update_rq_clock(rq); // 更新运行队列的时钟 post_init_entity_util_avg(p); // 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值 activate_task(rq, p, ENQUEUE_NOCLOCK); // 把新进程插入运行队列 trace_sched_wakeup_new(p); check_preempt_curr(rq, p, WF_FORK); // 检查新进程是否可以抢占当前进程 #ifdef CONFIG_SMP if (p-\u003esched_class-\u003etask_woken) { // 在SMP系统上，调用调度类的task_woken方法 /* Nothing relies on rq-\u003elock after this, so its fine to * drop it.*/ rq_unpin_lock(rq, \u0026rf); p-\u003esched_class-\u003etask_woken(rq, p); rq_repin_lock(rq, \u0026rf); } #endif task_rq_unlock(rq, p, \u0026rf); // 释放运行队列的锁 } 4.新进程第一次运行 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数\n// linux-5.10.102/arch/arm64/kernel/entry.S tsk .req x28 //当前进程的thread_info结构体的地址 SYM_CODE_START(ret_from_fork) bl\tschedule_tail // 为上一个进程执行清理操作 cbz\tx19, 1f // not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1 mov\tx0, x20 // 内核线程：x19存放线程函数的地址，x20存放线程函数的参数 blr\tx19 // 调用线程函数 1:\tget_current_task tsk // 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址 b\tret_to_user // 返回用户模式 SYM_CODE_END(ret_from_fork) NOKPROBE(ret_from_fork) copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0 // linux-5.10.102/kernel/sched/core.c asmlinkage __visible void schedule_tail(struct task_struct *prev) __releases(rq-\u003elock) { struct rq *rq; /* New tasks start with FORK_PREEMPT_COUNT, see there and * finish_task_switch() for details. * * finish_task_switch() will drop rq-\u003elock() and lower preempt_count * and the preempt_enable() will end up enabling preemption (on * PREEMPT_COUNT kernels).*/ rq = finish_task_switch(prev); // 为上一个进程执行清理操作2.8.6 balance_callback(rq); // 执行运行队列的所有负载均衡回调函数 preempt_enable(); // 开启内核抢占 if (current-\u003eset_child_tid) // pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置 put_user(task_pid_vnr(current), current-\u003eset_child_tid); calculate_sigpending(); } 2.5.2 装载程序 调度器调度新进程，新进程从函数ret_from_fork开始，从系统调用fork返回用户空间，返回值0。然后新进程使用系统调用execve装载程序。Linux内核练个装载程序系统调用： \\\n// 路径名是相对时execve解释为相对调用进程的当前工作目录 int execve(const char *filename, char *const argv[], char *const envp[]); // 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录 // 路径名时绝对的，execveat忽略参数dirfd int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); 参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值\n两个系统调用最终都调用函数do_execveat_common 函数do_open_execat打开可执行文件。 函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器 函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-\u003ep指向在栈底保留一个字长（指针长度）后的位置 函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？ \\ 依次把文件名称、环境字符串和参数字符串压到用户栈 函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止\n1.二进制格式 Linux二进制格式\n// linux-5.10.102/include/linux/binfmts.h struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump;\t/* minimal dump size */ } __randomize_layout; 二进制格式提供3个函数 (1)load_binary 加载普通程序 (2)load_shlib 加载共享库 (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度 二进制格式使用register_binfmt向内核注册\n2.装载ELF程序 ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 linux-5.10.102/include/uapi/linux/elf.h\n目标文件(可重定位文件)，.o，多个模板文件链接生成可执行文件或共享库 可执行文件 共享库 .so 核心转储文件(core dump file) ELF文件分成4部分：ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)，ELF只有首部的位置是固定的。\n程序首部表就是段表(segment table)，段(segment)是从运行角度描述，节(section)是从链接角度描述。 64位ELF文件格式\n参考链接： ELF 格式详解 https://blog.csdn.net/shanandqiu/article/details/115206426 ELF文件格式简介 https://blog.csdn.net/GrayOnDream/article/details/124564129\n# 查看ELF首部 readelf -h # 查看程序首部表 readelf -l # 查看节首部表 readelf -S ELF解析程序 linux-5.10.102/fs/binfmt_elf.c 解析64位ELF程序，和处理器架构无关 linux-5.10.102/fs/compat_binfmt_elf.c 在64位内核中解析32位ELF程序，和处理器架构无 \\\n装载ELF程序函数load_elf_binary\n1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构 2）读取程序首部表 3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。 4）检查解释器的ELF首部，读取解释器的程序首部表 5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间 6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域 7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈 8）把可加载段映射到进程的虚拟地址空间 9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段 10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口 11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈 12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread\n// linux-5.10.102/arch/arm64/include/asm/processor.h static inline void start_thread_common(struct pt_regs *regs, unsigned long pc) { memset(regs, 0, sizeof(*regs)); forget_syscall(regs); regs-\u003epc = pc; /* 把程序计数器设置为程序的入口 */ } static inline void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp) { start_thread_common(regs, pc); regs-\u003epstate = PSR_MODE_EL0t; /* 把处理器状态设置为0，其中异常级别是0 */ spectre_v4_enable_task_mitigation(current); regs-\u003esp = sp; /*设置用户栈指针 */ } 3.装载脚本程序 脚本程序前两个字节是#!，后面是解释器程序的名称和参数。解释器用来执行脚本程序 linux-5.10.102/fs/binfmt_script.c函数load_script负责装载脚本程序\n1）检查前两个字节是不是脚本程序的标识符 2）解析处解释程序的名称和参数 3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈 4）调用opens_exec打开解释程序文件 5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区 6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止 \\\n2.6 进程退出 进程退出两种情况：进程主动退出和终止进程 Linux内核两个主动退出的系统调用 \\\n// 线程退出 void exit(int status); // 一个线程组所有线程退出 void exit_group(int status); glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数 终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用\n// // 发送信号给进程或进程组 int kill(pid_t pid, int sig); // 发送信号给线程 已废弃 int tkill(int tid, int sig); // 发送信号给线程 int tgkill(int tgid, int tid, int sig); 父进程是否关注子进程退出事假， 1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。进程默认关注子进程退出事件，通过系统调用sigaction对信号SIGHLD设置标志SA_NOCLDWAIT(CLD是child)，子进程退出时不变成僵尸进程或设置忽略信号SIGCHLD 2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 Linux内核3个系统调用等待子进程状态改变：子进程终止、信号SIGSTOP使子进程停止执行或信号SIGCONT使子进程继续执行\npid_t waitpid(pid_t pid, int *wstatus, int options); int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); pit_t wiat4(pit_t pid, int *wstatus, int options, staruct usage *rusage); // 废弃 父进程退出时，给子进程寻找领养者 1）进程属于一个线程组，且还有其他线程，选择任意其他线程 2）选择最亲近的充当\"替补领养者\"的祖先进程，进程使用系统调用prtctl(PR_SET_CHILD_SUBREAPER)设置为替换领养者 3）选择所属进程号命名空间的1号进程 2.6.1 线程组退出 exit_group 系统调用exit_group执行流程\n一个线程组的两个线程，线程1和线程2，线程1调用exit_group使线程组退出，线程1执行流程： 1）把退出码保存在结构体成员group_exit_code中，传递给线程2 2）给线程组设置正在退出标志 3）向线程2发送杀死信号，唤醒线程2，线程2处理杀死信号 4）线程1调用函数do_exit以退出 线程2退出的执行流程，函数do_group_exit执行流程\n线程2可能发挥用户模式3种情况 （1）执行完系统调用 （2）被中断抢占，中断处理程序执行完 （3）执行指令是生成异常，异常处理程序执行完 \\\ndo_exit函数执行流程 （1）释放各种资源，把资源引用计数减一，如果引用计数变为0，则释放数据结构 （2）调用函数exit_notify，为子进程选择领养者，然后把自己死讯通知父进程 （3）把进程状态设置为死亡(TASK_DEAD) （4）最后一次调用函数__schedule以调度进程 死亡进程调用__schedule时进程调度器处理流程\n// linux-5.10.102/kernel/sched/core.c __schedule() --\u003e context_switch() --\u003e finish_task_switch() static struct rq *finish_task_switch(struct task_struct *prev) __releases(rq-\u003elock) { … prev_state = prev-\u003estate; … if (unlikely(prev_state == TASK_DEAD)) { if (prev-\u003esched_class-\u003etask_dead) prev-\u003esched_class-\u003etask_dead(prev); // 执行调度类task_dead … // 如果结构体thread_info放在进程描述符里面， // 而不是放在内核栈的顶部，那么释放进程的内核栈 put_task_stack(prev); // 进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符 put_task_struct(prev); } … } 2.6.2 终止进程 系统调用kill向线程组或进程组发送信号linux-5.10.102/kernel/signal.c，执行流程 函数__send_signal主要代码\n// linux-5.10.102/kernel/signal.c static int __send_signal(int sig, struct siginfo *info, struct task_struct *t, int group, int from_ancestor_ns) { struct sigpending *pending; struct sigqueue *q; int override_rlimit; int ret = 0, result; … result = TRACE_SIGNAL_IGNORED; // 目标线程忽略信号,不发送信号 if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED))) goto ret; // 确定把信号添加到哪个信号队列和集合 pending = group ? \u0026t-\u003esignal-\u003eshared_pending : \u0026t-\u003epending; result = TRACE_SIGNAL_ALREADY_PENDING; // 传统信号，并且信号集合已经包含同一个信号,不发送 if (legacy_queue(pending, sig)) goto ret; … // 判断分配信号队列节点时是否可以忽略信号队列长度的限制 if (sig \u003c SIGRTMIN) override_rlimit = (is_si_special(info) || info-\u003esi_code \u003e= 0); else override_rlimit = 0; // 分配一个信号队列节点 q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit); if (q) { list_add_tail(\u0026q-\u003elist, \u0026pending-\u003elist); // 添加到信号队列中 … } else if (!is_si_special(info)) { … } out_set: signalfd_notify(t, sig); sigaddset(\u0026pending-\u003esignal, sig); // 信号添加到信号集合中 // 在线程组中查找一个没有屏蔽信号的线程，唤醒它，让它处理信号 complete_signal(sig, t, group); ret: … return ret; } 2.6.3 查询子进程终止原因 系统调用waitid\nint waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); pid_t waitpid(pid_t pid, int *wstatus, int options); 参数 参数值 含义 idtype P_ALL 等待任意子进程，忽略参数id P_PID 等待进程号为id的子进程 P_PGID 等待进程组标识符是id的任意子进程 options WEXITED 等待退出的子进程 WSTOPPED 等待收到信号SIGSTOP并停止执行的子进程 WCONTINUED 等待收到信号SIGCONT并继续执行的子进程 WNOHANG 如果没有子进程退出，立即返回 WNOWAIT 让子进程处于僵尸状态，以后可以再次查询状态信息 do_wait函数执行流程\n2.7 进程状态 状态 state 含义 就绪状态 TASK_RUNNING 正在运行队列中等待调度器调度 运行状态 TASK_RUNNING 被调度器选中，正在处理器上运行 轻度睡眠 TASK_INTERRUPTIBLE 可信号打断的睡眠状态 中度睡眠 TASK_KILLABLE 只能被致命的信号打断 深度睡眠 TASK_UNINTERRUPTIBLE 不可打断的睡眠状态 僵尸状态 TASK_DEAD 被调度器选中，正在处理器上运行 死亡状态 TASK_DEAD 如果父进程不关注子进程退出事件，那么子进程退出时自动消亡 进程状态变迁 2.8 进程调度 2.8.1 调度策略 Linux内核支持的调度策略 （1）限制进程使用限期调度策略(SCHED_DEADLINE)，3个参数：运行时间runtime，截止期限deadline和周期period （2）实时进程支持两种调度策略：先进先出调度(SCHED_FIFO)和轮流调度(SCHED_RR) （3）普通进程两种调度策略：标准轮流分时(SCHED_NORMAL)和空闲(SCHED_BATCH)，Linux内核引入完全公平调度算法后，批量调度策略废弃。 \\\n2.8.2 进程优先级 限期进程的优先级比实时进程高，实时进程的优先级比普通进程高。 限期进程的优先级是−1。 实时进程的实时优先级是1～99，优先级数值越大，表示优先级越高。 普通进程的静态优先级是100～139，优先级数值越小，表示优先级越高，可通过修改nice值（即相对优先级，取值范围是−20～19）改变普通进程的优先级，优先级等于120加上nice值 task_struct中，4个成员和优先级有关 \\\ninclude/linux/sched.h struct task_struct { … int prio; int static_prio; int normal_prio; unsigned int rt_priority; … }; 优先级 限期进程 实时进程 普通进程 prio\n调度优先级(数值越小，表示优先级越高) 大多数prio等于normal_prio static_prio\n静态优先级 总是0 总是0 120 + nice值数值越小，\n表示优先级越高 normal_prio\n正常优先级(数值越小，表示优先级越高) -1 99 − rt_priority static_prio 实时优先级 总是0 值越大，优先级越高 2.8.3 调度类 Linux内核抽象一个调度类sched_class，目前实现5种调度类，优先级从上到下从高到低：\n调度类 调度策略 调度算法 调度对象 停机调度类\nstop_sched_class 无 无 停机进程 限期调度类\ndl_sched_class SCHED_DEADLINE 最早期限优先 限期进程 实时调度类\nrt_sched_class SCHED_FIFO\nSCHED_RR 先进先出\n轮流调度 实时进程 公平调度类\ncfs_sched_class SCHED_NORMAL\nSCHED_IDIE 完全公平调度算法 普通进程 空闲调度类\nidle_sched_class 无 无 每个处理器上的空闲线程 详细信息参考书籍\n2.8.4 运行队列 每个处理器有一个运行队列，结构体rq，定义全局变量\n// linux-5.10.102/kernel/sched/cpuacct.c DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); // linux-5.10.102/kernel/sched/sched.h struct rq { // 运行队列 ... struct cfs_rq\tcfs; // 公平运行队列 struct rt_rq\trt; // 实时运行队列 struct dl_rq\tdl; // 限期运行队列 ... struct task_struct\t*idle; // 空闲线程 struct task_struct\t*stop; // 迁移线程 }; 2.8.5 任务分组 1.任务分组方式 任务分组方式 控制宏 配置方式 自动组 CONFIG_SCHED_AUTOGROUP /proc/sys/kernel/sched_autogroup_enabled 运行过程中开启关闭，默认值1\n源文件kernel/sched/auto_group.c CPU控制组版本1 CONFIG_CGROUPS\nCONFIG_CGROUP_SCHED mount -t tmpfs cgroup_root /sys/fs/cgroup\nmkdir /sys/fs/cgroup/cpu\nmount -t cgroup -o cpu none /sys/fs/cgroup/cpu\ncd /sys/fs/cgroup/cpu\nmkdir multimedia # 创建\"multimedia\"任务组\nmkdir browser # 创建\"browser\"任务组\necho 2048 \u003e multimedia/cpu.shares\necho 1024 \u003e browser/cpu.shares\necho \u003c pid1\u003e \u003e browser/tasks echo \u003c pid2\u003e \u003e multimedia/tasks\necho \u003c pid1\u003e \u003e browser/cgroup.procs\necho \u003c pid2\u003e \u003e multimedia/cgroup.procs cgroup版本2 mount -t tmpfs cgroup_root /sys/fs/cgroup\nmount -t cgroup2 none /sys/fs/cgroup\ncd /sys/fs/cgroup echo \"+cpu\" \u003e cgroup.subtree_control\nmkdir multimedia # 创建\"multimedia\"任务组 mkdir browser # 创建\"browser\"任务组\necho 2048 \u003e multimedia/cpu.weight\necho 1024 \u003e browser/cpu.weight\necho \u003c pid1\u003e \u003e browser/cgroup.procs\necho \u003c pid2\u003e \u003e multimedia/cgroup.procs echo threaded \u003e browser/cgroup.type echo \u003c pid1\u003e \u003e browser/cgroup.threads echo threaded \u003e multimedia/cgroup.type echo \u003c pid2\u003e \u003e multimedia/cgroup.threads 2. 数据结构 task_group,默认任务组是更任务组(全局变量root_task_group)\n成员 说明 const struct sched_class *sched_class 调度类 struct sched_entity se 公平调度实体 struct sched_dl_entity dl 限期调度实体 任务组在每个处理器上有公平调度实体、公平运行队列、实时调度实体和实时运行队列，根任务组比较特殊：没有公平调度实体和实时调度实体\n每个处理器上，计算任务组的公平调度实体的权重的方法如下（参考源文件“kernel/ sched/fair.c”中的函数update_cfs_shares\n2.8.6 调度进程 调度进程的核心函数是__schedule()\nkernel/sched/core.c // preempt是否抢占，true抢占调度，false主动调度 static void __sched notrace __schedule(bool preempt) { 1. 调用pick_next_task选择下一个进程 2. 调用context_switch切换进程 } 1.选择下一个进程 函数pick_next_task // linux-5.10.102/kernel/sched/core.c static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) { const struct sched_class *class; struct task_struct *p; /* Optimization: we know that if all tasks are in the fair class we can * call that function directly, but only if the @prev task wasn't of a * higher scheduling class, because otherwise those loose the * opportunity to pull in more work from other CPUs.*/ // 优化：如果所有进程属于公平调度类 // 直接调用公平调度类的pick_next_task方法 if (likely(prev-\u003esched_class \u003c= \u0026fair_sched_class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = pick_next_task_fair(rq, prev, rf); if (unlikely(p == RETRY_TASK)) goto restart; /* Assumes fair_sched_class-\u003enext == idle_sched_class */ // 假定公平调度类的下一个调度类是空闲调度类 if (!p) { put_prev_task(rq, prev); p = pick_next_task_idle(rq); } return p; } restart: put_prev_task_balance(rq, prev, rf); for_each_class(class) { p = class-\u003epick_next_task(rq); if (p) return p; } /* The idle class should always have a runnable task: */ // 空闲调度类应该总是有一个运行的进程 BUG(); } 待补充\n2.切换进程 context_switch 1）switch_mm_irqs_off负责切换进程的用户虚拟地址空间 2）switch_to切换处理器的寄存器\n// linux-5.10.102/kernel/sched/core.c static __always_inline struct rq * context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next, struct rq_flags *rf) { prepare_task_switch(rq, prev, next); // 准备工作，调用prepare_arch_switch /* For paravirt, this is coupled with an exit in switch_to to * combine the page table reload and the switch backend into * one hypercall. */ // 开始上下文切换 arch_start_context_switch(prev); /* * kernel -\u003e kernel lazy + transfer active * user -\u003e kernel lazy + mmgrab() active * * kernel -\u003e user switch + mmdrop() active * user -\u003e user switch */ if (!next-\u003emm) { // to kernel // 通知处理器架构不需要切换用户虚拟地址空间，加速进程切换的技术称为惰性TLB enter_lazy_tlb(prev-\u003eactive_mm, next); next-\u003eactive_mm = prev-\u003eactive_mm; if (prev-\u003emm) // from user 切换进程的用户虚拟地址空间 mmgrab(prev-\u003eactive_mm); else prev-\u003eactive_mm = NULL; } else { // to user membarrier_switch_mm(rq, prev-\u003eactive_mm, next-\u003emm); /* * sys_membarrier() requires an smp_mb() between setting * rq-\u003ecurr / membarrier_switch_mm() and returning to userspace. * * The below provides this either through switch_mm(), or in * case 'prev-\u003eactive_mm == next-\u003emm' through * finish_task_switch()'s mmdrop(). */ switch_mm_irqs_off(prev-\u003eactive_mm, next-\u003emm, next); if (!prev-\u003emm) { // from kernel /* will mmdrop() in finish_task_switch(). */ rq-\u003eprev_mm = prev-\u003eactive_mm; prev-\u003eactive_mm = NULL; } } rq-\u003eclock_update_flags \u0026= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); prepare_lock_switch(rq, next, rf); /* Here we just switch the register state and the stack. */ // 只切换寄存器状态和栈 switch_to(prev, next, prev); barrier(); return finish_task_switch(prev); } （1）切换用户虚拟地址空间。\n// ARM64架构使用switch_mm_irqs_off include/linux/mmu_context.h #ifndef switch_mm_irqs_off #define switch_mm_irqs_off switch_mm #endif switch_mm函数\n// linux-5.10.102/arch/arm64/include/asm/mmu_context.h static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { if (prev != next) __switch_mm(next); /* Update the saved TTBR0_EL1 of the scheduled-in task as the previous * value may have not been initialised yet (activate_mm caller) or the * ASID has changed since the last run (following the context switch * of another thread of the same process).*/ /* 更新调入进程保存的寄存器TTBR0_EL1值， * 因为可能还没有初始化（调用者是函数activate_mm）， * 或者ASID自从上次运行以来已经改变（在同一个线程组的另一个线程切换上下文以后） * 避免把保留的寄存器TTBR0_EL1值设置为swapper_pg_dir（init_mm；例如通过函数idle_task_exit）*/ update_saved_ttbr0(tsk, next); } static inline void __switch_mm(struct mm_struct *next) { /*init_mm.pgd does not contain any user mappings and it is always * active for kernel addresses in TTBR1. Just set the reserved TTBR0.*/ /*init_mm.pgd没有包含任何用户虚拟地址的映射，对于TTBR1的内核虚拟地址总是有效的。 * 只设置保留的TTBR0 */ if (next == \u0026init_mm) { cpu_set_reserved_ttbr0(); return; } // 为进程分配地址空间标识符 check_and_switch_context(next); } 待补充\n（2）切换寄存器\n// linux-5.10.102/include/asm-generic/switch_to.h #define switch_to(prev, next, last)\t\\ do {\t\\ ((last) = __switch_to((prev), (next)));\t\\ } while (0) 函数__switch_to\n__notrace_funcgraph struct task_struct *__switch_to(struct task_struct *prev, struct task_struct *next) { struct task_struct *last; fpsimd_thread_switch(next); // 切换浮点寄存器 tls_thread_switch(next); // 切换本地存储相关的寄存器 hw_breakpoint_thread_switch(next); // 切换吊事寄存器 contextidr_thread_switch(next); // 把上下文标识符寄存器CONTEXTIDR_EL1设置为下一个进程号 entry_task_switch(next); // 使用处理器变量__entry_task记录下一个进程描述符的地址 uao_thread_switch(next); // 根据下一个进程可访问的虚拟地址空间上限恢复用户访问覆盖（User Access Override，UAO）状态 ssbs_thread_switch(next); // erratum_1418040_thread_switch(next); /* Complete any pending TLB or cache maintenance on this CPU in case * the thread migrates to a different CPU. * This full barrier is also required by the membarrier system * call.*/ // 在这个处理器上执行完前面的所有页表缓存或者缓存维护操作 // 以防线程迁移到其他处理器 // 数据同步屏障，确保屏障前面的缓存维护操作和页表缓存维护操作执行完 dsb(ish); /* MTE thread switching must happen after the DSB above to ensure that * any asynchronous tag check faults have been logged in the TFSR*_EL1 * registers.*/ mte_thread_switch(next); /* the actual thread switch */ // 实际线程切换 切换通用寄存器 last = cpu_switch_to(prev, next); return last; } 1）切换浮点寄存器，函数fpsimd_thread_switch负责切换浮点，内核不允许使用浮点数，只有用户空间可以使用浮点数,切换出去的进程把浮点寄存器的值保存在进程描述符的成员thread.fpsimd_state中。ARM64架构实现的linux-5.10.102/arch/arm64/kernel/fpsimd.c函数fpsimd_thread_switch \\ 2）切换通用寄存器，\n被调用函数负责保存的寄存器x19～x28 寄存器x29，即帧指针（Frame Pointer，FP）寄存器 栈指针（Stack Pointer，SP）寄存器 寄存器x30，即链接寄存器（Link Register，LR），它存放函数的返回地址 用户栈指针寄存器SP_EL0，内核使用它存放当前进程的进程描述符的第一个成员thread_info的地址 cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址\n// linux-5.10.102/arch/arm64/kernel/entry.S SYM_FUNC_START(cpu_switch_to) mov\tx10, #THREAD_CPU_CONTEXT // cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址 add\tx8, x0, x10 // x8存放上一个进程的进程描述符的成员thread.cpu_context的地址 mov\tx9, sp // x9保存栈指针 stp\tx19, x20, [x8], #16\t// store callee-saved registers stp\tx21, x22, [x8], #16 // 把上一个进程的寄存器x19～x28、x29、SP和LR stp\tx23, x24, [x8], #16 // 保存到上一个进程的进程描述符的成员thread.cpu_context中 stp\tx25, x26, [x8], #16 // stp\tx27, x28, [x8], #16 stp\tx29, x9, [x8], #16 str\tlr, [x8] // LR存放函数的返回地址 add\tx8, x1, x10 // x8存放下一个进程的进程描述符的成员thread.cpu_context的地址 ldp\tx19, x20, [x8], #16\t// restore callee-saved registers ldp\tx21, x22, [x8], #16 // 使用下一个进程的进程描述符的成员thread.cpu_context ldp\tx23, x24, [x8], #16 // 保存的值恢复下一个进程的寄存器x19～x28、x29、SP和LR ldp\tx25, x26, [x8], #16 ldp\tx27, x28, [x8], #16 ldp\tx29, x9, [x8], #16 ldr\tlr, [x8] mov\tsp, x9 msr\tsp_el0, x1 // 用户栈指针寄存器SP_EL0设置为下一个进程的进程描述符的第一个成员thread_info的地址 ptrauth_keys_install_kernel x1, x8, x9, x10 scs_save x0, x8 // 函数返回，返回值是寄存器x0的值：上一个进程的进程描述符的地址 scs_load x1, x8 ret SYM_FUNC_END(cpu_switch_to) NOKPROBE(cpu_switch_to) cpu_switch_to切换通用寄存器的过程，从进程prev切换到进程next。进程prev把通用寄存器的值保存在进程描述符的成员thread.cpu_context中，然后进程next从进程描述符的成员thread.cpu_context恢复通用寄存器的值，使用用户栈指针寄存器SP_EL0存放进程next的进程描述符的成员thread_info的地址 \\\nARM64架构切换通用寄存器 链接寄存器存放函数的返回地址，函数cpu_switch_to把链接寄存器设置为进程描述符的成员thread.cpu_context.pc，进程被调度后从返回地址开始执行 进程的返回地址分为以下两种情况:\n创建的新进程，函数copy_thread把进程描述符的成员thread.cpu_context.pc设置为函数ret_from_fork的地址 其他情况，返回地址是函数context_switch中调用函数cpu_switch_to之后的一行代码：“last = 函数cpu_switch_to的返回值”，返回地址记录在进程描述符的成员thread.cpu_context.pc中 （3）清理工作 函数finish_task_switch在从进程prev切换到进程next后为进程prev执行清理工作\n// kernel/sched/core.c static struct rq *finish_task_switch(struct task_struct *prev) __releases(rq-\u003elock) { struct rq *rq = this_rq(); // rq是当前处理器的运行队列 struct mm_struct *mm = rq-\u003eprev_mm; long prev_state; /* The previous task will have left us with a preempt_count of 2 * because it left us after: *\tschedule() *\tpreempt_disable();\t// 1 *\t__schedule() *\traw_spin_lock_irq(\u0026rq-\u003elock)\t// 2 * Also, see FORK_PREEMPT_COUNT.*/ if (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET, \"corrupted preempt_count: %s/%d/0x%x\\n\", current-\u003ecomm, current-\u003epid, preempt_count())) preempt_count_set(FORK_PREEMPT_COUNT); rq-\u003eprev_mm = NULL; /* A task struct has one reference for the use as \"current\". * If a task dies, then it sets TASK_DEAD in tsk-\u003estate and calls * schedule one last time. The schedule call will never return, and * the scheduled task must drop that reference. * * We must observe prev-\u003estate before clearing prev-\u003eon_cpu (in * finish_task), otherwise a concurrent wakeup can get prev * running on another CPU and we could rave with its RUNNING -\u003e DEAD * transition, resulting in a double drop.*/ prev_state = prev-\u003estate; vtime_task_switch(prev); // 计算进程prev的时间统计 perf_event_task_sched_in(prev, current); finish_task(prev); // 把prev-\u003eon_cpu设置为0，表示进程prev没有在处理器上运行；然后释放运行队列的锁，开启硬中断 finish_lock_switch(rq); finish_arch_post_lock_switch(); // 执行处理器架构特定的清理工作,ARM64为空 kcov_finish_switch(current); fire_sched_in_preempt_notifiers(current); /* When switching through a kernel thread, the loop in * membarrier_{private,global}_expedited() may have observed that * kernel thread and not issued an IPI. It is therefore possible to * schedule between user-\u003ekernel-\u003euser threads without passing though * switch_mm(). Membarrier requires a barrier after storing to * rq-\u003ecurr, before returning to userspace, so provide them here: * * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly * provided by mmdrop(), * - a sync_core for SYNC_CORE.*/ if (mm) { membarrier_mm_sync_core_before_usermode(mm); mmdrop(mm); } if (unlikely(prev_state == TASK_DEAD)) { // 进程主动退出或者被终止 if (prev-\u003esched_class-\u003etask_dead) prev-\u003esched_class-\u003etask_dead(prev); // 所属调度类的task_dead方法 /* * Remove function-return probe instances associated with this * task and put them back on the free list.*/ kprobe_flush_task(prev); /* Task is done with its stack. */ /*释放进程的内核栈 */ put_task_stack(prev); // 把进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符 put_task_struct_rcu_user(prev); } tick_nohz_task_switch(); return rq; } 2.8.7 调度时机 调度进程的时机: （1）进程主动调用schedule()函数 （2）周期性地调度，抢占当前进程，强迫当前进程让出处理器 （3）唤醒进程的时候，被唤醒的进程可能抢占当前进程 （4）创建新进程的时候，新进程可能抢占当前进程。\n1.主动调度 内核中3种主动调度方式： （1）直接调用schedule()函数来调度进程 （2）调用有条件重调度函数cond_resched()。非抢占式内核中，函数cond_resched()判断当前进程是否设置了需要重新调度的标志，如果设置了，就调度进程；抢占式内核中，cond_resched()为空 （3）如果需要等待某个资源，例如互斥锁或信号量，那么把进程的状态设置为睡眠状态，然后调用schedule()函数以调度进程\n2.周期调度 周期调度的函数是scheduler_tick()，它调用当前进程所属调度类的task_tick方法。 （1）限期调度类的周期调度 task_tick –\u003e task_tick_dl –\u003e update_curr_dl\n// kernel/sched/deadline.c static void update_curr_dl(struct rq *rq) { struct task_struct *curr = rq-\u003ecurr; struct sched_dl_entity *dl_se = \u0026curr-\u003edl; u64 delta_exec, scaled_delta_exec; ... delta_exec = now - curr-\u003ese.exec_start; if (unlikely((s64)delta_exec \u003c= 0)) { if (unlikely(dl_se-\u003edl_yielded)) goto throttle; return; } ... dl_se-\u003eruntime -= scaled_delta_exec; // 计算限期进程的剩余运行时间 throttle: // // 如果限期进程用完了运行时间或者主动让出处理器 if (dl_runtime_exceeded(dl_se) || dl_se-\u003edl_yielded) { dl_se-\u003edl_throttled = 1; // 设置节流标志 /* If requested, inform the user about runtime overruns. */ if (dl_runtime_exceeded(dl_se) \u0026\u0026 (dl_se-\u003eflags \u0026 SCHED_FLAG_DL_OVERRUN)) dl_se-\u003edl_overrun = 1; __dequeue_task_dl(rq, curr, 0); if (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr))) enqueue_task_dl(rq, curr, ENQUEUE_REPLENISH); if (!is_leftmost(curr, \u0026rq-\u003edl)) resched_curr(rq); } ... } （2）实时调度类的周期调度 \\\n实时调度类的task_tick方法是函数task_tick_rt\n// linux-5.10.102/kernel/sched/rt.c static void task_tick_rt(struct rq *rq, struct task_struct *p, int queued) { struct sched_rt_entity *rt_se = \u0026p-\u003ert; ... if (p-\u003epolicy != SCHED_RR) // 调度策略不是轮流调度 return; // 把时间片减一，如果没用完时间片，那么返回 if (--p-\u003ert.time_slice) return; // 用完了时间片，那么重新分配时间片 p-\u003ert.time_slice = sched_rr_timeslice; /* Requeue to the end of queue if we (and all of our ancestors) are not * the only element on the queue */ for_each_sched_rt_entity(rt_se) { if (rt_se-\u003erun_list.prev != rt_se-\u003erun_list.next) { requeue_task_rt(rq, p, 0); resched_curr(rq); return; } } } （3）公平调度类的周期调度 公平调度类的task_tick方法是函数task_tick_fair\n// kernel/sched/fair.c static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026curr-\u003ese; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); entity_tick(cfs_rq, se, queued); } ... } // kernel/sched/fair.c static void entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued) { ... if (cfs_rq-\u003enr_running \u003e 1) // 公平运行队列的进程数量超过1 check_preempt_tick(cfs_rq, curr); } // kernel/sched/fair.c static void check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr) { unsigned long ideal_runtime, delta_exec; struct sched_entity *se; s64 delta; ideal_runtime = sched_slice(cfs_rq, curr); delta_exec = curr-\u003esum_exec_runtime - curr-\u003eprev_sum_exec_runtime; if (delta_exec \u003e ideal_runtime) { resched_curr(rq_of(cfs_rq)); /* The current task ran long enough, ensure it doesn't get * re-elected due to buddy favours.*/ clear_buddies(cfs_rq, curr); return; } /* Ensure that a task that missed wakeup preemption by a * narrow margin doesn't have to wait for a full slice. * This also mitigates buddy induced latencies under load.*/ if (delta_exec \u003c sysctl_sched_min_granularity) return; se = __pick_first_entity(cfs_rq); delta = curr-\u003evruntime - se-\u003evruntime; if (delta \u003c 0) return; if (delta \u003e ideal_runtime) resched_curr(rq_of(cfs_rq)); } （4）中断返回时调度。 ARM64架构的中断处理程序的入口是e10_irq，中断处理程序执行完以后，跳转到标号ret_to_user以返回用户模式。标号ret_to_user判断当前进程的进程描述符的成员thread_info.flags有没有设置标志位集合_TIF_WORK_MASK中的任何一个标志位，如果设置了其中一个标志位，那么跳转到标号work_pending，标号work_pending调用函数do_notify_resume\n// arch/arm64/kernel/entry.S 5.10.102 代码中没有？ ret_to_user: disable_irq // 禁止中断 ldr x1, [tsk, #TSK_TI_FLAGS] and x2, x1, #_TIF_WORK_MASK cbnz x2, work_pending finish_ret_to_user: enable_step_tsk x1, x2 kernel_exit 0 ENDPROC(ret_to_user) work_pending: mov x0, sp /* * 寄存器x0存放第一个参数regs * 寄存器x1存放第二个参数task_struct.thread_info.flags */ bl do_notify_resume #ifdef CONFIG_TRACE_IRQFLAGS bl trace_hardirqs_on // 在用户空间执行时开启中断 #endif ldr x1, [tsk, #TSK_TI_FLAGS] // 重新检查单步执行 b finish_ret_to_user 函数do_notify_resume判断当前进程的进程描述符的成员thread_info.flags有没有设置需要重新调度的标志位_TIF_NEED_RESCHED，如果设置了，那么调用函数schedule()以调度进程。\n// arch/arm64/kernel/signal.c asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int thread_flags) { ... do { if (thread_flags \u0026 _TIF_NEED_RESCHED) { schedule(); } else { … } local_irq_disable(); thread_flags = READ_ONCE(current_thread_info()-\u003eflags); } while (thread_flags \u0026 _TIF_WORK_MASK); } 3.唤醒进程时抢占 唤醒进程的时候，被唤醒的进程可能抢占当前进程\n唤醒进程时抢占 ![20221106214732](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106214732.png) （1）如果被唤醒的进程和当前进程属于相同的调度类，那么调用调度类的check_preempt_curr方法以检查是否可以抢占当前进程 （2）如果被唤醒的进程所属调度类的优先级高于当前进程所属调度类的优先级，那么给当前进程设置需要重新调度的标志\n调度类 check_preempt_curr方法是函数 算法 停机调度类 check_preempt_curr_stop 空函数 限期调度类 check_preempt_curr_dl 如果被唤醒的进程的绝对截止期限比当前进程的绝对截止期限小，那么给当前进程设置需要重新调度的标志 实时调度类 check_preempt_curr_rt 优先级比当前进程的优先级高，那么给当前进程设置需要重新调度的标志 公平调度类 check_preempt_wakeup 空闲调度类 check_preempt_curr_idle 无条件抢占，给当前进程设置需要重新调度的标志 check_preempt_wakeup函数\n// linux-5.10.102/kernel/sched/fair.c static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) { // 当前进程的调度策略是SCHED_IDLE，被唤醒的进程的调度策略是SCHED_NORMAL或者SCHED_BATCH，那么允许抢占，给当前进程设置需要重新调度的标志 struct task_struct *curr = rq-\u003ecurr; struct sched_entity *se = \u0026curr-\u003ese, *pse = \u0026p-\u003ese; ... if (unlikely(task_has_idle_policy(curr)) \u0026\u0026 likely(!task_has_idle_policy(p))) goto preempt; if (unlikely(p-\u003epolicy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION)) return; // 为当前进程和被唤醒的进程找到两个兄弟调度实体 find_matching_se(\u0026se, \u0026pse); update_curr(cfs_rq_of(se)); BUG_ON(!pse); if (wakeup_preempt_entity(se, pse) == 1) { // 判断是否可以抢占 // 允许抢占，给当前进程设置需要重新调度的标志 ... goto preempt; } return; preempt: resched_curr(rq); ... } static int wakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se) { s64 gran, vdiff = curr-\u003evruntime - se-\u003evruntime; if (vdiff \u003c= 0) return -1; gran = wakeup_gran(se); if (vdiff \u003e gran) return 1; return 0; } 4.创建新进程时抢占 使用系统调用fork、clone和 vfork创建新进程使，新进程可抢占当前进程；使用韩式kernel_thread创建新的内核线程是，新内核线程可抢占当前进程 5.内核抢占 内核抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，需要打开配置宏CONFIG_PREEMPT。抢占式内核和非抢占式内核。进程tthread_info结构体一个类型为int的成员preempt_count为抢占计数器。\n待补充\n6.高精度调度时钟 高精度时钟的精度是纳秒,需要通过配置宏启用。\n2.8.8 带宽管理 调度类管理进程占用的处理器带宽的方法\n1.限期调度类的带框管理 每个限期进程有自己的带宽，内核把限期进程的运行时间统计到根实时任务组的运行时间里面了，限期进程共享实时进程的带宽\n// kernel/sched/deadline.c static void update_curr_dl(struct rq *rq) { … if (rt_bandwidth_enabled()) { struct rt_rq *rt_rq = \u0026rq-\u003ert; raw_spin_lock(\u0026rt_rq-\u003ert_runtime_lock); if (sched_rt_bandwidth_account(rt_rq)) rt_rq-\u003ert_time += delta_exec; raw_spin_unlock(\u0026rt_rq-\u003ert_runtime_lock); } } 2.实时调度类的带宽管理 指定实时进程的带宽有以下两种方式 （1）指定全局带宽：带宽包含的两个参数是周期和运行时间，即指定在每个周期内所有实时进程的运行时间总和。 默认的周期是1秒，默认的运行时间是0.95秒。可以借助文件“/proc/sys/kernel/sched_rt_period_us”设置周期，借助文件“/proc/sys/kernel/sched_rt_runtime_us”设置运行时间 配置宏CONFIG_RT_GROUP_SCHED，即支持实时任务组，那么全局带宽指定了所有实时任务组的总带宽 （2）指定每个实时任务组的带宽：在每个指定的周期，允许一个实时任务组最多执行长时间。当实时任务组在一个周期用完了带宽时，这个任务组将会被节流，不允许继续运行，直到下一个周期。可以使用cgroup设置一个实时任务组的周期和运行时间，cgroup版本1的配置方法如下\ncgroup版本1的配置方法 1）cpu.rt_period_us：周期，默认值是1秒。 2）cpu.rt_runtime_us：运行时间，默认值是0，把运行时间设置为非零值以后才允许把实时进程加入任务组，设置为−1表示没有带宽限制。 cgroup版本1的配置示例如下。 1）挂载cgroup文件系统，把CPU控制器关联到控制组层级树。 mount -t cgroup -o cpu none /sys/fs/cgroup/cpu 2）创建一个任务组。 cd /sys/fs/cgroup/cpu mkdir browser # 创建\"browser\"任务组 3）把实时运行时间设置为10毫秒。 echo 10000 \u003e browser/cpu.rt_runtime_us 4）把一个实时进程加入任务组。 echo \u003e browser/cgroup.procs cgroup版本2从内核4.15版本开始支持CPU控制器，暂时不支持实时进程。\n一个处理器用完了实时运行时间，可以从其他处理器借用实时运行时间，称为实时运行时间共享，对应调度特性RT_RUNTIME_SHARE，默认开启。\nkernel/sched/features.h SCHED_FEAT(RT_RUNTIME_SHARE, true) 实时任务组的带宽存放在结构体task_group的成员rt_bandwidth中：\n// kernel/sched/sched.h struct task_group { … #ifdef CONFIG_RT_GROUP_SCHED … struct rt_bandwidth rt_bandwidth; #endif … }; 节流\n书中详细解释\n3.公平调度类的带宽管理 使用周期和限额指定一个公平任务组的带宽 使用cgroup设置一个公平任务组的周期和限额，cgroup版本1的配置 \\\ncgroup版本1的配置方法 cgroup版本2的配置示例 \\ cgroup版本2的配置方法 （1）节流：在以下两种情况下，调度器会检查公平运行队列是否用完运行时间。 1）put_prev_task_fair：调度器把当前正在运行的普通进程放回公平运行队列。 2）pick_next_task_fair：当前正在运行的进程属于公平调度类，调度器选择下一个普通进程。\n（2）周期定时器：在每个周期的开始，重新填充任务组的带宽，把带宽分配给节流的公平运行队列。周期定时器的处理函数是sched_cfs_period_timer，它把主要工作委托给函数do_sched_cfs_period_timer\n// kernel/sched/fair.c static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun) { … throttled = !list_empty(\u0026cfs_b-\u003ethrottled_cfs_rq); … __refill_cfs_bandwidth_runtime(cfs_b); // 新填充任务组的带宽 if (!throttled) { cfs_b-\u003eidle = 1; return 0; } … while (throttled \u0026\u0026 cfs_b-\u003eruntime \u003e 0) { runtime = cfs_b-\u003eruntime; raw_spin_unlock(\u0026cfs_b-\u003elock); // 把任务组的可用运行时间分配给节流的公平运行队列 runtime = distribute_cfs_runtime(cfs_b, runtime, runtime_expires); raw_spin_lock(\u0026cfs_b-\u003elock); throttled = !list_empty(\u0026cfs_b-\u003ethrottled_cfs_rq); cfs_b-\u003eruntime -= min(runtime, cfs_b-\u003eruntime); } … } 函数__refill_cfs_bandwidth_runtime负责重新填充任务组的带宽：“把可用运行时间设置成限额，把运行时间的到期时间设置成当前时间加上1个周期”\n// kernel/sched/fair.c void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b) { u64 now; if (cfs_b-\u003equota == RUNTIME_INF) return; now = sched_clock_cpu(smp_processor_id()); cfs_b-\u003eruntime = cfs_b-\u003equota; cfs_b-\u003eruntime_expires = now + ktime_to_ns(cfs_b-\u003eperiod); } 函数distribute_cfs_runtime负责把任务组的可用运行时间分配给节流的公平运行队列\nstatic void distribute_cfs_runtime(struct cfs_bandwidth *cfs_b) { struct cfs_rq *cfs_rq; u64 runtime, remaining = 1; rcu_read_lock(); list_for_each_entry_rcu(cfs_rq, \u0026cfs_b-\u003ethrottled_cfs_rq, throttled_list) { struct rq *rq = rq_of(cfs_rq); struct rq_flags rf; rq_lock_irqsave(rq, \u0026rf); if (!cfs_rq_throttled(cfs_rq)) goto next; /* By the above check, this should never be true */ SCHED_WARN_ON(cfs_rq-\u003eruntime_remaining \u003e 0); raw_spin_lock(\u0026cfs_b-\u003elock); /* cfs_rq-\u003eruntime_remaining是公平运行队列的剩余运行时间 */ runtime = -cfs_rq-\u003eruntime_remaining + 1; if (runtime \u003e cfs_b-\u003eruntime) runtime = cfs_b-\u003eruntime; cfs_b-\u003eruntime -= runtime; remaining = cfs_b-\u003eruntime; raw_spin_unlock(\u0026cfs_b-\u003elock); cfs_rq-\u003eruntime_remaining += runtime; /* we check whether we're throttled above */ /* 上面检查过是否被节流 */ if (cfs_rq-\u003eruntime_remaining \u003e 0) unthrottle_cfs_rq(cfs_rq); next: rq_unlock_irqrestore(rq, \u0026rf); if (!remaining) break; } rcu_read_unlock(); } （3）取有余补不足：\n2.9 SMP调度 SMP系统进程调度器特性: （1）使每个处理器负载尽可能均衡 （2）设置进程的处理器亲和性(affinity)，即允许进程在哪些处理器上执行 （3）进程从一个处理器迁移到另一个处理器\n2.9.1 进程的处理器亲和性 进程描述符增加两个成员\n// include/linux/sched.h struct task_struct { … int nr_cpus_allowed; // 保存允许的处理器掩码 cpumask_t cpus_allowed;\t// 保存允许的处理器数量 … }; 1.应用编程接口 内核系统调用\n// sched_setaffinity用来设置进程的处理器亲和性掩码 int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); // sched_getaffinity用来获取进程的处理器亲和性掩码 int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask); 内核线程函数设置处理器亲和性掩码\n// kthread_bind用来把一个刚刚创建的内核线程绑定到一个处理器 void kthread_bind(struct task_struct *p, unsigned int cpu); // set_cpus_allowed_ptr用来设置内核线程的处理器亲和性掩码 int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask); 2.使用cpuset配置 cpuset在单独使用的时候，可以使用cpuset伪文件系统配置，配置方法\n2.9.2 对调度器的扩展 SMP系统上，调度类增加方法\n// kernel/sched/sched.h struct sched_class { … #ifdef CONFIG_SMP // 为进程选择运行队列 int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); // 在进程被迁移到新的处理器之前调用 void (*migrate_task_rq)(struct task_struct *p); // 用来在进程被唤醒以后调用 void (*task_woken) (struct rq *this_rq, struct task_struct *task); // 设置处理器亲和性的时候执行调度类的特殊处理 void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); #endif … }; 进程在内存和缓存中的数据是最少的，是有价值的实现负载均衡的机会：1）创建新进程，2）调用execve装载程序\n创建新进程时负载均衡 ![20221106235035](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106235035.png) 装载程序时负载均衡 ![20221106235110](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106235110.png) 2.9.3 限期调度类的处理器负载均衡 2.9.4 实时调度类的处理器负载均衡 2.9.5 公平调度类的处理器负载均衡 2.9.6 迁移线程 每个处理器有一个迁移线程，线程名称是“migration/”，属于停机调度类，可以抢占所有其他进程，其他进程不可以抢占它。迁移线程有两个作用 （1）调度器发出迁移请求，迁移线程处理迁移请求，把进程迁移到目标处理器。 （2）执行主动负载均衡。\n2.9.7 隔离处理器 2.10 进程的上下文安全 第3章 内存管理 3.1 内存管理子系统架构 用户空间、内核空间和硬件3个层面 1.用户空间 应用程序使用malloc()申请内存，使用free()释放内存。 malloc()和free()是glibc库的内存分配器ptmalloc提供的接口，ptmalloc使用系统调用brk或mmap向内核以页为单位申请内存，然后划分成小内存块分配给应用程序 用户空间的内存分配器，除了glibc库的ptmalloc，还有谷歌的tcmalloc和FreeBSD的jemalloc\n2.内核空间 （1）内核空间的基本功能 虚拟内存管理负责从进程的虚拟地址空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页 内核使用延迟分配物理内存的策略，进程第一次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页 页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口kmalloc()和释放内存的接口kfree()，支持3种块分配器：SLAB分配器、SLUB分配器和SLOB分配器。 \\\n（2）内核空间的扩展功能。 \\\n不连续页分配器提供了分配内存的接口vmalloc和释放内存的接口vfree 连续内存分配器（Contiguous Memory Allocator，CMA）用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用 \\\n3.硬件层面 处理器包含一个称为内存管理单元（Memory Management Unit，MMU）的部件，负责把虚拟地址转换成物理地址 内存管理单元包含一个称为页表缓存（Translation Lookaside Buffer，TLB）的部件，保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表 \\\n3.2 虚拟地址空间布局 3.2.1 虚拟地址空间划分 ARM64处理器不支持完全的64位虚拟地址，ARMv8.2 标准的大虚拟地址(Large Virtual Address，LVA)支持，并且页长度是64KB，那么虚拟地址的最大宽度是52位 可以为虚拟地址配置比最大宽度小的宽度，并且可以为内核虚拟地址和用户虚拟地址配置不同的宽度。转换控制寄存器（Translation Control Register）TCR_EL1的字段T0SZ定义了必须是全0的最高位的数量，字段T1SZ定义了必须是全1的最高位的数量，用户虚拟地址的宽度是（64-TCR_EL1.T0SZ），内核虚拟地址的宽度是（64-TCR_EL1.T1SZ） \\\n页长度 虚拟地址宽度 4KB 39 16KB 47 64KB 42 可选择48位虚拟地址 3.2.2 用户虚拟地址空间布局 进程的用户虚拟地址空间的起始地址是0，长度是TASK_SIZE，ARM64架构下TASK_SIZE下 （1）32位用户空间程序：TASK_SIZE值是TASK_SIZE_32，即0x100000000，4GB （2）64位用户空间程序：TASK_SIZE值是TASK_SIZE_64，即 2^VA_BITS，VA_BITS是编译内核时选择的虚拟地址位数。 \\\n//arch/arm64/include/asm/memory.h linux4.x #define VA_BITS (CONFIG_ARM64_VA_BITS) #define TASK_SIZE_64 (UL(1) \u003c\u003c VA_BITS) #ifdef CONFIG_COMPAT /* 支持执行32位用户空间程序 */ #define TASK_SIZE_32 UL(0x100000000) /* test_thread_flag(TIF_32BIT)判断用户空间程序是不是32位 */ #define TASK_SIZE (test_thread_flag(TIF_32BIT) ? \\ TASK_SIZE_32 : TASK_SIZE_64) #define TASK_SIZE_OF(tsk) (test_tsk_thread_flag(tsk, TIF_32BIT) ? \\ TASK_SIZE_32 : TASK_SIZE_64) #else #define TASK_SIZE TASK_SIZE_64 #endif /* CONFIG_COMPAT */ // linux-5.10.102/arch/arm64/include/asm/memory.h #define VA_BITS\t(CONFIG_ARM64_VA_BITS) #define _PAGE_OFFSET(va)\t(-(UL(1) \u003c\u003c (va))) #define PAGE_OFFSET\t(_PAGE_OFFSET(VA_BITS)) #define KIMAGE_VADDR\t(MODULES_END) #define BPF_JIT_REGION_START\t(KASAN_SHADOW_END) #define BPF_JIT_REGION_SIZE\t(SZ_128M) #define BPF_JIT_REGION_END\t(BPF_JIT_REGION_START + BPF_JIT_REGION_SIZE) #define MODULES_END\t(MODULES_VADDR + MODULES_VSIZE) #define MODULES_VADDR\t(BPF_JIT_REGION_END) #define MODULES_VSIZE\t(SZ_128M) #define VMEMMAP_START\t(-VMEMMAP_SIZE - SZ_2M) #define VMEMMAP_END\t(VMEMMAP_START + VMEMMAP_SIZE) #define PCI_IO_END\t(VMEMMAP_START - SZ_2M) #define PCI_IO_START\t(PCI_IO_END - PCI_IO_SIZE) #define FIXADDR_TOP\t(PCI_IO_START - SZ_2M) 进程的用户虚拟地址空间包含： （1）代码段、数据段和未初始化数据段 （2）动态库代码段、数据段和初始化数据段 （3）存放动态生成的数据的堆 （4）存放局部变量和实现函数调用的栈 （5）存放在栈底部的环境变量和参数字符串 （6）把文件区间映射到虚拟地址空间的内存映射区域 内核使用内存描述符mm_struct描述进程的用户虚拟地址空间，内存描述符主要成员\natomic_t mm_users; // 共享同一个用户虚拟地址空间进程的数量，即线程组包含的进程的数量 atomic_t mm_count; // 内存描述符的引用计数 struct vm_area_struct *mmap; // 虚拟内存区域链表 struct rb_root mm_rb; // 虚拟内存区域红黑树 unsigned long(*get_unmapped_area)(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags); // 在内存映射区域找到一个没有映射的区域 pgd_t *pgd; // 指向页全局目录，即第一级页表 unsigned long mmap_base; // 内存映射区的起始地址 unsigned long task_size; // 用户虚拟地址空间的长度 unsigned long start_code, end_code; // 代码段的起始地址和结束地址 unsigned long start_data, end_data; // 数据段的起始地址和结束地址 unsigned long start_brk, brk; // 堆的起始地址和结束地址 unsigned long start_stack; // 栈的起始地址 unsigned long arg_start, arg_end; // 参数字符串起始地址和结束地址 unsigned long env_start, env_end; // 环境变量的起始地址和结束地址 struct mm_struct *mm; // 进程mm指向一个内存描述符，内核线程mm为空指针 struct mm_struct　*active_mm; // 进程的active_mm和mm总是指向同一个内存描述符 // 内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符 进程地址空间随机化： （1）进程描述符成员personality是否设置ADDR_NO_RANDOMIZE （2）全局变量randomize_va_spce：0表示关闭虚拟地址空间随机化，1表示内存映射区和栈起始地址随机化，2表示内存映射区、栈和堆起始地址随机化，文件/proc/sys/kernel/randomize_va_space修改 \\\n栈向下增长，起始地址STACK_TOP，\n// arch/arm64/include/asm/processor.h #define STACK_TOP_MAX TASK_SIZE_64 #ifdef CONFIG_COMPAT /* 支持执行32位用户空间程序 */ #define AARCH32_VECTORS_BASE 0xffff0000 #define STACK_TOP (test_thread_flag(TIF_32BIT) ? \\ AARCH32_VECTORS_BASE : STACK_TOP_MAX) #else #define STACK_TOP STACK_TOP_MAX #endif /* CONFIG_COMPAT */ 内存映射区域的起始地址是内存描述符的成员 mmap_base\n用户虚拟地址空间两种布局 ![20221109013928](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109013928.png) 新布局：内存映射区域自顶向下增长，起始地址是(STACK_TOP − 栈的最大长度 − 间隙)，默认启用内存映射区域随机化，需要把起始地址减去一个随机值 \\\n进程调用execve以装载ELF文件的时候，函数load_elf_binary将会创建进程的用户虚拟地址空间 \\\n函数arch_pick_mmap_layout负责选择内存映射区域的布局。ARM64架构定义的函数arch_pick_mmap_layout\n// linux-5.10.102/mm/util.c void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack) { unsigned long random_factor = 0UL; if (current-\u003eflags \u0026 PF_RANDOMIZE) random_factor = arch_mmap_rnd(); if (mmap_is_legacy(rlim_stack)) { // 自底向上 mm-\u003emmap_base = TASK_UNMAPPED_BASE + random_factor; mm-\u003eget_unmapped_area = arch_get_unmapped_area; // } else { // 自顶向下 mm-\u003emmap_base = mmap_base(random_factor, rlim_stack); mm-\u003eget_unmapped_area = arch_get_unmapped_area_topdown; } } static int mmap_is_legacy(struct rlimit *rlim_stack) { if (current-\u003epersonality \u0026 ADDR_COMPAT_LAYOUT) return 1; if (rlim_stack-\u003erlim_cur == RLIM_INFINITY) return 1; return sysctl_legacy_va_layout; } 内存映射区域的起始地址的计算\n// linux-5.10.102/arch/arm64/include/asm/efi.h #ifdef CONFIG_COMPAT #define STACK_RND_MASK\t(test_thread_flag(TIF_32BIT) ? \\ 0x7ff \u003e\u003e (PAGE_SHIFT - 12) : \\ 0x3ffff \u003e\u003e (PAGE_SHIFT - 12)) #else #define STACK_RND_MASK\t(0x3ffff \u003e\u003e (PAGE_SHIFT - 12)) #endif // arch/arm64/mm/mmap.c #define MIN_GAP (SZ_128M + ((STACK_RND_MASK \u003c\u003c PAGE_SHIFT) + 1)) #define MAX_GAP (STACK_TOP/6*5) static unsigned long mmap_base(unsigned long rnd) { unsigned long gap = rlimit(RLIMIT_STACK); if (gap \u003c MIN_GAP) gap = MIN_GAP; else if (gap \u003e MAX_GAP) gap = MAX_GAP; return PAGE_ALIGN(STACK_TOP - gap - rnd); } 函数load_elf_binary：函数setup_arg_pages把栈顶设置为STACK_TOP减去随机值，然后把环境变量和参数从临时栈移到最终的用户栈；函数set_brk设置堆的起始地址，如果启用堆随机化，把堆的起始地址加上随机值\n// fs/binfmt_elf.c static int load_elf_binary(struct linux_binprm *bprm) { … retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP), executable_stack); … retval = set_brk(elf_bss, elf_brk, bss_prot); … if ((current-\u003eflags \u0026 PF_RANDOMIZE) \u0026\u0026 (randomize_va_space \u003e 1)) { current-\u003emm-\u003ebrk = current-\u003emm-\u003estart_brk = arch_randomize_brk(current-\u003emm); } … } 3.2.3 内核地址空间布局 ARM64处理器架构内核地址空间布局 ![20221109225722](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109225722.png) (1)先行映射区范围[PAGE_OFFSET, 2^64-1]，起始地址PAGE_OFFSET = (OxFFFF FFFF FFFF FFFF « (VA_BITS-1))，长度为内核虚拟地址空间的一半，虚拟地址和物理地址是线性关系 \\ 虚拟地址 = ((物理地址-PHYS_OFFSET)+PAGE_OFFSET)，PHY_OFFSET是内存起始物理地址 (2)vmemmap 区域的范围是[VMEMMAP_START, PAGE_OFFSET)，长度是VMEMMAP_SIZE =（线性映射区域的长度 / 页长度 * page结构体的长度上限） (3)PCI I/O区域的范围是[PCI_IO_START, PCI_IO_END)，长度是16MB，结束地址是PCI_IO_END = (VMEMMAP_START − 2MB)。外围组件互联（Peripheral Component Interconnect，PCI）是一种总线标准，PCI I/O区域是PCI设备的I/O地址空间 (4)定映射区域的范围是[FIXADDR_START, FIXADDR_TOP)，长度是FIXADDR_SIZE，结束地址是FIXADDR_TOP = (PCI_IO_START − 2MB) (5)vmalloc区域的范围是[VMALLOC_START, VMALLOC_END），起始地址是VMALLOC_START，等于内核模块区域的结束地址，结束地址是VMALLOC_END = (PAGE_OFFSET − PUD_SIZE − VMEMMAP_SIZE − 64KB)，其中PUD_SIZE是页上级目录表项映射的地址空间的长度 vmalloc区域是函数vmalloc使用的虚拟地址空间，内核镜像在vmalloc区域，起始虚拟地址是(KIMAGE_VADDR + TEXT_OFFSET) ，其中KIMAGE_VADDR是内核镜像的虚拟地址的基准值，等于内核模块区域的结束地址MODULES_END；TEXT_OFFSET是内存中的内核镜像相对内存起始位置的偏移 (6)内核模块区域的范围是[MODULES_VADDR, MODULES_END)，长度是128MB，起始地址是MODULES_VADDR =（内核虚拟地址空间的起始地址 + KASAN影子区域的长度）。内核模块区域是内核模块使用的虚拟地址空间 (7)KASAN影子区域的起始地址是内核虚拟地址空间的起始地址，长度是内核虚拟地址空间长度的1/8。内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具 \\\n3.3 物理地址空间 处理器通过外围设备控制器的寄存器访问外围设备，寄存器分为控制寄存器、状态寄存器和数据寄存器三大类，外围设备的寄存器通常被连续地编址。处理器对外围设备寄存器的编址方式有两种： （1）I/O映射方式(I/O-mapped) （2）内存映射方式(memroy-mapped)：精简指令集的处理器通常只实现一个物理地址空间，外围设备和物理内存使用统一的物理地址空间，处理器可以像访问一个内存单元那样访问外围设备，不需要提供专门的I/O指令 \\\n程序通过虚拟地址访问外设寄存器，内核函数把外设寄存器物理地址映射到虚拟地址空间\n// ioremap()把外设寄存器物理地址映射到内核虚拟地址空间 void* ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); // io_remap_pfn_range()函数把外设寄存器的物理地址映射到进程的用户虚拟地址空间 int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn, unsigned long size, pgprot_t prot); // iounmap()删除函数ioremap()创建映射 void iounmap(void *addr); ARM64架构两种内存类型： （1）正常内存(Normal Memory)：包括物理内存和只读存储器(ROM)，共享属性和可缓存 （2）设备内存(Device Memory)：指分配给外围设备寄存器的物理地址区域，外部共享，不可缓存 ARM64架构3种属性把设备分为4种类型: （1）Device-nGnRnE （2）Device-nGnRE。 （3）Device-nGRE。 （4）Device-GRE \\\n寄存器TCR_EL1（Translation Control Register for Exception Level 1，异常级别1的转换控制寄存器）的字段IPS（Intermediate Physical Address Size，中间物理地址长度）控制物理地址的宽度，IPS字段的长度是3位\n3.4　内存映射 进程在虚拟地址空间中创建映射： （1）文件映射，把文件一个区间映射到进程虚拟地址空间，数据源是存储设备上的文件，文件页 （2）匿名映射，把物理内存映射到进程虚拟地址空间，无数据源，匿名页 修改对其他进程可见和释放传递底层文件，内存映射分为共享映射和私有映射。 \u0026ensp；（1）共享映射：修改数据时映射相同区域的其他进程可以看见，如果是文件支持的映射，修改会传递到底层文件。 （2）私有映射：第一次修改数据时会从数据源复制一个副本，然后修改副本，其他进程看不见，不影响数据源 两个进程可以使用共享的文件映射实现共享内存，进程间通信？。匿名映射通常是私有映射，共享的匿名映射只可能出现在父进程和子进程之间。 进程的虚拟地址空间中，代码段和数据段是私有的文件映射，未初始化数据段、堆和栈是私有的匿名映射 内存映射的原理。 （1）创建内存映射的时候，在进程的用户虚拟地址空间中分配一个虚拟内存区域。 （2）Linux内核采用延迟分配物理内存的策略，在进程第一次访问虚拟页的时候，产生缺页异常。如果是文件映射，那么分配物理页，把文件指定区间的数据读到物理页中，然后在页表中把虚拟页映射到物理页；如果是匿名映射，那么分配物理页，然后在页表中把虚拟页映射到物理页\n3.4.1 应用编程接口 系统调用\n// 1.mmap()创建内存映射 void *mmap(void *addr, size_t length, int prot, int flags, in fd, off_t offset); // 2. mremap()扩大或缩小内存映射，可移动 void *mreemap(void *old_address, size_t old_size, size_t new_size, int flags, ... /*void *new_address */); // 3. munmap() 删除内存印刷 int munmap(void *addr, size_t length); // 4. brk() 设置堆上界 int brk(void *addr); // 6. mprotect()设置虚拟内存区域的访问权限 int mprotect(void *addr, size_t len, int prot); // 7. madvise 箱内核体术内存使用建议，配合内核预读和缓存 int madvise(void *addr, size_t length, int advice); 内核空间函数\n// 1. remap_pfn_range把内存的物理页映射到进程的虚拟地址空间，实现进程和内核共享内存 int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn,unsigned long size, pgprot_t prot); // 2.io_remap_pfn_range把外设寄存器的物理地址映射到进程的虚拟地址空间，进程可以直接访问外设寄存器 int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,unsigned long pfn, unsigned long size, pgprot_t prot); 应用程序通常使用C标准库提供的函数malloc()申请内存。glibc库的内存分配器ptmalloc使用brk或mmap向内核以页为单位申请虚拟内存，然后把页划分成小内存块分配给应用程序。默认的阈值是128KB，如果应用程序申请的内存长度小于阈值，ptmalloc分配器使用brk向内核申请虚拟内存，否则ptmalloc分配器使用mmap向内核申请虚拟内存 \\\n应用程序可以直接使用mmap向内核申请虚拟内存 系统调用mmap() 系统调用mprotect() 系统调用madvise()\n3.4.2 数据结构 1. 虚拟内存区域 内核使用结构体vm_area_struct描述虚拟内存区域\nstruct vm_area_struct { /* The first cache line has the info for VMA tree walking. */ /* Our start address within vm_mm. */ unsigned long vm_start;\t// 起始地址 /* The first byte after our end address within vm_mm. */ unsigned long vm_end; // 结束地址 /* linked list of VM areas per task, sorted by address */ // 虚拟内存区域链表，按起始地址排序 struct vm_area_struct *vm_next, *vm_prev; // 红黑树节点 struct rb_node vm_rb; /* Largest free memory gap in bytes to the left of this VMA. * Either between this VMA and vma-\u003evm_prev, or between one of the * VMAs below us in the VMA rbtree and its -\u003evm_prev. This helps * get_unmapped_area find a free area of the right size.*/ unsigned long rb_subtree_gap; /* Second cache line starts here. */ // 指向内存描述符，即虚拟内存区域所属的用户虚拟地址空间 struct mm_struct *vm_mm;\t/* The address space we belong to. */ /* Access permissions of this VMA. * See vmf_insert_mixed_prot() for discussion.*/ // 保护位，即访问权限 pgprot_t vm_page_prot; unsigned long vm_flags;\t/* Flags, see mm.h. */ /* For areas with an address space and backing store, * linkage into the address_space-\u003ei_mmap interval tree.*/ // 为了支持查询一个文件区间被映射到哪些虚拟内存区域， // 把一个文件映射到的所有虚拟内存区域加入该文件的地址空间结构体 // address_space的成员i_mmap指向的区间树 struct { struct rb_node rb; unsigned long rb_subtree_last; } shared; /* file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma * list, after a COW of one of the file pages.\tA MAP_SHARED vma * can only be in the i_mmap tree. An anonymous MAP_PRIVATE, stack * or brk vma (with NULL file) can only be in an anon_vma list.*/ // 把虚拟内存区域关联的所有anon_vma实例串联起来。 // 一个虚拟内存区域会关联到父进程的anon_vma实例和自己的anon_vma实例 struct list_head anon_vma_chain; /* Serialized by mmap_lock \u0026 * page_table_lock */ // 指向一个anon_vma实例，结构体anon_vma用来组织匿名页 // 被映射到的所有虚拟地址空间 struct anon_vma *anon_vma;\t/* Serialized by page_table_lock */ /* Function pointers to deal with this struct. */ // 虚拟内存操作集合 const struct vm_operations_struct *vm_ops; /* Information about our backing store: */ // 文件偏移，单位是页 unsigned long vm_pgoff;\t/* Offset (within vm_file) in PAGE_SIZE units */ // 文件，如果是私有的匿名映射，该成员是空指针 struct file * vm_file;\t/* File we map to (can be NULL). */ void * vm_private_data;\t/* was vm_pte (shared mem) */ #ifdef CONFIG_SWAP atomic_long_t swap_readahead_info; #endif #ifndef CONFIG_MMU struct vm_region *vm_region;\t/* NOMMU mapping region */ #endif #ifdef CONFIG_NUMA struct mempolicy *vm_policy;\t/* NUMA policy for the VMA */ #endif struct vm_userfaultfd_ctx vm_userfaultfd_ctx; } __randomize_layout; 文件映射的虚拟内存区域 ![20221111234010](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221111234010.png) （1）成员vm_file指向文件的一个打开实例（file）。索引节点代表一个文件，描述文件的属性。 （2）成员vm_pgoff存放文件的以页为单位的偏移。 （3）成员vm_ops指向虚拟内存操作集合，创建文件映射的时候调用文件操作集合中的mmap方法（file-\u003ef_op-\u003emmap）以注册虚拟内存操作集合。例如：假设文件属于EXT4文件系统，文件操作集合中的mmap方法是函数ext4_file_mmap，该函数把虚拟内存区域的成员vm_ops设置为ext4_file_vm_ops\n共享匿名映射的虚拟内存区域 ![20221111234048](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221111234048.png) （1）成员vm_file指向文件的一个打开实例（file）。 （2）成员vm_pgoff存放文件的以页为单位的偏移。 （3）成员vm_ops指向共享内存的虚拟内存操作集合shmem_vm_ops。\n私有匿名映射的虚拟内存区域 ![20221112001338](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221112001338.png) （1）页保护位（vm_area_struct.vm_page_prot）：描述虚拟内存区域的访问权限。内核定义了一个保护位映射数组，把VM_READ、VM_WRITE、VM_EXEC和VM_SHARED这4个标志转换成保护位组合 P代表私有（Private），S代表共享（Shared），后面的3个数字分别表示可读、可写和可执行，例如__P000表示私有、不可读、不可写和不可执行，__S111表示共享、可读、可写和可执行\n// mm/mmap.c pgprot_t protection_map[16] = { __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111, __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111 }; pgprot_t vm_get_page_prot(unsigned long vm_flags) { return __pgprot(pgprot_val(protection_map[vm_flags \u0026 (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) | pgprot_val(arch_vm_get_page_prot(vm_flags))); } ",
  "wordCount" : "32374",
  "inLanguage": "en",
  "datePublished": "2022-10-05T00:17:58+08:00",
  "dateModified": "2022-10-05T00:17:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Zain"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zain's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://liuz0123.gitee.io/zain/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://liuz0123.gitee.io/zain/" accesskey="h" title="Zain&#39;s Blog (Alt + H)">
            <img src="https://liuz0123.gitee.io/zain/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">Zain&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://liuz0123.gitee.io/zain/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/links" title="🤝 闲言俗语">
                <span>🤝 闲言俗语</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://liuz0123.gitee.io/zain/">主页</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                Linux内核深度解析
            </h1>
            <div class="post-meta">Create:&nbsp;<span title='2022-10-05 00:17:58 +0800 CST'>2022-10-05</span>&nbsp;|&nbsp;Update:&nbsp;2022-10-05&nbsp;|&nbsp;Words:&nbsp;32374&nbsp;|&nbsp;&nbsp;65 min&nbsp;|&nbsp;
&nbsp;Zain



                &nbsp;|&nbsp;tags: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://liuz0123.gitee.io/zain/tags/tech/">tech</a>
                    <a href="https://liuz0123.gitee.io/zain/tags/linux/">、linux</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| Viewers: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%86%85%e5%ae%b9%e6%8f%90%e7%ba%b2" aria-label="内容提纲">内容提纲</a></li>
                <li>
                    <a href="#%e7%ac%ac1%e7%ab%a0-%e5%86%85%e6%a0%b8%e5%bc%95%e5%af%bc%e5%92%8c%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="第1章 内核引导和初始化">第1章 内核引导和初始化</a><ul>
                        
                <li>
                    <a href="#11-%e5%bc%95%e5%af%bc%e7%a8%8b%e5%ba%8f" aria-label="1.1 引导程序">1.1 引导程序</a><ul>
                        
                <li>
                    <a href="#111-%e5%85%a5%e5%8f%a3_start" aria-label="1.1.1 入口_start">1.1.1 入口_start</a></li>
                <li>
                    <a href="#112-reset" aria-label="1.1.2 reset">1.1.2 <code>reset</code></a></li>
                <li>
                    <a href="#113-%e5%87%bd%e6%95%b0_main" aria-label="1.1.3 函数_main">1.1.3 函数_main</a></li>
                <li>
                    <a href="#114-%e5%87%bd%e6%95%b0run_main_loop" aria-label="1.1.4 函数run_main_loop">1.1.4 函数run_main_loop</a></li></ul>
                </li>
                <li>
                    <a href="#12-%e5%86%85%e6%a0%b8%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="1.2 内核初始化">1.2 内核初始化</a><ul>
                        
                <li>
                    <a href="#121-%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86" aria-label="1.2.1 汇编语言部分">1.2.1 汇编语言部分</a></li>
                <li>
                    <a href="#122-c%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86" aria-label="1.2.2 C语言部分">1.2.2 C语言部分</a></li>
                <li>
                    <a href="#123-smp%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%bc%95%e5%af%bc" aria-label="1.2.3 SMP系统的引导">1.2.3 SMP系统的引导</a></li></ul>
                </li>
                <li>
                    <a href="#13-init%e8%bf%9b%e7%a8%8b" aria-label="1.3 init进程">1.3 init进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac2%e7%ab%a0-%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86" aria-label="第2章 进程管理">第2章 进程管理</a><ul>
                        
                <li>
                    <a href="#21-%e8%bf%9b%e7%a8%8b" aria-label="2.1 进程">2.1 进程</a></li>
                <li>
                    <a href="#22-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="2.2 命名空间">2.2 命名空间</a></li>
                <li>
                    <a href="#23-%e8%bf%9b%e7%a8%8b%e6%a0%87%e8%af%86%e7%ac%a6" aria-label="2.3 进程标识符">2.3 进程标识符</a></li>
                <li>
                    <a href="#24-%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb" aria-label="2.4 进程关系">2.4 进程关系</a></li>
                <li>
                    <a href="#25-%e5%90%af%e5%8a%a8%e7%a8%8b%e5%ba%8f" aria-label="2.5 启动程序">2.5 启动程序</a><ul>
                        
                <li>
                    <a href="#251%e5%88%9b%e5%bb%ba%e6%96%b0%e8%bf%9b%e7%a8%8b" aria-label="2.5.1　创建新进程">2.5.1　创建新进程</a><ul>
                        
                <li>
                    <a href="#1-_do_fork%e5%87%bd%e6%95%b0" aria-label="1. _do_fork函数">1. _do_fork函数</a></li>
                <li>
                    <a href="#2-copy_process%e5%87%bd%e6%95%b0" aria-label="2. copy_process函数">2. copy_process函数</a></li>
                <li>
                    <a href="#3%e5%94%a4%e9%86%92%e6%96%b0%e8%bf%9b%e7%a8%8b" aria-label="3.唤醒新进程">3.唤醒新进程</a></li>
                <li>
                    <a href="#4%e6%96%b0%e8%bf%9b%e7%a8%8b%e7%ac%ac%e4%b8%80%e6%ac%a1%e8%bf%90%e8%a1%8c" aria-label="4.新进程第一次运行">4.新进程第一次运行</a></li></ul>
                </li>
                <li>
                    <a href="#252-%e8%a3%85%e8%bd%bd%e7%a8%8b%e5%ba%8f" aria-label="2.5.2 装载程序">2.5.2 装载程序</a><ul>
                        
                <li>
                    <a href="#1%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%a0%bc%e5%bc%8f" aria-label="1.二进制格式">1.二进制格式</a></li>
                <li>
                    <a href="#2%e8%a3%85%e8%bd%bdelf%e7%a8%8b%e5%ba%8f" aria-label="2.装载ELF程序">2.装载ELF程序</a></li>
                <li>
                    <a href="#3%e8%a3%85%e8%bd%bd%e8%84%9a%e6%9c%ac%e7%a8%8b%e5%ba%8f" aria-label="3.装载脚本程序">3.装载脚本程序</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#26-%e8%bf%9b%e7%a8%8b%e9%80%80%e5%87%ba" aria-label="2.6 进程退出">2.6 进程退出</a><ul>
                        
                <li>
                    <a href="#261-%e7%ba%bf%e7%a8%8b%e7%bb%84%e9%80%80%e5%87%ba-exit_group" aria-label="2.6.1 线程组退出 exit_group">2.6.1 线程组退出 exit_group</a></li>
                <li>
                    <a href="#262-%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b" aria-label="2.6.2 终止进程">2.6.2 终止进程</a></li>
                <li>
                    <a href="#263-%e6%9f%a5%e8%af%a2%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%bb%88%e6%ad%a2%e5%8e%9f%e5%9b%a0" aria-label="2.6.3 查询子进程终止原因">2.6.3 查询子进程终止原因</a></li></ul>
                </li>
                <li>
                    <a href="#27-%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81" aria-label="2.7 进程状态">2.7 进程状态</a></li>
                <li>
                    <a href="#28-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6" aria-label="2.8 进程调度">2.8 进程调度</a><ul>
                        
                <li>
                    <a href="#281-%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5" aria-label="2.8.1 调度策略">2.8.1 调度策略</a></li>
                <li>
                    <a href="#282-%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7" aria-label="2.8.2 进程优先级">2.8.2 进程优先级</a></li>
                <li>
                    <a href="#283-%e8%b0%83%e5%ba%a6%e7%b1%bb" aria-label="2.8.3 调度类">2.8.3 调度类</a></li>
                <li>
                    <a href="#284-%e8%bf%90%e8%a1%8c%e9%98%9f%e5%88%97" aria-label="2.8.4 运行队列">2.8.4 运行队列</a></li>
                <li>
                    <a href="#285-%e4%bb%bb%e5%8a%a1%e5%88%86%e7%bb%84" aria-label="2.8.5 任务分组">2.8.5 任务分组</a><ul>
                        
                <li>
                    <a href="#1%e4%bb%bb%e5%8a%a1%e5%88%86%e7%bb%84%e6%96%b9%e5%bc%8f" aria-label="1.任务分组方式">1.任务分组方式</a></li>
                <li>
                    <a href="#2-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="2. 数据结构">2. 数据结构</a></li></ul>
                </li>
                <li>
                    <a href="#286-%e8%b0%83%e5%ba%a6%e8%bf%9b%e7%a8%8b" aria-label="2.8.6 调度进程">2.8.6 调度进程</a><ul>
                        
                <li>
                    <a href="#1%e9%80%89%e6%8b%a9%e4%b8%8b%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b-%e5%87%bd%e6%95%b0pick_next_task" aria-label="1.选择下一个进程 函数pick_next_task">1.选择下一个进程 函数pick_next_task</a></li>
                <li>
                    <a href="#2%e5%88%87%e6%8d%a2%e8%bf%9b%e7%a8%8b-context_switch" aria-label="2.切换进程 context_switch">2.切换进程 context_switch</a></li></ul>
                </li>
                <li>
                    <a href="#287-%e8%b0%83%e5%ba%a6%e6%97%b6%e6%9c%ba" aria-label="2.8.7 调度时机">2.8.7 调度时机</a><ul>
                        
                <li>
                    <a href="#1%e4%b8%bb%e5%8a%a8%e8%b0%83%e5%ba%a6" aria-label="1.主动调度">1.主动调度</a></li>
                <li>
                    <a href="#2%e5%91%a8%e6%9c%9f%e8%b0%83%e5%ba%a6" aria-label="2.周期调度">2.周期调度</a></li>
                <li>
                    <a href="#3%e5%94%a4%e9%86%92%e8%bf%9b%e7%a8%8b%e6%97%b6%e6%8a%a2%e5%8d%a0" aria-label="3.唤醒进程时抢占">3.唤醒进程时抢占</a></li>
                <li>
                    <a href="#4%e5%88%9b%e5%bb%ba%e6%96%b0%e8%bf%9b%e7%a8%8b%e6%97%b6%e6%8a%a2%e5%8d%a0" aria-label="4.创建新进程时抢占">4.创建新进程时抢占</a></li>
                <li>
                    <a href="#5%e5%86%85%e6%a0%b8%e6%8a%a2%e5%8d%a0" aria-label="5.内核抢占">5.内核抢占</a></li>
                <li>
                    <a href="#6%e9%ab%98%e7%b2%be%e5%ba%a6%e8%b0%83%e5%ba%a6%e6%97%b6%e9%92%9f" aria-label="6.高精度调度时钟">6.高精度调度时钟</a></li></ul>
                </li>
                <li>
                    <a href="#288-%e5%b8%a6%e5%ae%bd%e7%ae%a1%e7%90%86" aria-label="2.8.8 带宽管理">2.8.8 带宽管理</a><ul>
                        
                <li>
                    <a href="#1%e9%99%90%e6%9c%9f%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%b8%a6%e6%a1%86%e7%ae%a1%e7%90%86" aria-label="1.限期调度类的带框管理">1.限期调度类的带框管理</a></li>
                <li>
                    <a href="#2%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%b8%a6%e5%ae%bd%e7%ae%a1%e7%90%86" aria-label="2.实时调度类的带宽管理">2.实时调度类的带宽管理</a></li>
                <li>
                    <a href="#3%e5%85%ac%e5%b9%b3%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%b8%a6%e5%ae%bd%e7%ae%a1%e7%90%86" aria-label="3.公平调度类的带宽管理">3.公平调度类的带宽管理</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#29-smp%e8%b0%83%e5%ba%a6" aria-label="2.9 SMP调度">2.9 SMP调度</a><ul>
                        
                <li>
                    <a href="#291-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e4%ba%b2%e5%92%8c%e6%80%a7" aria-label="2.9.1 进程的处理器亲和性">2.9.1 进程的处理器亲和性</a><ul>
                        
                <li>
                    <a href="#1%e5%ba%94%e7%94%a8%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="1.应用编程接口">1.应用编程接口</a></li>
                <li>
                    <a href="#2%e4%bd%bf%e7%94%a8cpuset%e9%85%8d%e7%bd%ae" aria-label="2.使用cpuset配置">2.使用cpuset配置</a></li></ul>
                </li>
                <li>
                    <a href="#292-%e5%af%b9%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e6%89%a9%e5%b1%95" aria-label="2.9.2 对调度器的扩展">2.9.2 对调度器的扩展</a></li>
                <li>
                    <a href="#293-%e9%99%90%e6%9c%9f%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="2.9.3 限期调度类的处理器负载均衡">2.9.3 限期调度类的处理器负载均衡</a></li>
                <li>
                    <a href="#294-%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="2.9.4 实时调度类的处理器负载均衡">2.9.4 实时调度类的处理器负载均衡</a></li>
                <li>
                    <a href="#295-%e5%85%ac%e5%b9%b3%e8%b0%83%e5%ba%a6%e7%b1%bb%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="2.9.5 公平调度类的处理器负载均衡">2.9.5 公平调度类的处理器负载均衡</a></li>
                <li>
                    <a href="#296-%e8%bf%81%e7%a7%bb%e7%ba%bf%e7%a8%8b" aria-label="2.9.6 迁移线程">2.9.6 迁移线程</a></li>
                <li>
                    <a href="#297-%e9%9a%94%e7%a6%bb%e5%a4%84%e7%90%86%e5%99%a8" aria-label="2.9.7 隔离处理器">2.9.7 隔离处理器</a></li></ul>
                </li>
                <li>
                    <a href="#210-%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%ae%89%e5%85%a8" aria-label="2.10 进程的上下文安全">2.10 进程的上下文安全</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac3%e7%ab%a0-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="第3章 内存管理">第3章 内存管理</a><ul>
                        
                <li>
                    <a href="#31-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%ad%90%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" aria-label="3.1 内存管理子系统架构">3.1 内存管理子系统架构</a><ul>
                        <ul>
                        
                <li>
                    <a href="#1%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4" aria-label="1.用户空间">1.用户空间</a></li>
                <li>
                    <a href="#2%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4" aria-label="2.内核空间">2.内核空间</a></li>
                <li>
                    <a href="#3%e7%a1%ac%e4%bb%b6%e5%b1%82%e9%9d%a2" aria-label="3.硬件层面">3.硬件层面</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#32-%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80" aria-label="3.2 虚拟地址空间布局">3.2 虚拟地址空间布局</a><ul>
                        
                <li>
                    <a href="#321-%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%88%92%e5%88%86" aria-label="3.2.1 虚拟地址空间划分">3.2.1 虚拟地址空间划分</a></li>
                <li>
                    <a href="#322-%e7%94%a8%e6%88%b7%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80" aria-label="3.2.2 用户虚拟地址空间布局">3.2.2 用户虚拟地址空间布局</a></li>
                <li>
                    <a href="#323-%e5%86%85%e6%a0%b8%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80" aria-label="3.2.3 内核地址空间布局">3.2.3 内核地址空间布局</a></li></ul>
                </li>
                <li>
                    <a href="#33-%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" aria-label="3.3 物理地址空间">3.3 物理地址空间</a></li>
                <li>
                    <a href="#34%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84" aria-label="3.4　内存映射">3.4　内存映射</a><ul>
                        <ul>
                        
                <li>
                    <a href="#341-%e5%ba%94%e7%94%a8%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3" aria-label="3.4.1 应用编程接口">3.4.1 应用编程接口</a></li></ul>
                    
                <li>
                    <a href="#342-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="3.4.2 数据结构">3.4.2 数据结构</a><ul>
                        
                <li>
                    <a href="#1-%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f" aria-label="1. 虚拟内存区域">1. 虚拟内存区域</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h1 id="内容提纲">内容提纲<a hidden class="anchor" aria-hidden="true" href="#内容提纲">#</a></h1>
<ul>
<li>内核的引导过程U-Boot</li>
<li>内核管理和调度进程</li>
<li>内核管理虚拟内存和物理内存</li>
<li>内核处理异常和中断的技术原理，以及系统调用的实现方式</li>
<li>保护临界区的互斥</li>
<li>虚拟文件系统</li>
</ul>
<h1 id="第1章-内核引导和初始化">第1章 内核引导和初始化<a hidden class="anchor" aria-hidden="true" href="#第1章-内核引导和初始化">#</a></h1>
<p> 处理器上电-&gt;执行引导程序-&gt;加载内核到内存-&gt;执行内核-&gt;内核初始化-&gt;启动用户空间第一个进程
 ARM64处理器到物理地址0取第一条指令</p>
<h2 id="11-引导程序">1.1 引导程序<a hidden class="anchor" aria-hidden="true" href="#11-引导程序">#</a></h2>
<h3 id="111-入口_start">1.1.1 入口_start<a hidden class="anchor" aria-hidden="true" href="#111-入口_start">#</a></h3>
<p> ARM64处理器U-Boot程序执行过程，入口<a href="https://elixir.bootlin.com/u-boot/latest/source/arch/arm/cpu/armv8/start.S#L20"><code>u-boot/arch/arm/cpu/armv8/start.S</code></a>标识<code>_start</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>.globl	_start
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/boot0-linux-kernel-header.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/arch/boot0.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b	reset
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><h3 id="112-reset">1.1.2 <code>reset</code><a hidden class="anchor" aria-hidden="true" href="#112-reset">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>reset:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Allow the board to save important registers */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 允许板卡保存重要的寄存器*/</span>
</span></span><span style="display:flex;"><span>	b	save_boot_params
</span></span><span style="display:flex;"><span>.globl	save_boot_params_ret
</span></span><span style="display:flex;"><span>save_boot_params_ret:
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SYS_RESET_SCTRL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl reset_sctrl   <span style="color:#75715e">// 初始化系统控制寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 异常级别可能是3、2或者1，初始状态：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 小端字节序，禁止MMU，禁止指令/数据缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>    adr  x0, vectors
</span></span><span style="display:flex;"><span>    witch_el x1, <span style="color:#ae81ff">3f</span>, <span style="color:#ae81ff">2f</span>, <span style="color:#ae81ff">1f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>  msr  vbar_el3, x0    <span style="color:#75715e">// 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mrs  x0, scr_el3   <span style="color:#75715e">// 设置安全配置寄存器SCR_EL3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    orr  x0, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>         <span style="color:#75715e">/* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */</span>
</span></span><span style="display:flex;"><span>    msr  scr_el3, x0
</span></span><span style="display:flex;"><span>    msr  cptr_el3, xzr           <span style="color:#75715e">/* 启用浮点和SIMD功能*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef COUNTER_FREQUENCY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>COUNTER_FREQUENCY
</span></span><span style="display:flex;"><span>    msr  cntfrq_el0, x0          <span style="color:#75715e">/* 初始化寄存器CNTFRQ */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>  msr   vbar_el2, x0   		<span style="color:#75715e">// 异常级别2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x33ff</span>
</span></span><span style="display:flex;"><span>    msr  cptr_el2, x0            <span style="color:#75715e">/* 启用浮点和SIMD功能 */</span>
</span></span><span style="display:flex;"><span>    b    <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>  msr    vbar_el1, x0
</span></span><span style="display:flex;"><span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>    msr  cpacr_el1, x0           <span style="color:#75715e">/* 启用浮点和SIMD功能 */</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 应用ARM处理器特定的勘误表*/</span>
</span></span><span style="display:flex;"><span>bl   apply_core_errata
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* 处理器特定的初始化*/</span>
</span></span><span style="display:flex;"><span>bl   lowlevel_init    <span style="color:#75715e">// 执行board_init_f()所需最小初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_ARMV8_SPIN_TABLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    branch_if_master x0, x1, master_cpu
</span></span><span style="display:flex;"><span>    b    spin_table_secondary_jump    <span style="color:#75715e">// arch/arm/cpu/armv8/spin_tabli.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/* 绝对不会返回*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_ARMV8_MULTIENTRY)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>branch_if_master x0, x1, master_cpu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 从处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>slave_cpu:
</span></span><span style="display:flex;"><span>    wfe
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x1, <span style="color:#f92672">=</span>CPU_RELEASE_ADDR 
</span></span><span style="display:flex;"><span>    ldr  x0, [x1]
</span></span><span style="display:flex;"><span>    cbz  x0, slave_cpu
</span></span><span style="display:flex;"><span>    br   x0               <span style="color:#75715e">/* 跳转到指定地址*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_ARMV8_MULTIENTRY */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>master_cpu:
</span></span><span style="display:flex;"><span>    bl   _main  <span style="color:#75715e">// 主处理器执行函数
</span></span></span></code></pre></div><p> U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序</p>
<h3 id="113-函数_main">1.1.3 函数_main<a hidden class="anchor" aria-hidden="true" href="#113-函数_main">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm/lib/crt0_64.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ENTRY(_main)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置初始的C语言运行环境，并且调用board_init_f(0)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>(CONFIG_SPL_STACK)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>(CONFIG_SYS_INIT_SP_ADDR)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bic  sp, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>   <span style="color:#75715e">/* 为了符合应用二进制接口规范，对齐到16字节*/</span>
</span></span><span style="display:flex;"><span>    mov  x0, sp
</span></span><span style="display:flex;"><span>    bl   board_init_f_alloc_reserve <span style="color:#75715e">// 在栈的顶部为结构体global_data分配空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  sp, x0
</span></span><span style="display:flex;"><span>    mov  x18, x0  <span style="color:#75715e">/* 设置gd */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 函数board_init_f_init_reserve，初始化结构体global_data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   board_init_f_init_reserve  
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    bl   board_init_f <span style="color:#75715e">// common/board_f.c 执行数组init_sequence_f中的每个函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if !defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// 设置中间环境（新的栈指针和gd），然后调用函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// relocate_code(addr_moni)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_START_ADDR_SP]    <span style="color:#75715e">/* 把寄存器x0设置为gd-&gt;start_addr_sp */</span>
</span></span><span style="display:flex;"><span>    bic  sp, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>             <span style="color:#75715e">/* 为了符合应用二进制接口规范，对齐到16字节 */</span>
</span></span><span style="display:flex;"><span>    ldr  x18, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_BD]       <span style="color:#75715e">/* 把寄存器x18设置为gd-&gt;bd */</span>
</span></span><span style="display:flex;"><span>    sub  x18, x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_SIZE       <span style="color:#75715e">/* 新的gd在bd的下面 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    adr  lr, relocation_return
</span></span><span style="display:flex;"><span>    ldr  x9, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOC_OFF]    <span style="color:#75715e">/* 把寄存器x9设置为gd-&gt;reloc_off */</span>
</span></span><span style="display:flex;"><span>    add  lr, lr, x9    <span style="color:#75715e">/* 在重定位后新的返回地址 */</span>
</span></span><span style="display:flex;"><span>    ldr  x0, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOCADDR]    <span style="color:#75715e">/* 把寄存器x0设置为gd-&gt;relocaddr */</span>
</span></span><span style="display:flex;"><span>    b    relocate_code
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>relocation_return:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置最终的完整环境
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">/* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/</span>
</span></span><span style="display:flex;"><span>    bl   c_runtime_cpu_setup  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* !CONFIG_SPL_BUILD */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   spl_relocate_stack_gd    <span style="color:#75715e">/* 可能返回空指针 重新定位栈*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行“sp = (x0 != NULL) ? x0 : sp”，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 规避这个约束：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 带条件的mov指令不能把栈指针寄存器作为操作数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  x1, sp
</span></span><span style="display:flex;"><span>    cmp  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    csel x0, x0, x1, ne
</span></span><span style="display:flex;"><span>    mov  sp, x0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用0初始化未初始化数据段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>__bss_start      <span style="color:#75715e">/* 这是自动重定位*/</span>
</span></span><span style="display:flex;"><span>    ldr  x1, <span style="color:#f92672">=</span>__bss_end        <span style="color:#75715e">/* 这是自动重定位*/</span>
</span></span><span style="display:flex;"><span>clear_loop:
</span></span><span style="display:flex;"><span>    str  xzr, [x0], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    cmp  x0, x1
</span></span><span style="display:flex;"><span>    b.lo clear_loop
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 调用函数board_init_r(gd_t *id, ulong dest_addr) */</span>
</span></span><span style="display:flex;"><span>    mov  x0, x18                     <span style="color:#75715e">/* gd_t */</span>
</span></span><span style="display:flex;"><span>    ldr  x1, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOCADDR]    <span style="color:#75715e">/* dest_addr */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */</span>
</span></span><span style="display:flex;"><span>    b    board_init_r   
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* 不会运行到这里，因为函数board_init_r()不会返回*/</span>
</span></span><span style="display:flex;"><span>ENDPROC(_main)
</span></span></code></pre></div><h3 id="114-函数run_main_loop">1.1.4 函数run_main_loop<a hidden class="anchor" aria-hidden="true" href="#114-函数run_main_loop">#</a></h3>
<p> 数组<code>init_sequence_r</code>最后一个函数<code>run_main_loop</code>，函数执行流程；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>run_main_loop
</span></span><span style="display:flex;"><span>    main_loop
</span></span><span style="display:flex;"><span>        bootdely_process <span style="color:#75715e"># 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量)</span>
</span></span><span style="display:flex;"><span>        autoboot_command
</span></span><span style="display:flex;"><span>            abortboot    <span style="color:#75715e"># 等待用户按键</span>
</span></span><span style="display:flex;"><span>            run_command_list  <span style="color:#75715e"># 未等待到按键，自动执行环境变量bootcmd</span>
</span></span></code></pre></div><p> <code>bootm</code>命令处理函数<code>do_bootm</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>do_bootm
</span></span><span style="display:flex;"><span>    do_bootm_states
</span></span><span style="display:flex;"><span>        bootm_start   <span style="color:#75715e"># 初始化全局变量bootm_header_timages</span>
</span></span><span style="display:flex;"><span>        bootm_find_os    <span style="color:#75715e"># 把内核镜像从存储设备读到内存</span>
</span></span><span style="display:flex;"><span>        bootm_find_other    <span style="color:#75715e"># ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件</span>
</span></span><span style="display:flex;"><span>        bootm_load_os  <span style="color:#75715e"># 解压病加载内核到正确位置</span>
</span></span><span style="display:flex;"><span>        bootm_os_get_boot_func  <span style="color:#75715e"># 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux</span>
</span></span><span style="display:flex;"><span>        do_bootm_linux<span style="color:#f92672">(</span>flag<span style="color:#f92672">=</span>BOOTM_STATE_OS_PREP<span style="color:#f92672">)</span>  <span style="color:#75715e"># 调用boot_prep_linux</span>
</span></span><span style="display:flex;"><span>            boot_prep_linux  <span style="color:#75715e"># 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件</span>
</span></span><span style="display:flex;"><span>        boot_selected_os  <span style="color:#75715e"># </span>
</span></span><span style="display:flex;"><span>            do_bootm_linux<span style="color:#f92672">(</span>flag<span style="color:#f92672">=</span>BOOTM_STATE_OS_GO<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                boot_jump_linux  <span style="color:#75715e"># 负责跳转到Linux内核</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>boot_jum_linux
</span></span><span style="display:flex;"><span>    do_nonsec_virt_switch
</span></span><span style="display:flex;"><span>        smp_kick_all_cpus  <span style="color:#75715e"># CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3</span>
</span></span><span style="display:flex;"><span>        dcache_disable  <span style="color:#75715e"># 禁用处理器的缓存和内存管理单元</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1</span>
</span></span><span style="display:flex;"><span>    armv8_switch_to_el2
</span></span><span style="display:flex;"><span>        switch_to_el1
</span></span><span style="display:flex;"><span>            armv8_switch_to_el1
</span></span><span style="display:flex;"><span>                内核入口
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在异常级别2执行内核</span>
</span></span><span style="display:flex;"><span>    armv8_switch_to_el2
</span></span><span style="display:flex;"><span>        内核入口
</span></span></code></pre></div><h2 id="12-内核初始化">1.2 内核初始化<a hidden class="anchor" aria-hidden="true" href="#12-内核初始化">#</a></h2>
<p> 内核初始化分为汇编语言部分和C语言部分</p>
<h3 id="121-汇编语言部分">1.2.1 汇编语言部分<a hidden class="anchor" aria-hidden="true" href="#121-汇编语言部分">#</a></h3>
<p> ARM64架构内核入口<code>_head</code>，直接跳转到标号<code>stext</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_head:
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_EFI   </span><span style="color:#75715e">// 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add  x13, x18, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x16</span>
</span></span><span style="display:flex;"><span>    b    stext
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    stext       <span style="color:#75715e">// 跳转到内核起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .long0           <span style="color:#75715e">// 保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p> <code>stext</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ENTRY(stext)
</span></span><span style="display:flex;"><span>    bl   preserve_boot_args  <span style="color:#75715e">// 把引导程序传递的4个参数保存在全局数组boot_args中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   el2_setup        <span style="color:#75715e">// 降级到异常级别1, 寄存器w0存放cpu_boot_mode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    adrp x23, __PHYS_OFFSET
</span></span><span style="display:flex;"><span>    and  x23, x23, MIN_KIMG_ALIGN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>    <span style="color:#75715e">// KASLR偏移，默认值是0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   set_cpu_boot_mode_flag  <span style="color:#75715e">// __boot_cpu_mode[2] 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   __create_page_tables  <span style="color:#75715e">// 创建页表映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 返回的时候，处理器已经为开启内存管理单元做好准备，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 转换控制寄存器已经设置好。*/</span>
</span></span><span style="display:flex;"><span>    bl    __cpu_setup        <span style="color:#75715e">// 初始化处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    __primary_switch  <span style="color:#75715e">// 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ENDPROC(stext)
</span></span></code></pre></div><br>
<ol>
<li>函数el2_setup</li>
</ol>
<blockquote>
<p>a.如果异常级别是1，那么在异常级别1执行内核。   <br>
b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。    <br>
1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。    \<br>
2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核      \</p>
</blockquote>
<p> 基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。       <br>
 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程           \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 打开KVM字符设备文件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/kvm&#34;</span>, O_RDWR);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vmfd <span style="color:#f92672">=</span> ioctl(fd, KVM_CREATE_VM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vcpu_fd <span style="color:#f92672">=</span> ioctl(vmfd, KVM_CREATE_VCPU, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p> 从QEMU切换到客户操作系统的过程如下。      <br>
 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。     <br>
 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。           <br>
 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。           <br>
 为了提高切换速度，<code>ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核</code>，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2      \</p>
<br>
<ol start="2">
<li>函数__create_page_tables</li>
</ol>
<blockquote>
<p>1）创建恒等映射，虚拟地址=物理地址<code>__enable_mmu</code>开启内存管理单元        <br>
2）为内核镜像创建映射             \</p>
</blockquote>
<p> 映射代码节<code>.idmap.text</code>,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址</p>
<br>
<ol start="3">
<li>函数__primary_switch</li>
</ol>
<blockquote>
<p>1）__enable_mmu开启内存管理单元            <br>
2）__primary_switched      <br>
 __enable_mmu执行流程     <br>
 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址     <br>
 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址        <br>
 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址    <br>
 __primary_switch执行流程      <br>
 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE)           <br>
 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体<code>thread_info</code>的地址(init_task.thread_info)        <br>
 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors)     <br>
 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中     <br>
 5）用0初始化内核的未初始化数据段      <br>
 6）调用C语言函数<code>start_kernel</code>      \</p>
</blockquote>
<br>
<h3 id="122-c语言部分">1.2.2 C语言部分<a hidden class="anchor" aria-hidden="true" href="#122-c语言部分">#</a></h3>
<p> 内核初始化的C语言部分入口是函数<code>start_kernel</code>，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数<code>rest_init</code>。函数rest_init的执行流程如下。   <br>
 （1）创建1号线程，即init线程，线程函数是kernel_init。     <br>
 （2）创建2号线程，即kthreadd线程，负责创建内核线程。     <br>
 （3）0号线程最终变成空闲线程。    \</p>
<p>init线程继续初始化，执行的主要操作如下。    <br>
 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。   <br>
 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。   <br>
 （3）smp_init()：初始化SMP系统，启动所有从处理器。   <br>
 （4）do_initcalls()：执行级别0～7的初始化。 <br>
 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。   <br>
 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。   <br>
 （7）free_initmem()：释放初始化代码和数据占用的内存。   <br>
 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。  \</p>
<p> 级别0～7的初始化，是指使用以下宏注册的初始化函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/init.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define pure_initcall(fn)           __define_initcall(fn, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define core_initcall(fn)           __define_initcall(fn, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define core_initcall_sync(fn)      __define_initcall(fn, 1s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define postcore_initcall(fn)       __define_initcall(fn, 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_initcall(fn)           __define_initcall(fn, 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define subsys_initcall(fn)         __define_initcall(fn, 4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fs_initcall(fn)             __define_initcall(fn, 5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rootfs_initcall(fn)         __define_initcall(fn, rootfs)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define device_initcall(fn)         __define_initcall(fn, 6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define device_initcall_sync(fn)    __define_initcall(fn, 6s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define late_initcall(fn)           __define_initcall(fn, 7)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define late_initcall_sync(fn)      __define_initcall(fn, 7s)
</span></span></span></code></pre></div><h3 id="123-smp系统的引导">1.2.3 SMP系统的引导<a hidden class="anchor" aria-hidden="true" href="#123-smp系统的引导">#</a></h3>
<p> 对称多处理器(Symmetirc Multi-Processor SMP)       <br>
 3种引导从处理器方法      \</p>
<ul>
<li>自旋表</li>
<li>电源状态协调接口</li>
<li>ACPI停车协议</li>
</ul>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/ARM64_SMP_spin_table.png" alt="ARM64架构下SMP系统的自旋表引导过程"  />
</p>
<h2 id="13-init进程">1.3 init进程<a hidden class="anchor" aria-hidden="true" href="#13-init进程">#</a></h2>
<p> init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有<code>sysvinit</code>、busybox init、upstart、<code>systemd</code>和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件<code>/etc/initab</code></p>
<br>
<h1 id="第2章-进程管理">第2章 进程管理<a hidden class="anchor" aria-hidden="true" href="#第2章-进程管理">#</a></h1>
<h2 id="21-进程">2.1 进程<a hidden class="anchor" aria-hidden="true" href="#21-进程">#</a></h2>
<p> Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间       <br>
 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。     <br>
 task_struct结构体是进程描述符，主要成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> state;    <span style="color:#75715e">// 进程状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>stack;            <span style="color:#75715e">// 指向内核栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pid_t pid;              <span style="color:#75715e">// 全局进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pid_t tgid              <span style="color:#75715e">// 全局的线程组标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> pid_link pid[PIDTYPE_MAX];   <span style="color:#75715e">// 进程号，进程组标识符和会话标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct _rcu <span style="color:#f92672">*</span>real_parent;   <span style="color:#75715e">// real_parent指向真实的父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct _rcu <span style="color:#f92672">*</span>parent;        <span style="color:#75715e">// parent指向父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>group_leader;   <span style="color:#75715e">// 指向进村组的组长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred _rcu <span style="color:#f92672">*</span>real_cred;  <span style="color:#75715e">// real_cred指向主题和真实客体证书
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred _rcu <span style="color:#f92672">*</span>cred;       <span style="color:#75715e">// cred指向客体证书
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> comm[TASK_COMM_LEN];           <span style="color:#75715e">// 进程名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> prio, static_prio, nornal_prio; <span style="color:#75715e">// 调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> rt_priority,prolicy<span style="color:#960050;background-color:#1e0010">；</span>  <span style="color:#75715e">// 优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>cpumask_t cpus_allowed;             <span style="color:#75715e">// 允许进程在哪些处理器上运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#f92672">*</span>active_mm;   <span style="color:#75715e">// 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> file_struct <span style="color:#f92672">*</span>files;          <span style="color:#75715e">// 打开文件表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>nsproxy;            <span style="color:#75715e">// 命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>signal;       <span style="color:#75715e">// 信号处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sigband_struct <span style="color:#f92672">*</span>sighand;
</span></span><span style="display:flex;"><span>sigset_t blocked, real_blocked;
</span></span><span style="display:flex;"><span>sigset_t saved_sigmask;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sigpending pending;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sysv_sem sysvsem;            <span style="color:#75715e">// UNIx系统5信号量和共享内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sysv_shm sysvshm;
</span></span></code></pre></div><h2 id="22-命名空间">2.2 命名空间<a hidden class="anchor" aria-hidden="true" href="#22-命名空间">#</a></h2>
<p> 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,容器仅仅是通过命名空间隔离？  \</p>
<table>
<thead>
<tr>
<th>命名空间</th>
<th>隔离资源</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>控制组cgroup</td>
<td>控制组根目录</td>
<td></td>
</tr>
<tr>
<td>进程间通信IPC</td>
<td>UNIX系统5进程间通信和POSIx消息队列</td>
<td></td>
</tr>
<tr>
<td>network</td>
<td>网络协议</td>
<td></td>
</tr>
<tr>
<td>挂载mount</td>
<td>挂载点</td>
<td></td>
</tr>
<tr>
<td>PID</td>
<td>进程号</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>用户标识符和组标识符</td>
<td></td>
</tr>
<tr>
<td>UNIX分时系统(UTS)</td>
<td>主机名和网络信息服务NIS域名</td>
<td></td>
</tr>
</tbody>
</table>
<p> 创建新的命名空间方法：   <br>
 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间   <br>
 调用unshare创建新的命名空间    <br>
 进程使用系统调用setns，绑定一个已经存在的命名空间</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/process_namespace.png" alt="进程的命名空间"  />
</p>
<p> 进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。</p>
<h2 id="23-进程标识符">2.3 进程标识符<a hidden class="anchor" aria-hidden="true" href="#23-进程标识符">#</a></h2>
<table>
<thead>
<tr>
<th>标识符</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>进程标识符</td>
<td>命名空间给进程分配标识符</td>
<td></td>
</tr>
<tr>
<td>线程组标识符</td>
<td>线程组中的主进程称为组长，线程组标识符就是组长的进程标识符<br>系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组</td>
<td></td>
</tr>
<tr>
<td>进程组标识符</td>
<td>进程组标识符是组长的进程标识符。<br>进程可以使用系统调用setpgid创建或者加入一个进程组</td>
<td></td>
</tr>
<tr>
<td>会话标识符</td>
<td>进程调用系统调用setsid的时候，创建一个新的会话</td>
<td></td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/pid_mark.png" alt="进程的命名空间"  />
</p>
<p> pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid    \</p>
<p> 进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，</p>
<h2 id="24-进程关系">2.4 进程关系<a hidden class="anchor" aria-hidden="true" href="#24-进程关系">#</a></h2>
<p> 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/process_relative.png" alt="进程的命名空间"  />
</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/tasks_table.png" alt="进程和线程链表"  />
</p>
<h2 id="25-启动程序">2.5 启动程序<a hidden class="anchor" aria-hidden="true" href="#25-启动程序">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> fork();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 父进程继续执行 */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 子进程装载程序 */</span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> execve(filename, argv, envp);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 创建子进程失败 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="251创建新进程">2.5.1　创建新进程<a hidden class="anchor" aria-hidden="true" href="#251创建新进程">#</a></h3>
<p> 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的
 两个个系统调用创建进程：    \</p>
<ul>
<li>fork：子进程是父进程的副本，用写时复制</li>
<li>clone：可控制子进程和父进程共享哪些资源</li>
<li>vfork：创建子进程，子进程用execve装载程序(已废弃)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 数字表示参数个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYSCALL_DEFINE0(fork)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏展开 asmlinkage表示C语言函数看被汇编代码调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">long</span> sys_fork(<span style="color:#66d9ef">void</span>)
</span></span></code></pre></div><p> 创建进程的进程p和被创建进程c三种关系</p>
<ul>
<li>新进程是进程p的子进程</li>
<li>clone传入CLONE_PARENT，兄弟关系</li>
<li>clone传入CLONE_THREAD，同属一个线程组</li>
</ul>
<h4 id="1-_do_fork函数">1. _do_fork函数<a hidden class="anchor" aria-hidden="true" href="#1-_do_fork函数">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">_do_fork</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_start,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_size,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>parent_tidptr,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>child_tidptr,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tls);  <span style="color:#75715e">// tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址
</span></span></span></code></pre></div><p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/_do_fork.png" alt="函数_do_fork的执行流程"  />
</p>
<p> 调用copy_process创建新进程  <br>
 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置   <br>
 wake_up_new_task唤醒新进程</p>
<h4 id="2-copy_process函数">2. copy_process函数<a hidden class="anchor" aria-hidden="true" href="#2-copy_process函数">#</a></h4>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030190536.png" alt="20221030190536"  />
</p>
<ul>
<li><strong>（1）标志组合</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CLONE_NEWNS &amp; CLONE_FS</td>
<td style="text-align:center">新进程属于新挂载命名空间<br>共享文件系统信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWUSER &amp; CLONE_FS</td>
<td style="text-align:center">新进程属于新用户命名空间<br>共享文件系统信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_THREAD <br> 未设置CLONE_SIGHAND</td>
<td style="text-align:center">新进程和当前进程同属一个线程组，<br>但不共享信号处理程序</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_SIGHAND <br> 未设置CLONE_VM</td>
<td style="text-align:center">新进程和当前进程共享信号处理程序，<br>但不共享虚拟内存</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>（2）dup_task_struct函数</strong>
 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈</li>
</ul>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030192206.png" alt="20221030192206"  title="进程的内核栈"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">union</span> thread_union {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct task;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_THREAD_INFO_IN_TASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> thread_info thread_info;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack[THREAD_SIZE<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 内核栈两种布局</p>
<ul>
<li>
<ol>
<li>thread_info在内核栈顶部，成员task指向进程描述符</li>
</ol>
</li>
<li>
<ol start="2">
<li>thread_info未占用内核栈
 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址
 内核栈的长度时<code>THREAD_SIZE</code>，<strong>ARM64架构内核栈长度为16KB</strong>
 thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/thread_info.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> thread_info {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>		flags;		<span style="color:#75715e">/* low level flags 底层标志位 */</span>
</span></span><span style="display:flex;"><span>	mm_segment_t		addr_limit;	<span style="color:#75715e">/* address limit 地址限制 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ARM64_SW_TTBR0_PAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	u64			ttbr0;		<span style="color:#75715e">/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    u64		preempt_count;	<span style="color:#75715e">/* 抢占计数器 0 =&gt; preemptible 可抢占, &lt;0 =&gt; bug缺陷 */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>
<p><strong>（3）copy_creds函数</strong>
 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1</p>
</li>
<li>
<p><strong>（4）检查线程数量限制</strong>
 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS</p>
</li>
<li>
<p><strong>（5）sched_fork函数</strong></p>
</li>
</ul>
<p> 为新进程设置调度器相关的参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c  书中为4.x版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_fork</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__sched_fork(clone_flags, p);   <span style="color:#75715e">// 执行基本设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We mark the process as NEW here. This guarantees that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * nobody will actually run it, and a signal or other external
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * event cannot wake it up and insert it on the runqueue either.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> TASK_NEW;    <span style="color:#75715e">// 新进程状态设置为TASK_NEW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Make sure we do not leak PI boosting priority to the child.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>prio <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>normal_prio;  <span style="color:#75715e">// 新进程调度优先级设置为当前进程正常优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	uclamp_fork(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Revert to default priority/policy on fork if requested.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(p<span style="color:#f92672">-&gt;</span>sched_reset_on_fork)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (task_has_dl_policy(p) <span style="color:#f92672">||</span> task_has_rt_policy(p)) { <span style="color:#75715e">// 限期进程或实时进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">=</span> SCHED_NORMAL;  <span style="color:#75715e">// 调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>static_prio <span style="color:#f92672">=</span> NICE_TO_PRIO(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// nice值默认值0，静态优先级120
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>rt_priority <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (PRIO_TO_NICE(p<span style="color:#f92672">-&gt;</span>static_prio) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 普通进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>static_prio <span style="color:#f92672">=</span> NICE_TO_PRIO(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// nice值默认值0，静态优先级120
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>prio <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>normal_prio <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>static_prio;
</span></span><span style="display:flex;"><span>		set_load_weight(p, false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * We don&#39;t need the reset flag anymore after the fork. It has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * fulfilled its duty:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_reset_on_fork <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (dl_prio(p<span style="color:#f92672">-&gt;</span>prio)) <span style="color:#75715e">// 调度优先级是限期调度累的优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;  <span style="color:#75715e">// 不允许限期进程分叉生成新的限期进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (rt_prio(p<span style="color:#f92672">-&gt;</span>prio))  <span style="color:#75715e">// 调度优先级是实时调度类优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		p<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rt_sched_class; <span style="color:#75715e">// 调度类设置为实时调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fair_sched_class;  <span style="color:#75715e">// 调度优先级是公平调度类的优先级，调度类设置为公平调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	init_entity_runnable_average(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>se);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SCHED_INFO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (likely(sched_info_on()))
</span></span><span style="display:flex;"><span>		memset(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>sched_info, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(p<span style="color:#f92672">-&gt;</span>sched_info));
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SMP)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>on_cpu <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	init_task_preempt_count(p);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	plist_node_init(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pushable_tasks, MAX_PRIO);
</span></span><span style="display:flex;"><span>	RB_CLEAR_NODE(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pushable_dl_tasks);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>（6）复制或共享资源</strong></li>
</ul>
<p> 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/ipc/sem.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_semundo</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sem_undo_list <span style="color:#f92672">*</span>undo_list;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SYSVSEM) {  <span style="color:#75715e">// CLONE_SYSTEM表示UNIX系统5信号量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		error <span style="color:#f92672">=</span> get_undo_list(<span style="color:#f92672">&amp;</span>undo_list);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (error)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>		refcount_inc(<span style="color:#f92672">&amp;</span>undo_list<span style="color:#f92672">-&gt;</span>refcnt); <span style="color:#75715e">// 5信号量的撤销请求链表，sem_undo_list 计数+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tsk<span style="color:#f92672">-&gt;</span>sysvsem.undo_list <span style="color:#f92672">=</span> undo_list;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		tsk<span style="color:#f92672">-&gt;</span>sysvsem.undo_list <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// 新进程5信号量撤销请求链表为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_files</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> files_struct <span style="color:#f92672">*</span>oldf, <span style="color:#f92672">*</span>newf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * A background process may not have any files ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	oldf <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>files;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>oldf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_FILES) { <span style="color:#75715e">// CLONE_FIELS共享打开文件表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		atomic_inc(<span style="color:#f92672">&amp;</span>oldf<span style="color:#f92672">-&gt;</span>count);  <span style="color:#75715e">// files_struct 计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	newf <span style="color:#f92672">=</span> dup_fd(oldf, NR_OPEN_MAX, <span style="color:#f92672">&amp;</span>error);  <span style="color:#75715e">// 新进程把当前进程的打开文件表复制一份
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>files <span style="color:#f92672">=</span> newf;
</span></span><span style="display:flex;"><span>	error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息     <br>
  函数copy_fs复制或共享文件系统信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_fs</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> fs_struct <span style="color:#f92672">*</span>fs <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>fs;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_FS) {  <span style="color:#75715e">// CLONE_FS共享文件系统信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">/* tsk-&gt;fs is already what we want */</span>
</span></span><span style="display:flex;"><span>		spin_lock(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fs<span style="color:#f92672">-&gt;</span>in_exec) {
</span></span><span style="display:flex;"><span>			spin_unlock(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		fs<span style="color:#f92672">-&gt;</span>users<span style="color:#f92672">++</span>;  <span style="color:#75715e">// fs_struct共享文件系统信息结构体 加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		spin_unlock(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>fs <span style="color:#f92672">=</span> copy_fs_struct(fs);  <span style="color:#75715e">// 新进程复制当前进程文件系统信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tsk<span style="color:#f92672">-&gt;</span>fs)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 <br>
  函数copy_sighand复制或共享信号处理程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_sighand</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sighand_struct <span style="color:#f92672">*</span>sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SIGHAND) {  <span style="color:#75715e">// CLONE_SIGHAND 表示共享信号处理程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		refcount_inc(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>count); <span style="color:#75715e">// 引用计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程复制当前进程信号处理程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sig <span style="color:#f92672">=</span> kmem_cache_alloc(sighand_cachep, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	RCU_INIT_POINTER(tsk<span style="color:#f92672">-&gt;</span>sighand, sig);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sig)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	refcount_set(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>count, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	spin_lock_irq(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>	memcpy(sig<span style="color:#f92672">-&gt;</span>action, current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>action, <span style="color:#66d9ef">sizeof</span>(sig<span style="color:#f92672">-&gt;</span>action));
</span></span><span style="display:flex;"><span>	spin_unlock_irq(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_CLEAR_SIGHAND)
</span></span><span style="display:flex;"><span>		flush_signal_handlers(tsk, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 5）信号结构体，同属一个线程组的线程才会共享信号结构体   <br>
  函数copy_signal复制或共享信号结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_signal</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_THREAD)  <span style="color:#75715e">// CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程分配结构体，初始化，继承当前进程资源限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sig <span style="color:#f92672">=</span> kmem_cache_zalloc(signal_cachep, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>signal <span style="color:#f92672">=</span> sig;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sig)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>nr_threads <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	atomic_set(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>live, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	refcount_set(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>sigcnt, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>thread_head <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> list_head)LIST_HEAD_INIT(tsk<span style="color:#f92672">-&gt;</span>thread_node);
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>thread_node <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> list_head)LIST_HEAD_INIT(sig<span style="color:#f92672">-&gt;</span>thread_head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	init_waitqueue_head(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>wait_chldexit);
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>curr_target <span style="color:#f92672">=</span> tsk;
</span></span><span style="display:flex;"><span>	init_sigpending(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>shared_pending);
</span></span><span style="display:flex;"><span>	INIT_HLIST_HEAD(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>multiprocess);
</span></span><span style="display:flex;"><span>	seqlock_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>stats_lock);
</span></span><span style="display:flex;"><span>	prev_cputime_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>prev_cputime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_POSIX_TIMERS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	INIT_LIST_HEAD(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>posix_timers);
</span></span><span style="display:flex;"><span>	hrtimer_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>real_timer.function <span style="color:#f92672">=</span> it_real_fn;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	task_lock(current<span style="color:#f92672">-&gt;</span>group_leader);
</span></span><span style="display:flex;"><span>	memcpy(sig<span style="color:#f92672">-&gt;</span>rlim, current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>rlim, <span style="color:#66d9ef">sizeof</span> sig<span style="color:#f92672">-&gt;</span>rlim);
</span></span><span style="display:flex;"><span>	task_unlock(current<span style="color:#f92672">-&gt;</span>group_leader);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	posix_cpu_timers_init_group(sig);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tty_audit_fork(sig);
</span></span><span style="display:flex;"><span>	sched_autogroup_fork(sig);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>oom_score_adj <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>oom_score_adj;
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>oom_score_adj_min <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>oom_score_adj_min;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	mutex_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>cred_guard_mutex);
</span></span><span style="display:flex;"><span>	init_rwsem(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>exec_update_lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存  \
  函数copy_mm复制或共享虚拟内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/freezer.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_mm</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#f92672">*</span>oldmm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> retval;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>min_flt <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>maj_flt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>nvcsw <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nivcsw <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_DETECT_HUNG_TASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tsk<span style="color:#f92672">-&gt;</span>last_switch_count <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nvcsw <span style="color:#f92672">+</span> tsk<span style="color:#f92672">-&gt;</span>nivcsw;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>last_switch_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Are we cloning a kernel thread?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We need to steal a active VM for that..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	oldmm <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>oldmm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* initialize the new vmacache entries */</span>
</span></span><span style="display:flex;"><span>	vmacache_flush(tsk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_VM) {  <span style="color:#75715e">// CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mmget(oldmm);
</span></span><span style="display:flex;"><span>		mm <span style="color:#f92672">=</span> oldmm;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> good_mm;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	retval <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程复制当前进程的虚拟内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mm <span style="color:#f92672">=</span> dup_mm(tsk, current<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> fail_nomem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>good_mm:
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>mm <span style="color:#f92672">=</span> mm;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fail_nomem:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> retval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 7）命名空间    <br>
  函数copy_namespace创建或共享命名空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/nsproxy.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_namespaces</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>old_ns <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nsproxy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> user_namespace <span style="color:#f92672">*</span>user_ns <span style="color:#f92672">=</span> task_cred_xxx(tsk, user_ns);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>new_ns;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果共享除了用户以外的所有其他命名空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (likely(<span style="color:#f92672">!</span>(flags <span style="color:#f92672">&amp;</span> (CLONE_NEWNS <span style="color:#f92672">|</span> CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWIPC <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			      CLONE_NEWPID <span style="color:#f92672">|</span> CLONE_NEWNET <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			      CLONE_NEWCGROUP <span style="color:#f92672">|</span> CLONE_NEWTIME)))) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (likely(old_ns<span style="color:#f92672">-&gt;</span>time_ns_for_children <span style="color:#f92672">==</span> old_ns<span style="color:#f92672">-&gt;</span>time_ns)) {
</span></span><span style="display:flex;"><span>			get_nsproxy(old_ns);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ns_capable(user_ns, CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 进程没有系统管理权限，那么不允许创建新的命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* CLONE_NEWIPC must detach from the undolist: after switching
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * to a new ipc namespace, the semaphore arrays from the old
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * means share undolist with parent, so we must forbid using
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * it along with CLONE_NEWIPC. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ((flags <span style="color:#f92672">&amp;</span> (CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_SYSVSEM)) <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>		(CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_SYSVSEM)) 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建新的命名空间代理，然后创建或者共享命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	new_ns <span style="color:#f92672">=</span> create_new_namespaces(flags, tsk, user_ns, tsk<span style="color:#f92672">-&gt;</span>fs);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (IS_ERR(new_ns))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>  PTR_ERR(new_ns);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> timens_on_fork(new_ns, tsk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret) {
</span></span><span style="display:flex;"><span>		free_nsproxy(new_ns);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>nsproxy <span style="color:#f92672">=</span> new_ns;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 8）I/O上下文    <br>
  函数copy_io创建或共享I/O上下文</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_io</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_BLOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> io_context <span style="color:#f92672">*</span>ioc <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>io_context;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_context <span style="color:#f92672">*</span>new_ioc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ioc)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Share io context with parent, if CLONE_IO is set */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_IO) {  <span style="color:#75715e">// CLONE_IO 共享I/O上小文
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ioc_task_link(ioc);  <span style="color:#75715e">// 计数nr_tasks加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tsk<span style="color:#f92672">-&gt;</span>io_context <span style="color:#f92672">=</span> ioc;  <span style="color:#75715e">// 共享I/O上下文结构体io_context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ioprio_valid(ioc<span style="color:#f92672">-&gt;</span>ioprio)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建新的I/O上下文，初始化，继承当前进程的I/O优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new_ioc <span style="color:#f92672">=</span> get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (unlikely(<span style="color:#f92672">!</span>new_ioc))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		new_ioc<span style="color:#f92672">-&gt;</span>ioprio <span style="color:#f92672">=</span> ioc<span style="color:#f92672">-&gt;</span>ioprio;
</span></span><span style="display:flex;"><span>		put_io_context(new_ioc);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 9）复制寄存器值   <br>
  函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030211811.png" alt="20221030211811"  />
</p>
<p>  ARM64架构copy_thread_tls-&gt;copy_thread</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/process.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_thread</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_start,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stk_sz, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>childregs <span style="color:#f92672">=</span> task_pt_regs(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	memset(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> cpu_context));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* In case p was allocated the same task_struct pointer as some
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * other recently-exited task, make sure p is disassociated from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * any cpu that may have run that now-exited task recently.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Otherwise we could erroneously skip reloading the FPSIMD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * registers for p. */</span>
</span></span><span style="display:flex;"><span>	fpsimd_flush_task_state(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ptrauth_thread_init_kernel(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (likely(<span style="color:#f92672">!</span>(p<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_KTHREAD))) {  <span style="color:#75715e">// 用户进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>childregs <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>current_pt_regs();
</span></span><span style="display:flex;"><span>		childregs<span style="color:#f92672">-&gt;</span>regs[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Read the current TLS pointer from tpidr_el0 as it may be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * out-of-sync with the saved value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 因为它可能和保存的值不一致 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>task_user_tls(p) <span style="color:#f92672">=</span> read_sysreg(tpidr_el0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (stack_start) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (is_compat_thread(task_thread_info(p)))
</span></span><span style="display:flex;"><span>				childregs<span style="color:#f92672">-&gt;</span>compat_sp <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				childregs<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* If a TLS pointer was passed to clone, use it for the new thread. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SETTLS)
</span></span><span style="display:flex;"><span>			p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.uw.tp_value <span style="color:#f92672">=</span> tls;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 内核线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		memset(childregs, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> pt_regs));
</span></span><span style="display:flex;"><span>		childregs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">=</span> PSR_MODE_EL1h;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (IS_ENABLED(CONFIG_ARM64_UAO) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    cpus_have_const_cap(ARM64_HAS_UAO))
</span></span><span style="display:flex;"><span>			childregs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">|=</span> PSR_UAO_BIT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		spectre_v4_enable_task_mitigation(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (system_uses_irq_prio_masking())
</span></span><span style="display:flex;"><span>			childregs<span style="color:#f92672">-&gt;</span>pmr_save <span style="color:#f92672">=</span> GIC_PRIO_IRQON;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.x19 <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.x20 <span style="color:#f92672">=</span> stk_sz;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.pc <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)ret_from_fork;
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.sp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)childregs;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ptrace_hw_copy_thread(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>（7）设置进程号和进程关系</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __latent_entropy <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">copy_process</span>(
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> pid <span style="color:#f92672">*</span>pid,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> trace,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> node,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> kernel_clone_args <span style="color:#f92672">*</span>args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程分配进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>init_struct_pid) {
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> alloc_pid(p<span style="color:#f92672">-&gt;</span>nsproxy<span style="color:#f92672">-&gt;</span>pid_ns_for_children);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (IS_ERR(pid)) {
</span></span><span style="display:flex;"><span>            retval <span style="color:#f92672">=</span> PTR_ERR(pid);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> bad_fork_cleanup_thread;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置新进程退出时发送给父进程的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>pid <span style="color:#f92672">=</span> pid_nr(pid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_THREAD) {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 新线程退出时不需要发送信号给父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>group_leader <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>group_leader;  <span style="color:#75715e">// group_leader指向同一个组长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>tgid <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>tgid;  <span style="color:#75715e">// tgid存放组长的进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_PARENT) <span style="color:#75715e">// CLONE_PARENT 新进程和当前进程是兄弟关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>group_leader<span style="color:#f92672">-&gt;</span>exit_signal;  <span style="color:#75715e">// 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">// 父子关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> (clone_flags <span style="color:#f92672">&amp;</span> CSIGNAL); <span style="color:#75715e">// 新进程的成员exit_signal是调用者指定的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>group_leader <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>tgid <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>pid;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 控制组的进程数控制器检查是否允许创建新进程：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 从当前进程所属的控制组一直到控制组层级的根，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果其中一个控制组的进程数量大于或等于限制，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 那么不允许使用fork和clone创建新进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cgroup_threadgroup_change_begin(current);
</span></span><span style="display:flex;"><span>    retval <span style="color:#f92672">=</span> cgroup_can_fork(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (retval)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> bad_fork_free_pid;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    write_lock_irq(<span style="color:#f92672">&amp;</span>tasklist_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程设置父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> (CLONE_PARENT<span style="color:#f92672">|</span>CLONE_THREAD)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 新进程和当前进程拥有相同的父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>real_parent <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>real_parent;  
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>parent_exec_id <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>parent_exec_id;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>real_parent <span style="color:#f92672">=</span> current;  <span style="color:#75715e">// 新进程的父进程是当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>parent_exec_id <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>self_exec_id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    spin_lock(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (likely(p<span style="color:#f92672">-&gt;</span>pid)) {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>        init_task_pid(p, PIDTYPE_PID, pid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (thread_group_leader(p)) {  <span style="color:#75715e">// true 新进程和当前进程属于同一个进程组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));  <span style="color:#75715e">// 指向同一个进程组的组长的进程号结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            init_task_pid(p, PIDTYPE_SID, task_session(current));  <span style="color:#75715e">// 指向同一个会话的控制进程的进程号结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (is_child_reaper(pid)) {  
</span></span><span style="display:flex;"><span>                ns_of_pid(pid)<span style="color:#f92672">-&gt;</span>child_reaper <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>                p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|=</span> SIGNAL_UNKILLABLE;  <span style="color:#75715e">// 1号进程是不能杀死的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>leader_pid <span style="color:#f92672">=</span> pid;
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>tty <span style="color:#f92672">=</span> tty_kref_get(current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>tty);
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>has_child_subreaper <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span> has_child_subreaper <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                                p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>is_child_subreaper;
</span></span><span style="display:flex;"><span>            list_add_tail(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>sibling, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>children);  <span style="color:#75715e">// 新进程添加到父进程的子进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 新进程添加到进程链表中，链表节点是成员tasks，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 头节点是空闲线程的成员tasks（init_task.tasks）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            list_add_tail_rcu(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>tasks, <span style="color:#f92672">&amp;</span>init_task.tasks);  
</span></span><span style="display:flex;"><span>            attach_pid(p, PIDTYPE_PGID);  <span style="color:#75715e">// 新进程添加到进程组的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            attach_pid(p, PIDTYPE_SID);  <span style="color:#75715e">// 新进程添加到会话的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            __this_cpu_inc(process_counts);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>nr_threads<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 线程组的线程计数值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            atomic_inc(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>live);  <span style="color:#75715e">// 原子变量线程组的第2个线程计数值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            atomic_inc(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>sigcnt);  <span style="color:#75715e">// 信号结构体的引用计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            list_add_tail_rcu(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>thread_group,    
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>group_leader<span style="color:#f92672">-&gt;</span>thread_group);  <span style="color:#75715e">// 线程加入线程组的线程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            list_add_tail_rcu(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>thread_node,
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>thread_head);  <span style="color:#75715e">// 线程加入线程组的第二条线程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        attach_pid(p, PIDTYPE_PID);  <span style="color:#75715e">// 新进程添加到进程号结构体的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        nr_threads<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 新进程添加到进程号结构体的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    total_forks<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    spin_unlock(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    write_unlock_irq(<span style="color:#f92672">&amp;</span>tasklist_lock);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    proc_fork_connector(p);
</span></span><span style="display:flex;"><span>    cgroup_post_fork(p);
</span></span><span style="display:flex;"><span>    cgroup_threadgroup_change_end(current);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3唤醒新进程">3.唤醒新进程<a hidden class="anchor" aria-hidden="true" href="#3唤醒新进程">#</a></h4>
<p> wake_up_new_task函数唤醒新进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wake_up_new_task</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq_flags rf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	raw_spin_lock_irqsave(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pi_lock, rf.flags);
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> TASK_RUNNING;  <span style="color:#75715e">// 切换TASK_RUNNING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Fork balancing, do it here and not earlier because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  - cpus_ptr can change in the fork path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  - any previously selected CPU might disappear through hotplug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * as we&#39;re not fully set-up yet.*/</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>recent_used_cpu <span style="color:#f92672">=</span> task_cpu(p);
</span></span><span style="display:flex;"><span>	rseq_migrate(p);
</span></span><span style="display:flex;"><span>	__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, <span style="color:#ae81ff">0</span>));  <span style="color:#75715e">// 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	rq <span style="color:#f92672">=</span> __task_rq_lock(p, <span style="color:#f92672">&amp;</span>rf);  <span style="color:#75715e">// 锁住运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	update_rq_clock(rq);  <span style="color:#75715e">// 更新运行队列的时钟
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	post_init_entity_util_avg(p);  <span style="color:#75715e">// 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	activate_task(rq, p, ENQUEUE_NOCLOCK); <span style="color:#75715e">// 把新进程插入运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	trace_sched_wakeup_new(p);
</span></span><span style="display:flex;"><span>	check_preempt_curr(rq, p, WF_FORK);  <span style="color:#75715e">// 检查新进程是否可以抢占当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_woken) {  <span style="color:#75715e">// 在SMP系统上，调用调度类的task_woken方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Nothing relies on rq-&gt;lock after this, so its fine to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * drop it.*/</span>
</span></span><span style="display:flex;"><span>		rq_unpin_lock(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_woken(rq, p);
</span></span><span style="display:flex;"><span>		rq_repin_lock(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	task_rq_unlock(rq, p, <span style="color:#f92672">&amp;</span>rf);  <span style="color:#75715e">// 释放运行队列的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="4新进程第一次运行">4.新进程第一次运行<a hidden class="anchor" aria-hidden="true" href="#4新进程第一次运行">#</a></h4>
<p> 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tsk   .req   x28      <span style="color:#75715e">//当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYM_CODE_START(ret_from_fork)
</span></span><span style="display:flex;"><span>	bl	schedule_tail  <span style="color:#75715e">// 为上一个进程执行清理操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cbz	x19, <span style="color:#ae81ff">1f</span>  <span style="color:#75715e">// not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mov	x0, x20  <span style="color:#75715e">// 内核线程：x19存放线程函数的地址，x20存放线程函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	blr	x19  <span style="color:#75715e">// 调用线程函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>	get_current_task tsk  <span style="color:#75715e">// 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b	ret_to_user  <span style="color:#75715e">// 返回用户模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYM_CODE_END(ret_from_fork)
</span></span><span style="display:flex;"><span>NOKPROBE(ret_from_fork)
</span></span></code></pre></div><p>  copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0   <br>
  </p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage __visible <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">schedule_tail</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span>	__releases(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* New tasks start with FORK_PREEMPT_COUNT, see there and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task_switch() for details.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task_switch() will drop rq-&gt;lock() and lower preempt_count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * and the preempt_enable() will end up enabling preemption (on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * PREEMPT_COUNT kernels).*/</span>
</span></span><span style="display:flex;"><span>	rq <span style="color:#f92672">=</span> finish_task_switch(prev);  <span style="color:#75715e">// 为上一个进程执行清理操作2.8.6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	balance_callback(rq);  <span style="color:#75715e">// 执行运行队列的所有负载均衡回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	preempt_enable();  <span style="color:#75715e">// 开启内核抢占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>set_child_tid)  <span style="color:#75715e">// pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		put_user(task_pid_vnr(current), current<span style="color:#f92672">-&gt;</span>set_child_tid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	calculate_sigpending();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="252-装载程序">2.5.2 装载程序<a hidden class="anchor" aria-hidden="true" href="#252-装载程序">#</a></h3>
<p> 调度器调度新进程，新进程从函数<code>ret_from_fork</code>开始，从系统调用<code>fork</code>返回用户空间，返回值0。然后新进程使用系统调用<code>execve</code>装载程序。Linux内核练个装载程序系统调用：    \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 路径名是相对时execve解释为相对调用进程的当前工作目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">execve</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> argv[], <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> envp[]);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 路径名时绝对的，execveat忽略参数dirfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">execveat</span>(<span style="color:#66d9ef">int</span> dirfd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pathname, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> argv[], <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> envp[], <span style="color:#66d9ef">int</span> flags);
</span></span></code></pre></div><p>  参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值</p>
<p> 两个系统调用最终都调用函数do_execveat_common
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221102001015.png" alt="20221102001015"  />
</p>
<p>  函数do_open_execat打开可执行文件。   <br>
  函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器      <br>
  函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-&gt;p指向在栈底保留一个字长（指针长度）后的位置           <br>
  函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？      \
  依次把文件名称、环境字符串和参数字符串压到用户栈         <br>
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221102001840.png" alt="20221102001840"  />

  函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止</p>
<h4 id="1二进制格式">1.二进制格式<a hidden class="anchor" aria-hidden="true" href="#1二进制格式">#</a></h4>
<p> Linux二进制格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/include/linux/binfmts.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> linux_binfmt {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head lh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> module <span style="color:#f92672">*</span>module;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>load_binary)(<span style="color:#66d9ef">struct</span> linux_binprm <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>load_shlib)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>core_dump)(<span style="color:#66d9ef">struct</span> coredump_params <span style="color:#f92672">*</span>cprm);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> min_coredump;	<span style="color:#75715e">/* minimal dump size */</span>
</span></span><span style="display:flex;"><span>} __randomize_layout;
</span></span></code></pre></div><p> 二进制格式提供3个函数        <br>
  (1)load_binary 加载普通程序       <br>
  (2)load_shlib 加载共享库     <br>
  (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度     <br>
 二进制格式使用<code>register_binfmt</code>向内核注册</p>
<h4 id="2装载elf程序">2.装载ELF程序<a hidden class="anchor" aria-hidden="true" href="#2装载elf程序">#</a></h4>
<p> ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 <code>linux-5.10.102/include/uapi/linux/elf.h</code></p>
<ul>
<li>目标文件(可重定位文件)，<code>.o</code>，多个模板文件链接生成可执行文件或共享库</li>
<li>可执行文件</li>
<li>共享库 <code>.so</code></li>
<li>核心转储文件(core dump file)</li>
</ul>
<p> ELF文件分成4部分：<code>ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)</code>，ELF只有首部的位置是固定的。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103105503.png" alt="20221103105503"  />
</p>
<p>  程序首部表就是段表(segment table)，<code>段(segment)是从运行角度描述</code>，<code>节(section)是从链接角度描述</code>。    <br>
 64位ELF文件格式</p>
<p>参考链接：
ELF 格式详解 <a href="https://blog.csdn.net/shanandqiu/article/details/115206426">https://blog.csdn.net/shanandqiu/article/details/115206426</a>     <br>
ELF文件格式简介  <a href="https://blog.csdn.net/GrayOnDream/article/details/124564129">https://blog.csdn.net/GrayOnDream/article/details/124564129</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 查看ELF首部</span>
</span></span><span style="display:flex;"><span>readelf -h &lt;ELF文件&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看程序首部表</span>
</span></span><span style="display:flex;"><span>readelf -l &lt;ELF文件&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看节首部表</span>
</span></span><span style="display:flex;"><span>readelf -S &lt;ELF文件&gt;
</span></span></code></pre></div><p> ELF解析程序  <br>
  <code>linux-5.10.102/fs/binfmt_elf.c</code> 解析64位ELF程序，和处理器架构无关 <br>
  <code>linux-5.10.102/fs/compat_binfmt_elf.c</code>  在64位内核中解析32位ELF程序，和处理器架构无   \</p>
<p> 装载ELF程序函数<code>load_elf_binary</code></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103112822.png" alt="20221103112822"  />
</p>
<p>  1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构
  2）读取程序首部表
  3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。
  4）检查解释器的ELF首部，读取解释器的程序首部表
  5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间
  6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域
  7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈
  8）把可加载段映射到进程的虚拟地址空间
  9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段
  10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口
  11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈
  12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/processor.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread_common</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pc)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	memset(regs, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>regs));
</span></span><span style="display:flex;"><span>	forget_syscall(regs);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">=</span> pc; <span style="color:#75715e">/* 把程序计数器设置为程序的入口 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pc,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	start_thread_common(regs, pc);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">=</span> PSR_MODE_EL0t;  <span style="color:#75715e">/* 把处理器状态设置为0，其中异常级别是0 */</span>
</span></span><span style="display:flex;"><span>	spectre_v4_enable_task_mitigation(current);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> sp;   <span style="color:#75715e">/*设置用户栈指针 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3装载脚本程序">3.装载脚本程序<a hidden class="anchor" aria-hidden="true" href="#3装载脚本程序">#</a></h4>
<p> 脚本程序前两个字节是<code>#!</code>，后面是解释器程序的名称和参数。解释器用来执行脚本程序
 <code>linux-5.10.102/fs/binfmt_script.c</code>函数<code>load_script</code>负责装载脚本程序</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103141127.png" alt="20221103141127"  />
</p>
<p>  1）检查前两个字节是不是脚本程序的标识符    <br>
  2）解析处解释程序的名称和参数      <br>
  3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈      <br>
  4）调用opens_exec打开解释程序文件       <br>
  5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区        <br>
  6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止     \</p>
<h2 id="26-进程退出">2.6 进程退出<a hidden class="anchor" aria-hidden="true" href="#26-进程退出">#</a></h2>
<p> 进程退出两种情况：进程主动退出和终止进程    <br>
 Linux内核两个主动退出的系统调用       \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exit</span>(<span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个线程组所有线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exit_group</span>(<span style="color:#66d9ef">int</span> status);
</span></span></code></pre></div><p> glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数        <br>
  终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给进程或进程组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kill</span>(pid_t pid, <span style="color:#66d9ef">int</span> sig);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给线程  已废弃
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tkill</span>(<span style="color:#66d9ef">int</span> tid, <span style="color:#66d9ef">int</span> sig);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tgkill</span>(<span style="color:#66d9ef">int</span> tgid, <span style="color:#66d9ef">int</span> tid, <span style="color:#66d9ef">int</span> sig);
</span></span></code></pre></div><p> 父进程是否关注子进程退出事假，
  1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。进程默认关注子进程退出事件，通过系统调用sigaction对信号SIGHLD设置标志SA_NOCLDWAIT(CLD是child)，子进程退出时不变成僵尸进程或设置忽略信号SIGCHLD    <br>
  2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 <br>
 Linux内核3个系统调用等待子进程状态改变：子进程终止、信号SIGSTOP使子进程停止执行或信号SIGCONT使子进程继续执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>pid_t <span style="color:#a6e22e">waitpid</span>(pid_t pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>wstatus, <span style="color:#66d9ef">int</span> options);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">waitid</span>(idtype_t idtype, id_t id, siginfo_t <span style="color:#f92672">*</span>infop, <span style="color:#66d9ef">int</span> options);
</span></span><span style="display:flex;"><span>pit_t <span style="color:#a6e22e">wiat4</span>(pit_t pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>wstatus, <span style="color:#66d9ef">int</span> options, staruct usage <span style="color:#f92672">*</span>rusage);  <span style="color:#75715e">// 废弃
</span></span></span></code></pre></div><p> 父进程退出时，给子进程寻找领养者
  1）进程属于一个线程组，且还有其他线程，选择任意其他线程   <br>
  2）选择最亲近的充当&quot;替补领养者&quot;的祖先进程，进程使用系统调用prtctl(PR_SET_CHILD_SUBREAPER)设置为替换领养者     <br>
  3）选择所属进程号命名空间的1号进程      <br>
  </p>
<h3 id="261-线程组退出-exit_group">2.6.1 线程组退出 exit_group<a hidden class="anchor" aria-hidden="true" href="#261-线程组退出-exit_group">#</a></h3>
<p>  系统调用exit_group执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103145928.png" alt="20221103145928"  />
</p>
<p> 一个线程组的两个线程，线程1和线程2，线程1调用exit_group使线程组退出，线程1执行流程：
 1）把退出码保存在结构体成员group_exit_code中，传递给线程2    <br>
 2）给线程组设置正在退出标志     <br>
 3）向线程2发送杀死信号，唤醒线程2，线程2处理杀死信号    <br>
 4）线程1调用函数do_exit以退出    <br>
 线程2退出的执行流程，函数do_group_exit执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103151545.png" alt="20221103151545"  />
</p>
<p> 线程2可能发挥用户模式3种情况
 （1）执行完系统调用      <br>
 （2）被中断抢占，中断处理程序执行完    <br>
 （3）执行指令是生成异常，异常处理程序执行完     \</p>
<p> do_exit函数执行流程
 （1）释放各种资源，把资源引用计数减一，如果引用计数变为0，则释放数据结构   <br>
 （2）调用函数exit_notify，为子进程选择领养者，然后把自己死讯通知父进程   <br>
 （3）把进程状态设置为死亡(TASK_DEAD)     <br>
 （4）最后一次调用函数__schedule以调度进程    <br>
 死亡进程调用__schedule时进程调度器处理流程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>__schedule() <span style="color:#f92672">--&gt;</span> context_switch() <span style="color:#f92672">--&gt;</span> finish_task_switch()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>finish_task_switch(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span> __releases(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	prev_state <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>state;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(prev_state <span style="color:#f92672">==</span> TASK_DEAD)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_dead)
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_dead(prev);  <span style="color:#75715e">// 执行调度类task_dead
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果结构体thread_info放在进程描述符里面，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 而不是放在内核栈的顶部，那么释放进程的内核栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		put_task_stack(prev);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		put_task_struct(prev);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="262-终止进程">2.6.2 终止进程<a hidden class="anchor" aria-hidden="true" href="#262-终止进程">#</a></h3>
<p> 系统调用kill向线程组或进程组发送信号linux-5.10.102/kernel/signal.c，执行流程
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103154752.png" alt="20221103154752"  />
</p>
<p> 函数__send_signal主要代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/signal.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__send_signal</span>(<span style="color:#66d9ef">int</span> sig, <span style="color:#66d9ef">struct</span> siginfo <span style="color:#f92672">*</span>info, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>t,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> group, <span style="color:#66d9ef">int</span> from_ancestor_ns)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sigpending <span style="color:#f92672">*</span>pending;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sigqueue <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> override_rlimit;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> TRACE_SIGNAL_IGNORED;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 目标线程忽略信号,不发送信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prepare_signal(sig, t,
</span></span><span style="display:flex;"><span>			from_ancestor_ns <span style="color:#f92672">||</span> (info <span style="color:#f92672">==</span> SEND_SIG_FORCED)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> ret;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 确定把信号添加到哪个信号队列和集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pending <span style="color:#f92672">=</span> group <span style="color:#f92672">?</span> <span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>shared_pending : <span style="color:#f92672">&amp;</span>t<span style="color:#f92672">-&gt;</span>pending;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> TRACE_SIGNAL_ALREADY_PENDING;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 传统信号，并且信号集合已经包含同一个信号,不发送
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (legacy_queue(pending, sig))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断分配信号队列节点时是否可以忽略信号队列长度的限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (sig <span style="color:#f92672">&lt;</span> SIGRTMIN)
</span></span><span style="display:flex;"><span>		override_rlimit <span style="color:#f92672">=</span> (is_si_special(info) <span style="color:#f92672">||</span> info<span style="color:#f92672">-&gt;</span>si_code <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		override_rlimit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 分配一个信号队列节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	q <span style="color:#f92672">=</span> __sigqueue_alloc(sig, t, GFP_ATOMIC <span style="color:#f92672">|</span> __GFP_NOTRACK_FALSE_POSITIVE,
</span></span><span style="display:flex;"><span>		override_rlimit);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (q) {
</span></span><span style="display:flex;"><span>		list_add_tail(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>list, <span style="color:#f92672">&amp;</span>pending<span style="color:#f92672">-&gt;</span>list); <span style="color:#75715e">// 添加到信号队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_si_special(info)) {
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out_set:
</span></span><span style="display:flex;"><span>	signalfd_notify(t, sig);
</span></span><span style="display:flex;"><span>	sigaddset(<span style="color:#f92672">&amp;</span>pending<span style="color:#f92672">-&gt;</span>signal, sig);  <span style="color:#75715e">// 信号添加到信号集合中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 在线程组中查找一个没有屏蔽信号的线程，唤醒它，让它处理信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	complete_signal(sig, t, group); 
</span></span><span style="display:flex;"><span>ret:
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="263-查询子进程终止原因">2.6.3 查询子进程终止原因<a hidden class="anchor" aria-hidden="true" href="#263-查询子进程终止原因">#</a></h3>
<p> 系统调用waitid</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">waitid</span>(idtype_t idtype, id_t id, siginfo_t <span style="color:#f92672">*</span>infop, <span style="color:#66d9ef">int</span> options);
</span></span><span style="display:flex;"><span>pid_t <span style="color:#a6e22e">waitpid</span>(pid_t pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>wstatus, <span style="color:#66d9ef">int</span> options);
</span></span></code></pre></div><table>
	<tr>
	    <th>参数</th>
	    <th>参数值</th>
	    <th>含义</th>  
	</tr >
	<tr >
	    <td rowspan="3">idtype</td>
	    <td>P_ALL</td>
	    <td>等待任意子进程，忽略参数id</td>
	</tr>
	<tr>
	    <td>P_PID</td>
	    <td>等待进程号为id的子进程</td>
	</tr>
	<tr>
	    <td>P_PGID</td>
	    <td>等待进程组标识符是id的任意子进程</td>
	</tr>
	<tr >
	    <td rowspan="5">options</td>
	    <td>WEXITED</td>
	    <td>等待退出的子进程</td>
	</tr>
	<tr>
	    <td >WSTOPPED</td>
	    <td>等待收到信号SIGSTOP并停止执行的子进程</td>
	</tr>
	<tr>
	    <td >WCONTINUED</td>
	    <td >等待收到信号SIGCONT并继续执行的子进程</td>
	</tr>
	<tr>
	    <td >WNOHANG</td>
	    <td >如果没有子进程退出，立即返回</td>
	</tr>
	<tr>
	    <td >WNOWAIT</td>
	    <td >让子进程处于僵尸状态，以后可以再次查询状态信息</td>
	</tr>
</table>
<p> do_wait函数执行流程</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103162302.png" alt="20221103162302"  />
</p>
<h2 id="27-进程状态">2.7 进程状态<a hidden class="anchor" aria-hidden="true" href="#27-进程状态">#</a></h2>
<table>
	<tr>
	    <th>状态</th>
	    <th>state</th>
	    <th>含义</th>  
	</tr >
	<tr >
	    <td>就绪状态</td>
	    <td>TASK_RUNNING</td>
	    <td>正在运行队列中等待调度器调度</td>
	</tr>
	<tr>
	    <td>运行状态</td>
	    <td>TASK_RUNNING</td>
	    <td>被调度器选中，正在处理器上运行</td>
	</tr>
	<tr>
	    <td>轻度睡眠</td>
	    <td>TASK_INTERRUPTIBLE</td>
	    <td>可信号打断的睡眠状态</td>
	</tr>
	<tr >
	    <td>中度睡眠</td>
	    <td>TASK_KILLABLE</td>
	    <td>只能被致命的信号打断</td>
	</tr>
	<tr>
	    <td>深度睡眠</td>
	    <td>TASK_UNINTERRUPTIBLE</td>
	    <td>不可打断的睡眠状态</td>
	</tr>
	<tr>
	    <td>僵尸状态</td>
	    <td>TASK_DEAD</td>
	    <td>被调度器选中，正在处理器上运行</td>
	</tr>
	<tr>
	    <td>死亡状态</td>
	    <td>TASK_DEAD</td>
	    <td>如果父进程不关注子进程退出事件，那么子进程退出时自动消亡</td>
	</tr>
</table>
<p> 进程状态变迁
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103163416.png" alt="20221103163416"  />
</p>
<h2 id="28-进程调度">2.8 进程调度<a hidden class="anchor" aria-hidden="true" href="#28-进程调度">#</a></h2>
<h3 id="281-调度策略">2.8.1 调度策略<a hidden class="anchor" aria-hidden="true" href="#281-调度策略">#</a></h3>
<p> Linux内核支持的调度策略
 （1）限制进程使用限期调度策略(SCHED_DEADLINE)，3个参数：运行时间runtime，截止期限deadline和周期period    <br>
 （2）实时进程支持两种调度策略：先进先出调度(SCHED_FIFO)和轮流调度(SCHED_RR)   <br>
 （3）普通进程两种调度策略：标准轮流分时(SCHED_NORMAL)和空闲(SCHED_BATCH)，Linux内核引入完全公平调度算法后，批量调度策略废弃。     \</p>
<h3 id="282-进程优先级">2.8.2 进程优先级<a hidden class="anchor" aria-hidden="true" href="#282-进程优先级">#</a></h3>
<p> 限期进程的优先级比实时进程高，实时进程的优先级比普通进程高。  <br>
 限期进程的优先级是−1。        <br>
 实时进程的实时优先级是1～99，优先级数值越大，表示优先级越高。    <br>
 普通进程的静态优先级是100～139，优先级数值越小，表示优先级越高，可通过修改nice值（即相对优先级，取值范围是−20～19）改变普通进程的优先级，优先级等于120加上nice值   <br>
 task_struct中，4个成员和优先级有关   \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>sched.h
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> task_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>                  prio;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>                  static_prio;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>                  normal_prio;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>         rt_priority;
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><table>
	<tr>
	    <th>优先级</th>
	    <th>限期进程</th>
	    <th>实时进程</th>  
	    <th>普通进程</th>  
	</tr >
	<tr >
	    <td>prio<br>调度优先级(数值越小，表示优先级越高)</td>
	    <td colspan="3">大多数prio等于normal_prio</td>
	</tr>
	<tr>
	    <td>static_prio<br>静态优先级</td>
	    <td>总是0</td>
	    <td>总是0</td>
	    <td>120 + nice值数值越小，<br>表示优先级越高</td>
	</tr>
	<tr>
	    <td>normal_prio<br>正常优先级(数值越小，表示优先级越高)</td>
	    <td>-1</td>
	    <td>99 − rt_priority</td>
	    <td>static_prio</td>
	</tr>
		<tr>
	    <td>实时优先级</td>
	    <td>总是0</td>
	    <td>值越大，优先级越高</td>
	    <td> </td>
	</tr>
</table>
<h3 id="283-调度类">2.8.3 调度类<a hidden class="anchor" aria-hidden="true" href="#283-调度类">#</a></h3>
<p> Linux内核抽象一个调度类<code>sched_class</code>，目前实现5种调度类，优先级从上到下从高到低：</p>
<table>
	<tr>
	    <th>调度类</th>
	    <th>调度策略</th>
	    <th>调度算法</th>  
	    <th>调度对象</th>  
	</tr >
	<tr >
	    <td>停机调度类<br>stop_sched_class</td>
	    <td>无</td>
	    <td>无</td>
	    <td>停机进程</td>
	</tr>
	<tr>
	    <td>限期调度类<br>dl_sched_class</td>
	    <td>SCHED_DEADLINE</td>
	    <td>最早期限优先</td>
	    <td>限期进程</td>
	</tr>
	<tr>
	    <td>实时调度类<br>rt_sched_class</td>
	    <td>SCHED_FIFO<br>SCHED_RR</td>
	    <td>先进先出<br>轮流调度</td>
	    <td>实时进程</td>
	</tr>
		<tr>
	    <td>公平调度类<br>cfs_sched_class</td>
	    <td>SCHED_NORMAL<br>SCHED_IDIE</td>
	    <td>完全公平调度算法</td>
	    <td>普通进程</td>
	</tr>
	</tr>
		<tr>
	    <td>空闲调度类<br>idle_sched_class</td>
	    <td>无</td>
	    <td>无</td>
	    <td>每个处理器上的空闲线程</td>
	</tr>
</table>
<p> 详细信息参考书籍</p>
<h3 id="284-运行队列">2.8.4 运行队列<a hidden class="anchor" aria-hidden="true" href="#284-运行队列">#</a></h3>
<p> 每个处理器有一个运行队列，结构体rq，定义全局变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/cpuacct.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DEFINE_PER_CPU_SHARED_ALIGNED(<span style="color:#66d9ef">struct</span> rq, runqueues);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/sched.h  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> rq { <span style="color:#75715e">// 运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cfs_rq		cfs;  <span style="color:#75715e">// 公平运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> rt_rq		rt;   <span style="color:#75715e">// 实时运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> dl_rq		dl;   <span style="color:#75715e">// 限期运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct	<span style="color:#f92672">*</span>idle;  <span style="color:#75715e">// 空闲线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct	<span style="color:#f92672">*</span>stop;  <span style="color:#75715e">// 迁移线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="285-任务分组">2.8.5 任务分组<a hidden class="anchor" aria-hidden="true" href="#285-任务分组">#</a></h3>
<h4 id="1任务分组方式">1.任务分组方式<a hidden class="anchor" aria-hidden="true" href="#1任务分组方式">#</a></h4>
<table>
	<tr>
	    <th>任务分组方式</th>
	    <th>控制宏</th>
	    <th>配置方式</th>  
	</tr >
	<tr >
	    <td>自动组</td>
	    <td>CONFIG_SCHED_AUTOGROUP</td>
	    <td>/proc/sys/kernel/sched_autogroup_enabled <br>运行过程中开启关闭，默认值1<br>源文件kernel/sched/auto_group.c</td>
	</tr>
	<tr>
	    <td>CPU控制组版本1</td>
	    <td>CONFIG_CGROUPS<br>CONFIG_CGROUP_SCHED</td>
	    <td>mount -t tmpfs cgroup_root /sys/fs/cgroup<br>mkdir /sys/fs/cgroup/cpu<br>mount -t cgroup -o cpu none /sys/fs/cgroup/cpu<br>cd /sys/fs/cgroup/cpu<br>mkdir multimedia  # 创建"multimedia"任务组<br>mkdir browser     # 创建"browser"任务组<br>echo 2048 > multimedia/cpu.shares<br>echo 1024 > browser/cpu.shares<br>echo < pid1> > browser/tasks <br>echo < pid2> > multimedia/tasks<br>echo < pid1> > browser/cgroup.procs<br>echo < pid2> > multimedia/cgroup.procs</td>
	</tr>
	<tr>
	    <td>cgroup版本2</td>
	    <td> </td>
	    <td>mount -t tmpfs cgroup_root /sys/fs/cgroup<br>mount -t cgroup2  none /sys/fs/cgroup<br>cd /sys/fs/cgroup <br>
echo "+cpu" > cgroup.subtree_control<br>mkdir multimedia   # 创建"multimedia"任务组 <br>mkdir browser      # 创建"browser"任务组<br>echo 2048 > multimedia/cpu.weight<br>echo 1024 > browser/cpu.weight<br>echo < pid1> > browser/cgroup.procs<br>echo < pid2> > multimedia/cgroup.procs <br>echo threaded > browser/cgroup.type <br> echo < pid1> > browser/cgroup.threads <br>echo threaded > multimedia/cgroup.type <br>echo < pid2> > multimedia/cgroup.threads
</td>
	</tr>
</table>
<h4 id="2-数据结构">2. 数据结构<a hidden class="anchor" aria-hidden="true" href="#2-数据结构">#</a></h4>
<p> task_group,默认任务组是更任务组(全局变量root_task_group)</p>
<table>
	<tr>
	    <th>成员</th>
	    <th>说明</th>
	</tr >
	<tr >
	    <td>const struct sched_class *sched_class</td>
	    <td>调度类</td>
	</tr>
	<tr >
	    <td>struct sched_entity se</td>
	    <td>公平调度实体</td>
	</tr>
		<tr >
	    <td>struct sched_dl_entity dl</td>
	    <td>限期调度实体</td>
	</tr>
</table>
<p> 任务组在每个处理器上有公平调度实体、公平运行队列、实时调度实体和实时运行队列，根任务组比较特殊：没有公平调度实体和实时调度实体</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221104104612.png" alt="20221104104612"  />
</p>
<p> 每个处理器上，计算任务组的公平调度实体的权重的方法如下（参考源文件“kernel/ sched/fair.c”中的函数update_cfs_shares</p>
<h3 id="286-调度进程">2.8.6 调度进程<a hidden class="anchor" aria-hidden="true" href="#286-调度进程">#</a></h3>
<p> 调度进程的核心函数是<code>__schedule()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>kernel<span style="color:#f92672">/</span>sched<span style="color:#f92672">/</span>core.c
</span></span><span style="display:flex;"><span><span style="color:#75715e">// preempt是否抢占，true抢占调度，false主动调度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __sched notrace __schedule(<span style="color:#66d9ef">bool</span> preempt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">1.</span> <span style="color:#960050;background-color:#1e0010">调用</span>pick_next_task选择下一个进程
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">2.</span> <span style="color:#960050;background-color:#1e0010">调用</span>context_switch切换进程
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="1选择下一个进程-函数pick_next_task">1.选择下一个进程 函数pick_next_task<a hidden class="anchor" aria-hidden="true" href="#1选择下一个进程-函数pick_next_task">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pick_next_task</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev, <span style="color:#66d9ef">struct</span> rq_flags <span style="color:#f92672">*</span>rf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sched_class <span style="color:#f92672">*</span>class;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Optimization: we know that if all tasks are in the fair class we can
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * call that function directly, but only if the @prev task wasn&#39;t of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * higher scheduling class, because otherwise those loose the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * opportunity to pull in more work from other CPUs.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 优化：如果所有进程属于公平调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 直接调用公平调度类的pick_next_task方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (likely(prev<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">&amp;</span>fair_sched_class <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		   rq<span style="color:#f92672">-&gt;</span>nr_running <span style="color:#f92672">==</span> rq<span style="color:#f92672">-&gt;</span>cfs.h_nr_running)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		p <span style="color:#f92672">=</span> pick_next_task_fair(rq, prev, rf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (unlikely(p <span style="color:#f92672">==</span> RETRY_TASK))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> restart;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 假定公平调度类的下一个调度类是空闲调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p) {
</span></span><span style="display:flex;"><span>			put_prev_task(rq, prev);
</span></span><span style="display:flex;"><span>			p <span style="color:#f92672">=</span> pick_next_task_idle(rq);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>restart:
</span></span><span style="display:flex;"><span>	put_prev_task_balance(rq, prev, rf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	for_each_class(class) {
</span></span><span style="display:flex;"><span>		p <span style="color:#f92672">=</span> class<span style="color:#f92672">-&gt;</span>pick_next_task(rq);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (p)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* The idle class should always have a runnable task: */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 空闲调度类应该总是有一个运行的进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	BUG();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>待补充</p>
</blockquote>
<h4 id="2切换进程-context_switch">2.切换进程 context_switch<a hidden class="anchor" aria-hidden="true" href="#2切换进程-context_switch">#</a></h4>
<blockquote>
<p>1）switch_mm_irqs_off负责切换进程的用户虚拟地址空间
2）switch_to切换处理器的寄存器</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">context_switch</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev,
</span></span><span style="display:flex;"><span>	       <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>next, <span style="color:#66d9ef">struct</span> rq_flags <span style="color:#f92672">*</span>rf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	prepare_task_switch(rq, prev, next); <span style="color:#75715e">// 准备工作，调用prepare_arch_switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* For paravirt, this is coupled with an exit in switch_to to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * combine the page table reload and the switch backend into
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * one hypercall. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 开始上下文切换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	arch_start_context_switch(prev);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * kernel -&gt; kernel   lazy + transfer active
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   user -&gt; kernel   lazy + mmgrab() active
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * kernel -&gt;   user   switch + mmdrop() active
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   user -&gt;   user   switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next<span style="color:#f92672">-&gt;</span>mm) {                 <span style="color:#75715e">// to kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 通知处理器架构不需要切换用户虚拟地址空间，加速进程切换的技术称为惰性TLB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		enter_lazy_tlb(prev<span style="color:#f92672">-&gt;</span>active_mm, next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		next<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>active_mm;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (prev<span style="color:#f92672">-&gt;</span>mm)     <span style="color:#75715e">// from user 切换进程的用户虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			mmgrab(prev<span style="color:#f92672">-&gt;</span>active_mm);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {                                        <span style="color:#75715e">// to user
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		membarrier_switch_mm(rq, prev<span style="color:#f92672">-&gt;</span>active_mm, next<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * sys_membarrier() requires an smp_mb() between setting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * The below provides this either through switch_mm(), or in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * case &#39;prev-&gt;active_mm == next-&gt;mm&#39; through
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * finish_task_switch()&#39;s mmdrop().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		switch_mm_irqs_off(prev<span style="color:#f92672">-&gt;</span>active_mm, next<span style="color:#f92672">-&gt;</span>mm, next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prev<span style="color:#f92672">-&gt;</span>mm) {                        <span style="color:#75715e">// from kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">/* will mmdrop() in finish_task_switch(). */</span>
</span></span><span style="display:flex;"><span>			rq<span style="color:#f92672">-&gt;</span>prev_mm <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>active_mm;
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rq<span style="color:#f92672">-&gt;</span>clock_update_flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>(RQCF_ACT_SKIP<span style="color:#f92672">|</span>RQCF_REQ_SKIP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	prepare_lock_switch(rq, next, rf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Here we just switch the register state and the stack. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 只切换寄存器状态和栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	switch_to(prev, next, prev);
</span></span><span style="display:flex;"><span>	barrier();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> finish_task_switch(prev);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （1）切换用户虚拟地址空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ARM64架构使用switch_mm_irqs_off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>include<span style="color:#f92672">/</span>linux<span style="color:#f92672">/</span>mmu_context.h
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef switch_mm_irqs_off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define switch_mm_irqs_off switch_mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>  switch_mm函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/mmu_context.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">switch_mm</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>prev, <span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>next,
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (prev <span style="color:#f92672">!=</span> next)
</span></span><span style="display:flex;"><span>		__switch_mm(next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Update the saved TTBR0_EL1 of the scheduled-in task as the previous
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * value may have not been initialised yet (activate_mm caller) or the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * ASID has changed since the last run (following the context switch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * of another thread of the same process).*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 更新调入进程保存的寄存器TTBR0_EL1值，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 因为可能还没有初始化（调用者是函数activate_mm），
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 或者ASID自从上次运行以来已经改变（在同一个线程组的另一个线程切换上下文以后）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 避免把保留的寄存器TTBR0_EL1值设置为swapper_pg_dir（init_mm；例如通过函数idle_task_exit）*/</span>
</span></span><span style="display:flex;"><span>	update_saved_ttbr0(tsk, next);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__switch_mm</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>next)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*init_mm.pgd does not contain any user mappings and it is always
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * active for kernel addresses in TTBR1. Just set the reserved TTBR0.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*init_mm.pgd没有包含任何用户虚拟地址的映射，对于TTBR1的内核虚拟地址总是有效的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * 只设置保留的TTBR0 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (next <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>init_mm) {
</span></span><span style="display:flex;"><span>		cpu_set_reserved_ttbr0();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为进程分配地址空间标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	check_and_switch_context(next);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>待补充</p>
</blockquote>
<p> （2）切换寄存器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/include/asm-generic/switch_to.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define switch_to(prev, next, last)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	do {								\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		((last) = __switch_to((prev), (next)));			\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	} while (0)
</span></span></span></code></pre></div><p> 函数__switch_to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>__notrace_funcgraph <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">__switch_to</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>next)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>last;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fpsimd_thread_switch(next);  <span style="color:#75715e">// 切换浮点寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tls_thread_switch(next);  <span style="color:#75715e">// 切换本地存储相关的寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hw_breakpoint_thread_switch(next);  <span style="color:#75715e">// 切换吊事寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	contextidr_thread_switch(next);  <span style="color:#75715e">// 把上下文标识符寄存器CONTEXTIDR_EL1设置为下一个进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	entry_task_switch(next);  <span style="color:#75715e">// 使用处理器变量__entry_task记录下一个进程描述符的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	uao_thread_switch(next);  <span style="color:#75715e">// 根据下一个进程可访问的虚拟地址空间上限恢复用户访问覆盖（User Access Override，UAO）状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ssbs_thread_switch(next);  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	erratum_1418040_thread_switch(next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Complete any pending TLB or cache maintenance on this CPU in case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * the thread migrates to a different CPU.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * This full barrier is also required by the membarrier system
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * call.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在这个处理器上执行完前面的所有页表缓存或者缓存维护操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 以防线程迁移到其他处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 数据同步屏障，确保屏障前面的缓存维护操作和页表缓存维护操作执行完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dsb(ish);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* MTE thread switching must happen after the DSB above to ensure that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * any asynchronous tag check faults have been logged in the TFSR*_EL1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * registers.*/</span> 
</span></span><span style="display:flex;"><span>	mte_thread_switch(next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* the actual thread switch */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 实际线程切换  切换通用寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	last <span style="color:#f92672">=</span> cpu_switch_to(prev, next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> last;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 1）切换浮点寄存器，函数fpsimd_thread_switch负责切换浮点，内核不允许使用浮点数，只有用户空间可以使用浮点数,切换出去的进程把浮点寄存器的值保存在进程描述符的成员thread.fpsimd_state中。ARM64架构实现的linux-5.10.102/arch/arm64/kernel/fpsimd.c函数fpsimd_thread_switch   \
 2）切换通用寄存器，</p>
<ul>
<li>被调用函数负责保存的寄存器x19～x28</li>
<li>寄存器x29，即帧指针（Frame Pointer，FP）寄存器</li>
<li>栈指针（Stack Pointer，SP）寄存器</li>
<li>寄存器x30，即链接寄存器（Link Register，LR），它存放函数的返回地址</li>
<li>用户栈指针寄存器SP_EL0，内核使用它存放当前进程的进程描述符的第一个成员thread_info的地址</li>
</ul>
<p>  cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYM_FUNC_START(cpu_switch_to)
</span></span><span style="display:flex;"><span>	mov	x10, <span style="color:#960050;background-color:#1e0010">#</span>THREAD_CPU_CONTEXT  <span style="color:#75715e">// cpu_switch_to有两个参数：寄存器x0存放上一个进程的进程描述符的地址，寄存器x1存放下一个进程的进程描述符的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	add	x8, x0, x10  <span style="color:#75715e">// x8存放上一个进程的进程描述符的成员thread.cpu_context的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mov	x9, sp  <span style="color:#75715e">// x9保存栈指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x19, x20, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>		<span style="color:#75715e">// store callee-saved registers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x21, x22, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 把上一个进程的寄存器x19～x28、x29、SP和LR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x23, x24, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 保存到上一个进程的进程描述符的成员thread.cpu_context中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x25, x26, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stp	x27, x28, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	stp	x29, x9, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  
</span></span><span style="display:flex;"><span>	str	lr, [x8]  <span style="color:#75715e">// LR存放函数的返回地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	add	x8, x1, x10  <span style="color:#75715e">// x8存放下一个进程的进程描述符的成员thread.cpu_context的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x19, x20, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>		<span style="color:#75715e">// restore callee-saved registers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x21, x22, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 使用下一个进程的进程描述符的成员thread.cpu_context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x23, x24, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>  <span style="color:#75715e">// 保存的值恢复下一个进程的寄存器x19～x28、x29、SP和LR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ldp	x25, x26, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	ldp	x27, x28, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	ldp	x29, x9, [x8], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>	ldr	lr, [x8]
</span></span><span style="display:flex;"><span>	mov	sp, x9
</span></span><span style="display:flex;"><span>	msr	sp_el0, x1  <span style="color:#75715e">// 用户栈指针寄存器SP_EL0设置为下一个进程的进程描述符的第一个成员thread_info的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ptrauth_keys_install_kernel x1, x8, x9, x10
</span></span><span style="display:flex;"><span>	scs_save x0, x8  <span style="color:#75715e">// 函数返回，返回值是寄存器x0的值：上一个进程的进程描述符的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	scs_load x1, x8
</span></span><span style="display:flex;"><span>	ret
</span></span><span style="display:flex;"><span>SYM_FUNC_END(cpu_switch_to)
</span></span><span style="display:flex;"><span>NOKPROBE(cpu_switch_to)
</span></span></code></pre></div><p>  cpu_switch_to切换通用寄存器的过程，从进程prev切换到进程next。进程prev把通用寄存器的值保存在进程描述符的成员thread.cpu_context中，然后进程next从进程描述符的成员thread.cpu_context恢复通用寄存器的值，使用用户栈指针寄存器SP_EL0存放进程next的进程描述符的成员thread_info的地址    \</p>
<center>ARM64架构切换通用寄存器</center>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/2022-11-05_21-28.png" alt="2022-11-05_21-28"  />
</p>
<p> 链接寄存器存放函数的返回地址，函数cpu_switch_to把链接寄存器设置为进程描述符的成员thread.cpu_context.pc，进程被调度后从返回地址开始执行   <br>
进程的返回地址分为以下两种情况:</p>
<ul>
<li>创建的新进程，函数copy_thread把进程描述符的成员thread.cpu_context.pc设置为函数ret_from_fork的地址</li>
<li>其他情况，返回地址是函数context_switch中调用函数cpu_switch_to之后的一行代码：“last = 函数cpu_switch_to的返回值”，返回地址记录在进程描述符的成员thread.cpu_context.pc中</li>
</ul>
<p> （3）清理工作
  函数finish_task_switch在从进程prev切换到进程next后为进程prev执行清理工作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span><span style="color:#a6e22e">finish_task_switch</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span>	__releases(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq <span style="color:#f92672">=</span> this_rq();  <span style="color:#75715e">// rq是当前处理器的运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> rq<span style="color:#f92672">-&gt;</span>prev_mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">long</span> prev_state;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*  The previous task will have left us with a preempt_count of 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * because it left us after:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	schedule()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	  preempt_disable();			// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	  __schedule()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Also, see FORK_PREEMPT_COUNT.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WARN_ONCE(preempt_count() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>PREEMPT_DISABLE_OFFSET,
</span></span><span style="display:flex;"><span>		      <span style="color:#e6db74">&#34;corrupted preempt_count: %s/%d/0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>		      current<span style="color:#f92672">-&gt;</span>comm, current<span style="color:#f92672">-&gt;</span>pid, preempt_count()))
</span></span><span style="display:flex;"><span>		preempt_count_set(FORK_PREEMPT_COUNT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rq<span style="color:#f92672">-&gt;</span>prev_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* A task struct has one reference for the use as &#34;current&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * schedule one last time. The schedule call will never return, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * the scheduled task must drop that reference.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task), otherwise a concurrent wakeup can get prev
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * running on another CPU and we could rave with its RUNNING -&gt; DEAD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * transition, resulting in a double drop.*/</span>
</span></span><span style="display:flex;"><span>	prev_state <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>state;
</span></span><span style="display:flex;"><span>	vtime_task_switch(prev);  <span style="color:#75715e">// 计算进程prev的时间统计
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	perf_event_task_sched_in(prev, current);
</span></span><span style="display:flex;"><span>	finish_task(prev);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把prev-&gt;on_cpu设置为0，表示进程prev没有在处理器上运行；然后释放运行队列的锁，开启硬中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	finish_lock_switch(rq); 
</span></span><span style="display:flex;"><span>	finish_arch_post_lock_switch(); <span style="color:#75715e">// 执行处理器架构特定的清理工作,ARM64为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	kcov_finish_switch(current);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fire_sched_in_preempt_notifiers(current);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* When switching through a kernel thread, the loop in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * membarrier_{private,global}_expedited() may have observed that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * kernel thread and not issued an IPI. It is therefore possible to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * schedule between user-&gt;kernel-&gt;user threads without passing though
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * switch_mm(). Membarrier requires a barrier after storing to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * rq-&gt;curr, before returning to userspace, so provide them here:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   provided by mmdrop(),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * - a sync_core for SYNC_CORE.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (mm) {
</span></span><span style="display:flex;"><span>		membarrier_mm_sync_core_before_usermode(mm);
</span></span><span style="display:flex;"><span>		mmdrop(mm);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(prev_state <span style="color:#f92672">==</span> TASK_DEAD)) { <span style="color:#75715e">// 进程主动退出或者被终止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_dead)
</span></span><span style="display:flex;"><span>			prev<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_dead(prev); <span style="color:#75715e">// 所属调度类的task_dead方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* * Remove function-return probe instances associated with this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * task and put them back on the free list.*/</span>
</span></span><span style="display:flex;"><span>		kprobe_flush_task(prev);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Task is done with its stack. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*释放进程的内核栈 */</span>
</span></span><span style="display:flex;"><span>		put_task_stack(prev);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把进程描述符的引用计数减1，如果引用计数变为0，那么释放进程描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		put_task_struct_rcu_user(prev);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tick_nohz_task_switch();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> rq;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="287-调度时机">2.8.7 调度时机<a hidden class="anchor" aria-hidden="true" href="#287-调度时机">#</a></h3>
<blockquote>
<p>调度进程的时机: <br>
（1）进程主动调用<code>schedule()</code>函数
（2）周期性地调度，抢占当前进程，强迫当前进程让出处理器
（3）唤醒进程的时候，被唤醒的进程可能抢占当前进程
（4）创建新进程的时候，新进程可能抢占当前进程。</p>
</blockquote>
<h4 id="1主动调度">1.主动调度<a hidden class="anchor" aria-hidden="true" href="#1主动调度">#</a></h4>
<p> 内核中3种主动调度方式：
 （1）直接调用<code>schedule()</code>函数来调度进程
 （2）调用有条件重调度函数cond_resched()。非抢占式内核中，函数cond_resched()判断当前进程是否设置了需要重新调度的标志，如果设置了，就调度进程；抢占式内核中，cond_resched()为空
 （3）如果需要等待某个资源，例如互斥锁或信号量，那么把进程的状态设置为睡眠状态，然后调用schedule()函数以调度进程</p>
<h4 id="2周期调度">2.周期调度<a hidden class="anchor" aria-hidden="true" href="#2周期调度">#</a></h4>
<p> 周期调度的函数是scheduler_tick()，它调用当前进程所属调度类的task_tick方法。
 （1）限期调度类的周期调度   <br>
 task_tick &ndash;&gt; task_tick_dl &ndash;&gt; update_curr_dl</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/deadline.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_curr_dl</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>curr <span style="color:#f92672">=</span> rq<span style="color:#f92672">-&gt;</span>curr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_dl_entity <span style="color:#f92672">*</span>dl_se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>curr<span style="color:#f92672">-&gt;</span>dl;
</span></span><span style="display:flex;"><span>	u64 delta_exec, scaled_delta_exec;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	delta_exec <span style="color:#f92672">=</span> now <span style="color:#f92672">-</span> curr<span style="color:#f92672">-&gt;</span>se.exec_start;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely((s64)delta_exec <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (unlikely(dl_se<span style="color:#f92672">-&gt;</span>dl_yielded))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> throttle;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	dl_se<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">-=</span> scaled_delta_exec; <span style="color:#75715e">// 计算限期进程的剩余运行时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>throttle:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// // 如果限期进程用完了运行时间或者主动让出处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (dl_runtime_exceeded(dl_se) <span style="color:#f92672">||</span> dl_se<span style="color:#f92672">-&gt;</span>dl_yielded) { 
</span></span><span style="display:flex;"><span>		dl_se<span style="color:#f92672">-&gt;</span>dl_throttled <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 设置节流标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* If requested, inform the user about runtime overruns. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (dl_runtime_exceeded(dl_se) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    (dl_se<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SCHED_FLAG_DL_OVERRUN))
</span></span><span style="display:flex;"><span>			dl_se<span style="color:#f92672">-&gt;</span>dl_overrun <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		__dequeue_task_dl(rq, curr, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (unlikely(is_dl_boosted(dl_se) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>start_dl_timer(curr)))
</span></span><span style="display:flex;"><span>			enqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_leftmost(curr, <span style="color:#f92672">&amp;</span>rq<span style="color:#f92672">-&gt;</span>dl))
</span></span><span style="display:flex;"><span>			resched_curr(rq);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （2）实时调度类的周期调度   \</p>
<p> 实时调度类的task_tick方法是函数task_tick_rt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/rt.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task_tick_rt</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> queued)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_rt_entity <span style="color:#f92672">*</span>rt_se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>rt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">!=</span> SCHED_RR) <span style="color:#75715e">// 调度策略不是轮流调度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把时间片减一，如果没用完时间片，那么返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>p<span style="color:#f92672">-&gt;</span>rt.time_slice)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 用完了时间片，那么重新分配时间片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>rt.time_slice <span style="color:#f92672">=</span> sched_rr_timeslice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Requeue to the end of queue if we (and all of our ancestors) are not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * the only element on the queue */</span>
</span></span><span style="display:flex;"><span>	for_each_sched_rt_entity(rt_se) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (rt_se<span style="color:#f92672">-&gt;</span>run_list.prev <span style="color:#f92672">!=</span> rt_se<span style="color:#f92672">-&gt;</span>run_list.next) {
</span></span><span style="display:flex;"><span>			requeue_task_rt(rq, p, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>			resched_curr(rq);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （3）公平调度类的周期调度     <br>
 公平调度类的task_tick方法是函数task_tick_fair</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task_tick_fair</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>curr, <span style="color:#66d9ef">int</span> queued)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>curr<span style="color:#f92672">-&gt;</span>se;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	for_each_sched_entity(se) {
</span></span><span style="display:flex;"><span>		cfs_rq <span style="color:#f92672">=</span> cfs_rq_of(se);
</span></span><span style="display:flex;"><span>		entity_tick(cfs_rq, se, queued);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">entity_tick</span>(<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq, <span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>curr, <span style="color:#66d9ef">int</span> queued)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cfs_rq<span style="color:#f92672">-&gt;</span>nr_running <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 公平运行队列的进程数量超过1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		check_preempt_tick(cfs_rq, curr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">check_preempt_tick</span>(<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq, <span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>curr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> ideal_runtime, delta_exec;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se;
</span></span><span style="display:flex;"><span>	s64 delta;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ideal_runtime <span style="color:#f92672">=</span> sched_slice(cfs_rq, curr);
</span></span><span style="display:flex;"><span>	delta_exec <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>sum_exec_runtime <span style="color:#f92672">-</span> curr<span style="color:#f92672">-&gt;</span>prev_sum_exec_runtime;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta_exec <span style="color:#f92672">&gt;</span> ideal_runtime) {
</span></span><span style="display:flex;"><span>		resched_curr(rq_of(cfs_rq));
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* The current task ran long enough, ensure it doesn&#39;t get
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * re-elected due to buddy favours.*/</span>
</span></span><span style="display:flex;"><span>		clear_buddies(cfs_rq, curr);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Ensure that a task that missed wakeup preemption by a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * narrow margin doesn&#39;t have to wait for a full slice.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * This also mitigates buddy induced latencies under load.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta_exec <span style="color:#f92672">&lt;</span> sysctl_sched_min_granularity)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	se <span style="color:#f92672">=</span> __pick_first_entity(cfs_rq);
</span></span><span style="display:flex;"><span>	delta <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>vruntime <span style="color:#f92672">-</span> se<span style="color:#f92672">-&gt;</span>vruntime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (delta <span style="color:#f92672">&gt;</span> ideal_runtime)
</span></span><span style="display:flex;"><span>		resched_curr(rq_of(cfs_rq));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （4）中断返回时调度。
 ARM64架构的中断处理程序的入口是e10_irq，中断处理程序执行完以后，跳转到标号ret_to_user以返回用户模式。标号ret_to_user判断当前进程的进程描述符的成员thread_info.flags有没有设置标志位集合_TIF_WORK_MASK中的任何一个标志位，如果设置了其中一个标志位，那么跳转到标号work_pending，标号work_pending调用函数do_notify_resume</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/entry.S  5.10.102 代码中没有？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ret_to_user:
</span></span><span style="display:flex;"><span>     disable_irq                   <span style="color:#75715e">// 禁止中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ldr  x1, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]
</span></span><span style="display:flex;"><span>     and  x2, x1, <span style="color:#960050;background-color:#1e0010">#</span>_TIF_WORK_MASK
</span></span><span style="display:flex;"><span>     cbnz x2, work_pending
</span></span><span style="display:flex;"><span>finish_ret_to_user:
</span></span><span style="display:flex;"><span>     enable_step_tsk x1, x2
</span></span><span style="display:flex;"><span>     kernel_exit <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ENDPROC(ret_to_user)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>work_pending:
</span></span><span style="display:flex;"><span>     mov  x0, sp
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      * 寄存器x0存放第一个参数regs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      * 寄存器x1存放第二个参数task_struct.thread_info.flags
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      */</span>
</span></span><span style="display:flex;"><span>     bl  do_notify_resume
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_TRACE_IRQFLAGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     bl  trace_hardirqs_on         <span style="color:#75715e">// 在用户空间执行时开启中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     ldr x1, [tsk, <span style="color:#960050;background-color:#1e0010">#</span>TSK_TI_FLAGS]  <span style="color:#75715e">// 重新检查单步执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     b   finish_ret_to_user
</span></span></code></pre></div><p> 函数do_notify_resume判断当前进程的进程描述符的成员thread_info.flags有没有设置需要重新调度的标志位_TIF_NEED_RESCHED，如果设置了，那么调用函数schedule()以调度进程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/kernel/signal.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_notify_resume</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>                         <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> thread_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_NEED_RESCHED) {
</span></span><span style="display:flex;"><span>             schedule();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        local_irq_disable();
</span></span><span style="display:flex;"><span>        thread_flags <span style="color:#f92672">=</span> READ_ONCE(current_thread_info()<span style="color:#f92672">-&gt;</span>flags);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (thread_flags <span style="color:#f92672">&amp;</span> _TIF_WORK_MASK);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3唤醒进程时抢占">3.唤醒进程时抢占<a hidden class="anchor" aria-hidden="true" href="#3唤醒进程时抢占">#</a></h4>
<p> 唤醒进程的时候，被唤醒的进程可能抢占当前进程</p>
<center>唤醒进程时抢占</center>
![20221106214732](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106214732.png)
<p> （1）如果被唤醒的进程和当前进程属于相同的调度类，那么调用调度类的check_preempt_curr方法以检查是否可以抢占当前进程   <br>
 （2）如果被唤醒的进程所属调度类的优先级高于当前进程所属调度类的优先级，那么给当前进程设置需要重新调度的标志</p>
<table>
	<tr>
	    <th>调度类</th>
	    <th>check_preempt_curr方法是函数</th>
	    <th>算法</th>  
	</tr >
	<tr >
	    <td>停机调度类</td>
	    <td>check_preempt_curr_stop</td>
	    <td>空函数</td>
	</tr>
	<tr >
	    <td>限期调度类</td>
	    <td>check_preempt_curr_dl</td>
	    <td>如果被唤醒的进程的绝对截止期限比当前进程的绝对截止期限小，那么给当前进程设置需要重新调度的标志</td>
	</tr>
	<tr >
	    <td>实时调度类</td>
	    <td>check_preempt_curr_rt</td>
	    <td>优先级比当前进程的优先级高，那么给当前进程设置需要重新调度的标志</td>
	</tr>
	<tr >
	    <td>公平调度类</td>
	    <td>check_preempt_wakeup</td>
	    <td></td>
	</tr>
	<tr >
	    <td>空闲调度类</td>
	    <td>check_preempt_curr_idle</td>
	    <td>无条件抢占，给当前进程设置需要重新调度的标志</td>
	</tr>
</table>
<p> check_preempt_wakeup函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">check_preempt_wakeup</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> wake_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前进程的调度策略是SCHED_IDLE，被唤醒的进程的调度策略是SCHED_NORMAL或者SCHED_BATCH，那么允许抢占，给当前进程设置需要重新调度的标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>curr <span style="color:#f92672">=</span> rq<span style="color:#f92672">-&gt;</span>curr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>curr<span style="color:#f92672">-&gt;</span>se, <span style="color:#f92672">*</span>pse <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>se;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(task_has_idle_policy(curr)) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    likely(<span style="color:#f92672">!</span>task_has_idle_policy(p)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> preempt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">!=</span> SCHED_NORMAL) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>sched_feat(WAKEUP_PREEMPTION))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为当前进程和被唤醒的进程找到两个兄弟调度实体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	find_matching_se(<span style="color:#f92672">&amp;</span>se, <span style="color:#f92672">&amp;</span>pse);
</span></span><span style="display:flex;"><span>	update_curr(cfs_rq_of(se));
</span></span><span style="display:flex;"><span>	BUG_ON(<span style="color:#f92672">!</span>pse);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (wakeup_preempt_entity(se, pse) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) { <span style="color:#75715e">// 判断是否可以抢占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 允许抢占，给当前进程设置需要重新调度的标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		...
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> preempt;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>preempt:
</span></span><span style="display:flex;"><span>	resched_curr(rq);
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wakeup_preempt_entity</span>(<span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>curr, <span style="color:#66d9ef">struct</span> sched_entity <span style="color:#f92672">*</span>se)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s64 gran, vdiff <span style="color:#f92672">=</span> curr<span style="color:#f92672">-&gt;</span>vruntime <span style="color:#f92672">-</span> se<span style="color:#f92672">-&gt;</span>vruntime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vdiff <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	gran <span style="color:#f92672">=</span> wakeup_gran(se);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (vdiff <span style="color:#f92672">&gt;</span> gran)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4创建新进程时抢占">4.创建新进程时抢占<a hidden class="anchor" aria-hidden="true" href="#4创建新进程时抢占">#</a></h4>
<p> 使用系统调用fork、clone和 vfork创建新进程使，新进程可抢占当前进程；使用韩式kernel_thread创建新的内核线程是，新内核线程可抢占当前进程
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106220629.png" alt="20221106220629"  />
</p>
<h4 id="5内核抢占">5.内核抢占<a hidden class="anchor" aria-hidden="true" href="#5内核抢占">#</a></h4>
<p> 内核抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，需要打开配置宏CONFIG_PREEMPT。抢占式内核和非抢占式内核。进程tthread_info结构体一个类型为int的成员preempt_count为抢占计数器。</p>
<blockquote>
<p>待补充</p>
</blockquote>
<h4 id="6高精度调度时钟">6.高精度调度时钟<a hidden class="anchor" aria-hidden="true" href="#6高精度调度时钟">#</a></h4>
<p> 高精度时钟的精度是纳秒,需要通过配置宏启用。</p>
<h3 id="288-带宽管理">2.8.8 带宽管理<a hidden class="anchor" aria-hidden="true" href="#288-带宽管理">#</a></h3>
<p> 调度类管理进程占用的处理器带宽的方法</p>
<h4 id="1限期调度类的带框管理">1.限期调度类的带框管理<a hidden class="anchor" aria-hidden="true" href="#1限期调度类的带框管理">#</a></h4>
<p> 每个限期进程有自己的带宽，内核把限期进程的运行时间统计到根实时任务组的运行时间里面了，限期进程共享实时进程的带宽</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/deadline.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_curr_dl</span>(<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (rt_bandwidth_enabled()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> rt_rq <span style="color:#f92672">*</span>rt_rq <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rq<span style="color:#f92672">-&gt;</span>rt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            raw_spin_lock(<span style="color:#f92672">&amp;</span>rt_rq<span style="color:#f92672">-&gt;</span>rt_runtime_lock);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (sched_rt_bandwidth_account(rt_rq))
</span></span><span style="display:flex;"><span>                  rt_rq<span style="color:#f92672">-&gt;</span>rt_time <span style="color:#f92672">+=</span> delta_exec;
</span></span><span style="display:flex;"><span>            raw_spin_unlock(<span style="color:#f92672">&amp;</span>rt_rq<span style="color:#f92672">-&gt;</span>rt_runtime_lock);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2实时调度类的带宽管理">2.实时调度类的带宽管理<a hidden class="anchor" aria-hidden="true" href="#2实时调度类的带宽管理">#</a></h4>
<p> 指定实时进程的带宽有以下两种方式
 （1）指定全局带宽：带宽包含的两个参数是周期和运行时间，即指定在每个周期内所有实时进程的运行时间总和。   <br>
 默认的周期是1秒，默认的运行时间是0.95秒。可以借助文件“/proc/sys/kernel/sched_rt_period_us”设置周期，借助文件“/proc/sys/kernel/sched_rt_runtime_us”设置运行时间        <br>
 配置宏CONFIG_RT_GROUP_SCHED，即支持实时任务组，那么全局带宽指定了所有实时任务组的总带宽
 （2）指定每个实时任务组的带宽：在每个指定的周期，允许一个实时任务组最多执行长时间。当实时任务组在一个周期用完了带宽时，这个任务组将会被节流，不允许继续运行，直到下一个周期。可以使用cgroup设置一个实时任务组的周期和运行时间，cgroup版本1的配置方法如下</p>
<details>
<summary>cgroup版本1的配置方法</summary>
<br>
1）cpu.rt_period_us：周期，默认值是1秒。   <br>
2）cpu.rt_runtime_us：运行时间，默认值是0，把运行时间设置为非零值以后才允许把实时进程加入任务组，设置为−1表示没有带宽限制。
cgroup版本1的配置示例如下。 <br>
1）挂载cgroup文件系统，把CPU控制器关联到控制组层级树。   <br>
mount -t cgroup -o cpu none /sys/fs/cgroup/cpu      <br>
2）创建一个任务组。     <br>
cd /sys/fs/cgroup/cpu      <br>
mkdir browser   # 创建"browser"任务组       <br>
3）把实时运行时间设置为10毫秒。         <br>
echo 10000 > browser/cpu.rt_runtime_us      <br>
4）把一个实时进程加入任务组。         <br>
echo <pid> > browser/cgroup.procs      <br>
</details>
<p> cgroup版本2从内核4.15版本开始支持CPU控制器，暂时不支持实时进程。</p>
<p> 一个处理器用完了实时运行时间，可以从其他处理器借用实时运行时间，称为实时运行时间共享，对应调度特性RT_RUNTIME_SHARE，默认开启。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>kernel<span style="color:#f92672">/</span>sched<span style="color:#f92672">/</span>features.h
</span></span><span style="display:flex;"><span>SCHED_FEAT(RT_RUNTIME_SHARE, true)
</span></span></code></pre></div><p>实时任务组的带宽存放在结构体task_group的成员rt_bandwidth中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_group {
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_RT_GROUP_SCHED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">struct</span> rt_bandwidth rt_bandwidth;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 节流</p>
<blockquote>
<p>书中详细解释</p>
</blockquote>
<h4 id="3公平调度类的带宽管理">3.公平调度类的带宽管理<a hidden class="anchor" aria-hidden="true" href="#3公平调度类的带宽管理">#</a></h4>
<p> 使用周期和限额指定一个公平任务组的带宽    <br>
 使用cgroup设置一个公平任务组的周期和限额，cgroup版本1的配置  \</p>
<details>
<summary>cgroup版本1的配置方法</summary>
</details>
&emsp;cgroup版本2的配置示例  \
<details>
<summary>cgroup版本2的配置方法</summary>
</details>
<p> （1）节流：在以下两种情况下，调度器会检查公平运行队列是否用完运行时间。
 1）put_prev_task_fair：调度器把当前正在运行的普通进程放回公平运行队列。
 2）pick_next_task_fair：当前正在运行的进程属于公平调度类，调度器选择下一个普通进程。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106231743.png" alt="20221106231743"  />
</p>
<p> （2）周期定时器：在每个周期的开始，重新填充任务组的带宽，把带宽分配给节流的公平运行队列。周期定时器的处理函数是sched_cfs_period_timer，它把主要工作委托给函数do_sched_cfs_period_timer</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106232422.png" alt="20221106232422"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_sched_cfs_period_timer</span>(<span style="color:#66d9ef">struct</span> cfs_bandwidth <span style="color:#f92672">*</span>cfs_b, <span style="color:#66d9ef">int</span> overrun)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	throttled <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>list_empty(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>throttled_cfs_rq);
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	__refill_cfs_bandwidth_runtime(cfs_b); <span style="color:#75715e">// 新填充任务组的带宽
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>throttled) {
</span></span><span style="display:flex;"><span>		cfs_b<span style="color:#f92672">-&gt;</span>idle <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (throttled <span style="color:#f92672">&amp;&amp;</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		runtime <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime;
</span></span><span style="display:flex;"><span>		raw_spin_unlock(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把任务组的可用运行时间分配给节流的公平运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		runtime <span style="color:#f92672">=</span> distribute_cfs_runtime(cfs_b, runtime,
</span></span><span style="display:flex;"><span>								runtime_expires);
</span></span><span style="display:flex;"><span>		raw_spin_lock(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		throttled <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>list_empty(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>throttled_cfs_rq);
</span></span><span style="display:flex;"><span>		cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">-=</span> min(runtime, cfs_b<span style="color:#f92672">-&gt;</span>runtime);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数__refill_cfs_bandwidth_runtime负责重新填充任务组的带宽：“把可用运行时间设置成限额，把运行时间的到期时间设置成当前时间加上1个周期”</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/fair.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__refill_cfs_bandwidth_runtime</span>(<span style="color:#66d9ef">struct</span> cfs_bandwidth <span style="color:#f92672">*</span>cfs_b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     u64 now;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (cfs_b<span style="color:#f92672">-&gt;</span>quota <span style="color:#f92672">==</span> RUNTIME_INF)
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     now <span style="color:#f92672">=</span> sched_clock_cpu(smp_processor_id());
</span></span><span style="display:flex;"><span>     cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>quota;
</span></span><span style="display:flex;"><span>     cfs_b<span style="color:#f92672">-&gt;</span>runtime_expires <span style="color:#f92672">=</span> now <span style="color:#f92672">+</span> ktime_to_ns(cfs_b<span style="color:#f92672">-&gt;</span>period);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数distribute_cfs_runtime负责把任务组的可用运行时间分配给节流的公平运行队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">distribute_cfs_runtime</span>(<span style="color:#66d9ef">struct</span> cfs_bandwidth <span style="color:#f92672">*</span>cfs_b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cfs_rq <span style="color:#f92672">*</span>cfs_rq;
</span></span><span style="display:flex;"><span>	u64 runtime, remaining <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rcu_read_lock();
</span></span><span style="display:flex;"><span>	list_for_each_entry_rcu(cfs_rq, <span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>throttled_cfs_rq,
</span></span><span style="display:flex;"><span>				throttled_list) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq <span style="color:#f92672">=</span> rq_of(cfs_rq);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rq_flags rf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		rq_lock_irqsave(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cfs_rq_throttled(cfs_rq))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* By the above check, this should never be true */</span>
</span></span><span style="display:flex;"><span>		SCHED_WARN_ON(cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		raw_spin_lock(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* cfs_rq-&gt;runtime_remaining是公平运行队列的剩余运行时间 */</span>
</span></span><span style="display:flex;"><span>		runtime <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (runtime <span style="color:#f92672">&gt;</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime)
</span></span><span style="display:flex;"><span>			runtime <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime;
</span></span><span style="display:flex;"><span>		cfs_b<span style="color:#f92672">-&gt;</span>runtime <span style="color:#f92672">-=</span> runtime;
</span></span><span style="display:flex;"><span>		remaining <span style="color:#f92672">=</span> cfs_b<span style="color:#f92672">-&gt;</span>runtime;
</span></span><span style="display:flex;"><span>		raw_spin_unlock(<span style="color:#f92672">&amp;</span>cfs_b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">+=</span> runtime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* we check whether we&#39;re throttled above */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* 上面检查过是否被节流 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cfs_rq<span style="color:#f92672">-&gt;</span>runtime_remaining <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			unthrottle_cfs_rq(cfs_rq);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>next:
</span></span><span style="display:flex;"><span>		rq_unlock_irqrestore(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>remaining)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	rcu_read_unlock();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> （3）取有余补不足：</p>
<h2 id="29-smp调度">2.9 SMP调度<a hidden class="anchor" aria-hidden="true" href="#29-smp调度">#</a></h2>
<p> SMP系统进程调度器特性:
 （1）使每个处理器负载尽可能均衡
 （2）设置进程的处理器亲和性(affinity)，即允许进程在哪些处理器上执行
 （3）进程从一个处理器迁移到另一个处理器</p>
<h3 id="291-进程的处理器亲和性">2.9.1 进程的处理器亲和性<a hidden class="anchor" aria-hidden="true" href="#291-进程的处理器亲和性">#</a></h3>
<p> 进程描述符增加两个成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>               nr_cpus_allowed;   <span style="color:#75715e">// 保存允许的处理器掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cpumask_t         cpus_allowed;		<span style="color:#75715e">// 保存允许的处理器数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="1应用编程接口">1.应用编程接口<a hidden class="anchor" aria-hidden="true" href="#1应用编程接口">#</a></h4>
<p> 内核系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// sched_setaffinity用来设置进程的处理器亲和性掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_setaffinity</span>(pid_t pid, size_t cpusetsize, cpu_set_t <span style="color:#f92672">*</span>mask);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// sched_getaffinity用来获取进程的处理器亲和性掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_getaffinity</span>(pid_t pid, size_t cpusetsize, cpu_set_t <span style="color:#f92672">*</span>mask);
</span></span></code></pre></div><p> 内核线程函数设置处理器亲和性掩码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kthread_bind用来把一个刚刚创建的内核线程绑定到一个处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kthread_bind</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpu);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// set_cpus_allowed_ptr用来设置内核线程的处理器亲和性掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">set_cpus_allowed_ptr</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cpumask <span style="color:#f92672">*</span>new_mask);
</span></span></code></pre></div><h4 id="2使用cpuset配置">2.使用cpuset配置<a hidden class="anchor" aria-hidden="true" href="#2使用cpuset配置">#</a></h4>
<p> cpuset在单独使用的时候，可以使用cpuset伪文件系统配置，配置方法</p>
<h3 id="292-对调度器的扩展">2.9.2 对调度器的扩展<a hidden class="anchor" aria-hidden="true" href="#292-对调度器的扩展">#</a></h3>
<p> SMP系统上，调度类增加方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/sched/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sched_class {
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 为进程选择运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span>  (<span style="color:#f92672">*</span>select_task_rq)(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> task_cpu, <span style="color:#66d9ef">int</span> sd_flag, <span style="color:#66d9ef">int</span> flags);  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在进程被迁移到新的处理器之前调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>migrate_task_rq)(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 用来在进程被唤醒以后调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>task_woken) (<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>this_rq, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>task);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置处理器亲和性的时候执行调度类的特殊处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>set_cpus_allowed)(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cpumask <span style="color:#f92672">*</span>newmask);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 进程在内存和缓存中的数据是最少的，是有价值的实现负载均衡的机会：1）创建新进程，2）调用execve装载程序</p>
<center>创建新进程时负载均衡</center>
![20221106235035](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106235035.png)
<center>装载程序时负载均衡</center>
![20221106235110](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221106235110.png)
<h3 id="293-限期调度类的处理器负载均衡">2.9.3 限期调度类的处理器负载均衡<a hidden class="anchor" aria-hidden="true" href="#293-限期调度类的处理器负载均衡">#</a></h3>
<h3 id="294-实时调度类的处理器负载均衡">2.9.4 实时调度类的处理器负载均衡<a hidden class="anchor" aria-hidden="true" href="#294-实时调度类的处理器负载均衡">#</a></h3>
<h3 id="295-公平调度类的处理器负载均衡">2.9.5 公平调度类的处理器负载均衡<a hidden class="anchor" aria-hidden="true" href="#295-公平调度类的处理器负载均衡">#</a></h3>
<h3 id="296-迁移线程">2.9.6 迁移线程<a hidden class="anchor" aria-hidden="true" href="#296-迁移线程">#</a></h3>
<p> 每个处理器有一个迁移线程，线程名称是“migration/&lt;cpu_id&gt;”，属于停机调度类，可以抢占所有其他进程，其他进程不可以抢占它。迁移线程有两个作用   <br>
 （1）调度器发出迁移请求，迁移线程处理迁移请求，把进程迁移到目标处理器。
 （2）执行主动负载均衡。</p>
<h3 id="297-隔离处理器">2.9.7 隔离处理器<a hidden class="anchor" aria-hidden="true" href="#297-隔离处理器">#</a></h3>
<h2 id="210-进程的上下文安全">2.10 进程的上下文安全<a hidden class="anchor" aria-hidden="true" href="#210-进程的上下文安全">#</a></h2>
<h1 id="第3章-内存管理">第3章 内存管理<a hidden class="anchor" aria-hidden="true" href="#第3章-内存管理">#</a></h1>
<h2 id="31-内存管理子系统架构">3.1 内存管理子系统架构<a hidden class="anchor" aria-hidden="true" href="#31-内存管理子系统架构">#</a></h2>
<p> 用户空间、内核空间和硬件3个层面
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221107001723.png" alt="20221107001723"  />
</p>
<h4 id="1用户空间">1.用户空间<a hidden class="anchor" aria-hidden="true" href="#1用户空间">#</a></h4>
<p> 应用程序使用<code>malloc()</code>申请内存，使用<code>free()</code>释放内存。 <br>
 malloc()和free()是glibc库的内存分配器<code>ptmalloc</code>提供的接口，ptmalloc使用系统调用<code>brk</code>或<code>mmap</code>向内核以页为单位申请内存，然后划分成小内存块分配给应用程序    <br>
 用户空间的内存分配器，除了glibc库的ptmalloc，还有谷歌的tcmalloc和FreeBSD的<code>jemalloc</code></p>
<h4 id="2内核空间">2.内核空间<a hidden class="anchor" aria-hidden="true" href="#2内核空间">#</a></h4>
<p>（1）内核空间的基本功能   <br>
 虚拟内存管理负责从进程的虚拟地址空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页   <br>
 内核使用延迟分配物理内存的策略，进程第一次访问虚拟页的时候，触发页错误异常，页错误异常处理程序从页分配器申请物理页，在进程的页表中把虚拟页映射到物理页   <br>
 页分配器负责分配物理页，当前使用的页分配器是伙伴分配器。 <br>
 内核空间提供了把页划分成小内存块分配的块分配器，提供分配内存的接口kmalloc()和释放内存的接口kfree()，支持3种块分配器：SLAB分配器、SLUB分配器和SLOB分配器。   \</p>
<p>（2）内核空间的扩展功能。 \</p>
<p> 不连续页分配器提供了分配内存的接口vmalloc和释放内存的接口vfree  <br>
 连续内存分配器（Contiguous Memory Allocator，CMA）用来给驱动程序预留一段连续的内存，当驱动程序不用的时候，可以给进程使用；当驱动程序需要使用的时候，把进程占用的内存通过回收或迁移的方式让出来，给驱动程序使用  \</p>
<h4 id="3硬件层面">3.硬件层面<a hidden class="anchor" aria-hidden="true" href="#3硬件层面">#</a></h4>
<p> 处理器包含一个称为内存管理单元（Memory Management Unit，MMU）的部件，负责把虚拟地址转换成物理地址   <br>
 内存管理单元包含一个称为页表缓存（Translation Lookaside Buffer，TLB）的部件，保存最近使用过的页表映射，避免每次把虚拟地址转换成物理地址都需要查询内存中的页表   \</p>
<h2 id="32-虚拟地址空间布局">3.2 虚拟地址空间布局<a hidden class="anchor" aria-hidden="true" href="#32-虚拟地址空间布局">#</a></h2>
<h3 id="321-虚拟地址空间划分">3.2.1 虚拟地址空间划分<a hidden class="anchor" aria-hidden="true" href="#321-虚拟地址空间划分">#</a></h3>
<p> ARM64处理器不支持完全的64位虚拟地址，ARMv8.2 标准的大虚拟地址(Large Virtual Address，LVA)支持，并且页长度是64KB，那么虚拟地址的最大宽度是52位    <br>
 可以为虚拟地址配置比最大宽度小的宽度，并且可以为内核虚拟地址和用户虚拟地址配置不同的宽度。转换控制寄存器（Translation Control Register）TCR_EL1的字段T0SZ定义了必须是全0的最高位的数量，字段T1SZ定义了必须是全1的最高位的数量，用户虚拟地址的宽度是（64-TCR_EL1.T0SZ），内核虚拟地址的宽度是（64-TCR_EL1.T1SZ）   \</p>
<table>
	<tr>
	    <th>页长度</th>
	    <th>虚拟地址宽度</th>
	</tr >
	<tr >
	    <td>4KB</td>
	    <td>39</td>
	</tr>
	<tr >
	    <td>16KB</td>
	    <td>47</td>
	</tr>
	<tr >
	    <td>64KB</td>
	    <td>42</td>
	</tr>
	<tr >
	    <td colspan="2">可选择48位虚拟地址</td>
	</tr>
</table>
<h3 id="322-用户虚拟地址空间布局">3.2.2 用户虚拟地址空间布局<a hidden class="anchor" aria-hidden="true" href="#322-用户虚拟地址空间布局">#</a></h3>
<p> 进程的用户虚拟地址空间的起始地址是0，长度是TASK_SIZE，ARM64架构下TASK_SIZE下  <br>
 （1）32位用户空间程序：TASK_SIZE值是TASK_SIZE_32，即0x100000000，4GB    <br>
 （2）64位用户空间程序：TASK_SIZE值是TASK_SIZE_64，即 <code>2^VA_BITS</code>，VA_BITS是编译内核时选择的虚拟地址位数。   \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//arch/arm64/include/asm/memory.h    linux4.x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define VA_BITS          (CONFIG_ARM64_VA_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE_64     (UL(1) &lt;&lt; VA_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_COMPAT    </span><span style="color:#75715e">/* 支持执行32位用户空间程序 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE_32     UL(0x100000000)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* test_thread_flag(TIF_32BIT)判断用户空间程序是不是32位 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE       (test_thread_flag(TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  TASK_SIZE_32 : TASK_SIZE_64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE_OF(tsk)  (test_tsk_thread_flag(tsk, TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                  TASK_SIZE_32 : TASK_SIZE_64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TASK_SIZE    TASK_SIZE_64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_COMPAT */</span><span style="color:#75715e">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/memory.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define VA_BITS			(CONFIG_ARM64_VA_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _PAGE_OFFSET(va)	(-(UL(1) &lt;&lt; (va)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PAGE_OFFSET		(_PAGE_OFFSET(VA_BITS))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define KIMAGE_VADDR		(MODULES_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BPF_JIT_REGION_START	(KASAN_SHADOW_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BPF_JIT_REGION_SIZE	(SZ_128M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define BPF_JIT_REGION_END	(BPF_JIT_REGION_START + BPF_JIT_REGION_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MODULES_END		(MODULES_VADDR + MODULES_VSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MODULES_VADDR		(BPF_JIT_REGION_END)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MODULES_VSIZE		(SZ_128M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define VMEMMAP_START		(-VMEMMAP_SIZE - SZ_2M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define VMEMMAP_END		(VMEMMAP_START + VMEMMAP_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PCI_IO_END		(VMEMMAP_START - SZ_2M)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PCI_IO_START		(PCI_IO_END - PCI_IO_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FIXADDR_TOP		(PCI_IO_START - SZ_2M)
</span></span></span></code></pre></div><p> 进程的用户虚拟地址空间包含：    <br>
 （1）代码段、数据段和未初始化数据段    <br>
 （2）动态库代码段、数据段和初始化数据段    <br>
 （3）存放动态生成的数据的堆      <br>
 （4）存放局部变量和实现函数调用的栈   <br>
 （5）存放在栈底部的环境变量和参数字符串   <br>
 （6）把文件区间映射到虚拟地址空间的内存映射区域   <br>
 内核使用内存描述符<code>mm_struct</code>描述进程的用户虚拟地址空间，内存描述符主要成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>atomic_t mm_users;  <span style="color:#75715e">// 共享同一个用户虚拟地址空间进程的数量，即线程组包含的进程的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>atomic_t mm_count;  <span style="color:#75715e">// 内存描述符的引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>mmap;  <span style="color:#75715e">// 虚拟内存区域链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> rb_root mm_rb;  <span style="color:#75715e">// 虚拟内存区域红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#a6e22e">long</span>(<span style="color:#f92672">*</span>get_unmapped_area)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pgoff, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);  <span style="color:#75715e">// 在内存映射区域找到一个没有映射的区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pgd_t <span style="color:#f92672">*</span>pgd;  <span style="color:#75715e">// 指向页全局目录，即第一级页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> mmap_base;  <span style="color:#75715e">// 内存映射区的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> task_size;  <span style="color:#75715e">// 用户虚拟地址空间的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_code, end_code;  <span style="color:#75715e">// 代码段的起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_data, end_data;  <span style="color:#75715e">// 数据段的起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_brk, brk;  <span style="color:#75715e">// 堆的起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> start_stack;  <span style="color:#75715e">// 栈的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg_start, arg_end;  <span style="color:#75715e">// 参数字符串起始地址和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> env_start, env_end;  <span style="color:#75715e">// 环境变量的起始地址和结束地址
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm;  <span style="color:#75715e">// 进程mm指向一个内存描述符，内核线程mm为空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> mm_struct　<span style="color:#f92672">*</span>active_mm;  <span style="color:#75715e">// 进程的active_mm和mm总是指向同一个内存描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 内核线程的active_mm在没有运行时是空指针，在运行时指向从上一个进程借用的内存描述符
</span></span></span></code></pre></div><p> 进程地址空间随机化：  <br>
 （1）进程描述符成员personality是否设置ADDR_NO_RANDOMIZE   <br>
 （2）全局变量<code>randomize_va_spce</code>：0表示关闭虚拟地址空间随机化，1表示内存映射区和栈起始地址随机化，2表示内存映射区、栈和堆起始地址随机化，文件<code>/proc/sys/kernel/randomize_va_space</code>修改 \</p>
<p> 栈向下增长，起始地址STACK_TOP，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/processor.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define STACK_TOP_MAX         TASK_SIZE_64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_COMPAT  </span><span style="color:#75715e">/* 支持执行32位用户空间程序 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define AARCH32_VECTORS_BASE  0xffff0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_TOP   (test_thread_flag(TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                 AARCH32_VECTORS_BASE : STACK_TOP_MAX)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_TOP    STACK_TOP_MAX
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_COMPAT */</span><span style="color:#75715e">
</span></span></span></code></pre></div><p> 内存映射区域的起始地址是内存描述符的成员 mmap_base</p>
<center>用户虚拟地址空间两种布局</center>
![20221109013928](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109013928.png)
<p> 新布局：内存映射区域自顶向下增长，起始地址是(STACK_TOP − 栈的最大长度 − 间隙)，默认启用内存映射区域随机化，需要把起始地址减去一个随机值   \</p>
<p> 进程调用execve以装载ELF文件的时候，函数load_elf_binary将会创建进程的用户虚拟地址空间   \</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109014232.png" alt="20221109014232"  />
</p>
<p> 函数arch_pick_mmap_layout负责选择内存映射区域的布局。ARM64架构定义的函数arch_pick_mmap_layout</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/mm/util.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arch_pick_mmap_layout</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">struct</span> rlimit <span style="color:#f92672">*</span>rlim_stack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> random_factor <span style="color:#f92672">=</span> <span style="color:#ae81ff">0UL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_RANDOMIZE)
</span></span><span style="display:flex;"><span>		random_factor <span style="color:#f92672">=</span> arch_mmap_rnd();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (mmap_is_legacy(rlim_stack)) { <span style="color:#75715e">// 自底向上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mm<span style="color:#f92672">-&gt;</span>mmap_base <span style="color:#f92672">=</span> TASK_UNMAPPED_BASE <span style="color:#f92672">+</span> random_factor;
</span></span><span style="display:flex;"><span>		mm<span style="color:#f92672">-&gt;</span>get_unmapped_area <span style="color:#f92672">=</span> arch_get_unmapped_area;  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 自顶向下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mm<span style="color:#f92672">-&gt;</span>mmap_base <span style="color:#f92672">=</span> mmap_base(random_factor, rlim_stack);
</span></span><span style="display:flex;"><span>		mm<span style="color:#f92672">-&gt;</span>get_unmapped_area <span style="color:#f92672">=</span> arch_get_unmapped_area_topdown;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mmap_is_legacy</span>(<span style="color:#66d9ef">struct</span> rlimit <span style="color:#f92672">*</span>rlim_stack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>personality <span style="color:#f92672">&amp;</span> ADDR_COMPAT_LAYOUT)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (rlim_stack<span style="color:#f92672">-&gt;</span>rlim_cur <span style="color:#f92672">==</span> RLIM_INFINITY)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> sysctl_legacy_va_layout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 内存映射区域的起始地址的计算</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/efi.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_COMPAT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_RND_MASK			(test_thread_flag(TIF_32BIT) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">						0x7ff &gt;&gt; (PAGE_SHIFT - 12) : \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">						0x3ffff &gt;&gt; (PAGE_SHIFT - 12))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_RND_MASK			(0x3ffff &gt;&gt; (PAGE_SHIFT - 12))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/mm/mmap.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MIN_GAP (SZ_128M + ((STACK_RND_MASK &lt;&lt; PAGE_SHIFT) + 1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_GAP (STACK_TOP/6*5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">mmap_base</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rnd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> gap <span style="color:#f92672">=</span> rlimit(RLIMIT_STACK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (gap <span style="color:#f92672">&lt;</span> MIN_GAP)
</span></span><span style="display:flex;"><span>           gap <span style="color:#f92672">=</span> MIN_GAP;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (gap <span style="color:#f92672">&gt;</span> MAX_GAP)
</span></span><span style="display:flex;"><span>           gap <span style="color:#f92672">=</span> MAX_GAP;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> PAGE_ALIGN(STACK_TOP <span style="color:#f92672">-</span> gap <span style="color:#f92672">-</span> rnd);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 函数load_elf_binary：函数setup_arg_pages把栈顶设置为STACK_TOP减去随机值，然后把环境变量和参数从临时栈移到最终的用户栈；函数set_brk设置堆的起始地址，如果启用堆随机化，把堆的起始地址加上随机值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// fs/binfmt_elf.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">load_elf_binary</span>(<span style="color:#66d9ef">struct</span> linux_binprm <span style="color:#f92672">*</span>bprm)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     retval <span style="color:#f92672">=</span> setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
</span></span><span style="display:flex;"><span>                     executable_stack);
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     retval <span style="color:#f92672">=</span> set_brk(elf_bss, elf_brk, bss_prot);
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> ((current<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_RANDOMIZE) <span style="color:#f92672">&amp;&amp;</span> (randomize_va_space <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>           current<span style="color:#f92672">-&gt;</span>mm<span style="color:#f92672">-&gt;</span>brk <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>mm<span style="color:#f92672">-&gt;</span>start_brk <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                arch_randomize_brk(current<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="323-内核地址空间布局">3.2.3 内核地址空间布局<a hidden class="anchor" aria-hidden="true" href="#323-内核地址空间布局">#</a></h3>
<center>ARM64处理器架构内核地址空间布局</center>
![20221109225722](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221109225722.png)
<p> (1)先行映射区范围[PAGE_OFFSET, 2^64-1]，起始地址PAGE_OFFSET = (OxFFFF FFFF FFFF FFFF &laquo; (VA_BITS-1))，长度为内核虚拟地址空间的一半，虚拟地址和物理地址是线性关系  \
 虚拟地址 = ((物理地址-PHYS_OFFSET)+PAGE_OFFSET)，PHY_OFFSET是内存起始物理地址
 (2)vmemmap 区域的范围是[VMEMMAP_START, PAGE_OFFSET)，长度是VMEMMAP_SIZE =（线性映射区域的长度 / 页长度 * page结构体的长度上限）
 (3)PCI I/O区域的范围是[PCI_IO_START, PCI_IO_END)，长度是16MB，结束地址是PCI_IO_END = (VMEMMAP_START − 2MB)。外围组件互联（Peripheral Component Interconnect，PCI）是一种总线标准，PCI I/O区域是PCI设备的I/O地址空间
 (4)定映射区域的范围是[FIXADDR_START, FIXADDR_TOP)，长度是FIXADDR_SIZE，结束地址是FIXADDR_TOP = (PCI_IO_START − 2MB)
 (5)vmalloc区域的范围是[VMALLOC_START, VMALLOC_END），起始地址是VMALLOC_START，等于内核模块区域的结束地址，结束地址是VMALLOC_END = (PAGE_OFFSET − PUD_SIZE − VMEMMAP_SIZE − 64KB)，其中PUD_SIZE是页上级目录表项映射的地址空间的长度   <br>
 vmalloc区域是函数vmalloc使用的虚拟地址空间，内核镜像在vmalloc区域，起始虚拟地址是(KIMAGE_VADDR + TEXT_OFFSET) ，其中KIMAGE_VADDR是内核镜像的虚拟地址的基准值，等于内核模块区域的结束地址MODULES_END；TEXT_OFFSET是内存中的内核镜像相对内存起始位置的偏移      <br>
 (6)内核模块区域的范围是[MODULES_VADDR, MODULES_END)，长度是128MB，起始地址是MODULES_VADDR =（内核虚拟地址空间的起始地址 + KASAN影子区域的长度）。内核模块区域是内核模块使用的虚拟地址空间    <br>
 (7)KASAN影子区域的起始地址是内核虚拟地址空间的起始地址，长度是内核虚拟地址空间长度的1/8。内核地址消毒剂（Kernel Address SANitizer，KASAN）是一个动态的内存错误检查工具       \</p>
<h2 id="33-物理地址空间">3.3 物理地址空间<a hidden class="anchor" aria-hidden="true" href="#33-物理地址空间">#</a></h2>
<p> 处理器通过外围设备控制器的寄存器访问外围设备，寄存器分为控制寄存器、状态寄存器和数据寄存器三大类，外围设备的寄存器通常被连续地编址。处理器对外围设备寄存器的编址方式有两种：     <br>
 （1）I/O映射方式(I/O-mapped)  <br>
 （2）内存映射方式(memroy-mapped)：精简指令集的处理器通常只实现一个物理地址空间，外围设备和物理内存使用统一的物理地址空间，处理器可以像访问一个内存单元那样访问外围设备，不需要提供专门的I/O指令     \</p>
<p> 程序通过虚拟地址访问外设寄存器，内核函数把外设寄存器物理地址映射到虚拟地址空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ioremap()把外设寄存器物理地址映射到内核虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">ioremap</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> phys_addr, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// io_remap_pfn_range()函数把外设寄存器的物理地址映射到进程的用户虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_remap_pfn_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, pgprot_t prot);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// iounmap()删除函数ioremap()创建映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iounmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span></code></pre></div><p> ARM64架构两种内存类型：
 （1）正常内存(Normal Memory)：包括物理内存和只读存储器(ROM)，共享属性和可缓存     <br>
 （2）设备内存(Device Memory)：指分配给外围设备寄存器的物理地址区域，外部共享，不可缓存  <br>
 ARM64架构3种属性把设备分为4种类型:      <br>
 （1）Device-nGnRnE          <br>
 （2）Device-nGnRE。          <br>
 （3）Device-nGRE。       <br>
 （4）Device-GRE         \</p>
<p> 寄存器TCR_EL1（Translation Control Register for Exception Level 1，异常级别1的转换控制寄存器）的字段IPS（Intermediate Physical Address Size，中间物理地址长度）控制物理地址的宽度，IPS字段的长度是3位</p>
<h2 id="34内存映射">3.4　内存映射<a hidden class="anchor" aria-hidden="true" href="#34内存映射">#</a></h2>
<p> 进程在虚拟地址空间中创建映射：
 （1）文件映射，把文件一个区间映射到进程虚拟地址空间，数据源是存储设备上的文件，文件页   <br>
 （2）匿名映射，把物理内存映射到进程虚拟地址空间，无数据源，匿名页   <br>
 修改对其他进程可见和释放传递底层文件，内存映射分为共享映射和私有映射。
&amp;ensp；（1）共享映射：修改数据时映射相同区域的其他进程可以看见，如果是文件支持的映射，修改会传递到底层文件。   <br>
 （2）私有映射：第一次修改数据时会从数据源复制一个副本，然后修改副本，其他进程看不见，不影响数据源    <br>
  两个进程可以使用共享的文件映射实现共享内存，进程间通信？。匿名映射通常是私有映射，共享的匿名映射只可能出现在父进程和子进程之间。    <br>
 进程的虚拟地址空间中，代码段和数据段是私有的文件映射，未初始化数据段、堆和栈是私有的匿名映射
 内存映射的原理。   <br>
 （1）创建内存映射的时候，在进程的用户虚拟地址空间中分配一个虚拟内存区域。  <br>
 （2）Linux内核采用延迟分配物理内存的策略，在进程第一次访问虚拟页的时候，产生缺页异常。如果是文件映射，那么分配物理页，把文件指定区间的数据读到物理页中，然后在页表中把虚拟页映射到物理页；如果是匿名映射，那么分配物理页，然后在页表中把虚拟页映射到物理页</p>
<h4 id="341-应用编程接口">3.4.1 应用编程接口<a hidden class="anchor" aria-hidden="true" href="#341-应用编程接口">#</a></h4>
<p> 系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 1.mmap()创建内存映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t length, <span style="color:#66d9ef">int</span> prot, <span style="color:#66d9ef">int</span> flags, in fd, off_t offset);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. mremap()扩大或缩小内存映射，可移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mreemap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>old_address, size_t old_size, size_t new_size, <span style="color:#66d9ef">int</span> flags, ... <span style="color:#75715e">/*void *new_address */</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3. munmap() 删除内存印刷
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">munmap</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t length);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4. brk() 设置堆上界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">brk</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 6. mprotect()设置虚拟内存区域的访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mprotect</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t len, <span style="color:#66d9ef">int</span> prot);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 7. madvise 箱内核体术内存使用建议，配合内核预读和缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">madvise</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t length, <span style="color:#66d9ef">int</span> advice);
</span></span></code></pre></div><p> 内核空间函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 1. remap_pfn_range把内存的物理页映射到进程的虚拟地址空间，实现进程和内核共享内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">remap_pfn_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, pgprot_t prot);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2.io_remap_pfn_range把外设寄存器的物理地址映射到进程的虚拟地址空间，进程可以直接访问外设寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_remap_pfn_range</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size, pgprot_t prot);
</span></span></code></pre></div><p> 应用程序通常使用C标准库提供的函数malloc()申请内存。glibc库的内存分配器ptmalloc使用brk或mmap向内核以页为单位申请虚拟内存，然后把页划分成小内存块分配给应用程序。默认的阈值是128KB，如果应用程序申请的内存长度小于阈值，ptmalloc分配器使用brk向内核申请虚拟内存，否则ptmalloc分配器使用mmap向内核申请虚拟内存   \</p>
<p> 应用程序可以直接使用mmap向内核申请虚拟内存
系统调用mmap()  <br>
系统调用mprotect()  <br>
系统调用madvise()</p>
<h3 id="342-数据结构">3.4.2 数据结构<a hidden class="anchor" aria-hidden="true" href="#342-数据结构">#</a></h3>
<h4 id="1-虚拟内存区域">1. 虚拟内存区域<a hidden class="anchor" aria-hidden="true" href="#1-虚拟内存区域">#</a></h4>
<p> 内核使用结构体<code>vm_area_struct</code>描述虚拟内存区域</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_area_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* The first cache line has the info for VMA tree walking. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Our start address within vm_mm. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_start;	  <span style="color:#75715e">// 起始地址 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* The first byte after our end address within vm_mm. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_end;  <span style="color:#75715e">// 结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* linked list of VM areas per task, sorted by address */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 虚拟内存区域链表，按起始地址排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vm_next, <span style="color:#f92672">*</span>vm_prev;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 	红黑树节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> rb_node vm_rb;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Largest free memory gap in bytes to the left of this VMA.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * get_unmapped_area find a free area of the right size.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rb_subtree_gap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Second cache line starts here. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 指向内存描述符，即虚拟内存区域所属的用户虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>vm_mm;	<span style="color:#75715e">/* The address space we belong to. */</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Access permissions of this VMA.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * See vmf_insert_mixed_prot() for discussion.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 保护位，即访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pgprot_t vm_page_prot;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags;		<span style="color:#75715e">/* Flags, see mm.h. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* For areas with an address space and backing store,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * linkage into the address_space-&gt;i_mmap interval tree.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为了支持查询一个文件区间被映射到哪些虚拟内存区域，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 把一个文件映射到的所有虚拟内存区域加入该文件的地址空间结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// address_space的成员i_mmap指向的区间树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rb_node rb;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rb_subtree_last;
</span></span><span style="display:flex;"><span>	} shared;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*  file&#39;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * or brk vma (with NULL file) can only be in an anon_vma list.*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 把虚拟内存区域关联的所有anon_vma实例串联起来。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 一个虚拟内存区域会关联到父进程的anon_vma实例和自己的anon_vma实例 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> list_head anon_vma_chain; <span style="color:#75715e">/* Serialized by mmap_lock &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">					  * page_table_lock */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 指向一个anon_vma实例，结构体anon_vma用来组织匿名页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 被映射到的所有虚拟地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> anon_vma <span style="color:#f92672">*</span>anon_vma;	<span style="color:#75715e">/* Serialized by page_table_lock */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Function pointers to deal with this struct. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 虚拟内存操作集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> vm_operations_struct <span style="color:#f92672">*</span>vm_ops;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Information about our backing store: */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 文件偏移，单位是页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_pgoff;		<span style="color:#75715e">/* Offset (within vm_file) in PAGE_SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">					   units */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 文件，如果是私有的匿名映射，该成员是空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span> vm_file;		<span style="color:#75715e">/* File we map to (can be NULL). */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> vm_private_data;		<span style="color:#75715e">/* was vm_pte (shared mem) */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SWAP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	atomic_long_t swap_readahead_info;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_MMU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> vm_region <span style="color:#f92672">*</span>vm_region;	<span style="color:#75715e">/* NOMMU mapping region */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mempolicy <span style="color:#f92672">*</span>vm_policy;	<span style="color:#75715e">/* NUMA policy for the VMA */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> vm_userfaultfd_ctx vm_userfaultfd_ctx;
</span></span><span style="display:flex;"><span>} __randomize_layout;
</span></span></code></pre></div><center>文件映射的虚拟内存区域</center>
![20221111234010](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221111234010.png)
<p> （1）成员vm_file指向文件的一个打开实例（file）。索引节点代表一个文件，描述文件的属性。    <br>
 （2）成员vm_pgoff存放文件的以页为单位的偏移。   <br>
 （3）成员vm_ops指向虚拟内存操作集合，创建文件映射的时候调用文件操作集合中的mmap方法（file-&gt;f_op-&gt;mmap）以注册虚拟内存操作集合。例如：假设文件属于EXT4文件系统，文件操作集合中的mmap方法是函数ext4_file_mmap，该函数把虚拟内存区域的成员vm_ops设置为ext4_file_vm_ops</p>
<center>共享匿名映射的虚拟内存区域</center>
![20221111234048](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221111234048.png)
<p> （1）成员vm_file指向文件的一个打开实例（file）。   <br>
 （2）成员vm_pgoff存放文件的以页为单位的偏移。   <br>
 （3）成员vm_ops指向共享内存的虚拟内存操作集合shmem_vm_ops。</p>
<center>私有匿名映射的虚拟内存区域</center>
![20221112001338](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221112001338.png)
<p> （1）页保护位（vm_area_struct.vm_page_prot）：描述虚拟内存区域的访问权限。内核定义了一个保护位映射数组，把VM_READ、VM_WRITE、VM_EXEC和VM_SHARED这4个标志转换成保护位组合        <br>
 P代表私有（Private），S代表共享（Shared），后面的3个数字分别表示可读、可写和可执行，例如__P000表示私有、不可读、不可写和不可执行，__S111表示共享、可读、可写和可执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// mm/mmap.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pgprot_t protection_map[<span style="color:#ae81ff">16</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,
</span></span><span style="display:flex;"><span>    __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pgprot_t <span style="color:#a6e22e">vm_get_page_prot</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> __pgprot(pgprot_val(protection_map[vm_flags <span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>                (VM_READ<span style="color:#f92672">|</span>VM_WRITE<span style="color:#f92672">|</span>VM_EXEC<span style="color:#f92672">|</span>VM_SHARED)]) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>             pgprot_val(arch_vm_get_page_prot(vm_flags)));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://liuz0123.gitee.io/zain/img/wechat_pay.jpg" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://liuz0123.gitee.io/zain/img/alipay.jpg" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://liuz0123.gitee.io/zain/posts/na/%E9%81%93%E6%AD%89/">
    <span class="title">« 上一页</span>
    <br>
    <span>请求娜的原谅</span>
  </a>
  <a class="next" href="https://liuz0123.gitee.io/zain/posts/blog/git/">
    <span class="title">下一页 »</span>
    <br>
    <span>git</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou', 
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2022 
        <a href="https://liuz0123.gitee.io/zain/" style="color:#939393;">zain&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号申请中</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="填自己的公安图标链接" style="float:left;margin: 0px 5px 0px 0px;"/>
             公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
