<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux内核深度解析 | zain&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区">
<meta name="author" content="
&nbsp;Zain">
<link rel="canonical" href="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">
<link crossorigin="anonymous" href="/zain/assets/css/stylesheet.6bbe4903eaf247f5c3db656a51fd7b09d982ab42029edfdc123f359e2748dc03.css" integrity="sha256-a75JA&#43;ryR/XD22VqUf17CdmCq0ICnt/cEj81nidI3AM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/zain/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="apple-touch-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="mask-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Linux内核深度解析" />
<meta property="og:description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-05T00:17:58&#43;08:00" />
<meta property="article:modified_time" content="2022-10-05T00:17:58&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux内核深度解析"/>
<meta name="twitter:description" content="内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://liuz0123.gitee.io/zain/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Linux内核深度解析",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux内核深度解析",
  "name": "Linux内核深度解析",
  "description": "内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区",
  "keywords": [
    ""
  ],
  "articleBody": "内容提纲 内核的引导过程U-Boot 内核管理和调度进程 内核管理虚拟内存和物理内存 内核处理异常和中断的技术原理，以及系统调用的实现方式 保护临界区的互斥 虚拟文件系统 第1章 内核引导和初始化 处理器上电-\u003e执行引导程序-\u003e加载内核到内存-\u003e执行内核-\u003e内核初始化-\u003e启动用户空间第一个进程 ARM64处理器到物理地址0取第一条指令\n1.1 引导程序 1.1.1 入口_start ARM64处理器U-Boot程序执行过程，入口u-boot/arch/arm/cpu/armv8/start.S标识_start\n.globl\t_start _start: #if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER) #include #elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) #include #else b\treset #endif 1.1.2 reset reset: /* Allow the board to save important registers */ /* 允许板卡保存重要的寄存器*/ b\tsave_boot_params .globl\tsave_boot_params_ret save_boot_params_ret: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl // 初始化系统控制寄存器 #endif /* * 异常级别可能是3、2或者1，初始状态： * 小端字节序，禁止MMU，禁止指令/数据缓存 */ adr x0, vectors witch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 // 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址 mrs x0, scr_el3 // 设置安全配置寄存器SCR_EL3 orr x0, x0, #0xf /* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */ msr scr_el3, x0 msr cptr_el3, xzr /* 启用浮点和SIMD功能*/ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* 初始化寄存器CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 // 异常级别2 mov x0, #0x33ff msr cptr_el2, x0 /* 启用浮点和SIMD功能 */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u003c\u003c 20 msr cpacr_el1, x0 /* 启用浮点和SIMD功能 */ 0: … /* 应用ARM处理器特定的勘误表*/ bl apply_core_errata /* 处理器特定的初始化*/ bl lowlevel_init // 执行board_init_f()所需最小初始化 #if defined(CONFIG_ARMV8_SPIN_TABLE) \u0026\u0026 !defined(CONFIG_SPL_BUILD) branch_if_master x0, x1, master_cpu b spin_table_secondary_jump // arch/arm/cpu/armv8/spin_tabli.c /* 绝对不会返回*/ #elif defined(CONFIG_ARMV8_MULTIENTRY) branch_if_master x0, x1, master_cpu /* * 从处理器 */ slave_cpu: wfe // 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数 ldr x1, =CPU_RELEASE_ADDR ldr x0, [x1] cbz x0, slave_cpu br x0 /* 跳转到指定地址*/ #endif /* CONFIG_ARMV8_MULTIENTRY */ master_cpu: bl _main // 主处理器执行函数 U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序\n1.1.3 函数_main // arch/arm/lib/crt0_64.S ENTRY(_main) // 设置初始的C语言运行环境，并且调用board_init_f(0)。 #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节*/ mov x0, sp bl board_init_f_alloc_reserve // 在栈的顶部为结构体global_data分配空间 mov sp, x0 mov x18, x0 /* 设置gd */ // 函数board_init_f_init_reserve，初始化结构体global_data bl board_init_f_init_reserve mov x0, #0 bl board_init_f // common/board_f.c 执行数组init_sequence_f中的每个函数 #if !defined(CONFIG_SPL_BUILD) // 设置中间环境（新的栈指针和gd），然后调用函数 // relocate_code(addr_moni) ldr x0, [x18, #GD_START_ADDR_SP] /* 把寄存器x0设置为gd-\u003estart_addr_sp */ bic sp, x0, #0xf /* 为了符合应用二进制接口规范，对齐到16字节 */ ldr x18, [x18, #GD_BD] /* 把寄存器x18设置为gd-\u003ebd */ sub x18, x18, #GD_SIZE /* 新的gd在bd的下面 */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* 把寄存器x9设置为gd-\u003ereloc_off */ add lr, lr, x9 /* 在重定位后新的返回地址 */ ldr x0, [x18, #GD_RELOCADDR] /* 把寄存器x0设置为gd-\u003erelocaddr */ b relocate_code relocation_return: // 设置最终的完整环境 /* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/ bl c_runtime_cpu_setup #endif /* !CONFIG_SPL_BUILD */ #if defined(CONFIG_SPL_BUILD) bl spl_relocate_stack_gd /* 可能返回空指针 重新定位栈*/ // 执行“sp = (x0 != NULL) ? x0 : sp”， // 规避这个约束： // 带条件的mov指令不能把栈指针寄存器作为操作数 mov x1, sp cmp x0, #0 csel x0, x0, x1, ne mov sp, x0 #endif // 用0初始化未初始化数据段 ldr x0, =__bss_start /* 这是自动重定位*/ ldr x1, =__bss_end /* 这是自动重定位*/ clear_loop: str xzr, [x0], #8 cmp x0, x1 b.lo clear_loop /* 调用函数board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ /* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */ b board_init_r /* 不会运行到这里，因为函数board_init_r()不会返回*/ ENDPROC(_main) 1.1.4 函数run_main_loop 数组init_sequence_r最后一个函数run_main_loop，函数执行流程；\nrun_main_loop main_loop bootdely_process # 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量) autoboot_command abortboot # 等待用户按键 run_command_list # 未等待到按键，自动执行环境变量bootcmd bootm命令处理函数do_bootm\ndo_bootm do_bootm_states bootm_start # 初始化全局变量bootm_header_timages bootm_find_os # 把内核镜像从存储设备读到内存 bootm_find_other # ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件 bootm_load_os # 解压病加载内核到正确位置 bootm_os_get_boot_func # 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux do_bootm_linux(flag=BOOTM_STATE_OS_PREP) # 调用boot_prep_linux boot_prep_linux # 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件 boot_selected_os # do_bootm_linux(flag=BOOTM_STATE_OS_GO) boot_jump_linux # 负责跳转到Linux内核 boot_jum_linux do_nonsec_virt_switch smp_kick_all_cpus # CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3 dcache_disable # 禁用处理器的缓存和内存管理单元 # 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el2 switch_to_el1 armv8_switch_to_el1 内核入口 # 在异常级别2执行内核 armv8_switch_to_el2 内核入口 1.2 内核初始化 内核初始化分为汇编语言部分和C语言部分\n1.2.1 汇编语言部分 ARM64架构内核入口_head，直接跳转到标号stext\n// linux-4.14.295/arch/arm64/kernel/head.S _head: #ifdef CONFIG_EFI // 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS add x13, x18, #0x16 b stext #else b stext // 跳转到内核起始位置 .long0 // 保留 #endif stext\n// linux-4.14.295/arch/arm64/kernel/head.S ENTRY(stext) bl preserve_boot_args // 把引导程序传递的4个参数保存在全局数组boot_args中 bl el2_setup // 降级到异常级别1, 寄存器w0存放cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR偏移，默认值是0 bl set_cpu_boot_mode_flag // __boot_cpu_mode[2] 数组 bl __create_page_tables // 创建页表映射 /* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。 * 返回的时候，处理器已经为开启内存管理单元做好准备， * 转换控制寄存器已经设置好。*/ bl __cpu_setup // 初始化处理器 b __primary_switch // 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel ENDPROC(stext) 函数el2_setup a.如果异常级别是1，那么在异常级别1执行内核。 b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。 1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。 \\\n2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核 \\\n基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程 \\\n// 打开KVM字符设备文件。 fd = open(\"/dev/kvm\", O_RDWR); // 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。 vmfd = ioctl(fd, KVM_CREATE_VM, 0); // KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符 vcpu_fd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 从QEMU切换到客户操作系统的过程如下。 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。 为了提高切换速度，ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2 \\\n函数__create_page_tables 1）创建恒等映射，虚拟地址=物理地址__enable_mmu开启内存管理单元 2）为内核镜像创建映射 \\\n映射代码节.idmap.text,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址\n函数__primary_switch 1）__enable_mmu开启内存管理单元 2）__primary_switched __enable_mmu执行流程 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址 __primary_switch执行流程 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE) 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体thread_info的地址(init_task.thread_info) 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors) 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中 5）用0初始化内核的未初始化数据段 6）调用C语言函数start_kernel \\\n1.2.2 C语言部分 内核初始化的C语言部分入口是函数start_kernel，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数rest_init。函数rest_init的执行流程如下。 （1）创建1号线程，即init线程，线程函数是kernel_init。 （2）创建2号线程，即kthreadd线程，负责创建内核线程。 （3）0号线程最终变成空闲线程。 \\\ninit线程继续初始化，执行的主要操作如下。 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。 （3）smp_init()：初始化SMP系统，启动所有从处理器。 （4）do_initcalls()：执行级别0～7的初始化。 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。 （7）free_initmem()：释放初始化代码和数据占用的内存。 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。 \\\n级别0～7的初始化，是指使用以下宏注册的初始化函数：\n// include/linux/init.h #define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 1.2.3 SMP系统的引导 对称多处理器(Symmetirc Multi-Processor SMP) 3种引导从处理器方法 \\\n自旋表 电源状态协调接口 ACPI停车协议 1.3 init进程 init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有sysvinit、busybox init、upstart、systemd和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件/etc/initab\n第2章 进程管理 2.1 进程 Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。 task_struct结构体是进程描述符，主要成员\nvolatile long state; // 进程状态 void *stack; // 指向内核栈 pid_t pid; // 全局进程号 pid_t tgid // 全局的线程组标识符 struct pid_link pid[PIDTYPE_MAX]; // 进程号，进程组标识符和会话标识符 struct task_struct _rcu *real_parent; // real_parent指向真实的父进程 struct task_struct _rcu *parent; // parent指向父进程 struct task_struct *group_leader; // 指向进村组的组长 const struct cred _rcu *real_cred; // real_cred指向主题和真实客体证书 const struct cred _rcu *cred; // cred指向客体证书 char comm[TASK_COMM_LEN]; // 进程名 int prio, static_prio, nornal_prio; // 调度策略 unsigned int rt_priority,prolicy； // 优先级 cpumask_t cpus_allowed; // 允许进程在哪些处理器上运行 struct mm_struct *mm, *active_mm; // 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符 struct file_struct *files; // 打开文件表 struct nsproxy *nsproxy; // 命名空间 struct signal_struct *signal; // 信号处理 struct sigband_struct *sighand; sigset_t blocked, real_blocked; sigset_t saved_sigmask; struct sigpending pending; struct sysv_sem sysvsem; // UNIx系统5信号量和共享内存 struct sysv_shm sysvshm; 2.2 命名空间 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,虚拟机仅仅是通过命名空间隔离？ \\\n命名空间 隔离资源 控制组cgroup 控制组根目录 进程间通信IPC UNIX系统5进程间通信和POSIx消息队列 network 网络协议 挂载mount 挂载点 PID 进程号 user 用户标识符和组标识符 UNIX分时系统(UTS) 主机名和网络信息服务NIS域名 创建新的命名空间方法： 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间 调用unshare创建新的命名空间 进程使用系统调用setns，绑定一个已经存在的命名空间\n进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。\n2.3 进程标识符 标识符 进程标识符 命名空间给进程分配标识符 线程组标识符 线程组中的主进程称为组长，线程组标识符就是组长的进程标识符\n系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组 进程组标识符 进程组标识符是组长的进程标识符。\n进程可以使用系统调用setpgid创建或者加入一个进程组 会话标识符 进程调用系统调用setsid的时候，创建一个新的会话 pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid \\\n进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，\n2.4 进程关系 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。\n2.4 启动程序 ret = fork(); if (ret \u003e 0) { /* 父进程继续执行 */ } else if (ret == 0) { /* 子进程装载程序 */ ret = execve(filename, argv, envp); } else { /* 创建子进程失败 */ } 2.4.1　创建新进程 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的 两个个系统调用创建进程： \\\nfork：子进程是父进程的副本，用写时复制 clone：可控制子进程和父进程共享哪些资源 vfork：创建子进程，子进程用execve装载程序(已废弃) // 数字表示参数个数 SYSCALL_DEFINE0(fork) // 宏展开 asmlinkage表示C语言函数看被汇编代码调用 asmlinkage long sys_fork(void) 创建进程的进程p和被创建进程c三种关系\n新进程是进程p的子进程 clone传入CLONE_PARENT，兄弟关系 clone传入CLONE_THREAD，同属一个线程组 1. _do_fork函数 // kernel/fork.c long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); // tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址 调用copy_process创建新进程 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置 wake_up_new_task唤醒新进程\n2. copy_process函数 （1）标志组合 CLONE_NEWNS \u0026 CLONE_FS 新进程属于新挂载命名空间\n共享文件系统信息 CLONE_NEWUSER \u0026 CLONE_FS 新进程属于新用户命名空间\n共享文件系统信息 CLONE_THREAD 未设置CLONE_SIGHAND 新进程和当前进程同属一个线程组，\n但不共享信号处理程序 CLONE_SIGHAND 未设置CLONE_VM 新进程和当前进程共享信号处理程序，\n但不共享虚拟内存 （2）dup_task_struct函数 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈 // include/linux/sched.h union thread_union { #ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK struct task_struct task; #endif #ifndef CONFIG_THREAD_INFO_IN_TASK struct thread_info thread_info; #endif unsigned long stack[THREAD_SIZE/sizeof(long)]; }; 内核栈两种布局\nthread_info在内核栈顶部，成员task指向进程描述符 thread_info未占用内核栈 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址 内核栈的长度时THREAD_SIZE，ARM64架构内核栈长度为16KB thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体 // arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long\tflags;\t/* low level flags 底层标志位 */ mm_segment_t\taddr_limit;\t/* address limit 地址限制 */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN u64\tttbr0;\t/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */ #endif u64\tpreempt_count;\t/* 抢占计数器 0 =\u003e preemptible 可抢占, \u003c0 =\u003e bug缺陷 */ }; （3）copy_creds函数 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1\n（4）检查线程数量限制 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS\n（5）sched_fork函数\n为新进程设置调度器相关的参数\n// linux-5.10.102/kernel/sched/core.c 书中为4.x版本 int sched_fork(unsigned long clone_flags, struct task_struct *p) { __sched_fork(clone_flags, p); // 执行基本设置 /* * We mark the process as NEW here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u003estate = TASK_NEW; // 新进程状态设置为TASK_NEW /* * Make sure we do not leak PI boosting priority to the child. */ p-\u003eprio = current-\u003enormal_prio; // 新进程调度优先级设置为当前进程正常优先级 uclamp_fork(p); /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u003esched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { // 限期进程或实时进程 p-\u003epolicy = SCHED_NORMAL; // 调度策略 p-\u003estatic_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u003ert_priority = 0; } else if (PRIO_TO_NICE(p-\u003estatic_prio) \u003c 0) // 普通进程 p-\u003estatic_prio = NICE_TO_PRIO(0); // nice值默认值0，静态优先级120 p-\u003eprio = p-\u003enormal_prio = p-\u003estatic_prio; set_load_weight(p, false); /* * We don't need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u003esched_reset_on_fork = 0; } if (dl_prio(p-\u003eprio)) // 调度优先级是限期调度累的优先级 return -EAGAIN; // 不允许限期进程分叉生成新的限期进程 else if (rt_prio(p-\u003eprio)) // 调度优先级是实时调度类优先级 p-\u003esched_class = \u0026rt_sched_class; // 调度类设置为实时调度类 else p-\u003esched_class = \u0026fair_sched_class; // 调度优先级是公平调度类的优先级，调度类设置为公平调度类 init_entity_runnable_average(\u0026p-\u003ese); #ifdef CONFIG_SCHED_INFO if (likely(sched_info_on())) memset(\u0026p-\u003esched_info, 0, sizeof(p-\u003esched_info)); #endif #if defined(CONFIG_SMP) p-\u003eon_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026p-\u003epushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026p-\u003epushable_dl_tasks); #endif return 0; } （6）复制或共享资源 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数\n// linux-4.14.295/ipc/sem.c int copy_semundo(unsigned long clone_flags, struct task_struct *tsk) { struct sem_undo_list *undo_list; int error; if (clone_flags \u0026 CLONE_SYSVSEM) { // CLONE_SYSTEM表示UNIX系统5信号量 error = get_undo_list(\u0026undo_list); if (error) return error; refcount_inc(\u0026undo_list-\u003erefcnt); // 5信号量的撤销请求链表，sem_undo_list 计数+1 tsk-\u003esysvsem.undo_list = undo_list; } else tsk-\u003esysvsem.undo_list = NULL; // 新进程5信号量撤销请求链表为空 return 0; } 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表\n// linux-5.10.102/kernel/fork.c static int copy_files(unsigned long clone_flags, struct task_struct *tsk) { struct files_struct *oldf, *newf; int error = 0; /* * A background process may not have any files ... */ oldf = current-\u003efiles; if (!oldf) goto out; if (clone_flags \u0026 CLONE_FILES) { // CLONE_FIELS共享打开文件表 atomic_inc(\u0026oldf-\u003ecount); // files_struct 计数加1 goto out; } newf = dup_fd(oldf, NR_OPEN_MAX, \u0026error); // 新进程把当前进程的打开文件表复制一份 if (!newf) goto out; tsk-\u003efiles = newf; error = 0; out: return error; } 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息 函数copy_fs复制或共享文件系统信息\n// linux-5.10.102/kernel/fork.c static int copy_fs(unsigned long clone_flags, struct task_struct *tsk) { struct fs_struct *fs = current-\u003efs; if (clone_flags \u0026 CLONE_FS) { // CLONE_FS共享文件系统信息 /* tsk-\u003efs is already what we want */ spin_lock(\u0026fs-\u003elock); if (fs-\u003ein_exec) { spin_unlock(\u0026fs-\u003elock); return -EAGAIN; } fs-\u003eusers++; // fs_struct共享文件系统信息结构体 加1 spin_unlock(\u0026fs-\u003elock); return 0; } tsk-\u003efs = copy_fs_struct(fs); // 新进程复制当前进程文件系统信息 if (!tsk-\u003efs) return -ENOMEM; return 0; } 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 函数copy_sighand复制或共享信号处理程序\n// static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk) { struct sighand_struct *sig; if (clone_flags \u0026 CLONE_SIGHAND) { // CLONE_SIGHAND 表示共享信号处理程序 refcount_inc(\u0026current-\u003esighand-\u003ecount); // 引用计数加1 return 0; } // 新进程复制当前进程信号处理程序 sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL); RCU_INIT_POINTER(tsk-\u003esighand, sig); if (!sig) return -ENOMEM; refcount_set(\u0026sig-\u003ecount, 1); spin_lock_irq(\u0026current-\u003esighand-\u003esiglock); memcpy(sig-\u003eaction, current-\u003esighand-\u003eaction, sizeof(sig-\u003eaction)); spin_unlock_irq(\u0026current-\u003esighand-\u003esiglock); /* Reset all signal handler not set to SIG_IGN to SIG_DFL. */ if (clone_flags \u0026 CLONE_CLEAR_SIGHAND) flush_signal_handlers(tsk, 0); return 0; } 5）信号结构体，同属一个线程组的线程才会共享信号结构体 函数copy_signal复制或共享信号结构体\n// linux-5.10.102/kernel/fork.c static int copy_signal(unsigned long clone_flags, struct task_struct *tsk) { struct signal_struct *sig; if (clone_flags \u0026 CLONE_THREAD) // CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct return 0; // 为新进程分配结构体，初始化，继承当前进程资源限制 sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL); tsk-\u003esignal = sig; if (!sig) return -ENOMEM; sig-\u003enr_threads = 1; atomic_set(\u0026sig-\u003elive, 1); refcount_set(\u0026sig-\u003esigcnt, 1); /* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */ sig-\u003ethread_head = (struct list_head)LIST_HEAD_INIT(tsk-\u003ethread_node); tsk-\u003ethread_node = (struct list_head)LIST_HEAD_INIT(sig-\u003ethread_head); init_waitqueue_head(\u0026sig-\u003ewait_chldexit); sig-\u003ecurr_target = tsk; init_sigpending(\u0026sig-\u003eshared_pending); INIT_HLIST_HEAD(\u0026sig-\u003emultiprocess); seqlock_init(\u0026sig-\u003estats_lock); prev_cputime_init(\u0026sig-\u003eprev_cputime); #ifdef CONFIG_POSIX_TIMERS INIT_LIST_HEAD(\u0026sig-\u003eposix_timers); hrtimer_init(\u0026sig-\u003ereal_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); sig-\u003ereal_timer.function = it_real_fn; #endif task_lock(current-\u003egroup_leader); memcpy(sig-\u003erlim, current-\u003esignal-\u003erlim, sizeof sig-\u003erlim); task_unlock(current-\u003egroup_leader); posix_cpu_timers_init_group(sig); tty_audit_fork(sig); sched_autogroup_fork(sig); sig-\u003eoom_score_adj = current-\u003esignal-\u003eoom_score_adj; sig-\u003eoom_score_adj_min = current-\u003esignal-\u003eoom_score_adj_min; mutex_init(\u0026sig-\u003ecred_guard_mutex); init_rwsem(\u0026sig-\u003eexec_update_lock); return 0; } 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存 \\ 函数copy_mm复制或共享虚拟内存\n// linux-5.10.102/kernel/freezer.c static int copy_mm(unsigned long clone_flags, struct task_struct *tsk) { struct mm_struct *mm, *oldmm; int retval; tsk-\u003emin_flt = tsk-\u003emaj_flt = 0; tsk-\u003envcsw = tsk-\u003enivcsw = 0; #ifdef CONFIG_DETECT_HUNG_TASK tsk-\u003elast_switch_count = tsk-\u003envcsw + tsk-\u003enivcsw; tsk-\u003elast_switch_time = 0; #endif tsk-\u003emm = NULL; tsk-\u003eactive_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ oldmm = current-\u003emm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); if (clone_flags \u0026 CLONE_VM) { // CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct mmget(oldmm); mm = oldmm; goto good_mm; } retval = -ENOMEM; // 新进程复制当前进程的虚拟内存 mm = dup_mm(tsk, current-\u003emm); if (!mm) goto fail_nomem; good_mm: tsk-\u003emm = mm; tsk-\u003eactive_mm = mm; return 0; fail_nomem: return retval; } 7）命名空间 函数copy_namespace创建或共享命名空间\n// linux-5.10.102/kernel/nsproxy.c int copy_namespaces(unsigned long flags, struct task_struct *tsk) { struct nsproxy *old_ns = tsk-\u003ensproxy; struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns); struct nsproxy *new_ns; int ret; // 如果共享除了用户以外的所有其他命名空间， // 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1 if (likely(!(flags \u0026 (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWCGROUP | CLONE_NEWTIME)))) { if (likely(old_ns-\u003etime_ns_for_children == old_ns-\u003etime_ns)) { get_nsproxy(old_ns); return 0; } } else if (!ns_capable(user_ns, CAP_SYS_ADMIN)) // 进程没有系统管理权限，那么不允许创建新的命名空间 return -EPERM; /* CLONE_NEWIPC must detach from the undolist: after switching * to a new ipc namespace, the semaphore arrays from the old * namespace are unreachable. In clone parlance, CLONE_SYSVSEM * means share undolist with parent, so we must forbid using * it along with CLONE_NEWIPC. */ // 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的 if ((flags \u0026 (CLONE_NEWIPC | CLONE_SYSVSEM)) == (CLONE_NEWIPC | CLONE_SYSVSEM)) return -EINVAL; // 创建新的命名空间代理，然后创建或者共享命名空间 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-\u003efs); if (IS_ERR(new_ns)) return PTR_ERR(new_ns); ret = timens_on_fork(new_ns, tsk); if (ret) { free_nsproxy(new_ns); return ret; } tsk-\u003ensproxy = new_ns; return 0; } 8）I/O上下文 函数copy_io创建或共享I/O上下文\n// linux-5.10.102/kernel/fork.c static int copy_io(unsigned long clone_flags, struct task_struct *tsk) { #ifdef CONFIG_BLOCK struct io_context *ioc = current-\u003eio_context; struct io_context *new_ioc; if (!ioc) return 0; /* Share io context with parent, if CLONE_IO is set */ if (clone_flags \u0026 CLONE_IO) { // CLONE_IO 共享I/O上小文 ioc_task_link(ioc); // 计数nr_tasks加1 tsk-\u003eio_context = ioc; // 共享I/O上下文结构体io_context } else if (ioprio_valid(ioc-\u003eioprio)) { // 创建新的I/O上下文，初始化，继承当前进程的I/O优先级 new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE); if (unlikely(!new_ioc)) return -ENOMEM; new_ioc-\u003eioprio = ioc-\u003eioprio; put_io_context(new_ioc); } #endif return 0; } 9）复制寄存器值 函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct\nARM64架构copy_thread_tls-\u003ecopy_thread\n// linux-5.10.102/arch/arm64/kernel/process.c int copy_thread(unsigned long clone_flags, unsigned long stack_start, unsigned long stk_sz, struct task_struct *p, unsigned long tls) { struct pt_regs *childregs = task_pt_regs(p); // 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值 memset(\u0026p-\u003ethread.cpu_context, 0, sizeof(struct cpu_context)); /* In case p was allocated the same task_struct pointer as some * other recently-exited task, make sure p is disassociated from * any cpu that may have run that now-exited task recently. * Otherwise we could erroneously skip reloading the FPSIMD * registers for p. */ fpsimd_flush_task_state(p); ptrauth_thread_init_kernel(p); if (likely(!(p-\u003eflags \u0026 PF_KTHREAD))) { // 用户进程 *childregs = *current_pt_regs(); childregs-\u003eregs[0] = 0; /* Read the current TLS pointer from tpidr_el0 as it may be * out-of-sync with the saved value. * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址， * 因为它可能和保存的值不一致 */ *task_user_tls(p) = read_sysreg(tpidr_el0); if (stack_start) { if (is_compat_thread(task_thread_info(p))) childregs-\u003ecompat_sp = stack_start; else childregs-\u003esp = stack_start; } /* If a TLS pointer was passed to clone, use it for the new thread. * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/ if (clone_flags \u0026 CLONE_SETTLS) p-\u003ethread.uw.tp_value = tls; } else { // 内核线程 memset(childregs, 0, sizeof(struct pt_regs)); childregs-\u003epstate = PSR_MODE_EL1h; if (IS_ENABLED(CONFIG_ARM64_UAO) \u0026\u0026 cpus_have_const_cap(ARM64_HAS_UAO)) childregs-\u003epstate |= PSR_UAO_BIT; spectre_v4_enable_task_mitigation(p); if (system_uses_irq_prio_masking()) childregs-\u003epmr_save = GIC_PRIO_IRQON; p-\u003ethread.cpu_context.x19 = stack_start; p-\u003ethread.cpu_context.x20 = stk_sz; } p-\u003ethread.cpu_context.pc = (unsigned long)ret_from_fork; p-\u003ethread.cpu_context.sp = (unsigned long)childregs; ptrace_hw_copy_thread(p); return 0; } （7）设置进程号和进程关系 static __latent_entropy struct task_struct *copy_process( struct pid *pid, int trace, int node, struct kernel_clone_args *args) { // 为新进程分配进程号 // pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号 if (pid != \u0026init_struct_pid) { pid = alloc_pid(p-\u003ensproxy-\u003epid_ns_for_children); if (IS_ERR(pid)) { retval = PTR_ERR(pid); goto bad_fork_cleanup_thread; } } … // 设置新进程退出时发送给父进程的信号 p-\u003epid = pid_nr(pid); if (clone_flags \u0026 CLONE_THREAD) { p-\u003eexit_signal = -1; // 新线程退出时不需要发送信号给父进程 p-\u003egroup_leader = current-\u003egroup_leader; // group_leader指向同一个组长 p-\u003etgid = current-\u003etgid; // tgid存放组长的进程号 } else { if (clone_flags \u0026 CLONE_PARENT) // CLONE_PARENT 新进程和当前进程是兄弟关系 p-\u003eexit_signal = current-\u003egroup_leader-\u003eexit_signal; // 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal else // 父子关系 p-\u003eexit_signal = (clone_flags \u0026 CSIGNAL); // 新进程的成员exit_signal是调用者指定的信号 p-\u003egroup_leader = p; p-\u003etgid = p-\u003epid; } // 控制组的进程数控制器检查是否允许创建新进程： // 从当前进程所属的控制组一直到控制组层级的根， // 如果其中一个控制组的进程数量大于或等于限制， // 那么不允许使用fork和clone创建新进程 cgroup_threadgroup_change_begin(current); retval = cgroup_can_fork(p); if (retval) goto bad_fork_free_pid; write_lock_irq(\u0026tasklist_lock); // 为新进程设置父进程 if (clone_flags \u0026 (CLONE_PARENT|CLONE_THREAD)) { // 新进程和当前进程拥有相同的父进程 p-\u003ereal_parent = current-\u003ereal_parent; p-\u003eparent_exec_id = current-\u003eparent_exec_id; } else { p-\u003ereal_parent = current; // 新进程的父进程是当前进程 p-\u003eparent_exec_id = current-\u003eself_exec_id; } … spin_lock(\u0026current-\u003esighand-\u003esiglock); … if (likely(p-\u003epid)) { … init_task_pid(p, PIDTYPE_PID, pid); if (thread_group_leader(p)) { // true 新进程和当前进程属于同一个进程组 init_task_pid(p, PIDTYPE_PGID, task_pgrp(current)); // 指向同一个进程组的组长的进程号结构体 init_task_pid(p, PIDTYPE_SID, task_session(current)); // 指向同一个会话的控制进程的进程号结构体 if (is_child_reaper(pid)) { ns_of_pid(pid)-\u003echild_reaper = p; p-\u003esignal-\u003eflags |= SIGNAL_UNKILLABLE; // 1号进程是不能杀死的 } p-\u003esignal-\u003eleader_pid = pid; p-\u003esignal-\u003etty = tty_kref_get(current-\u003esignal-\u003etty); p-\u003esignal-\u003ehas_child_subreaper = p-\u003ereal_parent-\u003esignal-\u003e has_child_subreaper || p-\u003ereal_parent-\u003esignal-\u003eis_child_subreaper; list_add_tail(\u0026p-\u003esibling, \u0026p-\u003ereal_parent-\u003echildren); // 新进程添加到父进程的子进程链表 // 新进程添加到进程链表中，链表节点是成员tasks， // 头节点是空闲线程的成员tasks（init_task.tasks） list_add_tail_rcu(\u0026p-\u003etasks, \u0026init_task.tasks); attach_pid(p, PIDTYPE_PGID); // 新进程添加到进程组的进程链表 attach_pid(p, PIDTYPE_SID); // 新进程添加到会话的进程链表 __this_cpu_inc(process_counts); } else { // 创建线程 current-\u003esignal-\u003enr_threads++; // 线程组的线程计数值加1 atomic_inc(\u0026current-\u003esignal-\u003elive); // 原子变量线程组的第2个线程计数值加1 atomic_inc(\u0026current-\u003esignal-\u003esigcnt); // 信号结构体的引用计数加1 list_add_tail_rcu(\u0026p-\u003ethread_group, \u0026p-\u003egroup_leader-\u003ethread_group); // 线程加入线程组的线程链表 list_add_tail_rcu(\u0026p-\u003ethread_node, \u0026p-\u003esignal-\u003ethread_head); // 线程加入线程组的第二条线程链表 } attach_pid(p, PIDTYPE_PID); // 新进程添加到进程号结构体的进程链表 nr_threads++; // 新进程添加到进程号结构体的进程链表 } total_forks++; spin_unlock(\u0026current-\u003esighand-\u003esiglock); … write_unlock_irq(\u0026tasklist_lock); proc_fork_connector(p); cgroup_post_fork(p); cgroup_threadgroup_change_end(current); … return p; } 3.唤醒新进程 wake_up_new_task函数唤醒新进程\n// linux-5.10.102/kernel/sched/core.c void wake_up_new_task(struct task_struct *p) { struct rq_flags rf; struct rq *rq; raw_spin_lock_irqsave(\u0026p-\u003epi_lock, rf.flags); p-\u003estate = TASK_RUNNING; // 切换TASK_RUNNING #ifdef CONFIG_SMP /* Fork balancing, do it here and not earlier because: * - cpus_ptr can change in the fork path * - any previously selected CPU might disappear through hotplug * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq, * as we're not fully set-up yet.*/ p-\u003erecent_used_cpu = task_cpu(p); rseq_migrate(p); __set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); // 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器 #endif rq = __task_rq_lock(p, \u0026rf); // 锁住运行队列 update_rq_clock(rq); // 更新运行队列的时钟 post_init_entity_util_avg(p); // 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值 activate_task(rq, p, ENQUEUE_NOCLOCK); // 把新进程插入运行队列 trace_sched_wakeup_new(p); check_preempt_curr(rq, p, WF_FORK); // 检查新进程是否可以抢占当前进程 #ifdef CONFIG_SMP if (p-\u003esched_class-\u003etask_woken) { // 在SMP系统上，调用调度类的task_woken方法 /* Nothing relies on rq-\u003elock after this, so its fine to * drop it.*/ rq_unpin_lock(rq, \u0026rf); p-\u003esched_class-\u003etask_woken(rq, p); rq_repin_lock(rq, \u0026rf); } #endif task_rq_unlock(rq, p, \u0026rf); // 释放运行队列的锁 } 4.新进程第一次运行 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数\n// linux-5.10.102/arch/arm64/kernel/entry.S tsk .req x28 //当前进程的thread_info结构体的地址 SYM_CODE_START(ret_from_fork) bl\tschedule_tail // 为上一个进程执行清理操作 cbz\tx19, 1f // not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1 mov\tx0, x20 // 内核线程：x19存放线程函数的地址，x20存放线程函数的参数 blr\tx19 // 调用线程函数 1:\tget_current_task tsk // 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址 b\tret_to_user // 返回用户模式 SYM_CODE_END(ret_from_fork) NOKPROBE(ret_from_fork) copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0 // linux-5.10.102/kernel/sched/core.c asmlinkage __visible void schedule_tail(struct task_struct *prev) __releases(rq-\u003elock) { struct rq *rq; /* New tasks start with FORK_PREEMPT_COUNT, see there and * finish_task_switch() for details. * * finish_task_switch() will drop rq-\u003elock() and lower preempt_count * and the preempt_enable() will end up enabling preemption (on * PREEMPT_COUNT kernels).*/ rq = finish_task_switch(prev); // 为上一个进程执行清理操作2.8.6 balance_callback(rq); // 执行运行队列的所有负载均衡回调函数 preempt_enable(); // 开启内核抢占 if (current-\u003eset_child_tid) // pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置 put_user(task_pid_vnr(current), current-\u003eset_child_tid); calculate_sigpending(); } 2.4.2 装载程序 调度器调度新进程，新进程从函数ret_from_fork开始，从系统调用fork返回用户空间，返回值0。然后新进程使用系统调用execve装载程序。Linux内核练个装载程序系统调用： \\\n// 路径名是相对时execve解释为相对调用进程的当前工作目录 int execve(const char *filename, char *const argv[], char *const envp[]); // 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录 // 路径名时绝对的，execveat忽略参数dirfd int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); 参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值\n两个系统调用最终都调用函数do_execveat_common 函数do_open_execat打开可执行文件。 函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器 函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-\u003ep指向在栈底保留一个字长（指针长度）后的位置 函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？ \\ 依次把文件名称、环境字符串和参数字符串压到用户栈 函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止\n1.二进制格式 Linux二进制格式\n// linux-5.10.102/include/linux/binfmts.h struct linux_binfmt { struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump;\t/* minimal dump size */ } __randomize_layout; 二进制格式提供3个函数 (1)load_binary 加载普通程序 (2)load_shlib 加载共享库 (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度 二进制格式使用register_binfmt向内核注册\n2.装载ELF程序 ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 linux-5.10.102/include/uapi/linux/elf.h\n目标文件(可重定位文件)，.o，多个模板文件链接生成可执行文件或共享库 可执行文件 共享库 .so 核心转储文件(core dump file) ELF文件分成4部分：ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)，ELF只有首部的位置是固定的。\n程序首部表就是段表(segment table)，段(segment)是从运行角度描述，节(section)是从链接角度描述。 64位ELF文件格式\n参考链接： ELF 格式详解 https://blog.csdn.net/shanandqiu/article/details/115206426 ELF文件格式简介 https://blog.csdn.net/GrayOnDream/article/details/124564129\n# 查看ELF首部 readelf -h # 查看程序首部表 readelf -l # 查看节首部表 readelf -S ELF解析程序 linux-5.10.102/fs/binfmt_elf.c 解析64位ELF程序，和处理器架构无关 linux-5.10.102/fs/compat_binfmt_elf.c 在64位内核中解析32位ELF程序，和处理器架构无 \\\n装载ELF程序函数load_elf_binary\n1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构 2）读取程序首部表 3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。 4）检查解释器的ELF首部，读取解释器的程序首部表 5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间 6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域 7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈 8）把可加载段映射到进程的虚拟地址空间 9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段 10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口 11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈 12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread\n// linux-5.10.102/arch/arm64/include/asm/processor.h static inline void start_thread_common(struct pt_regs *regs, unsigned long pc) { memset(regs, 0, sizeof(*regs)); forget_syscall(regs); regs-\u003epc = pc; /* 把程序计数器设置为程序的入口 */ } static inline void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp) { start_thread_common(regs, pc); regs-\u003epstate = PSR_MODE_EL0t; /* 把处理器状态设置为0，其中异常级别是0 */ spectre_v4_enable_task_mitigation(current); regs-\u003esp = sp; /*设置用户栈指针 */ } 3.装载脚本程序 脚本程序前两个字节是#!，后面是解释器程序的名称和参数。解释器用来执行脚本程序 linux-5.10.102/fs/binfmt_script.c函数load_script负责装载脚本程序\n1）检查前两个字节是不是脚本程序的标识符 2）解析处解释程序的名称和参数 3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈 4）调用opens_exec打开解释程序文件 5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区 6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止 \\\n2.6 进程退出 进程退出两种情况：进程主动退出和终止进程 Linux内核两个主动退出的系统调用 \\\n// 线程退出 void exit(int status); // 一个线程组所有线程退出 void exit_group(int status); glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数 终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用\n// // 发送信号给进程或进程组 int kill(pid_t pid, int sig); // 发送信号给线程 已废弃 int tkill(int tid, int sig); // 发送信号给线程 int tgkill(int tgid, int tid, int sig); 父进程是否关注子进程退出事假， 1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。 2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 \\\n",
  "wordCount" : "14547",
  "inLanguage": "en",
  "datePublished": "2022-10-05T00:17:58+08:00",
  "dateModified": "2022-10-05T00:17:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Zain"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zain's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://liuz0123.gitee.io/zain/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://liuz0123.gitee.io/zain/" accesskey="h" title="Zain&#39;s Blog (Alt + H)">
            <img src="https://liuz0123.gitee.io/zain/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">Zain&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://liuz0123.gitee.io/zain/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/links" title="🤝 闲言俗语">
                <span>🤝 闲言俗语</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://liuz0123.gitee.io/zain/">主页</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                Linux内核深度解析
            </h1>
            <div class="post-meta">Create:&nbsp;<span title='2022-10-05 00:17:58 +0800 CST'>2022-10-05</span>&nbsp;|&nbsp;Update:&nbsp;2022-10-05&nbsp;|&nbsp;Words:&nbsp;14547&nbsp;|&nbsp;&nbsp;30 min&nbsp;|&nbsp;
&nbsp;Zain



                &nbsp;|&nbsp;tags: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://liuz0123.gitee.io/zain/tags/tech/">tech</a>
                    <a href="https://liuz0123.gitee.io/zain/tags/linux/">、linux</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| Viewers: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%86%85%e5%ae%b9%e6%8f%90%e7%ba%b2" aria-label="内容提纲">内容提纲</a></li>
                <li>
                    <a href="#%e7%ac%ac1%e7%ab%a0-%e5%86%85%e6%a0%b8%e5%bc%95%e5%af%bc%e5%92%8c%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="第1章 内核引导和初始化">第1章 内核引导和初始化</a><ul>
                        
                <li>
                    <a href="#11-%e5%bc%95%e5%af%bc%e7%a8%8b%e5%ba%8f" aria-label="1.1 引导程序">1.1 引导程序</a><ul>
                        
                <li>
                    <a href="#111-%e5%85%a5%e5%8f%a3_start" aria-label="1.1.1 入口_start">1.1.1 入口_start</a></li>
                <li>
                    <a href="#112-reset" aria-label="1.1.2 reset">1.1.2 <code>reset</code></a></li>
                <li>
                    <a href="#113-%e5%87%bd%e6%95%b0_main" aria-label="1.1.3 函数_main">1.1.3 函数_main</a></li>
                <li>
                    <a href="#114-%e5%87%bd%e6%95%b0run_main_loop" aria-label="1.1.4 函数run_main_loop">1.1.4 函数run_main_loop</a></li></ul>
                </li>
                <li>
                    <a href="#12-%e5%86%85%e6%a0%b8%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="1.2 内核初始化">1.2 内核初始化</a><ul>
                        
                <li>
                    <a href="#121-%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86" aria-label="1.2.1 汇编语言部分">1.2.1 汇编语言部分</a></li>
                <li>
                    <a href="#122-c%e8%af%ad%e8%a8%80%e9%83%a8%e5%88%86" aria-label="1.2.2 C语言部分">1.2.2 C语言部分</a></li>
                <li>
                    <a href="#123-smp%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%bc%95%e5%af%bc" aria-label="1.2.3 SMP系统的引导">1.2.3 SMP系统的引导</a></li></ul>
                </li>
                <li>
                    <a href="#13-init%e8%bf%9b%e7%a8%8b" aria-label="1.3 init进程">1.3 init进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac2%e7%ab%a0-%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86" aria-label="第2章 进程管理">第2章 进程管理</a><ul>
                        
                <li>
                    <a href="#21-%e8%bf%9b%e7%a8%8b" aria-label="2.1 进程">2.1 进程</a></li>
                <li>
                    <a href="#22-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="2.2 命名空间">2.2 命名空间</a></li>
                <li>
                    <a href="#23-%e8%bf%9b%e7%a8%8b%e6%a0%87%e8%af%86%e7%ac%a6" aria-label="2.3 进程标识符">2.3 进程标识符</a></li>
                <li>
                    <a href="#24-%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb" aria-label="2.4 进程关系">2.4 进程关系</a></li>
                <li>
                    <a href="#24-%e5%90%af%e5%8a%a8%e7%a8%8b%e5%ba%8f" aria-label="2.4 启动程序">2.4 启动程序</a><ul>
                        
                <li>
                    <a href="#241%e5%88%9b%e5%bb%ba%e6%96%b0%e8%bf%9b%e7%a8%8b" aria-label="2.4.1　创建新进程">2.4.1　创建新进程</a><ul>
                        
                <li>
                    <a href="#1-_do_fork%e5%87%bd%e6%95%b0" aria-label="1. _do_fork函数">1. _do_fork函数</a></li>
                <li>
                    <a href="#2-copy_process%e5%87%bd%e6%95%b0" aria-label="2. copy_process函数">2. copy_process函数</a></li>
                <li>
                    <a href="#3%e5%94%a4%e9%86%92%e6%96%b0%e8%bf%9b%e7%a8%8b" aria-label="3.唤醒新进程">3.唤醒新进程</a></li>
                <li>
                    <a href="#4%e6%96%b0%e8%bf%9b%e7%a8%8b%e7%ac%ac%e4%b8%80%e6%ac%a1%e8%bf%90%e8%a1%8c" aria-label="4.新进程第一次运行">4.新进程第一次运行</a></li></ul>
                </li>
                <li>
                    <a href="#242-%e8%a3%85%e8%bd%bd%e7%a8%8b%e5%ba%8f" aria-label="2.4.2 装载程序">2.4.2 装载程序</a><ul>
                        
                <li>
                    <a href="#1%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%a0%bc%e5%bc%8f" aria-label="1.二进制格式">1.二进制格式</a></li>
                <li>
                    <a href="#2%e8%a3%85%e8%bd%bdelf%e7%a8%8b%e5%ba%8f" aria-label="2.装载ELF程序">2.装载ELF程序</a></li>
                <li>
                    <a href="#3%e8%a3%85%e8%bd%bd%e8%84%9a%e6%9c%ac%e7%a8%8b%e5%ba%8f" aria-label="3.装载脚本程序">3.装载脚本程序</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#26-%e8%bf%9b%e7%a8%8b%e9%80%80%e5%87%ba" aria-label="2.6 进程退出">2.6 进程退出</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h1 id="内容提纲">内容提纲<a hidden class="anchor" aria-hidden="true" href="#内容提纲">#</a></h1>
<ul>
<li>内核的引导过程U-Boot</li>
<li>内核管理和调度进程</li>
<li>内核管理虚拟内存和物理内存</li>
<li>内核处理异常和中断的技术原理，以及系统调用的实现方式</li>
<li>保护临界区的互斥</li>
<li>虚拟文件系统</li>
</ul>
<h1 id="第1章-内核引导和初始化">第1章 内核引导和初始化<a hidden class="anchor" aria-hidden="true" href="#第1章-内核引导和初始化">#</a></h1>
<p> 处理器上电-&gt;执行引导程序-&gt;加载内核到内存-&gt;执行内核-&gt;内核初始化-&gt;启动用户空间第一个进程
 ARM64处理器到物理地址0取第一条指令</p>
<h2 id="11-引导程序">1.1 引导程序<a hidden class="anchor" aria-hidden="true" href="#11-引导程序">#</a></h2>
<h3 id="111-入口_start">1.1.1 入口_start<a hidden class="anchor" aria-hidden="true" href="#111-入口_start">#</a></h3>
<p> ARM64处理器U-Boot程序执行过程，入口<a href="https://elixir.bootlin.com/u-boot/latest/source/arch/arm/cpu/armv8/start.S#L20"><code>u-boot/arch/arm/cpu/armv8/start.S</code></a>标识<code>_start</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>.globl	_start
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_LINUX_KERNEL_IMAGE_HEADER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/boot0-linux-kernel-header.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/arch/boot0.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b	reset
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><h3 id="112-reset">1.1.2 <code>reset</code><a hidden class="anchor" aria-hidden="true" href="#112-reset">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>reset:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Allow the board to save important registers */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 允许板卡保存重要的寄存器*/</span>
</span></span><span style="display:flex;"><span>	b	save_boot_params
</span></span><span style="display:flex;"><span>.globl	save_boot_params_ret
</span></span><span style="display:flex;"><span>save_boot_params_ret:
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SYS_RESET_SCTRL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl reset_sctrl   <span style="color:#75715e">// 初始化系统控制寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 异常级别可能是3、2或者1，初始状态：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 小端字节序，禁止MMU，禁止指令/数据缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>    adr  x0, vectors
</span></span><span style="display:flex;"><span>    witch_el x1, <span style="color:#ae81ff">3f</span>, <span style="color:#ae81ff">2f</span>, <span style="color:#ae81ff">1f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>  msr  vbar_el3, x0    <span style="color:#75715e">// 异常级别3，向量基准地址寄存器VBAR_EL3设置位异常向量的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mrs  x0, scr_el3   <span style="color:#75715e">// 设置安全配置寄存器SCR_EL3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    orr  x0, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>         <span style="color:#75715e">/* 设置寄存器SCR_EL3的NS、IRQ、FIQ和EA四个位 */</span>
</span></span><span style="display:flex;"><span>    msr  scr_el3, x0
</span></span><span style="display:flex;"><span>    msr  cptr_el3, xzr           <span style="color:#75715e">/* 启用浮点和SIMD功能*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef COUNTER_FREQUENCY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>COUNTER_FREQUENCY
</span></span><span style="display:flex;"><span>    msr  cntfrq_el0, x0          <span style="color:#75715e">/* 初始化寄存器CNTFRQ */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>  msr   vbar_el2, x0   		<span style="color:#75715e">// 异常级别2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x33ff</span>
</span></span><span style="display:flex;"><span>    msr  cptr_el2, x0            <span style="color:#75715e">/* 启用浮点和SIMD功能 */</span>
</span></span><span style="display:flex;"><span>    b    <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>  msr    vbar_el1, x0
</span></span><span style="display:flex;"><span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>    msr  cpacr_el1, x0           <span style="color:#75715e">/* 启用浮点和SIMD功能 */</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 应用ARM处理器特定的勘误表*/</span>
</span></span><span style="display:flex;"><span>bl   apply_core_errata
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* 处理器特定的初始化*/</span>
</span></span><span style="display:flex;"><span>bl   lowlevel_init    <span style="color:#75715e">// 执行board_init_f()所需最小初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_ARMV8_SPIN_TABLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    branch_if_master x0, x1, master_cpu
</span></span><span style="display:flex;"><span>    b    spin_table_secondary_jump    <span style="color:#75715e">// arch/arm/cpu/armv8/spin_tabli.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/* 绝对不会返回*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_ARMV8_MULTIENTRY)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>branch_if_master x0, x1, master_cpu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 从处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>slave_cpu:
</span></span><span style="display:flex;"><span>    wfe
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从处理器进入低功耗状态，它被唤醒的时候，从地址CPU_RELEASE_ADDR读取函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x1, <span style="color:#f92672">=</span>CPU_RELEASE_ADDR 
</span></span><span style="display:flex;"><span>    ldr  x0, [x1]
</span></span><span style="display:flex;"><span>    cbz  x0, slave_cpu
</span></span><span style="display:flex;"><span>    br   x0               <span style="color:#75715e">/* 跳转到指定地址*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_ARMV8_MULTIENTRY */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>master_cpu:
</span></span><span style="display:flex;"><span>    bl   _main  <span style="color:#75715e">// 主处理器执行函数
</span></span></span></code></pre></div><p> U-Boot分为SPL和正常的U-Boot程序两个部分，如果想要编译为SPL，需要开启配置宏CONFIG_SPL_BUILD。SPL是“Secondary Program Loader”的简称，即第二阶段程序加载器，第二阶段是相对于处理器里面的只读存储器中的固化程序来说的，处理器启动时最先执行的是只读存储器中的固化程序</p>
<h3 id="113-函数_main">1.1.3 函数_main<a hidden class="anchor" aria-hidden="true" href="#113-函数_main">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm/lib/crt0_64.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ENTRY(_main)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置初始的C语言运行环境，并且调用board_init_f(0)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>(CONFIG_SPL_STACK)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>(CONFIG_SYS_INIT_SP_ADDR)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bic  sp, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>   <span style="color:#75715e">/* 为了符合应用二进制接口规范，对齐到16字节*/</span>
</span></span><span style="display:flex;"><span>    mov  x0, sp
</span></span><span style="display:flex;"><span>    bl   board_init_f_alloc_reserve <span style="color:#75715e">// 在栈的顶部为结构体global_data分配空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  sp, x0
</span></span><span style="display:flex;"><span>    mov  x18, x0  <span style="color:#75715e">/* 设置gd */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 函数board_init_f_init_reserve，初始化结构体global_data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   board_init_f_init_reserve  
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    mov  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    bl   board_init_f <span style="color:#75715e">// common/board_f.c 执行数组init_sequence_f中的每个函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if !defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// 设置中间环境（新的栈指针和gd），然后调用函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// relocate_code(addr_moni)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_START_ADDR_SP]    <span style="color:#75715e">/* 把寄存器x0设置为gd-&gt;start_addr_sp */</span>
</span></span><span style="display:flex;"><span>    bic  sp, x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0xf</span>             <span style="color:#75715e">/* 为了符合应用二进制接口规范，对齐到16字节 */</span>
</span></span><span style="display:flex;"><span>    ldr  x18, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_BD]       <span style="color:#75715e">/* 把寄存器x18设置为gd-&gt;bd */</span>
</span></span><span style="display:flex;"><span>    sub  x18, x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_SIZE       <span style="color:#75715e">/* 新的gd在bd的下面 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    adr  lr, relocation_return
</span></span><span style="display:flex;"><span>    ldr  x9, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOC_OFF]    <span style="color:#75715e">/* 把寄存器x9设置为gd-&gt;reloc_off */</span>
</span></span><span style="display:flex;"><span>    add  lr, lr, x9    <span style="color:#75715e">/* 在重定位后新的返回地址 */</span>
</span></span><span style="display:flex;"><span>    ldr  x0, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOCADDR]    <span style="color:#75715e">/* 把寄存器x0设置为gd-&gt;relocaddr */</span>
</span></span><span style="display:flex;"><span>    b    relocate_code
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>relocation_return:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 设置最终的完整环境
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">/* 仍然调用旧的例程 把向量基准地址寄存器设置为异常向量表的起始地址*/</span>
</span></span><span style="display:flex;"><span>    bl   c_runtime_cpu_setup  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* !CONFIG_SPL_BUILD */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SPL_BUILD)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   spl_relocate_stack_gd    <span style="color:#75715e">/* 可能返回空指针 重新定位栈*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行“sp = (x0 != NULL) ? x0 : sp”，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 规避这个约束：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 带条件的mov指令不能把栈指针寄存器作为操作数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mov  x1, sp
</span></span><span style="display:flex;"><span>    cmp  x0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    csel x0, x0, x1, ne
</span></span><span style="display:flex;"><span>    mov  sp, x0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用0初始化未初始化数据段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ldr  x0, <span style="color:#f92672">=</span>__bss_start      <span style="color:#75715e">/* 这是自动重定位*/</span>
</span></span><span style="display:flex;"><span>    ldr  x1, <span style="color:#f92672">=</span>__bss_end        <span style="color:#75715e">/* 这是自动重定位*/</span>
</span></span><span style="display:flex;"><span>clear_loop:
</span></span><span style="display:flex;"><span>    str  xzr, [x0], <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    cmp  x0, x1
</span></span><span style="display:flex;"><span>    b.lo clear_loop
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 调用函数board_init_r(gd_t *id, ulong dest_addr) */</span>
</span></span><span style="display:flex;"><span>    mov  x0, x18                     <span style="color:#75715e">/* gd_t */</span>
</span></span><span style="display:flex;"><span>    ldr  x1, [x18, <span style="color:#960050;background-color:#1e0010">#</span>GD_RELOCADDR]    <span style="color:#75715e">/* dest_addr */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 相对程序计数器的跳转 common/board_r.c 执行数组init_sequence_r中的每个函数，最后一个函数是run_main_loop */</span>
</span></span><span style="display:flex;"><span>    b    board_init_r   
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/* 不会运行到这里，因为函数board_init_r()不会返回*/</span>
</span></span><span style="display:flex;"><span>ENDPROC(_main)
</span></span></code></pre></div><h3 id="114-函数run_main_loop">1.1.4 函数run_main_loop<a hidden class="anchor" aria-hidden="true" href="#114-函数run_main_loop">#</a></h3>
<p> 数组<code>init_sequence_r</code>最后一个函数<code>run_main_loop</code>，函数执行流程；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>run_main_loop
</span></span><span style="display:flex;"><span>    main_loop
</span></span><span style="display:flex;"><span>        bootdely_process <span style="color:#75715e"># 读取环境变量bootdelay(延迟时间)和bootcmd(环境变量)</span>
</span></span><span style="display:flex;"><span>        autoboot_command
</span></span><span style="display:flex;"><span>            abortboot    <span style="color:#75715e"># 等待用户按键</span>
</span></span><span style="display:flex;"><span>            run_command_list  <span style="color:#75715e"># 未等待到按键，自动执行环境变量bootcmd</span>
</span></span></code></pre></div><p> <code>bootm</code>命令处理函数<code>do_bootm</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>do_bootm
</span></span><span style="display:flex;"><span>    do_bootm_states
</span></span><span style="display:flex;"><span>        bootm_start   <span style="color:#75715e"># 初始化全局变量bootm_header_timages</span>
</span></span><span style="display:flex;"><span>        bootm_find_os    <span style="color:#75715e"># 把内核镜像从存储设备读到内存</span>
</span></span><span style="display:flex;"><span>        bootm_find_other    <span style="color:#75715e"># ARM64 扁平设备树(Flattended Device Tree FDT)二进制文件</span>
</span></span><span style="display:flex;"><span>        bootm_load_os  <span style="color:#75715e"># 解压病加载内核到正确位置</span>
</span></span><span style="display:flex;"><span>        bootm_os_get_boot_func  <span style="color:#75715e"># 在操作系统类型数组boot_os中查找引导函数，linux内核引导函数do_bootm_linux</span>
</span></span><span style="display:flex;"><span>        do_bootm_linux<span style="color:#f92672">(</span>flag<span style="color:#f92672">=</span>BOOTM_STATE_OS_PREP<span style="color:#f92672">)</span>  <span style="color:#75715e"># 调用boot_prep_linux</span>
</span></span><span style="display:flex;"><span>            boot_prep_linux  <span style="color:#75715e"># 1.分配一块内存，把设备数二进制文件复制 2.修改扁平设备树二进制文件</span>
</span></span><span style="display:flex;"><span>        boot_selected_os  <span style="color:#75715e"># </span>
</span></span><span style="display:flex;"><span>            do_bootm_linux<span style="color:#f92672">(</span>flag<span style="color:#f92672">=</span>BOOTM_STATE_OS_GO<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                boot_jump_linux  <span style="color:#75715e"># 负责跳转到Linux内核</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>boot_jum_linux
</span></span><span style="display:flex;"><span>    do_nonsec_virt_switch
</span></span><span style="display:flex;"><span>        smp_kick_all_cpus  <span style="color:#75715e"># CONFIG_GICV2或CONFIG_GICV3，中断控制器版本2，3</span>
</span></span><span style="display:flex;"><span>        dcache_disable  <span style="color:#75715e"># 禁用处理器的缓存和内存管理单元</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在异常级别1执行内核 # 开启配置宏 CONFIG_ARMV8_SWITCH_TO_EL1</span>
</span></span><span style="display:flex;"><span>    armv8_switch_to_el2
</span></span><span style="display:flex;"><span>        switch_to_el1
</span></span><span style="display:flex;"><span>            armv8_switch_to_el1
</span></span><span style="display:flex;"><span>                内核入口
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在异常级别2执行内核</span>
</span></span><span style="display:flex;"><span>    armv8_switch_to_el2
</span></span><span style="display:flex;"><span>        内核入口
</span></span></code></pre></div><h2 id="12-内核初始化">1.2 内核初始化<a hidden class="anchor" aria-hidden="true" href="#12-内核初始化">#</a></h2>
<p> 内核初始化分为汇编语言部分和C语言部分</p>
<h3 id="121-汇编语言部分">1.2.1 汇编语言部分<a hidden class="anchor" aria-hidden="true" href="#121-汇编语言部分">#</a></h3>
<p> ARM64架构内核入口<code>_head</code>，直接跳转到标号<code>stext</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_head:
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_EFI   </span><span style="color:#75715e">// 提供UEFI运行时支持UEFI（Unified Extensible Firmware Interface）是统一的可扩展固件接口，用于取代BIOS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add  x13, x18, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0x16</span>
</span></span><span style="display:flex;"><span>    b    stext
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    stext       <span style="color:#75715e">// 跳转到内核起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .long0           <span style="color:#75715e">// 保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p> <code>stext</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/arch/arm64/kernel/head.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ENTRY(stext)
</span></span><span style="display:flex;"><span>    bl   preserve_boot_args  <span style="color:#75715e">// 把引导程序传递的4个参数保存在全局数组boot_args中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   el2_setup        <span style="color:#75715e">// 降级到异常级别1, 寄存器w0存放cpu_boot_mode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    adrp x23, __PHYS_OFFSET
</span></span><span style="display:flex;"><span>    and  x23, x23, MIN_KIMG_ALIGN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>    <span style="color:#75715e">// KASLR偏移，默认值是0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   set_cpu_boot_mode_flag  <span style="color:#75715e">// __boot_cpu_mode[2] 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bl   __create_page_tables  <span style="color:#75715e">// 创建页表映射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 下面调用设置处理器的代码，请看文件“arch/arm64/mm/proc.S” 了解细节。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 返回的时候，处理器已经为开启内存管理单元做好准备，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 转换控制寄存器已经设置好。*/</span>
</span></span><span style="display:flex;"><span>    bl    __cpu_setup        <span style="color:#75715e">// 初始化处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b    __primary_switch  <span style="color:#75715e">// 主处理器开启内存管理单元，进入C语言部分入口函数start_kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ENDPROC(stext)
</span></span></code></pre></div><br>
<ol>
<li>函数el2_setup</li>
</ol>
<blockquote>
<p>a.如果异常级别是1，那么在异常级别1执行内核。   <br>
b.如果异常级别是2，那么根据处理器是否支持虚拟化宿主扩展（Virtualization Host Extensions，VHE），决定是否需要降级到异常级别1。    <br>
1）如果处理器支持虚拟化宿主扩展，那么在异常级别2执行内核。    \<br>
2）如果处理器不支持虚拟化宿主扩展，那么降级到异常级别1，在异常级别1执行内核      \</p>
</blockquote>
<p> 基于内核的虚拟机（Kernel-based Virtual Machine，KVM），KVM的主要特点是直接在处理器上执行客户操作系统，因此虚拟机的执行速度很快。KVM是内核的一个模块，把内核变成虚拟机监控程序。       <br>
 开源虚拟机管理软件是QEMU，QEMU支持KVM虚拟机。QEMU创建一个KVM虚拟机，和KVM的交互过程           \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 打开KVM字符设备文件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/kvm&#34;</span>, O_RDWR);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建一个虚拟机，QEMU进程得到一个关联到虚拟机的文件描述符。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vmfd <span style="color:#f92672">=</span> ioctl(fd, KVM_CREATE_VM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// KVM为每个虚拟处理器创建一个kvm_vcpu结构体，QEMU进程得到一个关联到虚拟处理器的文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vcpu_fd <span style="color:#f92672">=</span> ioctl(vmfd, KVM_CREATE_VCPU, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p> 从QEMU切换到客户操作系统的过程如下。      <br>
 （1）QEMU进程调用“ioctl(vcpu_fd, KVM_RUN, 0)”，陷入到内核。     <br>
 （2）KVM执行命令KVM_RUN，从异常级别1切换到异常级别2。           <br>
 （3）KVM首先把调用进程的所有寄存器保存在kvm_vcpu结构体中，然后把所有寄存器设置为客户操作系统的寄存器值，最后从异常级别2返回到异常级别1，执行客户操作系统。           <br>
 为了提高切换速度，<code>ARM64架构引入了虚拟化宿主扩展，在异常级别2执行宿主操作系统的内核</code>，从QEMU切换到客户操作系统的时候，KVM不再需要先从异常级别1切换到异常级别2      \</p>
<br>
<ol start="2">
<li>函数__create_page_tables</li>
</ol>
<blockquote>
<p>1）创建恒等映射，虚拟地址=物理地址<code>__enable_mmu</code>开启内存管理单元        <br>
2）为内核镜像创建映射             \</p>
</blockquote>
<p> 映射代码节<code>.idmap.text</code>,恒等映射代码节的起始地址存放在全局变量__idmap_text_start中，结束地址存放在全局变量__idmap_text_end中。恒等映射是为恒等映射代码节创建的映射，idmap_pg_dir是恒等映射的页全局目录（即第一级页表）的起始地址。内核的页表中为内核镜像创建映射，内核镜像的起始地址是_text，结束地址是_end，swapper_pg_dir是内核的页全局目录的起始地址</p>
<br>
<ol start="3">
<li>函数__primary_switch</li>
</ol>
<blockquote>
<p>1）__enable_mmu开启内存管理单元            <br>
2）__primary_switched      <br>
 __enable_mmu执行流程     <br>
 1）把转换表基准寄存器0(TTBR0_EL1)设置为恒等映射的页全局目录的起始物理地址     <br>
 2）把转换表基准寄存器1(TTBR1_EL1)设置为内核的页全局目录的起始物理地址        <br>
 3）设置系统控制寄存器(SCTLR_EL1)，开启内存管理单元，后MMU把虚拟地址转换成物理地址    <br>
 __primary_switch执行流程      <br>
 1）把当前异常级别的栈指针寄存器设置为0号线程内核栈的顶部(init_thread_union + THREAD_SIZE)           <br>
 2）把异常级别0的栈指针寄存器(SP_EL0)设置为0号线程的结构体<code>thread_info</code>的地址(init_task.thread_info)        <br>
 3）把向量基准地址寄存器(VBAR_EL1)设置为异常向量表的起始地址(vectors)     <br>
 4）计算内核镜像的起始虚拟地址(kimage_vaddr)和物理地址的差值，保存在全局变量kimage_voffset中     <br>
 5）用0初始化内核的未初始化数据段      <br>
 6）调用C语言函数<code>start_kernel</code>      \</p>
</blockquote>
<br>
<h3 id="122-c语言部分">1.2.2 C语言部分<a hidden class="anchor" aria-hidden="true" href="#122-c语言部分">#</a></h3>
<p> 内核初始化的C语言部分入口是函数<code>start_kernel</code>，函数start_kernel首先初始化基础设施，即初始化内核的各个子系统，然后调用函数<code>rest_init</code>。函数rest_init的执行流程如下。   <br>
 （1）创建1号线程，即init线程，线程函数是kernel_init。     <br>
 （2）创建2号线程，即kthreadd线程，负责创建内核线程。     <br>
 （3）0号线程最终变成空闲线程。    \</p>
<p>init线程继续初始化，执行的主要操作如下。    <br>
 （1）smp_prepare_cpus()：在启动从处理器以前执行准备工作。   <br>
 （2）do_pre_smp_initcalls()：执行必须在初始化SMP系统以前执行的早期初始化，即使用宏early_initcall注册的初始化函数。   <br>
 （3）smp_init()：初始化SMP系统，启动所有从处理器。   <br>
 （4）do_initcalls()：执行级别0～7的初始化。 <br>
 （5）打开控制台的字符设备文件“/dev/console”，文件描述符0、1和2分别是标准输入、标准输出和标准错误，都是控制台的字符设备文件。   <br>
 （6）prepare_namespace()：挂载根文件系统，后面装载init程序时需要从存储设备上的文件系统中读文件。   <br>
 （7）free_initmem()：释放初始化代码和数据占用的内存。   <br>
 （8）装载init程序（U-Boot程序可以传递内核参数“init=”以指定init程序），从内核线程转换成用户空间的init进程。  \</p>
<p> 级别0～7的初始化，是指使用以下宏注册的初始化函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/init.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define pure_initcall(fn)           __define_initcall(fn, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define core_initcall(fn)           __define_initcall(fn, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define core_initcall_sync(fn)      __define_initcall(fn, 1s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define postcore_initcall(fn)       __define_initcall(fn, 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define postcore_initcall_sync(fn)  __define_initcall(fn, 2s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_initcall(fn)           __define_initcall(fn, 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arch_initcall_sync(fn)      __define_initcall(fn, 3s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define subsys_initcall(fn)         __define_initcall(fn, 4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define subsys_initcall_sync(fn)    __define_initcall(fn, 4s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fs_initcall(fn)             __define_initcall(fn, 5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fs_initcall_sync(fn)        __define_initcall(fn, 5s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rootfs_initcall(fn)         __define_initcall(fn, rootfs)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define device_initcall(fn)         __define_initcall(fn, 6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define device_initcall_sync(fn)    __define_initcall(fn, 6s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define late_initcall(fn)           __define_initcall(fn, 7)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define late_initcall_sync(fn)      __define_initcall(fn, 7s)
</span></span></span></code></pre></div><h3 id="123-smp系统的引导">1.2.3 SMP系统的引导<a hidden class="anchor" aria-hidden="true" href="#123-smp系统的引导">#</a></h3>
<p> 对称多处理器(Symmetirc Multi-Processor SMP)       <br>
 3种引导从处理器方法      \</p>
<ul>
<li>自旋表</li>
<li>电源状态协调接口</li>
<li>ACPI停车协议</li>
</ul>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/ARM64_SMP_spin_table.png" alt="ARM64架构下SMP系统的自旋表引导过程"  />
</p>
<h2 id="13-init进程">1.3 init进程<a hidden class="anchor" aria-hidden="true" href="#13-init进程">#</a></h2>
<p> init进程是用户空间第一个进程，负责启动用户程序。Linux系统init程序有<code>sysvinit</code>、busybox init、upstart、<code>systemd</code>和procd。sysvinit是Unix系统5(System V)init程序，启动配置文件<code>/etc/initab</code></p>
<br>
<h1 id="第2章-进程管理">第2章 进程管理<a hidden class="anchor" aria-hidden="true" href="#第2章-进程管理">#</a></h1>
<h2 id="21-进程">2.1 进程<a hidden class="anchor" aria-hidden="true" href="#21-进程">#</a></h2>
<p> Linux内核把进程称为task，进程虚拟地址空间分为用户虚拟地址空间和内核地址空间，所有进程共享内核虚拟地址空间，每个进程有独立用户虚拟地址空间       <br>
 进程有两种特殊形式：没有用户虚拟地址空间的进程称为内核线程，共享用户虚拟地址空间的进程称为用户线程。     <br>
 task_struct结构体是进程描述符，主要成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> state;    <span style="color:#75715e">// 进程状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>stack;            <span style="color:#75715e">// 指向内核栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pid_t pid;              <span style="color:#75715e">// 全局进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pid_t tgid              <span style="color:#75715e">// 全局的线程组标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> pid_link pid[PIDTYPE_MAX];   <span style="color:#75715e">// 进程号，进程组标识符和会话标识符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct _rcu <span style="color:#f92672">*</span>real_parent;   <span style="color:#75715e">// real_parent指向真实的父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct _rcu <span style="color:#f92672">*</span>parent;        <span style="color:#75715e">// parent指向父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>group_leader;   <span style="color:#75715e">// 指向进村组的组长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred _rcu <span style="color:#f92672">*</span>real_cred;  <span style="color:#75715e">// real_cred指向主题和真实客体证书
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred _rcu <span style="color:#f92672">*</span>cred;       <span style="color:#75715e">// cred指向客体证书
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> comm[TASK_COMM_LEN];           <span style="color:#75715e">// 进程名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> prio, static_prio, nornal_prio; <span style="color:#75715e">// 调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> rt_priority,prolicy<span style="color:#960050;background-color:#1e0010">；</span>  <span style="color:#75715e">// 优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>cpumask_t cpus_allowed;             <span style="color:#75715e">// 允许进程在哪些处理器上运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#f92672">*</span>active_mm;   <span style="color:#75715e">// 指向内存描述符，进程mm，和active_mm指向同一个内存描述符，内核线程mm是指针，当内核线程运行时active_mm指向从进程借用的内存描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> file_struct <span style="color:#f92672">*</span>files;          <span style="color:#75715e">// 打开文件表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>nsproxy;            <span style="color:#75715e">// 命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>signal;       <span style="color:#75715e">// 信号处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sigband_struct <span style="color:#f92672">*</span>sighand;
</span></span><span style="display:flex;"><span>sigset_t blocked, real_blocked;
</span></span><span style="display:flex;"><span>sigset_t saved_sigmask;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sigpending pending;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sysv_sem sysvsem;            <span style="color:#75715e">// UNIx系统5信号量和共享内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sysv_shm sysvshm;
</span></span></code></pre></div><h2 id="22-命名空间">2.2 命名空间<a hidden class="anchor" aria-hidden="true" href="#22-命名空间">#</a></h2>
<p> 和虚拟机相比，容器是一种轻量级的虚拟化技术，直接使用宿主机的内核，使用命名空间隔离资源,虚拟机仅仅是通过命名空间隔离？  \</p>
<table>
<thead>
<tr>
<th>命名空间</th>
<th>隔离资源</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>控制组cgroup</td>
<td>控制组根目录</td>
<td></td>
</tr>
<tr>
<td>进程间通信IPC</td>
<td>UNIX系统5进程间通信和POSIx消息队列</td>
<td></td>
</tr>
<tr>
<td>network</td>
<td>网络协议</td>
<td></td>
</tr>
<tr>
<td>挂载mount</td>
<td>挂载点</td>
<td></td>
</tr>
<tr>
<td>PID</td>
<td>进程号</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>用户标识符和组标识符</td>
<td></td>
</tr>
<tr>
<td>UNIX分时系统(UTS)</td>
<td>主机名和网络信息服务NIS域名</td>
<td></td>
</tr>
</tbody>
</table>
<p> 创建新的命名空间方法：   <br>
 调用clone创建子进程时，使用标志位控制子进程是共享父进程的命名空间还是创建新命名空间   <br>
 调用unshare创建新的命名空间    <br>
 进程使用系统调用setns，绑定一个已经存在的命名空间</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/process_namespace.png" alt="进程的命名空间"  />
</p>
<p> 进程号命名空间用来隔离进程号，对应的结构体是pid_namespace,进程号命名空间用来隔离进程号，对应的结构体是pid_namespace。</p>
<h2 id="23-进程标识符">2.3 进程标识符<a hidden class="anchor" aria-hidden="true" href="#23-进程标识符">#</a></h2>
<table>
<thead>
<tr>
<th>标识符</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>进程标识符</td>
<td>命名空间给进程分配标识符</td>
<td></td>
</tr>
<tr>
<td>线程组标识符</td>
<td>线程组中的主进程称为组长，线程组标识符就是组长的进程标识符<br>系统调用clone传入标志CLONE_THREAD以创建新进程时，新进程和当前进程属于一个线程组</td>
<td></td>
</tr>
<tr>
<td>进程组标识符</td>
<td>进程组标识符是组长的进程标识符。<br>进程可以使用系统调用setpgid创建或者加入一个进程组</td>
<td></td>
</tr>
<tr>
<td>会话标识符</td>
<td>进程调用系统调用setsid的时候，创建一个新的会话</td>
<td></td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/pid_mark.png" alt="进程的命名空间"  />
</p>
<p> pid存储全局进程号，pids[PIDTYPE_PID].pid指向结构体pid，pids[PIDTYPE_PGID].pid指向进程组组长的结构体pid，pids[PIDTYPE_SIG].pid指向会话进程的结构体pid    \</p>
<p> 进程标识符结构体pid的成员，count是引用计数，level进程号命名空间的层次，numbers元素个数是level的值加1，</p>
<h2 id="24-进程关系">2.4 进程关系<a hidden class="anchor" aria-hidden="true" href="#24-进程关系">#</a></h2>
<p> 如果子进程被某个进程（通常是调试器）使用系统调用ptrace跟踪，那么成员parent指向跟踪者的进程描述符，否则成员parent也指向父进程的进程描述符。</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/process_relative.png" alt="进程的命名空间"  />
</p>
<p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/tasks_table.png" alt="进程和线程链表"  />
</p>
<h2 id="24-启动程序">2.4 启动程序<a hidden class="anchor" aria-hidden="true" href="#24-启动程序">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> fork();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 父进程继续执行 */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 子进程装载程序 */</span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> execve(filename, argv, envp);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* 创建子进程失败 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="241创建新进程">2.4.1　创建新进程<a hidden class="anchor" aria-hidden="true" href="#241创建新进程">#</a></h3>
<p> 内核使用静态数据构造出0号内核线程，0号内核线程分叉生成1号内核线程和2号内核线程（kthreadd线程）。1号内核线程完成初始化以后装载用户程序，变成1号进程，其他进程都是1号进程或者它的子孙进程分叉生成的；其他内核线程是kthreadd线程分叉生成的
 两个个系统调用创建进程：    \</p>
<ul>
<li>fork：子进程是父进程的副本，用写时复制</li>
<li>clone：可控制子进程和父进程共享哪些资源</li>
<li>vfork：创建子进程，子进程用execve装载程序(已废弃)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 数字表示参数个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYSCALL_DEFINE0(fork)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 宏展开 asmlinkage表示C语言函数看被汇编代码调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage <span style="color:#66d9ef">long</span> sys_fork(<span style="color:#66d9ef">void</span>)
</span></span></code></pre></div><p> 创建进程的进程p和被创建进程c三种关系</p>
<ul>
<li>新进程是进程p的子进程</li>
<li>clone传入CLONE_PARENT，兄弟关系</li>
<li>clone传入CLONE_THREAD，同属一个线程组</li>
</ul>
<h4 id="1-_do_fork函数">1. _do_fork函数<a hidden class="anchor" aria-hidden="true" href="#1-_do_fork函数">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">_do_fork</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_start,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_size,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>parent_tidptr,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>child_tidptr,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tls);  <span style="color:#75715e">// tls 创建线程，clone_flags为CLONE_SETTLS时，tlstls指定新线程的线程本地存储的地址
</span></span></span></code></pre></div><p><img loading="lazy" src="https://liuz0123.gitee.io/zain/img/_do_fork.png" alt="函数_do_fork的执行流程"  />
</p>
<p> 调用copy_process创建新进程  <br>
 clone_flags设置CLONE_PARENT_SETTID，新线程的进程标识符写到参数parent_tidptr指定的位置   <br>
 wake_up_new_task唤醒新进程</p>
<h4 id="2-copy_process函数">2. copy_process函数<a hidden class="anchor" aria-hidden="true" href="#2-copy_process函数">#</a></h4>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030190536.png" alt="20221030190536"  />
</p>
<ul>
<li><strong>（1）标志组合</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CLONE_NEWNS &amp; CLONE_FS</td>
<td style="text-align:center">新进程属于新挂载命名空间<br>共享文件系统信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_NEWUSER &amp; CLONE_FS</td>
<td style="text-align:center">新进程属于新用户命名空间<br>共享文件系统信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_THREAD <br> 未设置CLONE_SIGHAND</td>
<td style="text-align:center">新进程和当前进程同属一个线程组，<br>但不共享信号处理程序</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">CLONE_SIGHAND <br> 未设置CLONE_VM</td>
<td style="text-align:center">新进程和当前进程共享信号处理程序，<br>但不共享虚拟内存</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>（2）dup_task_struct函数</strong>
 未新进程的进程描述符分配内存，复制当前进程描述符，为新进程分配内核栈</li>
</ul>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030192206.png" alt="20221030192206"  title="进程的内核栈"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/linux/sched.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">union</span> thread_union {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> task_struct task;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_THREAD_INFO_IN_TASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> thread_info thread_info;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack[THREAD_SIZE<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p> 内核栈两种布局</p>
<ul>
<li>
<ol>
<li>thread_info在内核栈顶部，成员task指向进程描述符</li>
</ol>
</li>
<li>
<ol start="2">
<li>thread_info未占用内核栈
 第二种布局需打开CONFIG_THREAD_INFO_IN_TASK，ARM64使用第二种内核栈布局，thread_info结构体地址与进程描述符地址相同。进程在内核模式时，ARM64架构的内核使用用户栈指针寄存器SP_EL0存放当前进程的thread_info结构体地址，可同时得到thread_info地址和进程描述符地址
 内核栈的长度时<code>THREAD_SIZE</code>，<strong>ARM64架构内核栈长度为16KB</strong>
 thread_info存放汇编代码直接访问的底层数据，ARM64架构定义结构体</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// arch/arm64/include/asm/thread_info.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> thread_info {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>		flags;		<span style="color:#75715e">/* low level flags 底层标志位 */</span>
</span></span><span style="display:flex;"><span>	mm_segment_t		addr_limit;	<span style="color:#75715e">/* address limit 地址限制 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_ARM64_SW_TTBR0_PAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	u64			ttbr0;		<span style="color:#75715e">/* saved TTBR0_EL1 保存的寄存器TTBR0_EL1 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    u64		preempt_count;	<span style="color:#75715e">/* 抢占计数器 0 =&gt; preemptible 可抢占, &lt;0 =&gt; bug缺陷 */</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>
<p><strong>（3）copy_creds函数</strong>
 负责复制或共享证书，证书存放进程的用户标识符、组标识符和访问权限。设置标志CLONE_THREAD，同属一个线程组。CLONE_NEWUSER，需要为新进程创建新的用户命名空间。进程计数器加1</p>
</li>
<li>
<p><strong>（4）检查线程数量限制</strong>
 全局变量nr_threads存放当前线程数量，max_threads存放允许创建的线程最大数量，默认值MAX_THREADS</p>
</li>
<li>
<p><strong>（5）sched_fork函数</strong></p>
</li>
</ul>
<p> 为新进程设置调度器相关的参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c  书中为4.x版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_fork</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__sched_fork(clone_flags, p);   <span style="color:#75715e">// 执行基本设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We mark the process as NEW here. This guarantees that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * nobody will actually run it, and a signal or other external
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * event cannot wake it up and insert it on the runqueue either.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> TASK_NEW;    <span style="color:#75715e">// 新进程状态设置为TASK_NEW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Make sure we do not leak PI boosting priority to the child.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>prio <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>normal_prio;  <span style="color:#75715e">// 新进程调度优先级设置为当前进程正常优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	uclamp_fork(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Revert to default priority/policy on fork if requested.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(p<span style="color:#f92672">-&gt;</span>sched_reset_on_fork)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (task_has_dl_policy(p) <span style="color:#f92672">||</span> task_has_rt_policy(p)) { <span style="color:#75715e">// 限期进程或实时进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>policy <span style="color:#f92672">=</span> SCHED_NORMAL;  <span style="color:#75715e">// 调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>static_prio <span style="color:#f92672">=</span> NICE_TO_PRIO(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// nice值默认值0，静态优先级120
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>rt_priority <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (PRIO_TO_NICE(p<span style="color:#f92672">-&gt;</span>static_prio) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 普通进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			p<span style="color:#f92672">-&gt;</span>static_prio <span style="color:#f92672">=</span> NICE_TO_PRIO(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// nice值默认值0，静态优先级120
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>prio <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>normal_prio <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>static_prio;
</span></span><span style="display:flex;"><span>		set_load_weight(p, false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * We don&#39;t need the reset flag anymore after the fork. It has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * fulfilled its duty:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_reset_on_fork <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (dl_prio(p<span style="color:#f92672">-&gt;</span>prio)) <span style="color:#75715e">// 调度优先级是限期调度累的优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;  <span style="color:#75715e">// 不允许限期进程分叉生成新的限期进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (rt_prio(p<span style="color:#f92672">-&gt;</span>prio))  <span style="color:#75715e">// 调度优先级是实时调度类优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		p<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rt_sched_class; <span style="color:#75715e">// 调度类设置为实时调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_class <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fair_sched_class;  <span style="color:#75715e">// 调度优先级是公平调度类的优先级，调度类设置为公平调度类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	init_entity_runnable_average(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>se);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SCHED_INFO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (likely(sched_info_on()))
</span></span><span style="display:flex;"><span>		memset(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>sched_info, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(p<span style="color:#f92672">-&gt;</span>sched_info));
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SMP)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>on_cpu <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	init_task_preempt_count(p);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	plist_node_init(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pushable_tasks, MAX_PRIO);
</span></span><span style="display:flex;"><span>	RB_CLEAR_NODE(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pushable_dl_tasks);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>（6）复制或共享资源</strong></li>
</ul>
<p> 1）UNIX系统5信号量，同属一个线程组的线程才共享UNIX系统的5信号量，copy_semundo函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-4.14.295/ipc/sem.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_semundo</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sem_undo_list <span style="color:#f92672">*</span>undo_list;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SYSVSEM) {  <span style="color:#75715e">// CLONE_SYSTEM表示UNIX系统5信号量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		error <span style="color:#f92672">=</span> get_undo_list(<span style="color:#f92672">&amp;</span>undo_list);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (error)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>		refcount_inc(<span style="color:#f92672">&amp;</span>undo_list<span style="color:#f92672">-&gt;</span>refcnt); <span style="color:#75715e">// 5信号量的撤销请求链表，sem_undo_list 计数+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tsk<span style="color:#f92672">-&gt;</span>sysvsem.undo_list <span style="color:#f92672">=</span> undo_list;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		tsk<span style="color:#f92672">-&gt;</span>sysvsem.undo_list <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// 新进程5信号量撤销请求链表为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 2）打开文件夹，同属一个线程组的线程直接共享打开文件表，函数copy_files复制或共享打开文件表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_files</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> files_struct <span style="color:#f92672">*</span>oldf, <span style="color:#f92672">*</span>newf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * A background process may not have any files ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	oldf <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>files;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>oldf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_FILES) { <span style="color:#75715e">// CLONE_FIELS共享打开文件表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		atomic_inc(<span style="color:#f92672">&amp;</span>oldf<span style="color:#f92672">-&gt;</span>count);  <span style="color:#75715e">// files_struct 计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	newf <span style="color:#f92672">=</span> dup_fd(oldf, NR_OPEN_MAX, <span style="color:#f92672">&amp;</span>error);  <span style="color:#75715e">// 新进程把当前进程的打开文件表复制一份
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>files <span style="color:#f92672">=</span> newf;
</span></span><span style="display:flex;"><span>	error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 3）文件系统信息。进程文件系统信号包括：根目录、当前工作目录和文件模式创建掩码。同属一个线程组的线程之间才会共享文件系统信息     <br>
  函数copy_fs复制或共享文件系统信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_fs</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> fs_struct <span style="color:#f92672">*</span>fs <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>fs;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_FS) {  <span style="color:#75715e">// CLONE_FS共享文件系统信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">/* tsk-&gt;fs is already what we want */</span>
</span></span><span style="display:flex;"><span>		spin_lock(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fs<span style="color:#f92672">-&gt;</span>in_exec) {
</span></span><span style="display:flex;"><span>			spin_unlock(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		fs<span style="color:#f92672">-&gt;</span>users<span style="color:#f92672">++</span>;  <span style="color:#75715e">// fs_struct共享文件系统信息结构体 加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		spin_unlock(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>fs <span style="color:#f92672">=</span> copy_fs_struct(fs);  <span style="color:#75715e">// 新进程复制当前进程文件系统信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tsk<span style="color:#f92672">-&gt;</span>fs)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 4）信号处理程序，同属一个线程组线程之间才会共享信号处理程序 <br>
  函数copy_sighand复制或共享信号处理程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_sighand</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sighand_struct <span style="color:#f92672">*</span>sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SIGHAND) {  <span style="color:#75715e">// CLONE_SIGHAND 表示共享信号处理程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		refcount_inc(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>count); <span style="color:#75715e">// 引用计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程复制当前进程信号处理程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sig <span style="color:#f92672">=</span> kmem_cache_alloc(sighand_cachep, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	RCU_INIT_POINTER(tsk<span style="color:#f92672">-&gt;</span>sighand, sig);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sig)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	refcount_set(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>count, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	spin_lock_irq(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>	memcpy(sig<span style="color:#f92672">-&gt;</span>action, current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>action, <span style="color:#66d9ef">sizeof</span>(sig<span style="color:#f92672">-&gt;</span>action));
</span></span><span style="display:flex;"><span>	spin_unlock_irq(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_CLEAR_SIGHAND)
</span></span><span style="display:flex;"><span>		flush_signal_handlers(tsk, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 5）信号结构体，同属一个线程组的线程才会共享信号结构体   <br>
  函数copy_signal复制或共享信号结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_signal</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> signal_struct <span style="color:#f92672">*</span>sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_THREAD)  <span style="color:#75715e">// CLONE_THREAD表示创建线程，新进程和当前进程共享信号结构体signal_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程分配结构体，初始化，继承当前进程资源限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sig <span style="color:#f92672">=</span> kmem_cache_zalloc(signal_cachep, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>signal <span style="color:#f92672">=</span> sig;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sig)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>nr_threads <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	atomic_set(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>live, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	refcount_set(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>sigcnt, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>thread_head <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> list_head)LIST_HEAD_INIT(tsk<span style="color:#f92672">-&gt;</span>thread_node);
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>thread_node <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> list_head)LIST_HEAD_INIT(sig<span style="color:#f92672">-&gt;</span>thread_head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	init_waitqueue_head(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>wait_chldexit);
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>curr_target <span style="color:#f92672">=</span> tsk;
</span></span><span style="display:flex;"><span>	init_sigpending(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>shared_pending);
</span></span><span style="display:flex;"><span>	INIT_HLIST_HEAD(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>multiprocess);
</span></span><span style="display:flex;"><span>	seqlock_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>stats_lock);
</span></span><span style="display:flex;"><span>	prev_cputime_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>prev_cputime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_POSIX_TIMERS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	INIT_LIST_HEAD(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>posix_timers);
</span></span><span style="display:flex;"><span>	hrtimer_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>real_timer.function <span style="color:#f92672">=</span> it_real_fn;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	task_lock(current<span style="color:#f92672">-&gt;</span>group_leader);
</span></span><span style="display:flex;"><span>	memcpy(sig<span style="color:#f92672">-&gt;</span>rlim, current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>rlim, <span style="color:#66d9ef">sizeof</span> sig<span style="color:#f92672">-&gt;</span>rlim);
</span></span><span style="display:flex;"><span>	task_unlock(current<span style="color:#f92672">-&gt;</span>group_leader);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	posix_cpu_timers_init_group(sig);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tty_audit_fork(sig);
</span></span><span style="display:flex;"><span>	sched_autogroup_fork(sig);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>oom_score_adj <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>oom_score_adj;
</span></span><span style="display:flex;"><span>	sig<span style="color:#f92672">-&gt;</span>oom_score_adj_min <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>oom_score_adj_min;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	mutex_init(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>cred_guard_mutex);
</span></span><span style="display:flex;"><span>	init_rwsem(<span style="color:#f92672">&amp;</span>sig<span style="color:#f92672">-&gt;</span>exec_update_lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 6）虚拟内存，同属一个线程组的线程才会共享虚拟内存  \
  函数copy_mm复制或共享虚拟内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/freezer.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_mm</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#f92672">*</span>oldmm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> retval;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>min_flt <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>maj_flt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>nvcsw <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nivcsw <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_DETECT_HUNG_TASK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tsk<span style="color:#f92672">-&gt;</span>last_switch_count <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nvcsw <span style="color:#f92672">+</span> tsk<span style="color:#f92672">-&gt;</span>nivcsw;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>last_switch_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Are we cloning a kernel thread?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We need to steal a active VM for that..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	oldmm <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>oldmm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* initialize the new vmacache entries */</span>
</span></span><span style="display:flex;"><span>	vmacache_flush(tsk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_VM) {  <span style="color:#75715e">// CLONE_VM表示共享虚拟内存，新进程和当前进程共享内存描述符mm_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mmget(oldmm);
</span></span><span style="display:flex;"><span>		mm <span style="color:#f92672">=</span> oldmm;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> good_mm;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	retval <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程复制当前进程的虚拟内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mm <span style="color:#f92672">=</span> dup_mm(tsk, current<span style="color:#f92672">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mm)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> fail_nomem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>good_mm:
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>mm <span style="color:#f92672">=</span> mm;
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>active_mm <span style="color:#f92672">=</span> mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fail_nomem:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> retval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 7）命名空间    <br>
  函数copy_namespace创建或共享命名空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/nsproxy.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_namespaces</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>old_ns <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>nsproxy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> user_namespace <span style="color:#f92672">*</span>user_ns <span style="color:#f92672">=</span> task_cred_xxx(tsk, user_ns);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nsproxy <span style="color:#f92672">*</span>new_ns;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果共享除了用户以外的所有其他命名空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 那么新进程和当前进程共享命名空间代理结构体nsproxy，把计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (likely(<span style="color:#f92672">!</span>(flags <span style="color:#f92672">&amp;</span> (CLONE_NEWNS <span style="color:#f92672">|</span> CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWIPC <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			      CLONE_NEWPID <span style="color:#f92672">|</span> CLONE_NEWNET <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			      CLONE_NEWCGROUP <span style="color:#f92672">|</span> CLONE_NEWTIME)))) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (likely(old_ns<span style="color:#f92672">-&gt;</span>time_ns_for_children <span style="color:#f92672">==</span> old_ns<span style="color:#f92672">-&gt;</span>time_ns)) {
</span></span><span style="display:flex;"><span>			get_nsproxy(old_ns);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ns_capable(user_ns, CAP_SYS_ADMIN)) 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 进程没有系统管理权限，那么不允许创建新的命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EPERM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* CLONE_NEWIPC must detach from the undolist: after switching
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * to a new ipc namespace, the semaphore arrays from the old
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * means share undolist with parent, so we must forbid using
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * it along with CLONE_NEWIPC. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 既要求创建新的进程间通信命名空间，又要求共享UNIX系统5信号量，那么这种要求是不合理的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ((flags <span style="color:#f92672">&amp;</span> (CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_SYSVSEM)) <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>		(CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_SYSVSEM)) 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建新的命名空间代理，然后创建或者共享命名空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	new_ns <span style="color:#f92672">=</span> create_new_namespaces(flags, tsk, user_ns, tsk<span style="color:#f92672">-&gt;</span>fs);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (IS_ERR(new_ns))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>  PTR_ERR(new_ns);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> timens_on_fork(new_ns, tsk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret) {
</span></span><span style="display:flex;"><span>		free_nsproxy(new_ns);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk<span style="color:#f92672">-&gt;</span>nsproxy <span style="color:#f92672">=</span> new_ns;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 8）I/O上下文    <br>
  函数copy_io创建或共享I/O上下文</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/fork.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_io</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_BLOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> io_context <span style="color:#f92672">*</span>ioc <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>io_context;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_context <span style="color:#f92672">*</span>new_ioc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ioc)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Share io context with parent, if CLONE_IO is set */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_IO) {  <span style="color:#75715e">// CLONE_IO 共享I/O上小文
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ioc_task_link(ioc);  <span style="color:#75715e">// 计数nr_tasks加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tsk<span style="color:#f92672">-&gt;</span>io_context <span style="color:#f92672">=</span> ioc;  <span style="color:#75715e">// 共享I/O上下文结构体io_context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ioprio_valid(ioc<span style="color:#f92672">-&gt;</span>ioprio)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建新的I/O上下文，初始化，继承当前进程的I/O优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new_ioc <span style="color:#f92672">=</span> get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (unlikely(<span style="color:#f92672">!</span>new_ioc))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		new_ioc<span style="color:#f92672">-&gt;</span>ioprio <span style="color:#f92672">=</span> ioc<span style="color:#f92672">-&gt;</span>ioprio;
</span></span><span style="display:flex;"><span>		put_io_context(new_ioc);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 9）复制寄存器值   <br>
  函数copy_thread_tls复制当前进程的寄存器值，并修改一部分寄存器值。进程有两处用来保存寄存器值：从用户模式切换到内核模式时，把用户模式的各种寄存器保存在内核栈底部的结构体pt_regs中；进程调度器调度进程时，切换出去的进程把寄存器值保存在进程描述符的成员thread中。因为不同处理器架构的寄存器不同，所以各种处理器架构需要自己定义结构体pt_regs和thread_struct</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221030211811.png" alt="20221030211811"  />
</p>
<p>  ARM64架构copy_thread_tls-&gt;copy_thread</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/process.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">copy_thread</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> clone_flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stack_start,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> stk_sz, <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>childregs <span style="color:#f92672">=</span> task_pt_regs(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新进程的进程描述符的成员thread.cpu_context清零，在调度进程时切换出去的进程使用这个成员保存通用寄存器的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	memset(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> cpu_context));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* In case p was allocated the same task_struct pointer as some
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * other recently-exited task, make sure p is disassociated from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * any cpu that may have run that now-exited task recently.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Otherwise we could erroneously skip reloading the FPSIMD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * registers for p. */</span>
</span></span><span style="display:flex;"><span>	fpsimd_flush_task_state(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ptrauth_thread_init_kernel(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (likely(<span style="color:#f92672">!</span>(p<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_KTHREAD))) {  <span style="color:#75715e">// 用户进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>childregs <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>current_pt_regs();
</span></span><span style="display:flex;"><span>		childregs<span style="color:#f92672">-&gt;</span>regs[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Read the current TLS pointer from tpidr_el0 as it may be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * out-of-sync with the saved value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 从寄存器tpidr_el0读取当前线程的线程本地存储的地址，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 因为它可能和保存的值不一致 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>task_user_tls(p) <span style="color:#f92672">=</span> read_sysreg(tpidr_el0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (stack_start) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (is_compat_thread(task_thread_info(p)))
</span></span><span style="display:flex;"><span>				childregs<span style="color:#f92672">-&gt;</span>compat_sp <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				childregs<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* If a TLS pointer was passed to clone, use it for the new thread. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * 如果把线程本地存储的地址传给系统调用clone的第4个参数，那么新线程将使用它*/</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_SETTLS)
</span></span><span style="display:flex;"><span>			p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.uw.tp_value <span style="color:#f92672">=</span> tls;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 内核线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		memset(childregs, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> pt_regs));
</span></span><span style="display:flex;"><span>		childregs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">=</span> PSR_MODE_EL1h;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (IS_ENABLED(CONFIG_ARM64_UAO) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    cpus_have_const_cap(ARM64_HAS_UAO))
</span></span><span style="display:flex;"><span>			childregs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">|=</span> PSR_UAO_BIT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		spectre_v4_enable_task_mitigation(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (system_uses_irq_prio_masking())
</span></span><span style="display:flex;"><span>			childregs<span style="color:#f92672">-&gt;</span>pmr_save <span style="color:#f92672">=</span> GIC_PRIO_IRQON;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.x19 <span style="color:#f92672">=</span> stack_start;
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.x20 <span style="color:#f92672">=</span> stk_sz;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.pc <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)ret_from_fork;
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.cpu_context.sp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)childregs;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ptrace_hw_copy_thread(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>（7）设置进程号和进程关系</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __latent_entropy <span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">copy_process</span>(
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> pid <span style="color:#f92672">*</span>pid,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> trace,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> node,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> kernel_clone_args <span style="color:#f92672">*</span>args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程分配进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// pid等于init_struct_pid的地址，内核初始化时，引导处理器为每个从处理器分叉生成一个空闲线程（参考函数idle_threads_init），所有处理器的空闲线程使用进程号0，全局变量init_struct_pid存放空闲线程的进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>init_struct_pid) {
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> alloc_pid(p<span style="color:#f92672">-&gt;</span>nsproxy<span style="color:#f92672">-&gt;</span>pid_ns_for_children);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (IS_ERR(pid)) {
</span></span><span style="display:flex;"><span>            retval <span style="color:#f92672">=</span> PTR_ERR(pid);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> bad_fork_cleanup_thread;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置新进程退出时发送给父进程的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>pid <span style="color:#f92672">=</span> pid_nr(pid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_THREAD) {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 新线程退出时不需要发送信号给父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>group_leader <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>group_leader;  <span style="color:#75715e">// group_leader指向同一个组长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>tgid <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>tgid;  <span style="color:#75715e">// tgid存放组长的进程号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> CLONE_PARENT) <span style="color:#75715e">// CLONE_PARENT 新进程和当前进程是兄弟关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>group_leader<span style="color:#f92672">-&gt;</span>exit_signal;  <span style="color:#75715e">// 新进程的成员exit_signal等于当前进程所属线程组的组长的成员exit_signal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">// 父子关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>exit_signal <span style="color:#f92672">=</span> (clone_flags <span style="color:#f92672">&amp;</span> CSIGNAL); <span style="color:#75715e">// 新进程的成员exit_signal是调用者指定的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>group_leader <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>tgid <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>pid;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 控制组的进程数控制器检查是否允许创建新进程：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 从当前进程所属的控制组一直到控制组层级的根，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果其中一个控制组的进程数量大于或等于限制，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 那么不允许使用fork和clone创建新进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cgroup_threadgroup_change_begin(current);
</span></span><span style="display:flex;"><span>    retval <span style="color:#f92672">=</span> cgroup_can_fork(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (retval)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> bad_fork_free_pid;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    write_lock_irq(<span style="color:#f92672">&amp;</span>tasklist_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新进程设置父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (clone_flags <span style="color:#f92672">&amp;</span> (CLONE_PARENT<span style="color:#f92672">|</span>CLONE_THREAD)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 新进程和当前进程拥有相同的父进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>real_parent <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>real_parent;  
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>parent_exec_id <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>parent_exec_id;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>real_parent <span style="color:#f92672">=</span> current;  <span style="color:#75715e">// 新进程的父进程是当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>parent_exec_id <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>self_exec_id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    spin_lock(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (likely(p<span style="color:#f92672">-&gt;</span>pid)) {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>        init_task_pid(p, PIDTYPE_PID, pid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (thread_group_leader(p)) {  <span style="color:#75715e">// true 新进程和当前进程属于同一个进程组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));  <span style="color:#75715e">// 指向同一个进程组的组长的进程号结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            init_task_pid(p, PIDTYPE_SID, task_session(current));  <span style="color:#75715e">// 指向同一个会话的控制进程的进程号结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (is_child_reaper(pid)) {  
</span></span><span style="display:flex;"><span>                ns_of_pid(pid)<span style="color:#f92672">-&gt;</span>child_reaper <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>                p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|=</span> SIGNAL_UNKILLABLE;  <span style="color:#75715e">// 1号进程是不能杀死的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>leader_pid <span style="color:#f92672">=</span> pid;
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>tty <span style="color:#f92672">=</span> tty_kref_get(current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>tty);
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>has_child_subreaper <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span> has_child_subreaper <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                                p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>is_child_subreaper;
</span></span><span style="display:flex;"><span>            list_add_tail(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>sibling, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>real_parent<span style="color:#f92672">-&gt;</span>children);  <span style="color:#75715e">// 新进程添加到父进程的子进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 新进程添加到进程链表中，链表节点是成员tasks，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 头节点是空闲线程的成员tasks（init_task.tasks）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            list_add_tail_rcu(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>tasks, <span style="color:#f92672">&amp;</span>init_task.tasks);  
</span></span><span style="display:flex;"><span>            attach_pid(p, PIDTYPE_PGID);  <span style="color:#75715e">// 新进程添加到进程组的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            attach_pid(p, PIDTYPE_SID);  <span style="color:#75715e">// 新进程添加到会话的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            __this_cpu_inc(process_counts);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>nr_threads<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 线程组的线程计数值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            atomic_inc(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>live);  <span style="color:#75715e">// 原子变量线程组的第2个线程计数值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            atomic_inc(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>sigcnt);  <span style="color:#75715e">// 信号结构体的引用计数加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            list_add_tail_rcu(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>thread_group,    
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>group_leader<span style="color:#f92672">-&gt;</span>thread_group);  <span style="color:#75715e">// 线程加入线程组的线程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            list_add_tail_rcu(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>thread_node,
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>signal<span style="color:#f92672">-&gt;</span>thread_head);  <span style="color:#75715e">// 线程加入线程组的第二条线程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        attach_pid(p, PIDTYPE_PID);  <span style="color:#75715e">// 新进程添加到进程号结构体的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        nr_threads<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 新进程添加到进程号结构体的进程链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    total_forks<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    spin_unlock(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>sighand<span style="color:#f92672">-&gt;</span>siglock);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    write_unlock_irq(<span style="color:#f92672">&amp;</span>tasklist_lock);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    proc_fork_connector(p);
</span></span><span style="display:flex;"><span>    cgroup_post_fork(p);
</span></span><span style="display:flex;"><span>    cgroup_threadgroup_change_end(current);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3唤醒新进程">3.唤醒新进程<a hidden class="anchor" aria-hidden="true" href="#3唤醒新进程">#</a></h4>
<p> wake_up_new_task函数唤醒新进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wake_up_new_task</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq_flags rf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	raw_spin_lock_irqsave(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>pi_lock, rf.flags);
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> TASK_RUNNING;  <span style="color:#75715e">// 切换TASK_RUNNING
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Fork balancing, do it here and not earlier because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  - cpus_ptr can change in the fork path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  - any previously selected CPU might disappear through hotplug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * as we&#39;re not fully set-up yet.*/</span>
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>recent_used_cpu <span style="color:#f92672">=</span> task_cpu(p);
</span></span><span style="display:flex;"><span>	rseq_migrate(p);
</span></span><span style="display:flex;"><span>	__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, <span style="color:#ae81ff">0</span>));  <span style="color:#75715e">// 在SMP系统上，创建新进程是执行负载均衡的绝佳时机，为新进程选择一个负载最轻的处理器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	rq <span style="color:#f92672">=</span> __task_rq_lock(p, <span style="color:#f92672">&amp;</span>rf);  <span style="color:#75715e">// 锁住运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	update_rq_clock(rq);  <span style="color:#75715e">// 更新运行队列的时钟
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	post_init_entity_util_avg(p);  <span style="color:#75715e">// 根据公平运行队列的平均负载统计值，推算新进程的平均负载统计值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	activate_task(rq, p, ENQUEUE_NOCLOCK); <span style="color:#75715e">// 把新进程插入运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	trace_sched_wakeup_new(p);
</span></span><span style="display:flex;"><span>	check_preempt_curr(rq, p, WF_FORK);  <span style="color:#75715e">// 检查新进程是否可以抢占当前进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_woken) {  <span style="color:#75715e">// 在SMP系统上，调用调度类的task_woken方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Nothing relies on rq-&gt;lock after this, so its fine to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * drop it.*/</span>
</span></span><span style="display:flex;"><span>		rq_unpin_lock(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>sched_class<span style="color:#f92672">-&gt;</span>task_woken(rq, p);
</span></span><span style="display:flex;"><span>		rq_repin_lock(rq, <span style="color:#f92672">&amp;</span>rf);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	task_rq_unlock(rq, p, <span style="color:#f92672">&amp;</span>rf);  <span style="color:#75715e">// 释放运行队列的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="4新进程第一次运行">4.新进程第一次运行<a hidden class="anchor" aria-hidden="true" href="#4新进程第一次运行">#</a></h4>
<p> 新进程第一次运行，是从函数ret_from_fork开始执行，ARM64的ret_from_fork函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/kernel/entry.S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tsk   .req   x28      <span style="color:#75715e">//当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYM_CODE_START(ret_from_fork)
</span></span><span style="display:flex;"><span>	bl	schedule_tail  <span style="color:#75715e">// 为上一个进程执行清理操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cbz	x19, <span style="color:#ae81ff">1f</span>  <span style="color:#75715e">// not a kernel thread 如果寄存器x19的值是0，说明当前进程是用户进程，那么跳转到标号1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mov	x0, x20  <span style="color:#75715e">// 内核线程：x19存放线程函数的地址，x20存放线程函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	blr	x19  <span style="color:#75715e">// 调用线程函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>	get_current_task tsk  <span style="color:#75715e">// 用户进程：x28 = sp_el0 = 当前进程的thread_info结构体的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	b	ret_to_user  <span style="color:#75715e">// 返回用户模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SYM_CODE_END(ret_from_fork)
</span></span><span style="display:flex;"><span>NOKPROBE(ret_from_fork)
</span></span></code></pre></div><p>  copy_thread函数中，新进程是内核线程，寄存器x19存放线程函数的地址，寄存器x20存放线程函数的参数，如果新进程是用户进程，寄存器x19值是0   <br>
  </p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/kernel/sched/core.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>asmlinkage __visible <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">schedule_tail</span>(<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>prev)
</span></span><span style="display:flex;"><span>	__releases(rq<span style="color:#f92672">-&gt;</span>lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rq <span style="color:#f92672">*</span>rq;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* New tasks start with FORK_PREEMPT_COUNT, see there and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task_switch() for details.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * finish_task_switch() will drop rq-&gt;lock() and lower preempt_count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * and the preempt_enable() will end up enabling preemption (on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * PREEMPT_COUNT kernels).*/</span>
</span></span><span style="display:flex;"><span>	rq <span style="color:#f92672">=</span> finish_task_switch(prev);  <span style="color:#75715e">// 为上一个进程执行清理操作2.8.6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	balance_callback(rq);  <span style="color:#75715e">// 执行运行队列的所有负载均衡回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	preempt_enable();  <span style="color:#75715e">// 开启内核抢占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>set_child_tid)  <span style="color:#75715e">// pthread库在调用clone()创建线程时设置了标志位CLONE_CHILD_SETTID，那么新进程把自己的进程标识符写到指定位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		put_user(task_pid_vnr(current), current<span style="color:#f92672">-&gt;</span>set_child_tid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	calculate_sigpending();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="242-装载程序">2.4.2 装载程序<a hidden class="anchor" aria-hidden="true" href="#242-装载程序">#</a></h3>
<p> 调度器调度新进程，新进程从函数<code>ret_from_fork</code>开始，从系统调用<code>fork</code>返回用户空间，返回值0。然后新进程使用系统调用<code>execve</code>装载程序。Linux内核练个装载程序系统调用：    \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 路径名是相对时execve解释为相对调用进程的当前工作目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">execve</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> argv[], <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> envp[]);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 路径名是相对的，execveat解释为相对文件描述符dirfd指向的目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 路径名时绝对的，execveat忽略参数dirfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">execveat</span>(<span style="color:#66d9ef">int</span> dirfd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pathname, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> argv[], <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> envp[], <span style="color:#66d9ef">int</span> flags);
</span></span></code></pre></div><p>  参数argv是传给新程序的参数指针数组，数组的每个元素存放一个参数字符串的地址，argv[0]应该指向要装载的程序的名称。参数envp是传给新程序的环境指针数组，数组的每个元素存放一个环境字符串的地址，环境字符串的形式是“键=值</p>
<p> 两个系统调用最终都调用函数do_execveat_common
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221102001015.png" alt="20221102001015"  />
</p>
<p>  函数do_open_execat打开可执行文件。   <br>
  函数sched_exec。装载程序是实现处理器负载均衡的机会，此时进程在内存和缓存中的数据是最少的。选择负载最轻的处理器，然后唤醒当前处理器上的迁移线程，当前进程睡眠等待迁移线程把自己迁移到目标处理器      <br>
  函数bprm_mm_init创建新的内存描述符，分配长度为一页的临时的用户栈，虚拟地址范围是[STACK_TOP_MAX−页长度，STACK_TOP_MAX]，bprm-&gt;p指向在栈底保留一个字长（指针长度）后的位置           <br>
  函数prepare_binprm设置进程证书，然后读文件的前面128字节到缓冲区。128字节是什么？      \
  依次把文件名称、环境字符串和参数字符串压到用户栈         <br>
<img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221102001840.png" alt="20221102001840"  />

  函数exec_binprm调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别正在装载的程序为止</p>
<h4 id="1二进制格式">1.二进制格式<a hidden class="anchor" aria-hidden="true" href="#1二进制格式">#</a></h4>
<p> Linux二进制格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/include/linux/binfmts.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> linux_binfmt {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head lh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> module <span style="color:#f92672">*</span>module;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>load_binary)(<span style="color:#66d9ef">struct</span> linux_binprm <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>load_shlib)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>core_dump)(<span style="color:#66d9ef">struct</span> coredump_params <span style="color:#f92672">*</span>cprm);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> min_coredump;	<span style="color:#75715e">/* minimal dump size */</span>
</span></span><span style="display:flex;"><span>} __randomize_layout;
</span></span></code></pre></div><p> 二进制格式提供3个函数        <br>
  (1)load_binary 加载普通程序       <br>
  (2)load_shlib 加载共享库     <br>
  (3)core_dump 在进程异常退出时生成核心转储文件，min_coredump指定核心转储文件的最小长度     <br>
 二进制格式使用<code>register_binfmt</code>向内核注册</p>
<h4 id="2装载elf程序">2.装载ELF程序<a hidden class="anchor" aria-hidden="true" href="#2装载elf程序">#</a></h4>
<p> ELF文件,ELF(Executable and Linkable Format)可执行与可链接格式 <code>linux-5.10.102/include/uapi/linux/elf.h</code></p>
<ul>
<li>目标文件(可重定位文件)，<code>.o</code>，多个模板文件链接生成可执行文件或共享库</li>
<li>可执行文件</li>
<li>共享库 <code>.so</code></li>
<li>核心转储文件(core dump file)</li>
</ul>
<p> ELF文件分成4部分：<code>ELF首部、程序首部表(programe header table)、节(section)和节首部表(section header table)</code>，ELF只有首部的位置是固定的。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103105503.png" alt="20221103105503"  />
</p>
<p>  程序首部表就是段表(segment table)，<code>段(segment)是从运行角度描述</code>，<code>节(section)是从链接角度描述</code>。    <br>
 64位ELF文件格式</p>
<p>参考链接：
ELF 格式详解 <a href="https://blog.csdn.net/shanandqiu/article/details/115206426">https://blog.csdn.net/shanandqiu/article/details/115206426</a>     <br>
ELF文件格式简介  <a href="https://blog.csdn.net/GrayOnDream/article/details/124564129">https://blog.csdn.net/GrayOnDream/article/details/124564129</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 查看ELF首部</span>
</span></span><span style="display:flex;"><span>readelf -h &lt;ELF文件&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看程序首部表</span>
</span></span><span style="display:flex;"><span>readelf -l &lt;ELF文件&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看节首部表</span>
</span></span><span style="display:flex;"><span>readelf -S &lt;ELF文件&gt;
</span></span></code></pre></div><p> ELF解析程序  <br>
  <code>linux-5.10.102/fs/binfmt_elf.c</code> 解析64位ELF程序，和处理器架构无关 <br>
  <code>linux-5.10.102/fs/compat_binfmt_elf.c</code>  在64位内核中解析32位ELF程序，和处理器架构无   \</p>
<p> 装载ELF程序函数<code>load_elf_binary</code></p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103112822.png" alt="20221103112822"  />
</p>
<p>  1）检查ELF首部，检查是不是可执行文件或共享库，检查处理器架构
  2）读取程序首部表
  3）程序首部表中查找解释器段，如程序需要链接动态库，存在解释器段，从解释器段读取解释器的文件名称，打开文件，读取ELF首部。
  4）检查解释器的ELF首部，读取解释器的程序首部表
  5）flush_old_exec函数终止线程组中其他线程，释放旧的用户虚拟地址空间
  6）setup_new_exec函数调用arch_pick_mmap_layout设置内存映射的布局，在堆和栈直接有一个内存映射区域
  7）之前调用bprm_mm_init函数创建临时用户栈，调用set_arg_pages函数把用户栈定下来，更新用户栈标志位和访问权限，把用户栈移动到最终位置，并扩大用户栈
  8）把可加载段映射到进程的虚拟地址空间
  9）setbrk函数把初始化数据段映射到进程的用户虚拟地址空间，并设置堆的起始虚拟地址，调用padzero函数用零填充未初始化数据段
  10）得到程序入口。程序有解释器段，加载段映射到进程的用户虚拟地址空间，程序入口切换为解释器程序入口
  11）调用create_elf_tables依次把传递ELF解释器信息的辅助向量、环境指针数组envp、参数指针数组argv和参数个数argc压到进程的用户栈
  12）调用函数start_thread设置结构体pt_regs中程序计数器和栈指针寄存器，ARM64架构定义的函数start_thread</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux-5.10.102/arch/arm64/include/asm/processor.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread_common</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pc)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	memset(regs, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>regs));
</span></span><span style="display:flex;"><span>	forget_syscall(regs);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">=</span> pc; <span style="color:#75715e">/* 把程序计数器设置为程序的入口 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start_thread</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pc,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	start_thread_common(regs, pc);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>pstate <span style="color:#f92672">=</span> PSR_MODE_EL0t;  <span style="color:#75715e">/* 把处理器状态设置为0，其中异常级别是0 */</span>
</span></span><span style="display:flex;"><span>	spectre_v4_enable_task_mitigation(current);
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> sp;   <span style="color:#75715e">/*设置用户栈指针 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3装载脚本程序">3.装载脚本程序<a hidden class="anchor" aria-hidden="true" href="#3装载脚本程序">#</a></h4>
<p> 脚本程序前两个字节是<code>#!</code>，后面是解释器程序的名称和参数。解释器用来执行脚本程序
 <code>linux-5.10.102/fs/binfmt_script.c</code>函数<code>load_script</code>负责装载脚本程序</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20221103141127.png" alt="20221103141127"  />
</p>
<p>  1）检查前两个字节是不是脚本程序的标识符    <br>
  2）解析处解释程序的名称和参数      <br>
  3）从用户栈删除第一个参数，依次把脚本程序的文件名称、传给解释程序的参数和解释程序的名称压到用户栈      <br>
  4）调用opens_exec打开解释程序文件       <br>
  5）调用函数prepare_binprm设置进程证书，然后读取解释程序文件的前128字节到缓冲区        <br>
  6）调用函数search_binary_handler，尝试注册过的每种二进制格式的处理程序，直到某个处理程序识别解释程序为止     \</p>
<h2 id="26-进程退出">2.6 进程退出<a hidden class="anchor" aria-hidden="true" href="#26-进程退出">#</a></h2>
<p> 进程退出两种情况：进程主动退出和终止进程    <br>
 Linux内核两个主动退出的系统调用       \</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exit</span>(<span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个线程组所有线程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exit_group</span>(<span style="color:#66d9ef">int</span> status);
</span></span></code></pre></div><p> glibc库函数exit、_exit和_Exit用来使进程退出，库函数调用系统调用exit_group。库函数exit会执行进程使用的atexit和os_exit注册的函数        <br>
  终止进程是退出给进程发送信号实现的，Linux讷河发送信号的系统调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给进程或进程组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kill</span>(pid_t pid, <span style="color:#66d9ef">int</span> sig);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给线程  已废弃
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tkill</span>(<span style="color:#66d9ef">int</span> tid, <span style="color:#66d9ef">int</span> sig);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送信号给线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tgkill</span>(<span style="color:#66d9ef">int</span> tgid, <span style="color:#66d9ef">int</span> tid, <span style="color:#66d9ef">int</span> sig);
</span></span></code></pre></div><p> 父进程是否关注子进程退出事假，
  1）父进程关注子进程退出事件，子进程退出时释放各种资源，留空进程描述符的僵尸进程，发送信号SIGCHLD(CHILD是child)通知父进程，父进程查询进程终止原因从子进程收回进程描述符。    <br>
  2）父进程不关注子进程退出事件，进程退出是释放各种资源，释放进程描述符 \</p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://liuz0123.gitee.io/zain/img/wechat_pay.jpg" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://liuz0123.gitee.io/zain/img/alipay.jpg" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://liuz0123.gitee.io/zain/posts/na/%E9%81%93%E6%AD%89/">
    <span class="title">« 上一页</span>
    <br>
    <span>请求娜的原谅</span>
  </a>
  <a class="next" href="https://liuz0123.gitee.io/zain/posts/blog/git/">
    <span class="title">下一页 »</span>
    <br>
    <span>git</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou', 
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2022 
        <a href="https://liuz0123.gitee.io/zain/" style="color:#939393;">zain&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号申请中</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="填自己的公安图标链接" style="float:left;margin: 0px 5px 0px 0px;"/>
             公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
