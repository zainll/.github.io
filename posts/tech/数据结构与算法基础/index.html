<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>数据结构与算法基础 | zain&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="1 程序性能">
<meta name="author" content="
&nbsp;Zain">
<link rel="canonical" href="https://liuz0123.gitee.io/zain/posts/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">
<link crossorigin="anonymous" href="/zain/assets/css/stylesheet.6bbe4903eaf247f5c3db656a51fd7b09d982ab42029edfdc123f359e2748dc03.css" integrity="sha256-a75JA&#43;ryR/XD22VqUf17CdmCq0ICnt/cEj81nidI3AM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/zain/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="apple-touch-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<link rel="mask-icon" href="https://liuz0123.gitee.io/zain/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="数据结构与算法基础" />
<meta property="og:description" content="1 程序性能" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liuz0123.gitee.io/zain/posts/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-05T00:17:58&#43;08:00" />
<meta property="article:modified_time" content="2022-07-05T00:17:58&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构与算法基础"/>
<meta name="twitter:description" content="1 程序性能"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://liuz0123.gitee.io/zain/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "数据结构与算法基础",
      "item": "https://liuz0123.gitee.io/zain/posts/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法基础",
  "name": "数据结构与算法基础",
  "description": "1 程序性能",
  "keywords": [
    ""
  ],
  "articleBody": "1 程序性能 程序性能是指运行程序所需要的内存大小(空间复杂度)和时间(时间复杂度),运行时间和占用空间是算法性能最关键的指标。 软件程序性能衡量指标: 响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力\n1.1 空间复杂度 空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。 算法在计算机存储器上所占用的存储空间，包括存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间。\n1.2 时间复杂度 时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。\n1.2.1 常见算法大O 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k) 1.2.2 常见数据结构 {% pullquote mindmap mindmap-md %}\n数据结构与算法 线性表 数组 链表 单链表 双链表 循环链表 双向循环链表 静态链表 栈 顺序栈 链式栈 队列 普通队列 双端队列 阻塞队列 并发队列 阻塞并发队列 散列表 散列函数 冲突解决 链表法 开放地址 其他 动态扩容 位置 树 二叉树 二叉查找树 平衡二叉树 平衡二叉查找树 AVL树 红黑树 完全二叉树 满二叉树 多路查找树 B树 B+树 2-3树 2-3-4树 堆 小顶堆 大顶堆 优先级队列 斐波那契堆 二项堆 其他 树状数组 线段树 图 图的存储 邻接矩阵 邻接表 拓扑排序 最短路径 关键路径 最小生成树 二分图 最大流 复杂度分析 空间复杂度 时间复杂度 基本算法思想 分治法 递归算法 贪心算法 动态规划 回溯法 枚举法 排序 O(n^2) 冒泡排序 插入排序 选择排序 希尔排序 O(nlogn) 归并排序 快速排序 堆排序 O(n) 计数排序 基数排序 桶排序 搜索 深度优先搜索 广度优先搜索 A*启发式搜索 查找 线性表查找 树结构查找 散列表查找 字符串匹配 朴素 KMP Robin-Karp Boyer-Moore AC自动机 Trie 后缀数组 其他 数论 计算几何 概率分析 并查集 拓扑网络 矩阵运算 {% endpullquote %} 本章参考： 复杂度速查表 https://liam.page/2016/06/20/big-O-cheat-sheet/ 2 基本数据结构 2.1 线性表 线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。 数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。 两种情况下数据的存储问题： 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”； 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”\n2.1.1 数组 数组是一批相同数据的集合。数组的三部分：地址 大小 和 空间。数组的保存形式为线性表。\nint arr[10]; // /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...) // 数组初始化 int arr1[3] = {1, 2, 3}; char arr6[] = \"abcdef\"; // 指针 int *ptr = NULL;//定义一个整型的指针变量，初始化为NULL char *ptr = NULL;//定义一个字符的指针变量，初始化为NULL // 二维数组 int arr[3][5] = { 0 }; // C 传递数组给函数 // void myFunction(int *param) void myFunction(int param[10]) void myFunction(int param[]) // C 从函数返回数组 int * myFunction() { ... } array #include #include #include struct array { int size; int used; int *arr; }; void dump(struct array *array) { for (int idx = 0; idx \u003c array-\u003eused; idx++) { printf(\"[%02d]: %08d\\n\", idx, array-\u003earr[idx]); } } void alloc(struct array *array) { array-\u003earr = (int *)malloc(array-\u003esize * sizeof(int)); } int insert(struct array *array, int elem) { int idx; if (array-\u003eused \u003e= array-\u003esize) return -1; for (idx = 0; idx \u003c array-\u003eused; idx++) { if (array-\u003earr[idx] \u003e elem) break; } if (idx \u003c array-\u003eused) memmove(\u0026array-\u003earr[idx+1], \u0026array-\u003earr[idx], (array-\u003eused - idx) * sizeof(int)); array-\u003earr[idx] = elem; array-\u003eused++; return idx; } int delete(struct array *array, int idx) { if (idx \u003c 0 || idx \u003e= array-\u003eused) return -1; memmove(\u0026array-\u003earr[idx], \u0026array-\u003earr[idx+1], (array-\u003eused - idx - 1) * sizeof(int)); array-\u003eused--; return 0; } int search(struct array *array, int elem) { for (int idx = 0; idx \u003c array-\u003eused; idx++) { if (array-\u003earr[idx] == elem) return idx; if (array-\u003earr[idx] \u003e elem) return -1; } return -1; } int main() { struct array ten_int = {10, 0, NULL}; alloc(\u0026ten_int); if (!ten_int.arr) { return -1; } insert(\u0026ten_int, 1); insert(\u0026ten_int, 3); insert(\u0026ten_int, 2); printf(\"=== insert 1, 3, 2\\n\"); dump(\u0026ten_int); int idx = search(\u0026ten_int, 2); printf(\"2 is at position %d\\n\", idx); idx = search(\u0026ten_int, 9); printf(\"9 is at position %d\\n\", idx); printf(\"=== delete [6] element \\n\"); delete(\u0026ten_int, 6); dump(\u0026ten_int); printf(\"=== delete [0] element \\n\"); delete(\u0026ten_int, 0); dump(\u0026ten_int); return 0; } 二分搜索 基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0） 左闭右闭[left, right]：high = mid - 1; 左闭右开[left, right)：high = mid; 二分搜索的时间复杂度为 对数时间O(logn)\n// 左闭 右闭区间 [left, right] // low = mid + 1 high = mid - 1 int binary_search(int key, int a[], int n) { int low = 0; int high = n - 1; int mid, count = 0, count1 = 0; while(low \u003c high) { count++; mid = (low + high) / 2; if (key \u003c a[mid]) { high = mid - 1; } else if (key \u003e a[mid]) { low = mid + 1; } else if (key == a[mid]) { count1++; break; } } if (count1 == 0) { return 1; } return 0; } 2.1.2 单链表 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素\ntypedef struct ListElmt_ { void *data; // 数据成员 struct ListElmt_ * next; // next指针 } ListElmt; typedef struct List_ { int size; int (*match)(const void *key1, const void *key2); void (*destroy)(void *data); ListElmt *head; ListElmt *tail; } List; 单链表操作：插入、删除、 如何判断单链表存在回环？ 设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。\n翻转链表\nstruct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head-\u003enext; pre_node-\u003enext = res; res = pre_node; } return res; } singleList #ifndef __SINGLELIST_H__ #define __SINGLELIST_H__ #include #include typedef struct listNode { struct listNode *next; void *value; }listNode; typedef struct linkedList { listNode *head; size_t len; size_t typesize; void(*dup)(void*, void*); int(*match)(void*, void*); void(*free)(void*); }linkedList; #define listSetDupMethod(l,m) ((l)-\u003edup = (m)) #define listSetFreeMethod(l,m) ((l)-\u003efree = (m)) #define listSetMatchMethod(l,m) ((l)-\u003ematch = (m)) #define listGetDupMethod(l) ((l)-\u003edup) #define listGetFree(l) ((l)-\u003efree) #define listGetMatchMethod(l) ((l)-\u003ematch) linkedList *listCreate(); void listRelease(linkedList *list); void listEmpty(linkedList *list); linkedList *listAddNodeHead(linkedList *list, void *value); linkedList *listAddNodeTail(linkedList *list, void *value); linkedList *listInsertNode(linkedList *list, listNode *old_node, void *value, bool after); void listDelNode(linkedList *list, listNode *node); listNode *listSearchKey(linkedList *list, void *key); listNode *listIndex(linkedList *list, long index); linkedList* listRewind(linkedList *list); size_t listLength(linkedList *list); #endif // !__SINGLELIST_H__ // #include \"singleList.h\" #include linkedList * listCreate() { linkedList *list = NULL; list = malloc(sizeof(*list)); if (NULL == list) { return NULL; } list-\u003edup = NULL; list-\u003efree = NULL; list-\u003ematch = NULL; list-\u003ehead = NULL; list-\u003elen = 0; return list; } // void listRelease(linkedList *list) { if (NULL == list) { return; } listEmpty(list); free(list); list = NULL; } void listEmpty(linkedList *list) { if (NULL == list) { return; } while (NULL != list-\u003ehead) { listNode *pNode = list-\u003ehead; list-\u003ehead = pNode-\u003enext; if (NULL != list-\u003efree) { list-\u003efree(pNode-\u003evalue); } else { free(pNode-\u003evalue); } pNode-\u003enext = NULL; free(pNode); pNode = NULL; } } linkedList * listAddNodeHead(linkedList *list, void * value) { if (NULL == list || NULL == value) { return list; } listNode *node = NULL; node = malloc(sizeof(*node)); if (NULL == node) { return list; } node-\u003evalue = value; node-\u003enext = list-\u003ehead; list-\u003ehead = node; ++list-\u003elen; return list; } linkedList * listAddNodeTail(linkedList *list, void *value) { if (NULL == list || NULL == value) { return list; } listNode *node = NULL; node = malloc(sizeof(*node)); if (NULL == node) { return list; } node-\u003evalue = value; node-\u003enext = NULL; if (NULL == list-\u003ehead \u0026\u0026 list-\u003elen == 0) { list-\u003ehead = node; } else { listNode *tail = list-\u003ehead; listNode *pre = list-\u003ehead; while (NULL != tail) { pre = tail; tail = tail-\u003enext; } pre-\u003enext = node; } ++list-\u003elen; return list; } linkedList * listInsertNode(linkedList *list, listNode *old_node, void *value, bool after) { if (NULL == list || NULL == old_node) { return list; } listNode *pNode = NULL; pNode = malloc(sizeof(*pNode)); if (NULL == pNode) { return list; } pNode-\u003evalue = value; if (after) { pNode-\u003enext = old_node-\u003enext; old_node-\u003enext = pNode; } else { listNode *pre = list-\u003ehead; while (pre-\u003enext != old_node) { pre = pre-\u003enext; } if (NULL != pre) { pre-\u003enext = pNode; pNode-\u003enext = old_node; } } ++list-\u003elen; return list; } // void listDelNode(linkedList *list, listNode *node) { if (NULL == list || NULL == node) { return; } listNode *pre = list-\u003ehead; listNode *cur = list-\u003ehead; while (NULL != cur \u0026\u0026 cur != node) { pre = cur; cur = cur-\u003enext; } // if (NULL == pre) { return; } pre-\u003enext = node-\u003enext; node-\u003enext = NULL; --list-\u003elen; if (NULL != list-\u003efree) { list-\u003efree(node-\u003evalue); free(node); node = NULL; } } listNode * listSearchKey(linkedList *list, void *key) { if (NULL == list) { return NULL; } listNode *node = list-\u003ehead; while (NULL != node) { if (NULL != list-\u003ematch) { if (list-\u003ematch(key, node-\u003evalue) == 0) { return node; } } else { if (key == node-\u003evalue) { return node; } } node = node-\u003enext; } return NULL; } listNode * listIndex(linkedList *list, long index) { if (NULL == list) { return NULL; } if (index \u003c= 0 || index \u003e list-\u003elen) { return NULL; } listNode *pNode = list-\u003ehead; for (long i = 0; i \u003c index; ++i) { pNode = pNode-\u003enext; } return pNode; } linkedList* listRewind(linkedList *list) { if (NULL == list) { return NULL; } listNode *head = list-\u003ehead; listNode *pre = NULL; listNode *next = NULL; while (NULL != head) { next = head-\u003enext; head-\u003enext = pre; pre = head; head = next; } list-\u003ehead = pre; return list; } size_t listLength(linkedList *list) { if (NULL == list) { return 0; } return list-\u003elen; } single_list #include #include struct single_list { struct single_list *next; int val; }; struct single_list_head { struct single_list *head; }; bool is_empty(struct single_list_head *head) { return head-\u003ehead == NULL; } void dump(struct single_list_head *head) { struct single_list *tmp = head-\u003ehead; int idx = 0; while (tmp) { printf(\"[%02d]: %08d\\n\", idx++, tmp-\u003eval); tmp = tmp-\u003enext; } } void insert(struct single_list **prev, struct single_list *elem) { if (!prev) return; elem-\u003enext = *prev; *prev = elem; } void insert_head(struct single_list_head *head, struct single_list *elem) { insert(\u0026head-\u003ehead, elem); } struct single_list* del(struct single_list **prev) { struct single_list *tmp; if (!prev) return NULL; if (*prev == NULL) return NULL; tmp = *prev; *prev = (*prev)-\u003enext; tmp-\u003enext = NULL; return tmp; }; struct single_list* delete_head(struct single_list_head* head) { return del(\u0026head-\u003ehead); }; struct single_list** search(struct single_list_head* head, int target) { struct single_list **prev, *tmp; for (prev = \u0026head-\u003ehead, tmp = *prev; tmp \u0026\u0026 (tmp-\u003eval \u003c target); prev = \u0026tmp-\u003enext, tmp = *prev); return prev; }; void reverse(struct single_list_head* head) { struct single_list_head tmp = {NULL}; struct single_list *elem; while (!is_empty(head)) { elem = delete_head(head); insert_head(\u0026tmp, elem); } head-\u003ehead = tmp.head; } bool is_cyclic(struct single_list_head* head) { struct single_list *s1, *s2; s1 = s2 = head-\u003ehead; while(s1 \u0026\u0026 s2) { s1 = s1-\u003enext; s2 = s2-\u003enext ? s2-\u003enext-\u003enext:s2-\u003enext; if (s1 == s2) return true; } return false; } struct single_list* middle(struct single_list_head* head) { struct single_list *s1, *s2; struct single_list pseudo_head; pseudo_head.next = head-\u003ehead; s1 = s2 = \u0026pseudo_head; while (true) { if (!s2 || !s2-\u003enext) return s1; s1 = s1-\u003enext; s2 = s2-\u003enext-\u003enext; } return NULL; }; int main() { struct single_list_head head = {NULL}; struct single_list lists[10]; struct single_list **prev; int idx; for (idx = 0; idx \u003c 10; idx++) { lists[idx].val = idx; lists[idx].next = NULL; } insert_head(\u0026head, \u0026lists[6]); insert_head(\u0026head, \u0026lists[5]); insert_head(\u0026head, \u0026lists[4]); insert_head(\u0026head, \u0026lists[1]); insert_head(\u0026head, \u0026lists[0]); printf(\"=== insert 0, 1, 4, 5, 6\\n\"); dump(\u0026head); prev = search(\u0026head, 2); insert(prev, \u0026lists[2]); printf(\"=== insert 2\\n\"); dump(\u0026head); printf(\"middle elem is %d\\n\", middle(\u0026head)-\u003eval); prev = search(\u0026head, 2); if ((*prev) \u0026\u0026 ((*prev)-\u003eval == 2)) printf(\"The list contains 2\\n\"); else printf(\"The list not contains 2\\n\"); del(prev); prev = search(\u0026head, 2); printf(\"After remove 2\\n\"); if ((*prev) \u0026\u0026 ((*prev)-\u003eval == 2)) printf(\"The list contains 2\\n\"); else printf(\"The list not contains 2\\n\"); dump(\u0026head); printf(\"After reverse \\n\"); reverse(\u0026head); dump(\u0026head); printf(\"middle elem is %d\\n\", middle(\u0026head)-\u003eval); lists[0].next = \u0026lists[6]; printf(\"list is%s cyclic\\n\", is_cyclic(\u0026head)?\"\":\" not\"); return 0; } LinkedListAlgo #include #include /** * 1) 单链表反转 * 2) 链表中环的检测 * 3) 两个有序的链表合并 * 4) 删除链表倒数第 n 个结点 * 5) 求链表的中间结点 * * Author: Smallfly */ typedef struct SinglyLinkedNode { int data; struct SinglyLinkedNode* next; } SinglyLinkedNode; void insertNode(SinglyLinkedNode** head_ref, int data); void printLinkedList(SinglyLinkedNode* head); /** 反转单链表 */ void reverse(SinglyLinkedNode** head_ref) { if (*head_ref == NULL) return; SinglyLinkedNode *prev = NULL; SinglyLinkedNode *current = *head_ref; while (current) { SinglyLinkedNode *next = current-\u003enext; if (!next) { // 到达尾结点时，将地址存入 head_ref *head_ref = current; } current-\u003enext = prev; prev = current; current = next; } } void test_reverse() { SinglyLinkedNode* head = NULL; insertNode(\u0026head, 3); insertNode(\u0026head, 2); insertNode(\u0026head, 1); reverse(\u0026head); printLinkedList(head); } /** 检测单链表是否有环 */ // 这里使用一级指针也可以 int checkCircle(SinglyLinkedNode** head_ref) { if (*head_ref == NULL) return 0; SinglyLinkedNode *slow = *head_ref, *fast = *head_ref; while (fast != NULL \u0026\u0026 fast-\u003enext != NULL) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if (slow == fast) return 1; } return 0; } void test_checkCircle() { SinglyLinkedNode* head = NULL; insertNode(\u0026head, 3); insertNode(\u0026head, 2); insertNode(\u0026head, 1); int result1 = checkCircle(\u0026head); printf(\"has circle: %d\\n\", result1); // make circle linklist SinglyLinkedNode* current = malloc(sizeof(SinglyLinkedNode)); current-\u003edata = 0; SinglyLinkedNode* h = current; for (int i = 1; i \u003c 4; ++i) { SinglyLinkedNode* node = malloc(sizeof(SinglyLinkedNode)); node-\u003edata = i; current-\u003enext = node; //reset current node current = node; } current-\u003enext = h; int result2 = checkCircle(\u0026h); printf(\"has circle: %d\\n\", result2); } /** 有序链表合并 */ void moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref); SinglyLinkedNode* mergeSortedLinkedList(SinglyLinkedNode* la, SinglyLinkedNode* lb) { // 辅助结点，next 指针持有合并后的有序链表 SinglyLinkedNode dummy; // 有序链表的尾结点 SinglyLinkedNode* tail = \u0026dummy; while (1) { // 如果有一个链表为空，直接与另一个链表接起来 if (!la) { tail-\u003enext = lb; break; } else if (!lb) { tail-\u003enext = la; break; } // 将头结点较小的优先添加到 tail if (la-\u003edata \u003c= lb-\u003edata) { moveNode(\u0026(tail-\u003enext), \u0026la); } else { moveNode(\u0026(tail-\u003enext), \u0026lb); } tail = tail-\u003enext; } return dummy.next; } // 将 src_ref 的头结点，添加到 dest_ref 的头部。 void moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref) { if (*src_ref == NULL) return; SinglyLinkedNode* new_node = *src_ref; *src_ref = new_node-\u003enext; new_node-\u003enext = *dest_ref; *dest_ref = new_node; } void test_mergeSortedLinkedList() { SinglyLinkedNode* a = NULL; insertNode(\u0026a, 10); insertNode(\u0026a, 5); insertNode(\u0026a, 0); SinglyLinkedNode* b = NULL; insertNode(\u0026b, 8); insertNode(\u0026b, 6); insertNode(\u0026b, 3); SinglyLinkedNode* result = mergeSortedLinkedList(a, b); printLinkedList(result); SinglyLinkedNode* result2 = mergeSortedLinkedList(a, NULL); printLinkedList(result2); } /** 删除倒数第 K 个结点 */ void deleteLastKth(SinglyLinkedNode** head_ref, int k) { if (*head_ref == NULL || k == 0) return; // 快指针向前移动 k-1 SinglyLinkedNode* fast = *head_ref; int i = 1; while (i \u003c k \u0026\u0026 fast != NULL) { fast = fast-\u003enext; ++i; } // 如果快指针为空，说明结点个数小于 k if (fast == NULL) return; SinglyLinkedNode* slow = *head_ref; SinglyLinkedNode* prev = NULL; while (fast-\u003enext != NULL) { fast = fast-\u003enext; prev = slow; slow = slow-\u003enext; } // 如果 prev 为空，头结点刚好是第 k 个结点 if (!prev) { (*head_ref) = (*head_ref)-\u003enext; } else { prev-\u003enext = slow-\u003enext; } free(slow); } void test_deleteLastKth() { SinglyLinkedNode* head = NULL; insertNode(\u0026head, 1); insertNode(\u0026head, 2); insertNode(\u0026head, 3); insertNode(\u0026head, 4); insertNode(\u0026head, 5); // 1. 删除头结点 deleteLastKth(\u0026head, 5); printLinkedList(head); // 2. 删除中间结点 deleteLastKth(\u0026head, 2); printLinkedList(head); } /** 求中间结点 */ SinglyLinkedNode* findMiddleNode(SinglyLinkedNode* head) { if (!head) return NULL; SinglyLinkedNode* slow = head; SinglyLinkedNode* fast = head; // 1. 慢指针走一步，快指针两步 while (fast-\u003enext != NULL \u0026\u0026 fast-\u003enext-\u003enext != NULL) { slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; } return slow; } void test_findMiddleNode() { SinglyLinkedNode* head = NULL; insertNode(\u0026head, 1); insertNode(\u0026head, 2); insertNode(\u0026head, 3); insertNode(\u0026head, 4); insertNode(\u0026head, 5); SinglyLinkedNode* middleNode = findMiddleNode(head); printf(\"%d\\n\", middleNode-\u003edata); printLinkedList(head); } /** 工具方法 */ // 插入新结点到链表头部 void insertNode(SinglyLinkedNode** head_ref, int data) { SinglyLinkedNode* new_node = malloc(sizeof(SinglyLinkedNode)); new_node-\u003edata = data; new_node-\u003enext = *head_ref; *head_ref = new_node; } // 打印链表 void printLinkedList(SinglyLinkedNode* node) { printf(\"--- start ---\\n\"); while (node) { printf(\"data: %d\\n\", node-\u003edata); node = node-\u003enext; } printf(\"--- end ---\\n\"); } // 跑测试 void test() { test_reverse(); // test_checkCircle(); // test_mergeSortedLinkedList(); // test_deleteLastKth(); // test_findMiddleNode(); } linklist_jinshaohui /************************************************************************* \u003e File Name: lisklist.c \u003e Author: jinshaohui \u003e Mail: jinshaohui789@163.com \u003e Time: 18-10-07 ************************************************************************/ #include struct stlistNode { int val; struct listNode *next; }listNode; /*反转链表*/ listNode reverseList(listNode *head) { listNode *prev = NULL; listNode *next = NULL; while(head != NULL) { next = head-\u003enext; head-\u003enext = prev; prev = head; head = next; } return prev; } /*判断链表是否有环*/ int hasCycle(listNode *head) { listNode * fast = head; listNode * low = head; while(fast != NULL \u0026\u0026 fast-\u003enext != NULL) { low = low-\u003enext; fast = fast-\u003enext-\u003enext; if (low == fast) { return 1; } } return 0; } /*合并有序链表*/ listNode *mergeTwoLists(listNode *l1,listNode *l2) { listNode head = {0}; listNode *pRes = \u0026head; while(1) { if(l1 == NULL) { pRes-\u003enext = l2; } if (l2 == NULL) { pRes-\u003enext = l1; } if(l1-\u003eval \u003c l2-\u003eval) { pRes-\u003enext = l1; l1 = l1-\u003enext; } else { pRes-\u003enext = l2; l2 = l2-\u003enext; } pRes = pRes-\u003enext; } return head; } /* *删除链表倒数第n个节点，并返回链表头节点 */ listNode * removeNthFromEnd(listNode*headi,int n) { listNode *fast = head; listNode *prev = NULL; listNpde *next = head; int k = n; /*快指针往后移动k-1*/ while((k \u003e 1) \u0026\u0026 (fast != NULL)) { fast = fast-\u003enext; k--; } /*说明链表数目不足n个*/ if (fast == NULL) { return head; } while (fast-\u003enext != NULL) { fast = fast-\u003enext; prev = next; next = next-\u003enext; } if(prev == NULL) { head = head-\u003enext; } else { prev-\u003enext = prev-\u003enext-\u003enext; } return head; } /*求链表的中间节点*/ listNode *middleNode(listNode *head) { listNode * fast = head; listNode * low = head; while(fast != NULL \u0026\u0026 fast-\u003enext != NULL) { low = low-\u003enext; fast = fast-\u003enext-\u003enext; } return low; } 2.1.3 双链表 双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。\ntypedef struct DListElmt_ { void *data; struct DListElmt_ *prev; struct DListElmt_ *next; } DListElmt; typedef struct DList_ { int size; int (*match)(const void *key1, const void *key2); void (*destroy)(void *data); DListElmt *head; DListElmt *tail; } DList; Dlist // Dlist.h #include typedef struct DlistNode { //双向链表中每一个节点 struct DlistNode *prev; //节点前项指针 struct DlistNode *next; //节点后项指针 int data; //数据 }stDlistNode; typedef struct Dlisthead { //定义链表总体 int size; //链表长度 stDlistNode *head; //头指针 stDlistNode *tail; //尾部指针 }stDlistHead; // Dlist.c #include #include #include \"./Dlist.h\" void dlist_init(stDlistHead *dlist) //链表初始化 { dlist-\u003esize = 0; dlist-\u003ehead = NULL; dlist-\u003etail = NULL; return; } void dlist_destory(stDlistHead *dlist) //删除链表 { stDlistNode *pNode = NULL; while(dlist-\u003esize \u003e 0) { pNode = dlist-\u003ehead; dlist-\u003ehead = dlist-\u003ehead-\u003enext; free(pNode); dlist-\u003esize--; } memset(dlist,0,sizeof(stDlistHead)); return; } int dlist_insert_head(stDlistHead *dlist,stDlistNode *pNode,int data) //插入头结点，操作的链表，操作的节点，数据 { if(pNode == NULL) { //当只传递一个数据时 pNode = (stDlistNode *)malloc(sizeof(stDlistNode)); //新建节点，为节点分配空间（malloc（）可能需要#include） if (pNode == NULL) { return -1; } } pNode-\u003edata = data; pNode-\u003eprev = NULL; pNode-\u003enext = NULL; if (dlist-\u003esize == 0) { //如果链表长度为0，即链表当前无节点， dlist-\u003ehead = pNode; dlist-\u003etail = pNode; } else { //如果链表已有节点，则令新插入节点为头节点 pNode-\u003enext = dlist-\u003ehead; dlist-\u003ehead-\u003eprev = pNode; dlist-\u003ehead = pNode; } dlist-\u003esize++; //每成功调用一次，链表长度+1 return 0; } stDlistNode * dlist_remove_tail(stDlistHead *dlist) //删除尾部节点,并返回删除节点 { stDlistNode *pNode = NULL; if(dlist-\u003esize == 0) { return NULL; } pNode = dlist-\u003etail; if(dlist-\u003esize \u003e 1) { dlist-\u003etail = dlist-\u003etail-\u003eprev; dlist-\u003etail-\u003enext = NULL; } else { dlist-\u003ehead = NULL; dlist-\u003etail = NULL; } dlist-\u003esize--; return pNode; } void dlist_remove_node(stDlistHead * dlist,stDlistNode *pNode) //删除指定节点 { if ((dlist == NULL)||(pNode == NULL)) { return; } if (dlist-\u003ehead == pNode) { dlist-\u003ehead = dlist-\u003ehead-\u003enext; } else if (dlist-\u003etail == pNode) { dlist-\u003etail = pNode-\u003eprev; dlist-\u003etail-\u003enext = NULL; } else { pNode-\u003eprev-\u003enext = pNode-\u003enext; pNode-\u003enext-\u003eprev = pNode-\u003eprev; } dlist-\u003esize--; pNode-\u003eprev = NULL; pNode-\u003enext = NULL; if (dlist-\u003esize == 0) { memset(dlist,0,sizeof(stDlistHead)); //将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容 } return; } stDlistNode * dlist_search(stDlistHead * dlist,int data) //根据值搜索节点，并返回 { stDlistNode *pNode = dlist-\u003ehead; while(pNode != NULL) { if (pNode-\u003edata == data) { return pNode; } pNode = pNode-\u003enext; } return NULL; } void dlist_dump(stDlistHead *dlist) //显示链表中的数据 { int no = 0; stDlistNode *pNode = dlist-\u003ehead; while(pNode != NULL) { printf(\"\\r\\n [%d] = %d\",no++,pNode-\u003edata); pNode = pNode-\u003enext; //将pNode的下一个节点赋值给pNode，推进循环 } return; } void Lru_dlist(stDlistHead *dlist,int data) //LRU（最近最少使用）缓存淘汰算法 { stDlistNode *pNode = NULL; pNode = dlist_search(dlist,data); if (pNode != NULL) { //如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部 dlist_remove_node(dlist,pNode); } else if(dlist-\u003esize \u003e= 4) { //没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部 pNode = dlist_remove_tail(dlist); } dlist_insert_head(dlist ,pNode,data); return; } int main() { stDlistHead dlist = {0}; stDlistNode * pNode = NULL; dlist_init(\u0026dlist); printf(\"\\r\\n inset 1,2,3\"); dlist_insert_head(\u0026dlist,NULL,1); dlist_insert_head(\u0026dlist,NULL,2); dlist_insert_head(\u0026dlist,NULL,3); dlist_dump(\u0026dlist); pNode = dlist_remove_tail(\u0026dlist); if(pNode != NULL) { printf(\"\\r\\n remove %d\",pNode-\u003edata); } dlist_insert_head(\u0026dlist,pNode,4); dlist_dump(\u0026dlist); Lru_dlist(\u0026dlist,5); dlist_dump(\u0026dlist); Lru_dlist(\u0026dlist,6); dlist_dump(\u0026dlist); Lru_dlist(\u0026dlist,7); dlist_dump(\u0026dlist); Lru_dlist(\u0026dlist,5); dlist_dump(\u0026dlist); while(dlist.size \u003e 0) { pNode = dlist_remove_tail(\u0026dlist); if(pNode != NULL) { printf(\"\\r\\n remove %d\",pNode-\u003edata); free (pNode); } } return 0; } linux/list // linux内核源码双向链表实现include/linux/list.h #ifndef _LIST_HEAD_H #define _LIST_HEAD_H // 双向链表节点 struct list_head { struct list_head *next, *prev; }; // 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。 #define LIST_HEAD_INIT(name) { \u0026(name), \u0026(name) } // 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。 #define LIST_HEAD(name) \\ struct list_head name = LIST_HEAD_INIT(name) // 初始化节点：将list节点的前继节点和后继节点都是指向list本身。 static inline void INIT_LIST_HEAD(struct list_head *list) { list-\u003enext = list; list-\u003eprev = list; } // 添加节点：将new插入到prev和next之间。 static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-\u003eprev = new; new-\u003enext = next; new-\u003eprev = prev; prev-\u003enext = new; } // 添加new节点：将new添加到head之后，是new称为head的后继节点。 static inline void list_add(struct list_head *new, struct list_head *head) { __list_add(new, head, head-\u003enext); } // 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。 static inline void list_add_tail(struct list_head *new, struct list_head *head) { __list_add(new, head-\u003eprev, head); } // 从双链表中删除entry节点。 static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u003eprev = prev; prev-\u003enext = next; } // 从双链表中删除entry节点。 static inline void list_del(struct list_head *entry) { __list_del(entry-\u003eprev, entry-\u003enext); } // 从双链表中删除entry节点。 static inline void __list_del_entry(struct list_head *entry) { __list_del(entry-\u003eprev, entry-\u003enext); } // 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。 static inline void list_del_init(struct list_head *entry) { __list_del_entry(entry); INIT_LIST_HEAD(entry); } // 用new节点取代old节点 static inline void list_replace(struct list_head *old, struct list_head *new) { new-\u003enext = old-\u003enext; new-\u003enext-\u003eprev = new; new-\u003eprev = old-\u003eprev; new-\u003eprev-\u003enext = new; } // 双链表是否为空 static inline int list_empty(const struct list_head *head) { return head-\u003enext == head; } // 获取\"MEMBER成员\"在\"结构体TYPE\"中的位置偏移 #define offsetof(TYPE, MEMBER) ((size_t) \u0026((TYPE *)0)-\u003eMEMBER) // 根据\"结构体(type)变量\"中的\"域成员变量(member)的指针(ptr)\"来获取指向整个结构体变量的指针 #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u003emember ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) // 遍历双向链表 #define list_for_each(pos, head) \\ for (pos = (head)-\u003enext; pos != (head); pos = pos-\u003enext) #define list_for_each_safe(pos, n, head) \\ for (pos = (head)-\u003enext, n = pos-\u003enext; pos != (head); \\ pos = n, n = pos-\u003enext) #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) #endif 2.1.4 跳表 跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。\nskiplist /************************************************************************* \u003e File Name: skiplist.h \u003e Author: jinshaohui \u003e Mail: jinshaohui789@163.com \u003e Time: 18-10-31 \u003e Desc: ************************************************************************/ #ifndef __SKIP_LIST_H__ #define __SKIP_LIST_H__ typedef struct _node { int key; /*key是唯一的*/ int value; /*存储的内容*/ int max_level; /*当前节点最大层数*/ struct _node *next[0];/*level层链表结构*/ }node; typedef struct _skiplist { int level; int count; node *head; }skiplist; /*根据当前结构体元素的地址，获取到结构体首地址*/ #define offsetof(TYPE,MEMBER) ((size_t) \u0026((TYPE *)0)-\u003eMEMBER) #define container(ptr,type,member) ({\\ const typeof( ((type *)0)-\u003emember) *__mptr = (ptr);\\ (type *) ( (char *)__mptr - offsetof(type,member));}) #endif #include #include #include #include #include\"./skiplist.h\" /*创建node节点*/ node* skip_list_create_node(int level,int key,int value) { node * tmp = NULL; tmp =(node *)malloc(sizeof(node) + level*sizeof(node *)); assert(tmp != NULL); memset(tmp,0,sizeof(node) + level*sizeof(node*)); tmp-\u003ekey = key; tmp-\u003evalue = value; tmp-\u003emax_level = level; return tmp; } /*创建跳表的表头，max_level层数*/ skiplist * skip_list_create(int max_level) { int i = 0; skiplist * list = NULL; list = (skiplist *)malloc (sizeof(skiplist)); assert(list != NULL); list-\u003elevel = 1; list-\u003ecount = 0; list-\u003ehead = skip_list_create_node(max_level,0,0); if(list-\u003ehead == NULL) { free(list); return NULL; } return list; } /*skiplist 销毁*/ void skip_list_destory(skiplist * list) { int i = 0; node * tmp = NULL; if((list == NULL) || (list-\u003ehead == NULL)) { return; } while(list-\u003ehead-\u003enext[0] != NULL) { tmp = list-\u003ehead-\u003enext[0]; list-\u003ehead-\u003enext[0] = tmp-\u003enext[0]; free(tmp); } free(list-\u003ehead); free(list); return; } /*插入元素获得层数，是随机产生的*/ int skip_list_level(skiplist * list) { int i = 0; int level = 1; for (i = 1; i \u003c list-\u003ehead-\u003emax_level; i++) { if ((rand()%2) == 1) { level++; } } return level; } int skip_list_insert(skiplist *list,int key,int value) { int i = 0; int level = 0; node **update = NULL;/*用来更新每层的指针*/ node *tmp = NULL; node *prev = NULL; if (list == NULL) { return 1; } /*申请update空间用于保存每层的指针*/ update = (node **)malloc(sizeof(node *)*list-\u003ehead-\u003emax_level); if (update == NULL) { return 2; } /*逐层查询节点的*/ prev = list-\u003ehead; for (i = (list-\u003elevel -1); i \u003e= 0; i--) { /*初始化每level层的头指针*/ while(((tmp = prev-\u003enext[i]) != NULL) \u0026\u0026 (tmp-\u003ekey \u003c key)) { prev = tmp; } update[i] = prev; } /*当前key已经存在，返回错误*/ if ((tmp!= NULL) \u0026\u0026 (tmp-\u003ekey == key)) { return 3; } /*获取插入元素的随机层数，并更新跳表的最大层数*/ level = skip_list_level(list); /*创建当前数据节点*/ tmp = skip_list_create_node(level,key,value); if (tmp == NULL) { return 4; } /*更新最大层数*/ if (level \u003e list-\u003elevel) { for (i = list-\u003elevel;i \u003c level; i ++) { update[i] = list-\u003ehead; } list-\u003elevel = level; } /*逐层更新节点的指针*/ for(i = 0; i \u003c level; i++) { tmp-\u003enext[i] = update[i]-\u003enext[i]; update[i]-\u003enext[i] = tmp; } list-\u003ecount++; return 0; } int skip_list_delete(skiplist * list, int key ,int *value) { int i = 0; node **update = NULL;/*用来更新每层的指针*/ node *tmp = NULL; node *prev = NULL; if ((list == NULL) \u0026\u0026 (value == NULL)\u0026\u0026 (list-\u003ecount == 0)) { return 1; } /*申请update空间用于保存每层的指针*/ update = (node **)malloc(sizeof(node *)*list-\u003elevel); if (update == NULL) { return 2; } /*逐层查询节点的*/ prev = list-\u003ehead; for (i = (list-\u003elevel -1); i \u003e= 0; i--) { /*初始化每level层的头指针*/ while(((tmp = prev-\u003enext[i]) != NULL) \u0026\u0026 (tmp-\u003ekey \u003c key)) { prev = tmp; } update[i] = prev; } if ((tmp != NULL) \u0026\u0026 (tmp-\u003ekey == key)) { *value = tmp-\u003evalue; /*逐层删除*/ for(i = 0; i \u003c list-\u003elevel; i++) { if(update[i]-\u003enext[i] == tmp) { update[i]-\u003enext[i] = tmp-\u003enext[i]; } } free(tmp); tmp = NULL; /*更新level的层数*/ for (i = list-\u003elevel - 1; i \u003e= 0; i++) { if (list-\u003ehead-\u003enext[i] == NULL ) { list-\u003elevel--; } else { break; } } list-\u003ecount--; } else { return 3;/*未找到节点*/ } return 0 ; } /*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/ int skip_list_search(skiplist *list,int key,int *value) { int i = 0; node *prev = NULL; node *tmp = NULL; if((list == NULL) || (list-\u003ecount == 0) || (value == NULL)) { return 1; } prev = list-\u003ehead; for(i = list-\u003elevel - 1; i \u003e= 0; i--) { while(((tmp = prev-\u003enext[i]) != NULL) \u0026\u0026 (tmp-\u003ekey \u003c= key)) { if (tmp-\u003ekey == key) { *value = tmp-\u003evalue; return 0; } prev = tmp; } } return -1; } void skip_list_dump(skiplist *list) { int i = 0; node *ptmp = NULL; printf(\"\\r\\n----------------------------------------------\"); printf(\"\\r\\n skip list level[%d],count[%d]\",list-\u003elevel,list-\u003ecount); for(i = list-\u003elevel - 1; i \u003e= 0; i --) { ptmp = list-\u003ehead-\u003enext[i]; printf(\"\\r\\n level[%d]:\",i); while(ptmp != NULL) { printf(\"%d-%d \",ptmp-\u003ekey,ptmp-\u003evalue); ptmp = ptmp-\u003enext[i]; } } printf(\"\\r\\n----------------------------------------------\"); return; } int main() { int res = 0; int key = 0; int value = 0; skiplist *list = NULL; list = skip_list_create(5); assert(list != NULL); while(1) { printf(\"\\r\\n 请输入key 和 value，当key = 1000时，退出输入：\"); scanf(\"%d%d\",\u0026key,\u0026value); if (key == 1000) { break; } res = skip_list_insert(list,key,value); if (res != 0) { printf(\"\\r\\n skip list insert %d,failed,res=%d.\",key,res); } } skip_list_dump(list); while(1) { printf(\"\\r\\n 通过key 查询value的数值，当key = 1000时，退出查询\"); scanf(\"%d\",\u0026key); if(key == 1000) { break; } res = skip_list_search(list,key,\u0026value); if (res != 0) { printf(\"\\r\\n skip list search %d,failed,res=%d.\",key,res); } else { printf(\"\\r\\n skip list search %d,sucessful,value=%d.\",key,value); } } skip_list_dump(list); while(1) { printf(\"\\r\\n 通过key 删除节点，当key = 1000时，退出删除\"); scanf(\"%d\",\u0026key); if(key == 1000) { break; } res = skip_list_delete(list,key,\u0026value); if (res != 0) { printf(\"\\r\\n skip list search %d,failed,res=%d.\",key,res); } else { printf(\"\\r\\n skip list search %d,sucessful,value=%d.\",key,value); } } skip_list_dump(list); skip_list_destory(list); return 0; } 2.1.5 栈 栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。 可通过链表来实现栈stack,允许插入和删除的为栈顶(top),另一端为栈底(bottom),栈中每个元素为frame,栈只支持三个操作:pop,top,push.\ntypedef List Stack; #define stack_init list_init; int stack_push(Stack *stack, const void *data); int stack_pop(Stack *stack, void **data); #define stack_peek(stack) ((stack)-\u003ehead == NULL ? NULL : (stack)-\u003ehead-\u003edata); #define stack_size list_size; c语言顺序栈\n// 元素elem进栈 int push(char *a, int top, char elem) { a[++top] = elem; return top; } // 数据元素出栈 int pop(char *a, int top) { if (top == -1) { return -1; } top--; return top; } arrayStack /************************************************************************* \u003e File Name: arrayStack \u003e Author: jinshaohui \u003e Mail: jinshaohui789@163.com \u003e Time: 18-10-12 \u003e Desc: 数组实现顺序栈 ************************************************************************/ #ifndef ARRAY_STACJ_H #define ARRAY_STACJ_H typedef struct _array_stack { int size;/*栈的大小*/ int pos;/*当前存储元素的个数，即栈顶元素下表*/ int *array;/*数据存储区*/ }stArrayStack; #define arrayStack_size(arrayStack) (arrayStack-\u003esize) #define arrayStack_is_empty(arrayStack) (arrayStack-\u003epos == -1) #define arrayStack_is_full(arrayStack) (arrayStack-\u003epos == (arrayStack-\u003esize-1)) #endif #include #include #include #include\"./arrayStack.h\" /*创建并初始化顺序栈*/ stArrayStack * arrayStack_create(int size) { stArrayStack *parrStack = NULL; parrStack = (stArrayStack *)malloc(sizeof(stArrayStack)); if (parrStack == NULL) { return NULL; } parrStack-\u003esize = size; parrStack-\u003epos = -1; parrStack-\u003earray = (int *)malloc(sizeof(int)*size); if(parrStack-\u003earray == NULL) { free(parrStack); return NULL; } return parrStack; } /*销毁顺序栈*/ void arrayStack_destory(stArrayStack * parrStack) { if(parrStack == NULL) { return; } if (parrStack-\u003earray != NULL) { free(parrStack-\u003earray); } free(parrStack); return; } /*出栈*/ int arrayStack_pop(stArrayStack *parrStack) { int data = 0; if(arrayStack_is_empty(parrStack)) { return -1; } data = parrStack-\u003earray[parrStack-\u003epos]; parrStack-\u003epos--; return data; } /*入栈*/ int arrayStack_push(stArrayStack *parrStack,int data) { if(arrayStack_is_full(parrStack)) { return -1; } parrStack-\u003epos++; parrStack-\u003earray[parrStack-\u003epos] = data; return 0; } int arrayStack_push_new(stArrayStack*parrStack,int data) { int *ptmp = NULL; /*如果栈不满，直接插入*/ if(!arrayStack_is_full(parrStack)) { return arrayStack_push(parrStack,data); } /*如果栈已经满，申请内存*/ ptmp = (int *)malloc(2*parrStack-\u003esize*sizeof(int)); if (ptmp == NULL) { return -1; } memcpy(ptmp,parrStack-\u003earray,parrStack-\u003esize*sizeof(int)); free(parrStack-\u003earray); parrStack-\u003earray = ptmp; parrStack-\u003esize = 2*parrStack-\u003esize; parrStack-\u003epos++; parrStack-\u003earray[parrStack-\u003epos] = data; return ; } void arrayStack_dump(stArrayStack *parrStack) { int i = 0; if (arrayStack_is_empty(parrStack)) { printf(\"\\r\\n arrayStack is empty.\"); return; } printf(\"\\r\\narrayStack size = %d,pos= %d,\", parrStack-\u003esize,parrStack-\u003epos); for(i = 0; i \u003c= parrStack-\u003epos; i++) { printf(\"\\r\\narry[%d] = %d\",i,parrStack-\u003earray[i]); } } int main() { int i = 0; int ret = 0; stArrayStack * parrStack = NULL; printf(\"\\r\\n create size = 4 arrayStack.\"); parrStack = arrayStack_create(4); if (parrStack == NULL) { printf(\"\\r\\n create size = 4 arrayStack faided.\"); return 0; } for (i = 0; i \u003c 5; i++) { ret = arrayStack_push(parrStack,i); if(ret != 0) { printf(\"\\r\\n push size = %d arrayStack faided.\",i); } } arrayStack_dump(parrStack); ret = arrayStack_push_new(parrStack,4); if(ret != 0) { printf(\"\\r\\n push size = %d arrayStack faided.\",4); } arrayStack_dump(parrStack); arrayStack_destory(parrStack); return; } 链栈\ntypedef struct lineStack { char data; struct lineStack *next; }lineStack; lineStack* push(lineStack * stack, char a){ lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u003edata=a; line-\u003enext=stack; stack=line; return stack; } lineStack * pop(lineStack * stack){ if (stack) { lineStack * p=stack; stack=stack-\u003enext; printf(\"弹栈元素：%c \",p-\u003edata); if (stack) { printf(\"栈顶元素：%c\\n\",stack-\u003edata); } else { printf(\"栈已空\\n\"); } free(p); } else { printf(\"栈内没有元素\"); return stack; } return stack; } linklist_stack /************************************************************************* \u003e File Name: linklist_stack \u003e Author: jinshaohui \u003e Mail: jinshaohui789@163.com \u003e Time: 18-10-12 \u003e Desc: ************************************************************************/ #ifndef STACK_LINK_LIST_H #define STACK_LINK_LIST_H typedef struct _linkliststack { int data; struct _linkliststack *next; }linklist_stack; #define stack_is_empty(liststack) (liststack-\u003enext == NULL) #endif #include #include #include #include \"./linklist_stack.h\" linklist_stack * stack_create() { linklist_stack * stack = NULL; stack = (linklist_stack *)malloc(sizeof(linklist_stack)); if (stack == NULL) { return NULL; } stack-\u003enext = NULL; return stack; } void stack_destory(linklist_stack* stack) { linklist_stack * ptmp = NULL; while(!stack_is_empty(stack)) { ptmp = stack-\u003enext; stack-\u003enext = stack-\u003enext-\u003enext; free(ptmp); } free(stack); return; } int stack_push(linklist_stack *stack,int data) { linklist_stack * ptmp = NULL; ptmp = (linklist_stack *)malloc(sizeof(linklist_stack)); if (ptmp == NULL) { return -1; } ptmp-\u003edata = data; ptmp-\u003enext = stack-\u003enext; stack-\u003enext = ptmp; return 0; } int stack_pop(linklist_stack*stack,int *data) { linklist_stack *ptmp = NULL; if (data == NULL) { return -1; } if(stack_is_empty(stack)) { return -1; } *data = stack-\u003enext-\u003edata; ptmp = stack-\u003enext; stack-\u003enext = ptmp-\u003enext; free(ptmp); return 0; } void stack_dump(linklist_stack *stack) { linklist_stack * ptmp = stack-\u003enext; while(ptmp != NULL) { printf(\"\\r\\n data = %d\",ptmp-\u003edata); ptmp = ptmp-\u003enext; } return; } int main() { int i = 0; int ret = 0; int data = 0; linklist_stack * stack = NULL; stack = stack_create(); if (stack == NULL) { printf(\"\\r\\n stack create falied.\"); return 0; } for (i = 0; i \u003c 4; i++) { ret = stack_push(stack,i); if(ret != 0) { printf(\"\\r\\n stack push %d falied.\",i); } } stack_dump(stack); for (i = 0; i \u003c 5; i++) { ret = stack_pop(stack,\u0026data); if(ret != 0) { printf(\"\\r\\n stack pop%d falied.\", i); } else { printf(\"\\r\\n data = %d,\",data); } } stack_destory(stack); return 0; } 2.1.6 队列 队列，在前端(front)进行删除操作，后端(rear)进行插入操作; 按照先进先出(FIFO)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。 队列也可通过数组和链表实现。\ntypedef List Queue; #define queue_init list_init; #define queue_destroy list_destroy; int queue_enqueue(Queue *queue, const void *data); int queue_dequeue(Queue *queue, void **data); #define queue_peek(queue) ((queue)-\u003ehead == NULL ? NULL : (queue)-\u003ehead-\u003edata); #define queue_size list_size; array_queue /************************************************************************* \u003e File Name: array_queue \u003e Author: jinshaohui \u003e Mail: jinshaohui789@163.com \u003e Time: 18-10-12 \u003e Desc: ************************************************************************/ #ifndef ARRAY_QUEUE_H #define ARRAY_QUEUE_H typedef struct _array_queue { int size;/*队列的大小*/ int num; /*当前存储数据的大小*/ int head;/*队列的头*/ int tail;/*队列的尾*/ int *array;/*数据存储区*/ }array_queue; #define array_queue_is_empty(array_queue) (array_queue-\u003enum == 0) #define array_queue_is_full(array_queue) ((array_queue-\u003enum) == (array_queue-\u003esize)) #endif #include #include #include #include\"./array_queue.h\" array_queue * array_queue_create(int size) { array_queue * queue = NULL; queue = (array_queue*)malloc(sizeof(array_queue)); if (queue == NULL) { return NULL; } queue-\u003earray = (int *)malloc(sizeof(int)*size); if (queue-\u003earray == NULL) { free(queue); return NULL; } queue-\u003esize = size; queue-\u003enum = 0; queue-\u003ehead = 0; queue-\u003etail = 0; return queue; } void array_queue_destory(array_queue *queue) { if (queue == NULL) { return; } if (queue-\u003earray != NULL) { free(queue-\u003earray); } free(queue); return; } /*入队列 */ int array_queue_enqueue(array_queue *queue,int data) { /*队列为空，或者队列满时，返回-1*/ if ((queue == NULL) || (array_queue_is_full(queue))) { return -1; } queue-\u003enum++; queue-\u003earray[queue-\u003etail] = data; queue-\u003etail = (queue-\u003etail + 1) % queue-\u003esize; return 0; } /*出队列*/ int array_queue_dequeue(array_queue * queue,int *data) { /*队列为空，数据存储为空，队列为空时返回-1*/ if ((queue == NULL) || (data == NULL) || (array_queue_is_empty(queue))) { return -1; } *data = queue-\u003earray[queue-\u003ehead]; queue-\u003enum--; queue-\u003ehead = (queue-\u003ehead + 1) % queue-\u003esize; return 0; } void array_queue_dump(array_queue *queue) { int i = 0; int pos = 0; if ((queue == NULL) || (array_queue_is_empty(queue))) { printf(\"\\r\\n queue is empty\"); return; } printf(\"\\r\\n size:%d,num:%d,head:%d,tali:%d\", queue-\u003esize,queue-\u003enum,queue-\u003ehead,queue-\u003etail); for (i = 0; i \u003c queue-\u003enum; i ++) { pos = (queue-\u003ehead + i) %queue-\u003esize; printf(\"\\r\\n array[%d] = %d\",pos,queue-\u003earray[pos]); } return; } int main() { int i = 0; int ret = 0; int data = 0; array_queue * queue = NULL; queue = array_queue_create(4); if (queue == NULL) { printf(\"\\r\\n queue is create failed.\"); return 0; } /*队列时空时，出队返回错误*/ ret = array_queue_dequeue(queue, \u0026data); if (ret != 0) { printf(\"\\r\\n queue %d dequeue failed.\",ret); } /*队列大小是4，入队5个，最后一个报错*/ for (i = 0; i \u003c 5; i++) { ret = array_queue_enqueue(queue,i); if (ret != 0) { printf(\"\\r\\n queue %d enqueue failed.\",i); } } array_queue_dump(queue); ret = array_queue_dequeue(queue, \u0026data); if (ret != 0) { printf(\"\\r\\n queue %d dequeue failed.\",i); } printf(\"\\r\\n queue %d dequue.\",data); array_queue_dump(queue); data = 5; printf(\"\\r\\n queue %d enqueue.\",data); ret = array_queue_enqueue(queue,data); if (ret != 0) { printf(\"\\r\\n queue %d enqueue failed.\",data); } array_queue_dump(queue); array_queue_destory(queue); return 0; } list_queue #ifndef LINK_LIST_QUEUE_H #define LINK_LIST_QUEUE_H typedef struct _list_queue_node { void *data; struct _list_queue_node *next; }queue_node; typedef struct _list_queue { int num; queue_node *head; queue_node *tail; }list_queue; #define list_queue_is_empty(queue) ((queue-\u003enum) == 0) list_queue *list_queue_create(); int list_queue_enqueue(list_queue *queue,void *data); int list_queue_dequeue(list_queue *queue,void **data); #endif // #include #include #include #include\"./list_queue.h\" /*创建队列头*/ list_queue *list_queue_create() { list_queue * queue = NULL; queue = (list_queue *)malloc(sizeof(list_queue)); if(queue == NULL) { return NULL; } queue-\u003enum = 0; queue-\u003ehead = NULL; queue-\u003etail = NULL; return queue; } /*入队*/ int list_queue_enqueue(list_queue *queue,void *data) { queue_node *ptmp = NULL; if(queue == NULL) { return -1; } ptmp = (queue_node *)malloc(sizeof(queue_node)); if (ptmp == NULL) { return -1; } ptmp-\u003edata = data; ptmp-\u003enext = NULL; if (queue-\u003ehead == NULL) { queue-\u003ehead = ptmp; } else { queue-\u003etail-\u003enext = ptmp; } queue-\u003etail = ptmp; queue-\u003enum++; return 0; } /*出队*/ int list_queue_dequeue(list_queue *queue,void **data) { queue_node * ptmp = NULL; if ((queue == NULL) || (data == NULL) || list_queue_is_empty(queue)) { return -1; } *data = queue-\u003ehead-\u003edata; ptmp = queue-\u003ehead; queue-\u003ehead = queue-\u003ehead-\u003enext; queue-\u003enum--; if (queue-\u003ehead == NULL) { queue-\u003etail = NULL; } free(ptmp); return 0; } ring_queue #include #include #include #include struct ring_queue { int cap; int head, tail; int *_q; }; int alloc_queue(struct ring_queue* queue, int cap) { if (!queue || cap \u003c 0) return -1; if (queue-\u003e_q) return -1; queue-\u003e_q = (int *)malloc(cap * sizeof(int)); if (!queue-\u003e_q) return -1; queue-\u003ehead = queue-\u003etail = 0; queue-\u003ecap = cap; return 0; } void free_queue(struct ring_queue *queue) { queue-\u003ecap = 0; queue-\u003ehead = queue-\u003etail = 0; free(queue-\u003e_q); } int _valid_index(int curr, int step, int cap) { return (curr + step) % cap; } int _next(int curr, int cap) { return _valid_index(curr, 1, cap); } bool is_empty(struct ring_queue *queue) { return (queue-\u003ehead == queue-\u003etail); } bool is_full(struct ring_queue *queue) { int next_tail = _next(queue-\u003etail, queue-\u003ecap); return (next_tail == queue-\u003ehead); } int enqueue(struct ring_queue* queue, int elem) { if (is_full(queue)) return -1; queue-\u003e_q[queue-\u003etail] = elem; queue-\u003etail = _next(queue-\u003etail, queue-\u003ecap); return 0; } int dequeue(struct ring_queue* queue, int *elem) { if (is_empty(queue)) return -1; if (elem) *elem = queue-\u003e_q[queue-\u003ehead]; queue-\u003ehead = _next(queue-\u003ehead, queue-\u003ecap); return 0; } int size(struct ring_queue* queue) { int size = queue-\u003etail - queue-\u003ehead; if (size \u003c 0) size += queue-\u003ecap; return size; } void dump(struct ring_queue* queue) { int i, idx; printf(\"Queue has %d elements with %d capacity\\n\", size(queue), queue-\u003ecap); for (i = 0; i \u003c size(queue); i++) { idx = _valid_index(queue-\u003ehead, i, queue-\u003ecap); printf(\"[%02d]: %08d\\n\", idx, queue-\u003e_q[idx]); } } int main() { struct ring_queue queue = {0, 0, 0, NULL}; int i; if (alloc_queue(\u0026queue, 8)) { printf(\"Failed to allocate a queue\\n\"); return -1; } printf(\"A new queue is %s\\n\", is_empty(\u0026queue)?\"empty\":\"not empty\"); enqueue(\u0026queue, 1); printf(\"After enqueue 1 element, queue is %s\\n\", is_empty(\u0026queue)?\"empty\":\"not empty\"); dequeue(\u0026queue, NULL); printf(\"After dequeue 1 element, queue is %s\\n\", is_empty(\u0026queue)?\"empty\":\"not empty\"); for (i = 0; i \u003c 7; i++) enqueue(\u0026queue, i); printf(\"After enqueue 7 element, queue is %s\\n\", is_full(\u0026queue)?\"full\":\"not full\"); for (i = 0; i \u003c 4; i++) { dequeue(\u0026queue, NULL); enqueue(\u0026queue, i); } printf(\"After enqueue/dequeue 4 element, queue is %s\\n\", is_full(\u0026queue)?\"full\":\"not full\"); printf(\"Head is %d, Tail is %d\\n\", queue.head, queue.tail); dump(\u0026queue); free_queue(\u0026queue); return 0; } 队列应用：进程通信 消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.\nlinux内核 头文件中定义了消息队列结构\nstruct msqid_ds { struct ipc_perm msg_perm; struct msg* msg_first; // 指向队列中第一个消息 struct msg* msg_last; // 队列中最后一个消息 ... } Linux消息队列函数接口\n// 创建和访问一个消息队列 int msgget(key_t key, int msgflg); // 把消息添加到消息队列中 int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); // 从一个消息对立获取消息 int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); // 控制消息队列 int msgctl(int msgid, int command, struct msgid_ds *buf); 2.1.7 leetcode题目 重复N次的元素\u003c数组\u003e\n两数相加\u003c链表\u003e\n基本计算器\u003c栈\u003e\n设计循环队列\u003c队列\u003e\n2.2 哈希表 哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。 每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.\n2.2.1 哈希函数设计 直接地址法 关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址. H(k) = aK*i + b\n数字分析法 取关键字数中分布均匀的若干作为哈希地址\n平方取中法 取关键字平方中间几位作为散列地址\n折叠法 把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址\n除留取余法 关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址. H(K) = K MOD P\nuthash用法 /************************************************************************* \u003e File Name: listhash.h \u003e Author: jinshaohui \u003e Mail: jinshaohui789@163.com \u003e Time: 18-11-06 \u003e Desc: 根据linux内核模块hashtab编写用户层hashtab接口 linux-4.19.1\\security\\selinux\\ss\\hashtab.c linux-4.19.1\\security\\selinux\\ss\\hashtab.h ************************************************************************/ #ifndef __HASHTAB_H__ #define __HASHTAB_H__ typedef struct _hashtab_node { void * key; void * data; struct _hashtab_node *next; }hashtab_node; typedef struct _hashtab { hashtab_node **htables; /*哈希桶*/ int size; /*哈希桶的最大数量*/ int nel; /*哈希桶中元素的个数*/ int (*hash_value)(struct _hashtab *h,const void *key); /*哈希函数*/ int (*keycmp)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/ void (*hash_node_free)(hashtab_node *node); }hashtab; #define HASHTAB_MAX_NODES (0xffffffff) typedef int (*hash_key_func)(struct _hashtab *h,const void *key); /*哈希函数*/ typedef int (*keycmp_func)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/ typedef void (*hash_node_free_func)(hashtab_node *node); /*根据当前结构体元素的地址，获取到结构体首地址*/ #define offsetof(TYPE,MEMBER) ((size_t) \u0026((TYPE *)0)-\u003eMEMBER) #define container(ptr,type,member) ({\\ const typeof( ((type *)0)-\u003emember) *__mptr = (ptr);\\ (type *) ( (char *)__mptr - offsetof(type,member));}) hashtab * hashtab_create(int size,hash_key_func hash_value, keycmp_func keycmp,hash_node_free_func hash_node_free); void hashtab_destory(hashtab *h); int hashtab_insert(hashtab * h,void *key,void *data); hashtab_node *hashtab_delete(hashtab *h, void *key); void *hashtab_search(hashtab*h,void *key); #endif #include #include #include #include #include\"listhash.h\" #ifdef MEMORY_TEST #include #endif hashtab * hashtab_create(int size,hash_key_func hash_value, keycmp_func keycmp,hash_node_free_func hash_node_free) { hashtab * h = NULL; int i = 0; if ((size \u003c 0) || (hash_value == NULL) || (keycmp == NULL)) { return NULL; } h = (hashtab *)malloc(sizeof(hashtab)); if (h == NULL) { return NULL; } h-\u003ehtables = (hashtab_node **)malloc(size * sizeof(hashtab_node*)); if (h-\u003ehtables == NULL) { return NULL; } h-\u003esize = size; h-\u003enel = 0; h-\u003ehash_value = hash_value; h-\u003ekeycmp = keycmp; h-\u003ehash_node_free = hash_node_free; for (i = 0; i \u003c size; i++) { h-\u003ehtables[i] = NULL; } return h; } void hashtab_destory(hashtab *h) { int i = 0; hashtab_node * cur = NULL; hashtab_node * tmp = NULL; if (h == NULL) { return; } for (i = 0; i \u003ch-\u003esize; i++) { cur = h-\u003ehtables[i]; while (cur != NULL) { tmp = cur; cur = cur-\u003enext; h-\u003ehash_node_free(tmp); } h-\u003ehtables[i] = NULL; } free(h-\u003ehtables); free(h); return; } int hashtab_insert(hashtab * h,void *key,void *data) { unsigned int hvalue = 0; int i = 0; hashtab_node *cur = NULL; hashtab_node *prev = NULL; hashtab_node *newnode = NULL; if ((h == NULL) || (key == NULL) || (data == NULL)) { return 1; } /*获取hash 数值*/ hvalue = h-\u003ehash_value(h,key); cur = h-\u003ehtables[hvalue]; /*hash桶中元素是从小到大排列的，找到要插入的位置*/ while((cur != NULL) \u0026\u0026 (h-\u003ekeycmp(h,key,cur-\u003ekey) \u003e 0)) { prev = cur; cur = cur-\u003enext; } /*如果key和当前key比对一致，直接返回，数据已经存在*/ if ((cur != NULL) \u0026\u0026 (h-\u003ekeycmp(h,key,cur-\u003ekey) == 0)) { return 2; } newnode = (hashtab_node *)malloc(sizeof(hashtab_node)); if (newnode == NULL) { return 3; } newnode-\u003ekey = key; newnode-\u003edata = data; if (prev == NULL) { newnode-\u003enext = h-\u003ehtables[hvalue]; h-\u003ehtables[hvalue] = newnode; } else { newnode-\u003enext = prev-\u003enext; prev-\u003enext = newnode; } h-\u003enel++; return 0; } hashtab_node *hashtab_delete(hashtab *h, void *key) { int hvalue = 0; int i = 0; hashtab_node *cur = NULL; hashtab_node *prev = NULL; if ((h == NULL) || (key == NULL)) { return NULL; } /*获取hash 数值*/ hvalue = h-\u003ehash_value(h,key); cur = h-\u003ehtables[hvalue]; /*hash桶中元素是从小到大排列的，找到要插入的位置*/ while((cur != NULL) \u0026\u0026 (h-\u003ekeycmp(h,key,cur-\u003ekey) \u003e= 0)) { if (h-\u003ekeycmp(h,key,cur-\u003ekey) == 0) { if (prev == NULL) { h-\u003ehtables[hvalue] = cur-\u003enext; } else { prev-\u003enext = cur-\u003enext; } return cur; } prev = cur; cur = cur-\u003enext; } return NULL; } void *hashtab_search(hashtab*h,void *key) { int hvalue = 0; int i = 0; hashtab_node *cur = NULL; if ((h == NULL) || (key == NULL)) { return NULL; } /*获取hash 数值*/ hvalue = h-\u003ehash_value(h,key); cur = h-\u003ehtables[hvalue]; /*hash桶中元素是从小到大排列的，找到要插入的位置*/ while((cur != NULL) \u0026\u0026 (h-\u003ekeycmp(h,key,cur-\u003ekey) \u003e= 0)) { if (h-\u003ekeycmp(h,key,cur-\u003ekey) == 0) { return cur-\u003edata; } cur = cur-\u003enext; } return NULL; } void hashtab_dump(hashtab *h) { int i = 0; hashtab_node * cur = NULL; if (h == NULL) { return ; } printf(\"\\r\\n----开始--size[%d],nel[%d]------------\",h-\u003esize,h-\u003enel); for( i = 0; i \u003c h-\u003esize; i ++) { printf(\"\\r\\n htables[%d]:\",i); cur = h-\u003ehtables[i]; while((cur != NULL)) { printf(\"key[%s],data[%s] \",cur-\u003ekey,cur-\u003edata); cur = cur-\u003enext; } } printf(\"\\r\\n----结束--size[%d],nel[%d]------------\",h-\u003esize,h-\u003enel); } struct test_node { char key[80]; char data[80]; }; unsigned int siample_hash(const char *str) { register unsigned int hash = 0; register unsigned int seed = 131; while(*str) { hash = hash*seed + *str++; } return hash \u0026 (0x7FFFFFFF); } int hashtab_hvalue(hashtab *h,const void *key) { return (siample_hash(key) % h-\u003esize); } int hashtab_keycmp(hashtab *h,const void *key1,const void *key2) { return strcmp(key1,key2); } void hashtab_node_free(hashtab_node*node) { struct test_node * ptmp = NULL; ptmp = container(node-\u003ekey,struct test_node,key); free(ptmp); free(node); } int main () { int i = 0; int res = 0; char *pres = NULL; hashtab_node * node = NULL; struct test_node *p = NULL; hashtab *h = NULL; #ifdef MEMORY_TEST setenv(\"MALLOC_TRACE\",\"1.txt\",1); mtrace(); #endif h = hashtab_create(5,hashtab_hvalue,hashtab_keycmp,hashtab_node_free); assert(h!= NULL); while(1) { p = (struct test_node*)malloc(sizeof(struct test_node)); assert(p != NULL); printf(\"\\r\\n 请输入key 和value，当可以等于\\\"quit\\\"时退出\"); scanf(\"%s\",p-\u003ekey); scanf(\"%s\",p-\u003edata); if(strcmp(p-\u003ekey,\"quit\") == 0) { free(p); break; } res = hashtab_insert(h,p-\u003ekey,p-\u003edata); if (res != 0) { free(p); printf(\"\\r\\n key[%s],data[%s] insert failed %d\",p-\u003ekey,p-\u003edata,res); } else { printf(\"\\r\\n key[%s],data[%s] insert success %d\",p-\u003ekey,p-\u003edata,res); } } hashtab_dump(h); while(1) { p = (struct test_node*)malloc(sizeof(struct test_node)); assert(p != NULL); printf(\"\\r\\n 请输入key 查询value的数值，当可以等于\\\"quit\\\"时退出\"); scanf(\"%s\",p-\u003ekey); if(strcmp(p-\u003ekey,\"quit\") == 0) { free(p); break; } pres = hashtab_search(h,p-\u003ekey); if (pres == NULL) { printf(\"\\r\\n key[%s] search data failed\",p-\u003ekey); } else { printf(\"\\r\\n key[%s],search data[%s] success\",p-\u003ekey,pres); } free(p); } hashtab_dump(h); while(1) { p = (struct test_node*)malloc(sizeof(struct test_node)); assert(p != NULL); printf(\"\\r\\n 请输入key 删除节点的数值，当可以等于\\\"quit\\\"时退出\"); scanf(\"%s\",p-\u003ekey); if(strcmp(p-\u003ekey,\"quit\") == 0) { free(p); break; } node = hashtab_delete(h,p-\u003ekey); if (node == NULL) { printf(\"\\r\\n key[%s] delete node failed \",p-\u003ekey); } else { printf(\"\\r\\n key[%s],delete data[%s] success\",node-\u003ekey,node-\u003edata); h-\u003ehash_node_free(node); } free(p); hashtab_dump(h); } hashtab_destory(h); #ifdef MEMORY_TEST muntrace(); #endif return 0; } hash_table #include #include #include #include #include /* One implementation of hash table with linear probing. */ #define HASH_SHIFT 4 #define HASH_SIZE (1 \u003c\u003c HASH_SHIFT) #define HASH_MASK (HASH_SIZE - 1) struct hash_table { unsigned int used; unsigned long entry[HASH_SIZE]; }; void hash_table_reset(struct hash_table *table) { int i; table-\u003eused = 0; for (i = 0; i \u003c HASH_SIZE; i++) table-\u003eentry[i] = ~0; } unsigned int hash_function(unsigned long value) { return value \u0026 HASH_MASK; } void dump_hash_table(struct hash_table *table) { int i; for (i = 0; i \u003c HASH_SIZE; i++) { if (table-\u003eentry[i] == ~0) printf(\"%2u: nil \\n\", i); else printf(\"%2u:%10lu -\u003e %2u\\n\", i, table-\u003eentry[i], hash_function(table-\u003eentry[i])); } } void hash_function_test() { int i; srandom(time(NULL)); for (i = 0; i \u003c 10; i++) { unsigned long val = random(); printf(\"%10lu -\u003e %2u\\n\", val, hash_function(val));; } } unsigned int next_probe(unsigned int prev_key) { return (prev_key + 1) \u0026 HASH_MASK; } void next_probe_test() { int i; unsigned int key1, key2; key1 = 0; for (i = 0; i \u003c HASH_SIZE; i++) { key2 = next_probe(key1); printf(\"%2u -\u003e %2u\\n\", key1, key2); key1 = key2; } } void hash_table_add(struct hash_table *table, unsigned long value) { unsigned int key = hash_function(value); if (table-\u003eused \u003e= HASH_SIZE) return; while (table-\u003eentry[key] != ~0) key = next_probe(key); table-\u003eentry[key] = value; table-\u003eused++; } unsigned int hash_table_slot(struct hash_table *table, unsigned long value) { int i; unsigned int key = hash_function(value); for (i = 0; i \u003c HASH_SIZE; i++) { if (table-\u003eentry[key] == value || table-\u003eentry[key] == ~0) break; key = next_probe(key); } return key; } bool hash_table_find(struct hash_table *table, unsigned long value) { return table-\u003eentry[hash_table_slot(table, value)] == value; } void hash_table_del(struct hash_table *table, unsigned long value) { unsigned int i, j, k; if (!hash_table_find(table, value)) return; i = j = hash_table_slot(table, value); while (true) { table-\u003eentry[i] = ~0; do { j = next_probe(j); if (table-\u003eentry[j] == ~0) return; k = hash_function(table-\u003eentry[j]); } while ((i \u003c= j) ? (i \u003c k \u0026\u0026 k \u003c= j) : (i \u003c k || k \u003c= j)); table-\u003eentry[i] = table-\u003eentry[j]; i = j; } table-\u003eused++; } void hash_table_add_test() { struct hash_table table; hash_table_reset(\u0026table); hash_table_add(\u0026table, 87645); printf(\"Table has%s 87645\\n\", hash_table_find(\u0026table, 87645) ? \"\":\"n't\"); printf(\"Table has%s 87647\\n\", hash_table_find(\u0026table, 87647) ? \"\":\"n't\"); } void hash_table_del_test1() { struct hash_table table; hash_table_reset(\u0026table); hash_table_add(\u0026table, 0x1ff0); hash_table_add(\u0026table, 0x2ff0); hash_table_add(\u0026table, 0x3ff0); dump_hash_table(\u0026table); printf(\"=== Remove 0x1ff0\\n\"); hash_table_del(\u0026table, 0x1ff0); dump_hash_table(\u0026table); } void hash_table_del_test2() { struct hash_table table; hash_table_reset(\u0026table); hash_table_add(\u0026table, 0x1ff0); hash_table_add(\u0026table, 0x1ff1); hash_table_add(\u0026table, 0x1ff2); hash_table_add(\u0026table, 0x2ff0); dump_hash_table(\u0026table); printf(\"=== Remove 0x1ff0\\n\"); hash_table_del(\u0026table, 0x1ff0); dump_hash_table(\u0026table); } int main() { //hash_function_test(); //next_probe_test(); //hash_table_add_test(); hash_table_del_test2(); return 0; } 2.2.2 哈希冲突 理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.\n解决哈希冲突常用方法:\n链地址法 将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中. 线性探测 二次探测 2.2.3 uthash uthash的插入、查找、删除的操作时间都是常量\n#include \"uthash.h\" struct my_struct { int id; /* we'll use this field as the key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; struct my_struct *users = NULL; void add_user(struct my_struct *s) { HASH_ADD_INT(users, id, s); } uthash用法 #include /* gets */ #include /* atoi, malloc */ #include /* strcpy */ #include \"uthash.h\" struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; struct my_struct *users = NULL; void add_user(int user_id, char *name) { struct my_struct *s; HASH_FIND_INT(users, \u0026user_id, s); /* id already in the hash? */ if (s==NULL) { s = (struct my_struct *)malloc(sizeof *s); s-\u003eid = user_id; HASH_ADD_INT( users, id, s ); /* id: name of key field */ } strcpy(s-\u003ename, name); } struct my_struct *find_user(int user_id) { struct my_struct *s; HASH_FIND_INT(users, \u0026user_id, s); /* s: output pointer */ return s; } void delete_user(struct my_struct *user) { HASH_DEL(users, user); /* user: pointer to deletee */ free(user); } void delete_all() { struct my_struct *current_user, *tmp; HASH_ITER(hh, users, current_user, tmp) { HASH_DEL(users, current_user); /* delete it (users advances to next) */ free(current_user); /* free it */ } } void print_users() { struct my_struct *s; for(s=users; s != NULL; s=(struct my_struct*)(s-\u003ehh.next)) { printf(\"user id %d: name %s\\n\", s-\u003eid, s-\u003ename); } } int name_sort(struct my_struct *a, struct my_struct *b) { return strcmp(a-\u003ename,b-\u003ename); } int id_sort(struct my_struct *a, struct my_struct *b) { return (a-\u003eid - b-\u003eid); } void sort_by_name() { HASH_SORT(users, name_sort); } void sort_by_id() { HASH_SORT(users, id_sort); } int main(int argc, char *argv[]) { char in[10]; int id=1, running=1; struct my_struct *s; unsigned num_users; while (running) { printf(\" 1. add user\\n\"); printf(\" 2. add/rename user by id\\n\"); printf(\" 3. find user\\n\"); printf(\" 4. delete user\\n\"); printf(\" 5. delete all users\\n\"); printf(\" 6. sort items by name\\n\"); printf(\" 7. sort items by id\\n\"); printf(\" 8. print users\\n\"); printf(\" 9. count users\\n\"); printf(\"10. quit\\n\"); gets(in); switch(atoi(in)) { case 1: printf(\"name?\\n\"); add_user(id++, gets(in)); break; case 2: printf(\"id?\\n\"); gets(in); id = atoi(in); printf(\"name?\\n\"); add_user(id, gets(in)); break; case 3: printf(\"id?\\n\"); s = find_user(atoi(gets(in))); printf(\"user: %s\\n\", s ? s-\u003ename : \"unknown\"); break; case 4: printf(\"id?\\n\"); s = find_user(atoi(gets(in))); if (s) delete_user(s); else printf(\"id unknown\\n\"); break; case 5: delete_all(); break; case 6: sort_by_name(); break; case 7: sort_by_id(); break; case 8: print_users(); break; case 9: num_users=HASH_COUNT(users); printf(\"there are %u users\\n\", num_users); break; case 10: running=0; break; } } delete_all(); /* free any structures */ return 0; } 参考链接 官网:https://troydhanson.github.io/uthash/ https://blog.csdn.net/fan_h_l/article/details/107241520 https://blog.csdn.net/whatday/article/details/95926766 https://www.cnblogs.com/pam-sh/p/12827658.html 2.2.4 leetcode题目 设计哈希集合\n设计哈希映射\n根据字符出现频率排序\n2.3 树与二叉树 树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);\n树的特点:\n没有父节点的节点称为根节点 每个非根节点有且只有一个父节点 除了根结点外,每个子节点可分为多个不相交的子树 树中没有环路 2.3.1 概述 节点的度: 一个节点含有子树的个数 树的度: 树中最大的节点度 叶节点: 度为零的节点 父节点 子节点 兄弟节点 节点的层次 深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0 高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0. 森林 树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。\n2.3.2 树的种类 无序树 有序树 二叉树: 每个节点最多含有两个子树的树.\n完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列. 满二叉树:所有叶节点都最底层的完全二叉树. 平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树. 排序二叉树:二叉查找树 霍夫曼树:带权路径最短的二叉树(又称最优二叉树).\nB树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.\n二叉树 二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树 自平衡二叉查找树 AVL树 红黑树 加权平衡树 AA树 B树 B树 B+树 堆 二项堆 斐波那契堆 Trie 后缀树 基数树 三叉查找树 树有多种结构形式，包括二叉树、。\n2.3.3 二叉树 二叉树两个条件:\n本身是有序树 树中包含的各个节点的度不能超过2,即只能是0,1或者2 二叉树中结点包含三部分：一个数据成员两个左右指针。\ntypedef struct BiTreeNode_ { void *data; struct BiTreeNode_ *left; struct BiTreeNode_ *right; }BiTreeNode; typedef struct BiTree_ { int size; int (*compare)(const void *key1, const void *key2); void (*destroy)(void *data); BiTreeNode *root; }BiTree; /*树根*/ typedef struct tree{ Node * root; }Tree; 二叉树 #include #include #include #include #include\"list_queue.h\" typedef struct _treenode { int data; struct _treenode *lchild; struct _treenode *rchild; }Tnode,Tree; void binarytree_create(Tree **Root) { int a = 0; printf(\"\\r\\n输入节点数值((当输入为100时，当前节点创建完成))):\"); scanf(\"%d\",\u0026a); if (a == 100) { *Root = NULL; } else { *Root = (Tnode *)malloc(sizeof(Tnode)); if (*Root == NULL) { return; } (*Root)-\u003edata = a; printf(\"\\r\\n create %d 的左孩子:\",a); binarytree_create(\u0026((*Root)-\u003elchild)); printf(\"\\r\\n create %d 的右孩子:\",a); binarytree_create(\u0026((*Root)-\u003erchild)); } return ; } void binarytree_destory(Tree *root) { if (root == NULL) { return; } binarytree_destory(root-\u003elchild); binarytree_destory(root-\u003erchild); free(root); } /*先序遍历:根结点--》左子树---》右子树*/ void binarytree_preorder(Tree *root) { if (root == NULL) { return; } printf(\" %d \",root-\u003edata); binarytree_preorder(root-\u003elchild); binarytree_preorder(root-\u003erchild); return; } /*中序遍历:左子树--》跟节点---》右子树*/ void binarytree_inorder(Tree *root) { if (root == NULL) { return; } binarytree_inorder(root-\u003elchild); printf(\" %d \",root-\u003edata); binarytree_inorder(root-\u003erchild); return; } /*后序遍历:左子树---》右子树-》根节点*/ void binarytree_postorder(Tree *root) { if (root == NULL) { return; } binarytree_postorder(root-\u003elchild); binarytree_postorder(root-\u003erchild); printf(\" %d \",root-\u003edata); return; } void binarytree_levelorder(Tree * root) { list_queue *queue = NULL; Tnode * node = NULL; if(root == NULL) { return; } queue = list_queue_create(); /*根节点先入队*/ list_queue_enqueue(queue,(void *)root); while(!list_queue_is_empty(queue)) { list_queue_dequeue(queue,(void *)\u0026node); printf(\" %d \",node-\u003edata); if(node-\u003elchild != NULL) { list_queue_enqueue(queue,(void *)node-\u003elchild); } if(node-\u003erchild != NULL) { list_queue_enqueue(queue,(void *)node-\u003erchild); } } free(queue); } /*打印叶子节点*/ void binarytree_printfleaf(Tree *root) { if (root == NULL) { return; } if ((root-\u003elchild == NULL) \u0026\u0026 (root-\u003erchild == NULL)) { printf(\" %d \",root-\u003edata); } else { binarytree_printfleaf(root-\u003elchild); binarytree_printfleaf(root-\u003erchild); } } /*打印叶子的个数*/ int binarytree_getleafnum(Tree*root) { if (root == NULL) { return 0; } if ((root-\u003elchild == NULL) \u0026\u0026 (root-\u003erchild == NULL)) { return 1; } return binarytree_getleafnum(root-\u003elchild) + binarytree_getleafnum(root-\u003erchild); } /*打印数的高度*/ int binarytree_gethigh(Tree *root) { int lhigh = 0; int rhigh = 0; if (root == NULL) { return 0; } lhigh = binarytree_gethigh(root-\u003elchild); rhigh = binarytree_gethigh(root-\u003erchild); return ((lhigh \u003e rhigh)?(lhigh + 1):(rhigh + 1)); } int main() { Tree *root = NULL; setenv(\"MALLOC_TRACE\",\"1.txt\",1); mtrace(); printf(\"\\r\\n创建二叉树:\"); binarytree_create(\u0026root); printf(\"\\r\\n先序遍历二叉树:\"); binarytree_preorder(root); printf(\"\\r\\n中序遍历二叉树:\"); binarytree_inorder(root); printf(\"\\r\\n后序遍历二叉树:\"); binarytree_postorder(root); printf(\"\\r\\n层次遍历二叉树:\"); binarytree_levelorder(root); printf(\"\\r\\n打印二叉树叶子节点:\"); binarytree_printfleaf(root); printf(\"\\r\\n打印二叉树叶子节点个数:%d\",binarytree_getleafnum(root)); printf(\"\\r\\n打印二叉树高度:%d\",binarytree_gethigh(root)); binarytree_destory(root); muntrace(); return 0; } binarytree #include #include #include #include #include /* Implement binary tree in array */ #define MAX_TREE_NODES (1 \u003c\u003c 8) struct node { int data; }; struct binary_tree { union { unsigned long nodes; struct node *n[MAX_TREE_NODES]; }; }; void init_binary_tree(struct binary_tree *tree) { int i; for(i = 0; i \u003c MAX_TREE_NODES; i++) { tree-\u003en[i] = NULL; } } struct node* create_node(int data) { struct node* n; n = malloc(sizeof(struct node)); if (n) n-\u003edata = data; return n; } void fake_a_tree(struct binary_tree* tree) { /* data is in ordered */ int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5}; init_binary_tree(tree); /* root start at 1 */ for (i = 0; i \u003c 10; i++) tree-\u003en[i+1] = create_node(data[i]); tree-\u003enodes = 10; } void _in_order(struct binary_tree* tree, int index) { if (!tree-\u003en[index]) return; /* left child at (index \u003c\u003c 1) */ _in_order(tree, index \u003c\u003c 1); printf(\"[%2d]: %4d\\n\", index, tree-\u003en[index]-\u003edata); /* right child at (index \u003c\u003c 1) + 1 */ _in_order(tree, (index \u003c\u003c 1) + 1); } void in_order(struct binary_tree* tree) { _in_order(tree, 1); } int main() { struct binary_tree tree; fake_a_tree(\u0026tree); in_order(\u0026tree); return 0; } 二叉树性质:\n二叉树中,第i层最多有 2^(i-1)个节点 如果二叉树的深度为K,则二叉树最多有2^K - 1个节点 二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1 满二叉树 如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。\n完全二叉树 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。\n先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。 // 递归 void traversal(TreeNode* cur) { if (cur == NULL) return; printf(\"cur-\u003eval = %d\\n\", cur-\u003eval); // 中 traversal(cur-\u003eleft, vec); // 左 traversal(cur-\u003eright, vec); // 右 } void preorderTraversal(TreeNode* root) { traversal(root); } // 迭戈 #define MAXSIZE 10000 int* preorderTraversal(TreeNode* root) { struct TreeNode st[MAXSIZE]; int top = 0; int result[MAXSIZE]; if (root == NULL) return result; st[top] = root; int i = 0; while (top \u003e= 0) { TreeNode* node = st[top]; // 中 top--; result[i++] = node-\u003eval; if (node-\u003eright) { // 右（空节点不入栈） st[++top] = node-\u003eright } if (node-\u003eleft) { // 左（空节点不入栈） st[++top] = node-\u003eleft; } } return result; } 中序遍历：先访问左子结点，然后根结点，最后右子结点。 后序遍历：先访问左子结点，然后右子结点，最后根结点。 层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。 void traversal(TreeNode* cur) { if (cur == NULL) return; printf(\"cur-\u003eval = %d\\n\", cur-\u003eval); // 中 traversal(cur-\u003eleft, vec); // 左 traversal(cur-\u003eright, vec); // 右 } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e result; traversal(root, result); return result; } 2.3.4 二叉查找树(BST) 二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:\n若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值 若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值 任意节点的左,右子树也分别为二叉查找树 没有键值相等的节点 一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。 二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。查找,插入操作的复杂度是 O(logn)，搜索,插入,删除复杂度等于树高,期望O(logn),最坏为O(n),(树退化为线性表)n为树中结点数。 保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。\n二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。\n查找算法 1.若b是空树,则搜索失败,否则; 2.若x等于b的根节点的数据域之值,则查找成功; 3.若x小于b的根节点的数据域之值,则搜索左子树 4.查找右子树\n插入算法 1.若b是空树,则将s所指节点作为根节点插入;否则 2.若s-\u003edata等于b的根节点的数据域值,则返回,否则; 3.若s-\u003edata小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则 4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)\n删除算法 1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.\nbinarysearch #include #include #include #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status; typedef char ElemType; typedef struct node { ElemType data; struct node *lchild, *rchild; } BTree, *BTreePtr; /**************** 插入 **********************/ Status Insert(BTreePtr *T, ElemType e) { BTreePtr p; if (*T == NULL) { *T = (BTreePtr)malloc(sizeof(BTree)); (*T)-\u003edata = e; return TRUE; } else { p = *T; while ( p != NULL) { if (e \u003e p-\u003edata) { if (p-\u003erchild == NULL) { p-\u003erchild = (BTreePtr) malloc (sizeof(BTree)); p-\u003erchild-\u003edata = e; return TRUE; } p = p-\u003erchild; } else { if (p-\u003elchild == NULL) { p-\u003elchild = (BTreePtr) malloc (sizeof(BTree)); p-\u003elchild-\u003edata = e; return TRUE; } p = p-\u003elchild; } } } return FALSE; } /**************** 删除 **********************/ Status Delete(BTreePtr T, ElemType e) { BTreePtr p, pp, minP, minPP, child; child = NULL; p = T; pp = NULL; while ( (p != NULL) \u0026\u0026 (p-\u003edata != e) ) { pp = p; if (e \u003e p-\u003edata) { p = p-\u003erchild; } else { p = p-\u003elchild; } } if (p == NULL) return FALSE; //双节点 if ((p-\u003elchild != NULL) \u0026\u0026 (p-\u003erchild != NULL) { minPP = p; minP = p-\u003erchild; while (minP-\u003elchild != NULL) { minPP = minP; minP = minP-\u003elchild; } p-\u003edata = minP-\u003edata; minPP-\u003elchild = minP-\u003erchild; free(minP); return TRUE; } //有一个节点 if ((p-\u003elchild != NULL) || (p-\u003erchild != NULL)) { //应该将原有的pp同child连接在一起 if (p-\u003elchild) { child = p-\u003elchild; } else { child = p-\u003erchild; } if(pp-\u003edata\u003ep-\u003edata) { pp-\u003elchild=child; } else { pp-\u003erchild=child; } free(p); return TRUE; } //没有节点 if (pp-\u003elchild == p) {//这里面临pp除p以外的节点为null的情况 pp-\u003elchild = child; } else { pp-\u003erchild = child; } return TRUE; } /**************** 查找 **********************/ Status Find(BTreePtr T, ElemType e) { if (T == NULL) return FALSE; while ((T != NULL) \u0026\u0026 (T-\u003edata != e)) { if (e \u003e T-\u003edata) { T = T-\u003erchild; } else { T = T-\u003elchild; } } if (T) { return TRUE; } else { return FALSE; } } /**************** 最大值 **********************/ ElemType FindMax(BTreePtr T) { ElemType max; while(T != NULL) { max = T-\u003edata; T = T-\u003erchild; } return max; } /**************** 最小值 **********************/ ElemType FindMin(BTreePtr T) { ElemType min; while(T != NULL) { min = T-\u003edata; T = T-\u003elchild; } return min; } void PreOrderTraverse(BTreePtr T)//前序遍历二叉树 { if (T == NULL) return; if(T) { printf(\"%d \",T-\u003edata); PreOrderTraverse(T-\u003elchild); PreOrderTraverse(T-\u003erchild); } } void DestroyTree(BTreePtr T) { if (T) { if (T-\u003elchild) { DestroyTree(T-\u003elchild); } if(T-\u003erchild) { DestroyTree(T-\u003erchild); } free(T); T = NULL; } } /***************** 执行测试 *************************/ int main(int argc, char const *argv[]) { BTreePtr T; T = NULL; int a[] = {33, 16, 50, 13, 18, 34, 58, 15, 17, 25, 51, 66, 19, 27, 55}; int i; for (i = 0; i \u003c 15; i++) { Insert(\u0026T, a[i]); } printf(\"Max is %d\\n\", FindMax(T)); printf(\"Min is %d\\n\", FindMin(T)); Delete(T, 18); Delete(T, 13); PreOrderTraverse(T); DestroyTree(T); return 0; } bst #include #include #include #include #include enum child_dir { left_child, right_child, root, }; struct node { unsigned long data; struct node *left; struct node *right; }; struct root { struct node *r; }; void dump(struct node *node, int level, enum child_dir dir) { if (!node) return; dump(node-\u003eright, level + 1, right_child); if (dir == left_child) printf(\"%*s\\n\", level*3, \"|\"); printf(\"%*s - %05lu\\n\", level*3, \" \", node-\u003edata); if (dir == right_child) printf(\"%*s\\n\", level*3, \"|\"); dump(node-\u003eleft, level + 1, left_child); } struct node* find(struct root *root, unsigned long data) { struct node* n = root-\u003er; while (n) { if (n-\u003edata == data) return n; if (data \u003c n-\u003edata) n = n-\u003eleft; else n = n-\u003eright; } return NULL; } struct node* new_node(unsigned long data) { struct node *n; n = malloc(sizeof(struct node)); n-\u003edata = data; n-\u003eleft = n-\u003eright = NULL; return n; } void insert(struct root *root, struct node *new) { struct node *parent; if (!root-\u003er) { root-\u003er = new; return; } parent = root-\u003er; while (true) { /* Don't support duplicate data */ if (new-\u003edata == parent-\u003edata) break; if (new-\u003edata \u003c parent-\u003edata) { if (!parent-\u003eleft) { parent-\u003eleft = new; break; } parent = parent-\u003eleft; } else { if (!parent-\u003eright) { parent-\u003eright = new; break; } parent = parent-\u003eright; } } } struct node* delete(struct root *root, unsigned long data) { struct node *n = root-\u003er, **p = \u0026root-\u003er; struct node *child; while (n \u0026\u0026 n-\u003edata != data) { if (data \u003c n-\u003edata) { p = \u0026n-\u003eleft; n = n-\u003eleft; } else { p = \u0026n-\u003eright; n = n-\u003eright; } } if (!n) return NULL; if (n-\u003eleft \u0026\u0026 n-\u003eright) { struct node *rn = n-\u003eright, **rp = \u0026n-\u003eright; while (rn-\u003eleft) { rp = \u0026rn-\u003eleft; rn = rn-\u003eleft; } n-\u003edata = rn-\u003edata; n = rn; p = rp; } child = n-\u003eleft ? n-\u003eleft : n-\u003eright; *p = child; return NULL; } void insert_test() { struct root tree; struct node* n; tree.r = NULL; insert(\u0026tree, new_node(9)); insert(\u0026tree, new_node(5)); insert(\u0026tree, new_node(2)); insert(\u0026tree, new_node(8)); insert(\u0026tree, new_node(18)); insert(\u0026tree, new_node(13)); insert(\u0026tree, new_node(21)); insert(\u0026tree, new_node(20)); dump(tree.r, 0, root); n = find(\u0026tree, 18); if (n \u0026\u0026 n-\u003edata == 18) printf(\"Get 18\\n\"); } void delete_test() { struct root tree; struct node* n; tree.r = NULL; insert(\u0026tree, new_node(9)); insert(\u0026tree, new_node(5)); insert(\u0026tree, new_node(2)); insert(\u0026tree, new_node(8)); insert(\u0026tree, new_node(18)); insert(\u0026tree, new_node(13)); insert(\u0026tree, new_node(21)); insert(\u0026tree, new_node(20)); dump(tree.r, 0, root); delete(\u0026tree, 20); printf(\"Delete 20\\n\"); dump(tree.r, 0, root); delete(\u0026tree, 9); printf(\"Delete 9\\n\"); dump(tree.r, 0, root); } int main() { //insert_test(); delete_test(); return 0; } 2.3.5 平衡树 平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升. 平衡指所有叶子的深度趋于平衡,更广义指树上所有可能查找的均摊复杂度偏低.平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡. 对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.\nAVL树 在AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡. 高度为h的AVL树,总节点数最多为2^h-1; 当前节点数为N时,高度h最多为:\nlog(5*0.5 * (N + 1)) - 2\n红黑树 红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn) 红黑树相对于AVL树,牺牲了部分平衡性以换取插入\\删除操作时少量的旋转操作,整体性能优于AVL树.\n红黑树与AVL树的相比: AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好. AVL的查找性能通常比红黑树好 如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.\n红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求: 1.节点是红或黑色 2.根是黑色 3.所有叶子都是黑色(叶子是NIL节点) 4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.) 5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点. 红黑树关键特性:从根到叶子的最长的可能路径不多于最短的可能路径的两倍长.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.\nB+树 B+树通常用于数据库和操作系统的文件系统中.B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度.B+树元素自底向上插入,与二叉树相反. B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.\n字典树 Trie #include #include #include #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status; typedef struct Node { char data; struct Node *children[26]; Status end; } Trie, *TriePtr; void Init(TriePtr *T) { (*T) = (TriePtr)malloc(sizeof(Trie)); (*T)-\u003edata = '/'; (*T)-\u003eend = FALSE; } void Insert(TriePtr T, char *str) { int index; char c; while(c = *str++) { index = c - 'a'; if (T-\u003echildren[index] == NULL) { TriePtr Node; Node = (TriePtr)malloc(sizeof(Trie)); Node-\u003edata = c; Node-\u003eend = FALSE; T-\u003echildren[index] = Node; } T = T-\u003echildren[index]; } T-\u003eend = TRUE; } Status Search(TriePtr T, char *str) { int index; char c; while(c = *str++) { index = c - 'a'; if (T-\u003echildren[index] == NULL) { return FALSE; } T = T-\u003echildren[index]; } if (T-\u003eend) { return TRUE; } else { return FALSE; } } int main(int argc, char const *argv[]) { TriePtr T; Init(\u0026T); char *str = \"hello\"; char *str2 = \"hi\"; Insert(T, str); printf(\"str is search %d\\n\", Search(T, str)); printf(\"str2 is search %d\\n\", Search(T, str2)); return 0; } 2.3.6 堆树和优先队列 堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的. 堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示. 堆的特性: 必须是完全二叉树 用数组实现 任一节点的值是其子树所有节点的最大值或最小值 最大值时,称为最大堆,也称大顶堆 最小时,称为最小堆,也称小顶堆. 堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)\n堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。 堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。\ntypedef struct Heap_ { int size; int (*compare)(const void *key1, const void *key2); void (*destroy)(void *data); void **tree; } heap #include #include #include #include #include /* Implement heap */ #define MAX_HEAP_SIZE (1 \u003c\u003c 8) struct element { int data; }; struct heap { union { unsigned long elements; struct element *elem[MAX_HEAP_SIZE]; }; }; void init_heap(struct heap *heap) { int i; for(i = 0; i \u003c MAX_HEAP_SIZE; i++) { heap-\u003eelem[i] = NULL; } } void dump_heap(struct heap *heap, int index) { struct element *elem; int level; if (index \u003e heap-\u003eelements) return; elem = heap-\u003eelem[index]; level = fls(index); dump_heap(heap, index * 2 + 1); if (!(index % 2) \u0026\u0026 index != 1) printf(\"%*s\\n\", level*3, \"|\"); printf(\"%*s - %05d\\n\", level*3, \" \", elem-\u003edata); if (index % 2 \u0026\u0026 index != 1) printf(\"%*s\\n\", level*3, \"|\"); dump_heap(heap, index * 2); } void dump(struct heap *heap, int elements) { int i; for (i = 1; i \u003c= elements; i++) printf(\"[%02d]: %4d\\n\", i, heap-\u003eelem[i]-\u003edata); } struct element* create_element(int data) { struct element *elem; elem = malloc(sizeof(struct element)); if (elem) elem-\u003edata = data; return elem; } void fake_a_heap(struct heap *heap) { /* data is in ordered */ int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5}; init_heap(heap); /* root start at 1 */ for (i = 0; i \u003c 10; i++) heap-\u003eelem[i+1] = create_element(data[i]); heap-\u003eelements = 10; } void swap(struct heap *heap, int i, int j) { struct element *tmp; tmp = heap-\u003eelem[j]; heap-\u003eelem[j] = heap-\u003eelem[i]; heap-\u003eelem[i] = tmp; } void heapify(struct heap *heap, int parent) { struct element **elem = heap-\u003eelem; int elements = heap-\u003eelements; int left, right, max; while (true) { left = parent * 2; right = left + 1; max = parent; if (left \u003c= elements \u0026\u0026 elem[max]-\u003edata \u003c elem[left]-\u003edata) max = left; if (right \u003c= elements \u0026\u0026 elem[max]-\u003edata \u003c elem[right]-\u003edata) max = right; if (max == parent) break; swap(heap, max, parent); parent = max; } } void build_heap(struct heap *heap) { int i; for (i = heap-\u003eelements / 2; i \u003e= 1; i--) heapify(heap, i); } int heap_sort(struct heap *heap) { int elements = heap-\u003eelements; while (heap-\u003eelements) { swap(heap, 1, heap-\u003eelements); heap-\u003eelements--; heapify(heap, 1); } return elements; } int main() { struct heap heap; int elements; fake_a_heap(\u0026heap); dump_heap(\u0026heap, 1); printf(\"After Heapify:\\n\"); build_heap(\u0026heap); dump_heap(\u0026heap, 1); printf(\"After Heap sort:\\n\"); elements = heap_sort(\u0026heap); dump(\u0026heap, elements); return 0; } 堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。\n优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。\n优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。\ntypedef Heap PQueue; 2.3.7 leetcode题目 先序遍历构造二叉树 从中序与后序遍历构造二叉树 二叉树的层次遍历 从二叉搜索树到更大和树 二叉搜索树的最近公共祖先 前K个高频单词\u003c堆\u003e 2.4 图 图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:G(V,E).其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.\n图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。 图的访问方式：广度优先和深度优先。\n2.4.1 基础知识 图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。\n一组顶点：用V(vertex)表示顶点集合 一组边：用E(edge)表示边的集合 图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。 (v, w)表示无向边，即v和w是互通的 \u003c v, w \u003e表示有向边，该边始于v，终于w 图可分为连通图和非连通图 连通图：所有的点都右路径相连 非连通图：存在某两个点没有路径相连 强连通图： 图中的顶点度\n度 入度 出度 2.4.2 图表示 图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。 图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。 邻接矩阵表示\n邻接链表表示\ntypedef struct AdjList_ { void *vertex; Set adjacent; }AdjList; typedef struct Graph_ { int vcount; int ecount; int (*match)(const void *key1, const void *key2); List adjlists; } graph #include #include #include #include #include struct vertex; struct vertex_adjs { struct vertex *v; struct vertex_adjs *next; }; struct vertex { int data; struct vertex_adjs *adj; }; #define MAX_GRAPH_VERTEX (1 \u003c\u003c 8) struct graph { struct vertex *vxs[MAX_GRAPH_VERTEX]; }; void init_graph(struct graph *graph) { int i; for (i = 0; i \u003c MAX_GRAPH_VERTEX; i++) graph-\u003evxs[i] = NULL; } struct vertex *create_vertex(int data) { struct vertex *v; v = malloc(sizeof(struct vertex)); if (v) { v-\u003edata = data; v-\u003eadj = NULL; } return v; } struct vertex_adjs *create_vertex_adj(struct vertex *v) { struct vertex_adjs *v_adj; v_adj = malloc(sizeof(struct vertex_adjs)); if (!v_adj) return NULL; v_adj-\u003ev = v; v_adj-\u003enext = NULL; return v_adj; } void insert_adj(struct vertex *v, struct vertex *adj) { struct vertex_adjs **v_adj; v_adj = \u0026v-\u003eadj; while (*v_adj) v_adj = \u0026(*v_adj)-\u003enext; *v_adj = create_vertex_adj(adj); } void dump_raw(struct graph *graph) { int i; for (i = 0; i \u003c MAX_GRAPH_VERTEX; i++) { struct vertex *v = graph-\u003evxs[i]; struct vertex_adjs *adj; if (v == NULL) continue; printf(\"Vertex[%02d]: %8d -\u003e\", i, v-\u003edata); adj = v-\u003eadj; while (adj) { printf(\" %8d,\", adj-\u003ev-\u003edata); adj = adj-\u003enext; } printf(\"\\n\"); } } /* 1 ----- 2 ----- 3 | / | / | / | / | / | / | / | / | / | / 4 ----- 5 */ void fake_a_graph(struct graph *graph) { int i; init_graph(graph); for (i = 0; i \u003c 5; i++) graph-\u003evxs[i] = create_vertex(i+1); /* connect 1 -\u003e 2, 1 -\u003e 4 */ insert_adj(graph-\u003evxs[0], graph-\u003evxs[1]); insert_adj(graph-\u003evxs[0], graph-\u003evxs[3]); /* connect 2 -\u003e 1, 2 -\u003e 3, 2 -\u003e 5, 2 -\u003e 4 */ insert_adj(graph-\u003evxs[1], graph-\u003evxs[0]); insert_adj(graph-\u003evxs[1], graph-\u003evxs[2]); insert_adj(graph-\u003evxs[1], graph-\u003evxs[4]); insert_adj(graph-\u003evxs[1], graph-\u003evxs[3]); /* connect 3 -\u003e 2, 3 -\u003e 5 */ insert_adj(graph-\u003evxs[2], graph-\u003evxs[1]); insert_adj(graph-\u003evxs[2], graph-\u003evxs[4]); /* connect 4 -\u003e 1, 4 -\u003e 2, 4 -\u003e 5 */ insert_adj(graph-\u003evxs[3], graph-\u003evxs[0]); insert_adj(graph-\u003evxs[3], graph-\u003evxs[1]); insert_adj(graph-\u003evxs[3], graph-\u003evxs[4]); /* connect 5 -\u003e 4, 5 -\u003e 2, 5 -\u003e 3 */ insert_adj(graph-\u003evxs[4], graph-\u003evxs[3]); insert_adj(graph-\u003evxs[4], graph-\u003evxs[1]); insert_adj(graph-\u003evxs[4], graph-\u003evxs[3]); } int main() { struct graph g; fake_a_graph(\u0026g); dump_raw(\u0026g); return 0; } 2.4.3 图遍历 图的搜索方法：深度优先搜索和广度优先搜索。 深度优先遍历(DFS) 思路: 从图中某点v出发: 1.访问顶点v 2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历. 3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问. 伪代码:\n// void DFS(Vertex v) { vistied[v] = true; for (v 的每个邻接点 w) { if (!visited[w]) { DFS(w); } } } dfs #include #include #include \"Graph.h\" #define MAX_NODES 1000 int visited[MAX_NODES]; // array to store visiting order // indexed by vertex 0..nV-1 bool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest) { Vertex w; for (w = 0; w \u003c nV; w++) if (adjacent(g, v, w) \u0026\u0026 visited[w] == -1) { visited[w] = v; if (w == dest) return true; else if (dfsPathCheck(g, nV, w, dest)) return true; } return false; } bool findPathDFS(Graph g, int nV, Vertex src, Vertex dest) { Vertex v; for (v = 0; v \u003c nV; v++) visited[v] = -1; visited[src] = src; return dfsPathCheck(g, nV, src, dest); } int main(void) { int V = 6; Graph g = newGraph(V); Edge e; e.v = 0; e.w = 1; insertEdge(g, e); e.v = 0; e.w = 4; insertEdge(g, e); e.v = 0; e.w = 5; insertEdge(g, e); e.v = 5; e.w = 4; insertEdge(g, e); e.v = 4; e.w = 2; insertEdge(g, e); e.v = 4; e.w = 3; insertEdge(g, e); e.v = 5; e.w = 3; insertEdge(g, e); e.v = 1; e.w = 2; insertEdge(g, e); e.v = 3; e.w = 2; insertEdge(g, e); int src = 0, dest = 5; if (findPathDFS(g, V, src, dest)) { Vertex v = dest; while (v != src) { printf(\"%d - \", v); v = visited[v]; } printf(\"%d\\n\", src); } return 0; } 广度优先遍历(BFS) 思路: 1.顶点v入队列 2.当队列非空时则继续执行,否则算法结束. 3.出队列取得队头顶点v’,访问顶点v 并标记顶点v已被访问. 4.查找顶点v的第一个邻接顶点col 5.若v的邻接顶点col未被访问过的,则col继续. 6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.\nbfs_queue #include #include #include \"Graph.h\" #include \"queue.h\" #define MAX_NODES 1000 int visited[MAX_NODES]; // array to store visiting order // indexed by vertex 0..nV-1 bool findPathBFS(Graph g, int nV, Vertex src, Vertex dest) { Vertex v; for (v = 0; v \u003c nV; v++) visited[v] = -1; visited[src] = src; queue Q = newQueue(); QueueEnqueue(Q, src); while (!QueueIsEmpty(Q)) { v = QueueDequeue(Q); Vertex w; for (w = 0; w \u003c nV; w++) ( if (adjacent(g, v, w) \u0026\u0026 visited[w] == -1) { visited[w] = v; if (w == dest) return true; else QueueEnqueue(Q, w); } ) } return false; } int main(void) { int V = 10; Graph g = newGraph(V); Edge e; e.v = 0; e.w = 1; insertEdge(g, e); e.v = 0; e.w = 2; insertEdge(g, e); e.v = 0; e.w = 5; insertEdge(g, e); e.v = 1; e.w = 5; insertEdge(g, e); e.v = 2; e.w = 3; insertEdge(g, e); e.v = 3; e.w = 4; insertEdge(g, e); e.v = 3; e.w = 5; insertEdge(g, e); e.v = 3; e.w = 8; insertEdge(g, e); e.v = 4; e.w = 5; insertEdge(g, e); e.v = 4; e.w = 7; insertEdge(g, e); e.v = 4; e.w = 8; insertEdge(g, e); e.v = 5; e.w = 6; insertEdge(g, e); e.v = 7; e.w = 8; insertEdge(g, e); e.v = 7; e.w = 9; insertEdge(g, e); e.v = 8; e.w = 9; insertEdge(g, e); int src = 0, dest = 6; if (findPathBFS(g, V, src, dest)) { Vertex v = dest; while (v != src) { printf(\"%d - \", v); v = visited[v]; } printf(\"%d\\n\", src); } return 0; } 深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)\n深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置. 广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.\n2.4.4 最短路径 迪杰斯特拉Dijkstra算法 Dijkstra算法适用于权值为正的图. Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离. 在源点可达的情况下,Dijkstra算法的时间复杂度时 O(ElogV) 算法步骤: 1.将所有边初始化为无穷大 2.旋转一个开始的顶点,添加到优先队列中. 3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新. 4.将该点所有邻接顶点添加到优先队列中. 5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5 6.直到所有点都被处理过一次.\n迪杰斯特拉 #include #include #define MAX 20 #define INF 999 int mat[MAX][MAX]; int V; int dist[MAX]; int q[MAX]; int qp = 0; void enqueue(int v) { q[qp++] = v; } int cf(void *a, void *b) { int *x = (int *)a; int *y = (int *)b; return *y - *x; } int dequeue() { qsort(q, qp, sizeof(int), cf); return q[--qp]; } int queue_has_something() { return (qp \u003e 0); } int visited[MAX]; int vp = 0; void dijkstra(int s) { dist[s] = 0; int i; for (i = 0; i \u003c V; ++i) { if (i != s) { dist[i] = INF; } enqueue(i); } while (queue_has_something()) { int u = dequeue(); visited[vp++] = u; for (i = 0; i \u003c V; ++i) { if (mat[u][i]) { if (dist[i] \u003e dist[u] + mat[u][i]) { dist[i] = dist[u] + mat[u][i]; } } } } } int main(int argc, char const *argv[]) { printf(\"Enter the number of vertices: \"); scanf(\" %d\", \u0026V); printf(\"Enter the adj matrix: \"); int i, j; for (i = 0; i \u003c V; ++i) { for (j = 0; j \u003c V; ++j) { scanf(\" %d\", \u0026mat[i][j]); } } dijkstra(0); printf(\"\\nNode\\tDist\\n\"); for (i = 0; i \u003c V; ++i) { printf(\"%d\\t%d\\n\", i, dist[i]); } return 0; } 弗洛伊德Floyd算法 Floyd算法是一个经典的动态规划算法.首先目标是寻找从点i到j的最短路径. Floyd算法可以求出任意两点的最短距离.时间复杂度:O(你^3) 从任意节点i到任意节点j的最短路径不外乎2种可能: 1.是之间从i到j 2是从i到经过若干个节点k到j 设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) \u003c Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\nfor (int k = 0; k \u003c n; k++) { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { if (A[i][j] \u003e (A[i][k] + A[k][j])) { A[i][j] = A[i][k] + A[k][j]; path[i][j] = k; } } } } 2.4.5 拓扑排序 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:\n每个顶点出现且只出现一次 若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面. 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。 拓扑排序步骤： 从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出 从图中删除该顶点和所有以它为起点的有向边 重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。 2.4.6 leetcode题目 判断二分图 克隆图 找到小镇的法官 钥匙和房间 最短路径访问所有节点 3 常见算法 3.1 递归思想 3.1.1 递归思想 递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果. 如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.\n斐波那契数列\nint fib(int N) { if (N \u003c = 1) { return N; } return fib(N-1) + fib(N-2); } 递归的过程中,符合后进先出规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是递归终止条件. 递归思想的两个延申算法:分治算法和动态规划. 递归的一般结构:\nvoid func() { if (符合边界条件) { ... return ..; } // 某种形式的调用 func(); } 阶乘函数:\nint factorial(int n) { if (n \u003c= 1) { return 1; } return n * factorial(n-1); } 参考链接:https://www.jianshu.com/p/b2d2edb4ba5b 3.1.2 递归基本步骤: 1.定义一个函数,明确函数功能 2.寻找问题与子问题之间的关系(递推公式) 3.将递推公式在定义的函数中实现 4.推导时间复杂度,判定是否可以接受,无法接受更换算法.\n3.1.3 代表题目 爬楼梯 70 int climbStairs(int n) { int *mem = (int *)malloc(sizeof(int) * (n+1)); int mem[n] = {}; return climb(n, mem); } int climb(int n, int *mem) { if (n == 1) { return 1; } if (n == 2) { return 2; } if (mem[n] \u003e 0) { return mem[n]; } mem[0] = climb(n-1, mem) + climb(n-2, mem); return mem[n]; } 青蛙跳台阶 10-II int numWays(int n) { int num[n+1] = {-1}; return jump(n, num); } int jump(int n, int *num) { if (num[n] != -1) { return num[n]; } if (n == 1 || n == 0) { return 1; } num[n] = (jump(n-1, num) + jump(n-2, num) % 1e9+7); return num[n]; } 3.1.4 触类旁通 反转二叉树 226 1).对于根节点1来说,假设2,3节点下的节点都已经翻转,那么只要翻转2,2节点即满足需求. 2).对于2,3节点来说,也是翻转其左右节点即可. 依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即 invert(root) = invert(root-\u003eleft) + invert(root-\u003eright) 加号是追加到root上的意思\ntypedef struct TreeNode { int data; TreeNode *left; TreeNode *right; } TreeNode invertTree(TreeNode *root) { if (root == NULL) { return NULL; } TreeNode *left = (struct TreeNode *)malloc(sizeof(TreeNode)); TreeNode *right = (struct TreeNode *)malloc(sizeof(TreeNode)); left = invertTree(root.left); rgith = invertTree(root.right); root.left = right; root.right = left; return root; } 路径总和 112 给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和. typedef struct TreeNode { int data; struct TreeNode *left; struct TreeNode *right; } bool hasPathSum(TreeNode *root, int sum) { if (root == NULL) { return false; } if (root.left == NULL \u0026\u0026 root.right == NULL) { return root.data == sum; } int remain = sum - root.data; return hasPathSum(root.left, remain) || hashPashSum(root.right, remain); } 细胞分裂 https://www.jianshu.com/p/b2d2edb4ba5b\n3.2 分治法 把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题…，直到可以直接求解，原问题的解为子问题解的合并。 分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。\n3.2.1 概述 分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.\n分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题…,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的合并.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换 1):数学归纳是使用分治思想. 2):分治思想不一定使用递归结构. 递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是如何分\n3.2.2 策略 分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.\n3.2.3 应用场景 分治法特征:\n问题缩小到一定程度可容易解决. 问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质. 子问题的解可合并为该问题的解. 问题分解的子问题相互独立,子问题之间不包含公告子问题. 3.2.4 步骤 分治法一层递归步骤:\n分解:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题. 解决:若子问题可直接求解,则直接求解,否则递归解各个子问题. 合并:将各个子问题的解合并为原问题的解. 3.2.5 应用 分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。\n求x的n次幂 对数复杂度O(logn)\nint power(int x, int n) { int result; if (n == 1) { return x; } if (n % 2 == 0) { result = power(x, n/2) * power(x, n / 2); } else { result = power(x, (n + 1) / 2) * power(x, (n - 1) / 2); } return result; } 3.2.6 leetcode题目 搜索二维矩阵II 求众数 合并k个排序链表 3.3 排序算法 各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，\n3.3.1 冒泡排序 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 冒泡排序算法复杂度是O(n^2)\nstatic void bubleSort(int[] arr) { int size = arr.length; // for (int out = size - 1; out \u003e 0; out--) { // for (int in = 0; in \u003c out; in++) { if (arr[in] \u003e arr[in + 1]) { swap(arr, in, in + 1); } } } } #define SWAP(a,b) \\ do{\\ (a) ^= (b);\\ (b) ^= (a);\\ (a) ^= (b);\\ }while(0) /*冒泡排序*/ void bubble_sort(int a[],int size) { int i = 0; int j = 0; int swap_flg = 0; if (size \u003c 1) { return; } for (i = size - 1; i \u003e 0; i--) {/*排序的趟数*/ swap_flg = 0;/*每次设置交换标识为0*/ for (j = 0; j \u003c i; j++) { /*本趟排序的遍历元素个数*/ if (a[j] \u003e a[j + 1]) { SWAP(a[j],a[j+1]); swap_flg = 1; } } /*本趟数，无数据交换的话，说明已经有序，直接退出*/ if (swap_flg == 0) { break; } } return; } #include using namespace std; template\u003ctypename T\u003e //整数或浮点数皆可使用 void bubble_sort(T arr[], int len) { int i, j; T temp; for (i = 0; i \u003c len - 1; i++) { for (j = 0; j \u003c len - 1 - i; j++) { if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } 3.3.2 选择排序 选择排序算法时间复杂度为O(n^2)\nstatic void selectSort(int[] arr) { int size = arr.lenght; // for (int out = 0; out \u003c size; out++) { int mixIndex = out; // for (int in = out - 1; in \u003c size; in++) { if (arr[mixIndex] \u003e arr[in]) { mixIndex = in; } } if (mixIndex != out) { swap(arr, mixIndex, out); } } } /*选择排序*/ void select_sort(int a[],int size) { int i = 0; int j = 0; int min = 0; for (i = 0; i \u003c size - 1; i++) { min = i; for (j = i + 1; j \u003c size; j++) { if (a[j] \u003c a[min]) { min = j; } } if (min != i) { SWAP(a[i],a[min]); } } return; } 3.3.3 插入排序 插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)\nstatic void insertSort(int[] arr) { int size = arr.lenght; // for (int out = 1; out \u003c size; out++) { // int temp = arr[out]; int in = out; // // while (in - 1 \u003e= 0 \u0026\u0026 arr[in - 1] \u003e temp) { arr[in] = arr[in - 1]; in--; } if (in != out) { arr[in] = temp; } } } /*插入排序*/ void insert_sort(int a[],int size) { for (int i = 1; i \u003c size; i ++)/*需要插入的元素个数*/ { int key = a[i];/*保存插入的元素数据*/ int j = i - 1; /* i 之前的元素都是有序的，找到比key小的插入到他后面， * 比key大的，需要往后挪一个位置*/ while((j \u003e= 0) \u0026\u0026 (a[j] \u003e key)) { a[j + 1] = a[j]; j--; } a[j + 1] = key; } return; } int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2)) { char *a = data; void *key; int i, j; if ((key = (char *)malloc(esize)) == NULL) { return -1; } for (j = 1; j \u003c size; j++) { i = j - 1; while (i \u003e= 0 \u0026\u0026 compare(\u0026a[i * esize], key) \u003e 0) { mamcpy(\u0026a[(i + 1) * esize], \u0026a[i * esize], esize); i--; } memcpy(\u0026a[(i + 1) * esize], key, esize); } free(key); return 0; } 3.3.4 希尔排序 希尔排序时间复杂度O(n*(logn)^2)\nstatic void shellSort(int[] arr) { int size = arr.lenght; int h = 1; while (h \u003c= size / 3) { // h = h * 3 + 1; } while (h \u003e 0) { for (int out = h; out \u003c size; out++) { int temp = arr[out]; int in = out; // while (in - h \u003e= 0 \u0026\u0026 arr[in - h] \u003e temp) { arr[in] = arr[in - h]; in = in - h; } if (in != out) { arr[in] = temp; } } h = (h - 1) / 3; } } 3.3.5 归并排序 归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。\nint min(int x, int y) { return x \u003c y ? x : y; } void merge_sort(int arr[], int len) { int *a = arr; int *b = (int *)malloc(len * sizeof(int)); int seg, start; for (seg = 1; seg \u003c len; seg += seg) { for (start ) } } #include #include #include #include void dump(int *arr, int size) { int idx; for (idx = 0; idx \u003c size; idx++) printf(\"%08d\\n\", arr[idx]); } void __merge(int *arr, int p, int q, int r) { int *tmp; int i, j, k; tmp = (int*)malloc((r - p + 1) * sizeof(int)); if (!tmp) abort(); for (i = p, j = q + 1, k = 0; i \u003c= q \u0026\u0026 j \u003c= r;) { if (arr[i] \u003c= arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } if (i == q + 1) { for (; j \u003c= r;) tmp[k++] = arr[j++]; } else { for (; i \u003c= q;) tmp[k++] = arr[i++]; } memcpy(arr + p, tmp, (r - p + 1) * sizeof(int)); free(tmp); } void __merge_sort(int *arr, int p, int r) { int q; if (p \u003e= r) return; q = (p + r) / 2; __merge_sort(arr, p, q); __merge_sort(arr, q + 1, r); __merge(arr, p, q, r); } void merge_sort(int *arr, int size) { __merge_sort(arr, 0, size - 1); } void merge_verify() { int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56}; __merge(test, 0, 4, 9); dump(test, 10); } void merge_sort_test() { int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56}; merge_sort(test, 10); dump(test, 10); } int main() { //merge_verify(); merge_sort_test(); return 0; } 3.3.6 快速排序 快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)\n快速排序三个步骤：\n分：设定一个分割值并将数据分为两部分。 治：分别在两部分使用递归方式继续使用快速排序方法。 和：对分割部分排序直至完成。 typedef struct _Range { int start; int end; } Range; Range now_Range(int s, int e) { Range r; r.start = s; r.end = e; return r; } void swap(int *x, int *y) { int t = *x; *x = *y; *y = t; } void quick_sort(int arr[], const int len) { if (len \u003c= 0) { return; } Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) { Range range = r[--p]; if (range.start \u003e= range.end) { continue; } int mid = arr[(range.start + range.end) / 2]; int left = range.start; int right = range.end; do { while (arr[left] \u003c mid) { ++left; } while (arr[right] \u003e mid) { --right; } if (left \u003c= right) { swap(\u0026arr[left], \u0026arr[right]); left++; right--; } } while (left \u003c= right); if (range.start \u003c right) { r[p++] = new_Range(range.start, right); } if (range.end \u003e left) { r[p++] = new_Range(left, range.end); } } } void QuickSort(int *arr, int low, int high) { if (low \u003c high) { int i = low; int j = high; int k = arr[low]; while (i \u003c j) { // 从右向左找第一个小于k的数 while (i \u003c j \u0026\u0026 arr[j] \u003e= k) { j--; } if (i \u003c j) { arr[i++] = arr[j]; } // 从左向右找第一个大于等于k的数 while (i \u003c j \u0026\u0026 arr[i] \u003c k) { i++; } if (i \u003c j) { arr[j--] = arr[i]; } } arr[i] = k; // 递归调用 QuickSort(arr, low, i - 1); // 排序k左边 QuickSort(arr, i + 1, high); // 排序k右边 } } void quick_sort( int *a, int n) { int i, j, p, tmp; if (n \u003c 2) return; p = a[n / 2]; // Get the middle element as pivot .. for ( i = 0, j = n -1;; i++, j--) { while (a[i] \u003c p) i++; while (p \u003c a[j]) j--; if ( i \u003e= j) break; tmp = a[i]; a[i] = a[j]; a[j] = tmp; //swap both .. } quick_sort( a, i); quick_sort( a + i, n - i); } #include #include #include #include void dump(int *arr, int size) { int idx; for (idx = 0; idx \u003c size; idx++) printf(\"%08d\\n\", arr[idx]); } void swap(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } int partition(int *arr, int p, int r) { //int pivot = arr[r]; int i, j; i = j = p; for (; j \u003c r; j++) { if (arr[j] \u003c arr[r]) { if(i != j) { swap(arr + i, arr + j); } i++; } } swap(arr + i, arr + r); return i; } void __quick_sort(int *arr, int p, int r) { int q; if (p \u003e= r) return; q = partition(arr, p, r); __quick_sort(arr, p, q-1); __quick_sort(arr, q+1, r); } void quick_sort(int *arr, int size) { __quick_sort(arr, 0, size - 1); } void quick_sort_test() { int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56}; quick_sort(test, 10); dump(test, 10); } int main() { quick_sort_test(); return 0; } #include using namespace std; void Qsort(int arr[], int low, int high){ if (high \u003c= low) return; int i = low; int j = high + 1; int key = arr[low]; while (true) { /*从左向右找比key大的值*/ while (arr[++i] \u003c key) { if (i == high) { break; } } /*从右向左找比key小的值*/ while (arr[--j] \u003e key) { if (j == low) { break; } } if (i \u003e= j) break; /*交换i,j对应的值*/ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } /*中枢值与j对应值交换*/ int temp = arr[low]; arr[low] = arr[j]; arr[j] = temp; Qsort(arr, low, j - 1); Qsort(arr, j + 1, high); } qsort/sort函数 在c语言库函数中已经实现了qsort函数, qsort函数用法:\nvoid qsort(void *base, int nelem, int width, int (*fcmp)(const void *, const void *)); // 参数:1 带排序数组首地址, nelem 数组中待排元素数量 width 各元素所在空间大小 *fcmp 指向函数的指针 // int 数组 int cmp(const void *a, const void *b) { return (*(int *)a - *(int *)b); } qsort(arr, n, sizeof(arr[0]), cmp); // char 数组 int com(const void *a, const void *b) { return *(char *)a - *(char *)b; } char word[100]; qsort(word, 100, sizeof(word[0]), cmp); // double 类型 int cmp(const void *a, const void *b) { return *(double *)a \u003e *(double*)b ? 1 : -1; } double in[100]; qsort(in, 100, sizeof(in[00]), cmp); // struct 结构体 struct Sample { double data; int num; }st[100]; int cmp(const void *a, const void *b) { return (*(Sample *)a).data \u003e (*(Sampel *)b).data ? 1 : -1; } qsort(s, 100, sizeof(s[0]), cmp); // int cmp(const void *a, const void *b) { struct Sample *c = (Sample *)a; struct Sample *d = (Sample *)b; if(c-\u003ex != d-\u003ex) { return c-\u003ex - d-\u003ex; } else { return d-\u003ey - c-\u003ey; } } qsort(s,100,sizeof(s[0]),cmp); truct Sample { int data; char str[100]; }s[100]; //按照结构体中字符串str的字典顺序排序 int cmp (const void *a, const void *b) { return strcmp((*(Sample *)a)-\u003estr , (*(Sample *)b)-\u003estr); } qsort(s,100,sizeof(s[0]),cmp); 3.3.7 堆排序 桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。 存在两个问题： (1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。 (2)对每个数据块里的数据怎样排序。 堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。 堆排序的过程： 1.由输入的无序数组构造一个最大堆，作为初始的无序区 2.把堆顶元素(最大值)和堆尾元素互换 3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。 4.重复步骤2，直到堆的尺寸为1 因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。\n#include #include typedef struct node { int key; struct node *next; } KeyNode; void bucket_sort(int keys[], int size, int bucket_size) { int i, j; KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * sizeof(KeyNode*)); for(i = 0;i \u003c bucket_size;i++) { bucket_table[i] = (KeyNode*)malloc(sizeof(KeyNode)); bucket_table[i]-\u003ekey = 0; bucket_table[i]-\u003enext = NULL; } for(j = 0;j \u003c size;j++) { KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode)); node-\u003ekey = keys[j]; node-\u003enext = NULL; int index = keys[j]/10; KeyNode *p = bucket_table[index]; if(p-\u003ekey == 0) { bucket_table[index]-\u003enext = node; (bucket_table[index]-\u003ekey)++; } else { while(p-\u003enext != NULL \u0026\u0026 p-\u003enext-\u003ekey \u003c= node-\u003ekey) p = p-\u003enext; node-\u003enext = p-\u003enext; p-\u003enext = node; (bucket_table[index]-\u003ekey)++; } } //print result KeyNode * k = NULL; for(i = 0;i \u003c bucket_size;i++) for(k = bucket_table[i]-\u003enext;k!=NULL;k=k-\u003enext) printf(\"%d \",k-\u003ekey); printf(\"\\n\"); } int main() { int raw[] = {49,38,65,97,76,13,27,49}; int size = sizeof(raw)/sizeof(int); bucket_sort(raw,size,10); } void Heapify(int A[], int i, int size) { int lef_child = 2 * i + 1; int right_child = 2 * i + 2; int max = i; if (lef_child \u003c size \u0026\u0026 A[lef_child] \u003e A[max]) { max = lef_child; } if (right_child \u003c size \u0026\u0026 A[right_child] \u003e A[max]) { max = right_child; } if (max != i) { Swap(A, i max); Heapify(A, max, size); } } int BuildHeap(int A[], int n) { int heap_size = n; for (int i = heap_size / w - 1; i \u003e= 0; i--) { Heapify(A, i, heap_size); return heap_size; } } void HeapSort(int A[], int n) { int heap_size = BuildHeap(A, n); while (heap_size \u003e 1) { Swap(A, 0, heap_size); Heap(A, 0, heap_size); } } 3.3.8 leetcode排序 按奇偶排序数组 对链表进行插入排序 合并区间 最大数 最接近原点的K个点 3.4 贪心算法 3.4.1 基本概念 贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解. 贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.\n3.4.2 描述 贪心算法实现步骤: 1.建立数学模型描述问题 2.把求解的问题分成若干个子问题 3.对每个子问题求解,得到子问题的局部最优解 4.把子问题的解局部最优解合成原来问题的一个解. 实现算法过程:\nwhile (能朝给定总目标前进一步) { 利用可行的决策,求出可行解的一个解元素; } 由所有解元素组合成问题的一个可行解 3.4.3 应用 最小生成树算法 贪心算法经典实践:最小生成树算法 设G=(V, E)是无向连通带权图,即一个网络,E中的每一条边(v,w) 的全为 c[v][w].如果G的字体 G’ 是一颗包含 G 的所有顶点的数,则称 G’ 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树. 最小生成树的性质: 设G=(V, E)是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.\nPrim算法 设G=(V, E)是连通带权图, V={1,2,…,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.\nPrim /** * @file * @author [Timothy Maloney](https://github.com/sl1mb0) * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm) * implementation in C to find the MST of a weighted, connected graph. * @details Prim's algorithm uses a greedy approach to generate the MST of a *weighted connected graph. The algorithm begins at an arbitrary vertex v, and *selects a next vertex u, where v and u are connected by a weighted edge whose *weight is the minimum of all edges connected to v. * @references Page 319 \"Introduction to the Design and Analysis of Algorithms\" *- Anany Levitin * * To test - run './prim -test' * prim() will find the MST of the following adj. matrix: * *\t0 1 2 3 * 1 0 4 6 * 2 4 0 5 * 3 6 5 0 * * The minimum spanning tree for the above weighted connected graph is given by *the following adj matrix: * *\t0 1 2 3 *\t1 0 0 0 *\t2 0 0 0 *\t3 0 0 0 * * * The following [link](https://visualgo.net/en/mst) provides a visual *representation of graphs that can be used to test/verify the algorithm for *different adj matrices and their weighted, connected graphs. */ #include /// for assert() #include /// for uint16_t #include /// for IO operations #include /// for string comparison #define MAX 20 #define INF 999 /** * @brief Finds index of minimum element in edge list for an arbitrary vertex * @param arr graph row * @param N number of elements in arr * @returns index of minimum element in arr */ uint16_t minimum(uint16_t arr[], uint16_t N) { uint16_t index = 0; uint16_t min = INF; for (uint16_t i = 0; i \u003c N; i++) { if (arr[i] \u003c min) { min = arr[i]; index = i; } } return index; } /** * @brief Used to find MST of user-generated adj matrix G * @returns void */ void prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V) { uint16_t u, v; uint16_t E_t[MAX], path[MAX]; uint16_t V_t[MAX], no_of_edges; E_t[0] = 0; // edges for current vertex V_t[0] = 1; // list of visited vertices for (uint16_t i = 1; i \u003c V; i++) { E_t[i] = G[i][0]; path[i] = 0; V_t[i] = 0; } no_of_edges = V - 1; while (no_of_edges \u003e 0) { u = minimum(E_t, V); while (V_t[u] == 1) { E_t[u] = INF; u = minimum(E_t, V); } v = path[u]; MST[v][u] = E_t[u]; MST[u][v] = E_t[u]; no_of_edges--; V_t[u] = 1; for (uint16_t i = 1; i \u003c V; i++) { if (V_t[i] == 0 \u0026\u0026 G[u][i] \u003c E_t[i]) { E_t[i] = G[u][i]; path[i] = v; } } } } /** * @brief Self-test implementations * @returns void */ static void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V) { uint16_t test[4][4] = { {0, 1, 2, 3}, {1, 0, 4, 6}, {2, 4, 0, 5}, {3, 6, 5, 0}}; uint16_t solution[4][4] = { {0, 1, 2, 3}, {1, 0, 0, 0}, {2, 0, 0, 0}, {3, 0, 0, 0}}; V = 4; for (uint16_t i = 0; i \u003c V; ++i) { for (uint16_t j = 0; j \u003c V; ++j) { G[i][j] = test[i][j]; } } prim(\u0026(*G), \u0026(*MST), V); for (uint16_t i = 0; i \u003c V; ++i) { for (uint16_t j = 0; j \u003c V; ++j) { assert(MST[i][j] == solution[i][j]); } } } /** * @brief Function user_graph(); * gets user input adj. matrix and finds MST of that graph * @returns void */ void user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V) { printf(\"Enter the number of vertices: \"); scanf(\" %hd\", \u0026V); assert(V \u003c= MAX); printf(\"Enter the adj matrix\\n\"); uint16_t i, j; for (i = 0; i \u003c V; ++i) { for (j = 0; j \u003c V; ++j) { printf(\"G[%d][%d]: \", i, j); scanf(\" %hd\", \u0026G[i][j]); if (G[i][j] == 0) G[i][j] = INF; } } prim(\u0026(*G), \u0026(*MST), V); printf(\"minimum spanning tree:\\n\"); for (i = 0; i \u003c V; ++i) { printf(\"\\n\"); for (j = 0; j \u003c V; ++j) { printf(\"%d\\t\", MST[i][j]); } } } /** * @brief Main function * @param argc commandline argument count (ignored) * @param argv commandline array of arguments (ignored) * @returns 0 on exit */ int main(int argc, char const *argv[]) { uint16_t G[MAX][MAX]; ///\u003c weighted, connected graph G uint16_t MST[MAX][MAX]; ///\u003c adj matrix to hold minimum spanning tree of G uint16_t V; ///\u003c number of vertices in V in G if (argc == 2 \u0026\u0026 strcmp(argv[1], \"-test\") == 0) { test(\u0026(*G), \u0026(*MST), V); } else { user_graph(\u0026(*G), \u0026(*MST), V); } return 0; } 3.4.4 leetcode题目 柠檬水找零 分发饼干 3.5 动态规划 动态规划(DP):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.\n3.5.1 基本概念 动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录. 动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划. 动态规划与分治法的区别是子问题通常不是独立的.\n3.5.2 描述算法 可采用动态规划的问题3个性质: 1) 最优化原理:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理. 2) 无后效性:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关. 3) 有重叠子问题:\n动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列. 动态规划求解三要素:\n(1) 问题的节点 (2) 每个阶段的状态 (3) 从前一个阶段转化到后一个阶段之间的递推关系\n最优决策表\nf(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}\n3.5.3 背包问题 问题描述: 有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大. 解题思路: p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为\"前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为\"前i-1物品放入剩下的容量为v-volume[i]的背包中\",此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].\n状态转移方程:\np[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]} 伪代码描述:\nfor i = 1...N for j = V...0 p[j] = max{p[j-volume[i]] + value[i], p[j]}; dp #include int v[]={6,3,5,4,6}; int w[]={2,2,6,5,4}; int dp[100][100]; int Max(int a,int b){ if(a\u003e=b){ return a; }else{ return b; } } int getAns(int i,int wi) { for(int x=0;x\u003c=i;x++) { dp[x][0]=0; } for(int x = 0; x \u003c= wi; x++) { dp[0][x]=0; } for(int x = 1; x \u003c= i; x++) { for(int y=1;y\u003c=wi;y++) { if(y\u003e=w[x-1]) { dp[x][y]=Max(dp[x-1][y],v[x-1]+dp[x-1][y-w[x-1]]); } else { dp[x][y]=dp[x-1][y]; } printf(\"%4d\",dp[x][y]); } printf(\"\\n\"); } return dp[i][wi]; } int main() { int max=getAns(5,10); printf(\"%d\\n\",max); return 0; } 3.5.4 最长公共子序列 问题描述: 一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS) 给定两个序列X,Y,求两个序列的最长公共子序列. 解题思路: 最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。 最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：\nf[1][1] = same(1,1) f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]} 其中，same(a,b)当X的第a位与Y的第b位完全相同是\"1\"，否则位\"1\"。 此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。 该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。\n伪代码:\nfunction LCSLength(X[1..m], Y[1..n]) C = array(0..m, 0..n) for i := 0..m C[i, 0] = 0; for j := 0..n C[0, j] = 0 for i := 1..m for j := 1..n if X[i] = Y[j] C[i, j] := C[i-1, j-1] + 1 else C[i, j] := max(C[i, j-1], C[i-1,j]) return C[m, n] 最长公共序列数 #include #include int dp[100][100]; int Max(int a,int b,int c){ int max=a; if(b\u003emax){ max=b; } if(c\u003emax){ max=c; } return max; } int getMax(char s1[],char s2[],int m,int n){ int i,j; for(i=0;i\u003cm;i++){ //当 s2取 1个的时候 ,s1为可变长度 if(s1[i]==s2[0]){ dp[i][0]=1; for(j=i+1;j\u003cm;j++){ dp[j][0]=1; } break; } } for(i=0;i\u003cn;i++){ //当 s1取 1个的时候 ,s2为可变长度 if(s2[i]==s1[0]){ dp[0][i]=1; for(j=i+1;j\u003cn;j++){ dp[0][j]=1; } break; } } for(i=1;i\u003cm;i++){ for(j=1;j\u003cn;j++){ if(s1[i]==s2[j]){ dp[i][j]=Max(dp[i-1][j-1]+1,dp[i-1][j],dp[i][j-1]); }else{ dp[i][j]=dp[i-1][j]\u003e=dp[i][j-1]?dp[i-1][j]:dp[i][j-1]; } } } return dp[m-1][n-1]; } int main() { int m,n; char s1[100]; char s2[100]; gets(s1); gets(s2); m=strlen(s1); n=strlen(s2); printf(\"%d\\n\",getMax(s1,s2,m,n)); return 0; } Fibonacci_dp // Fibonacci Series using Dynamic Programming /* Author: Moinak Banerjee(moinak878) Date : 1 October ,2019 */ #include #include int fib(int n) { // Out of Range checking if (n \u003c 0) { printf(\"\\nNo Such term !\\n\"); exit(0); } // declaring array to store fibonacci numbers -- memoization int *f = (int *)malloc((n + 2) * sizeof(int)); // one extra to handle edge case, n = 0 int i; /* let 0th and 1st number of the series be 0 and 1*/ f[0] = 0; f[1] = 1; for (i = 2; i \u003c= n; i++) { // Adding the previous 2 terms to make the 3rd term f[i] = f[i - 1] + f[i - 2]; } int out = f[n]; free(f); return out; } int main(int argc, char *argv[]) { int number; // Asks for the number/position of term in Fibonnacci sequence if (argc == 2) { number = atoi(argv[1]); } else { printf(\"Enter the value of n(n starts from 0 ): \"); scanf(\"%d\", \u0026number); } printf(\"The nth term is : %d \\n\", fib(number)); return 0; } 3.5.5 leetcode题目 最大子序和 编辑距离 大礼包 最长上升子序列 3.6 回溯法 3.6.1 基本概念 回溯算法实际上一个类似枚举的搜索尝试过程,主要是在搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就\"回溯\"返回,尝试别的路径. 回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为\"回溯法\". 许多复杂度,规模较大的问题都看看而已使用回溯法,有\"通用解题方法\"的美称.\n在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法). 若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束. 回溯法一般解题步骤: 1.针对所给问题,确定问题的解空间;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解. 2.确定节点的扩展搜索规则 3.以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索\n伪代码:\n// void iterativeBacktrack() { int t = 1; while (t \u003e 0) { if (f(n, t) \u003c= g(n, t)) { for (int i = f(n,t); i \u003c= g(n,t); i++) { x[t] = h(i); if (constraint(t) \u0026\u0026 bound(t)) { // if (solution(t)) { output(x); } else { t++; } } else { t--; } } } } } 3.6.2 八皇后问题 问题描述 八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上. 转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n \u003e= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。 （1）因为所有的皇后都不能放在同一列，因为任意两个a[0]…a[7]的值不能存在相同的两个值 （2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下： 假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。\n伪代码描述\nint queens(int Queens) { int i, k, flag, not_finish = 1, count = 0, // 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素 int a[Queeens+1]; // 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1 i = 1; a[1] = 1; // 为数组的第一个元素赋初值 while (not_finish) { // not_finish=1 处理尚未结束 while(not_finish \u0026\u0026 i \u003c= Queens) { // 处理尚未结束且还没处理到第Queeens个元素 for (flag=1, k=1; flag \u0026\u0026 k \u003c i; k++) { // 判断是否有多个皇后在同一行 if (a[k] == a[i]) { flag = 0; } } // 判断是否有多个皇后在同一个对角线 for (k=1; flag \u0026\u0026 k \u003c i; k++) { if ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) { flag = 0; } } } } } 3.6.3 leetcode题目 N皇后 括号生成 单词搜索 解数独 4 参考链接 复杂度速查表 https://liam.page/2016/06/20/big-O-cheat-sheet/ 线性表 https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8 单链表 https://www.jianshu.com/p/73f0d8f807aa http://cocofe.cn/\n数据结构 https://github.com/wangzheng0822/algo/ ",
  "wordCount" : "31223",
  "inLanguage": "en",
  "datePublished": "2022-07-05T00:17:58+08:00",
  "dateModified": "2022-07-05T00:17:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "Zain"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://liuz0123.gitee.io/zain/posts/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zain's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://liuz0123.gitee.io/zain/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://liuz0123.gitee.io/zain/" accesskey="h" title="Zain&#39;s Blog (Alt + H)">
            <img src="https://liuz0123.gitee.io/zain/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">Zain&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://liuz0123.gitee.io/zain/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://liuz0123.gitee.io/zain/links" title="🤝 闲言俗语">
                <span>🤝 闲言俗语</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://liuz0123.gitee.io/zain/">主页</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://liuz0123.gitee.io/zain/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                数据结构与算法基础
            </h1>
            <div class="post-meta">Create:&nbsp;<span title='2022-07-05 00:17:58 +0800 CST'>2022-07-05</span>&nbsp;|&nbsp;Update:&nbsp;2022-07-05&nbsp;|&nbsp;Words:&nbsp;31223&nbsp;|&nbsp;&nbsp;63 min&nbsp;|&nbsp;
&nbsp;Zain



                &nbsp;|&nbsp;tags: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://liuz0123.gitee.io/zain/tags/leetcode/">leetcode</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| Viewers: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd" aria-label="1 程序性能">1 程序性能</a><ul>
                        
                <li>
                    <a href="#11-%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" aria-label="1.1 空间复杂度">1.1 空间复杂度</a></li>
                <li>
                    <a href="#12-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" aria-label="1.2 时间复杂度">1.2 时间复杂度</a><ul>
                        
                <li>
                    <a href="#121-%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95%e5%a4%a7o" aria-label="1.2.1 常见算法大O">1.2.1 常见算法大O</a></li>
                <li>
                    <a href="#122-%e5%b8%b8%e8%a7%81%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="1.2.2 常见数据结构">1.2.2 常见数据结构</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%ac%e7%ab%a0%e5%8f%82%e8%80%83" aria-label="本章参考：">本章参考：</a></li></ul>
                </li>
                <li>
                    <a href="#2-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="2 基本数据结构">2 基本数据结构</a><ul>
                        
                <li>
                    <a href="#21-%e7%ba%bf%e6%80%a7%e8%a1%a8" aria-label="2.1 线性表">2.1 线性表</a><ul>
                        
                <li>
                    <a href="#211-%e6%95%b0%e7%bb%84" aria-label="2.1.1 数组">2.1.1 数组</a></li>
                <li>
                    <a href="#212-%e5%8d%95%e9%93%be%e8%a1%a8" aria-label="2.1.2 单链表">2.1.2 单链表</a></li>
                <li>
                    <a href="#213-%e5%8f%8c%e9%93%be%e8%a1%a8" aria-label="2.1.3 双链表">2.1.3 双链表</a></li>
                <li>
                    <a href="#214-%e8%b7%b3%e8%a1%a8" aria-label="2.1.4 跳表">2.1.4 跳表</a></li>
                <li>
                    <a href="#215-%e6%a0%88" aria-label="2.1.5 栈">2.1.5 栈</a></li>
                <li>
                    <a href="#216-%e9%98%9f%e5%88%97" aria-label="2.1.6 队列">2.1.6 队列</a></li>
                <li>
                    <a href="#217-leetcode%e9%a2%98%e7%9b%ae" aria-label="2.1.7 leetcode题目">2.1.7 leetcode题目</a></li></ul>
                </li>
                <li>
                    <a href="#22-%e5%93%88%e5%b8%8c%e8%a1%a8" aria-label="2.2 哈希表">2.2 哈希表</a><ul>
                        
                <li>
                    <a href="#221-%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0%e8%ae%be%e8%ae%a1" aria-label="2.2.1 哈希函数设计">2.2.1 哈希函数设计</a></li>
                <li>
                    <a href="#222-%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81" aria-label="2.2.2 哈希冲突">2.2.2 哈希冲突</a></li>
                <li>
                    <a href="#223-uthash" aria-label="2.2.3 uthash">2.2.3 uthash</a></li>
                <li>
                    <a href="#224-leetcode%e9%a2%98%e7%9b%ae" aria-label="2.2.4 leetcode题目">2.2.4 leetcode题目</a></li></ul>
                </li>
                <li>
                    <a href="#23-%e6%a0%91%e4%b8%8e%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="2.3 树与二叉树">2.3 树与二叉树</a><ul>
                        
                <li>
                    <a href="#231-%e6%a6%82%e8%bf%b0" aria-label="2.3.1 概述">2.3.1 概述</a></li>
                <li>
                    <a href="#232-%e6%a0%91%e7%9a%84%e7%a7%8d%e7%b1%bb" aria-label="2.3.2 树的种类">2.3.2 树的种类</a></li>
                <li>
                    <a href="#233-%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="2.3.3 二叉树">2.3.3 二叉树</a></li>
                <li>
                    <a href="#234-%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91bst" aria-label="2.3.4 二叉查找树(BST)">2.3.4 二叉查找树(BST)</a></li>
                <li>
                    <a href="#235-%e5%b9%b3%e8%a1%a1%e6%a0%91" aria-label="2.3.5 平衡树">2.3.5 平衡树</a></li>
                <li>
                    <a href="#236-%e5%a0%86%e6%a0%91%e5%92%8c%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" aria-label="2.3.6 堆树和优先队列">2.3.6 堆树和优先队列</a></li>
                <li>
                    <a href="#237-leetcode%e9%a2%98%e7%9b%ae" aria-label="2.3.7 leetcode题目">2.3.7 leetcode题目</a></li></ul>
                </li>
                <li>
                    <a href="#24-%e5%9b%be" aria-label="2.4 图">2.4 图</a><ul>
                        
                <li>
                    <a href="#241-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="2.4.1 基础知识">2.4.1 基础知识</a></li>
                <li>
                    <a href="#242-%e5%9b%be%e8%a1%a8%e7%a4%ba" aria-label="2.4.2 图表示">2.4.2 图表示</a></li>
                <li>
                    <a href="#243-%e5%9b%be%e9%81%8d%e5%8e%86" aria-label="2.4.3 图遍历">2.4.3 图遍历</a></li>
                <li>
                    <a href="#244-%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84" aria-label="2.4.4 最短路径">2.4.4 最短路径</a></li>
                <li>
                    <a href="#245-%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" aria-label="2.4.5 拓扑排序">2.4.5 拓扑排序</a></li>
                <li>
                    <a href="#246-leetcode%e9%a2%98%e7%9b%ae" aria-label="2.4.6 leetcode题目">2.4.6 leetcode题目</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#3-%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95" aria-label="3 常见算法">3 常见算法</a><ul>
                        
                <li>
                    <a href="#31-%e9%80%92%e5%bd%92%e6%80%9d%e6%83%b3" aria-label="3.1 递归思想">3.1 递归思想</a><ul>
                        
                <li>
                    <a href="#311-%e9%80%92%e5%bd%92%e6%80%9d%e6%83%b3" aria-label="3.1.1 递归思想">3.1.1 递归思想</a></li>
                <li>
                    <a href="#312-%e9%80%92%e5%bd%92%e5%9f%ba%e6%9c%ac%e6%ad%a5%e9%aa%a4" aria-label="3.1.2 递归基本步骤:">3.1.2 递归基本步骤:</a></li>
                <li>
                    <a href="#313-%e4%bb%a3%e8%a1%a8%e9%a2%98%e7%9b%ae" aria-label="3.1.3 代表题目">3.1.3 代表题目</a></li>
                <li>
                    <a href="#314-%e8%a7%a6%e7%b1%bb%e6%97%81%e9%80%9a" aria-label="3.1.4 触类旁通">3.1.4 触类旁通</a></li></ul>
                </li>
                <li>
                    <a href="#32-%e5%88%86%e6%b2%bb%e6%b3%95" aria-label="3.2 分治法">3.2 分治法</a><ul>
                        
                <li>
                    <a href="#321-%e6%a6%82%e8%bf%b0" aria-label="3.2.1 概述">3.2.1 概述</a></li>
                <li>
                    <a href="#322-%e7%ad%96%e7%95%a5" aria-label="3.2.2 策略">3.2.2 策略</a></li>
                <li>
                    <a href="#323-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="3.2.3 应用场景">3.2.3 应用场景</a></li>
                <li>
                    <a href="#324-%e6%ad%a5%e9%aa%a4" aria-label="3.2.4 步骤">3.2.4 步骤</a></li>
                <li>
                    <a href="#325-%e5%ba%94%e7%94%a8" aria-label="3.2.5 应用">3.2.5 应用</a></li>
                <li>
                    <a href="#326-leetcode%e9%a2%98%e7%9b%ae" aria-label="3.2.6 leetcode题目">3.2.6 leetcode题目</a></li></ul>
                </li>
                <li>
                    <a href="#33-%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" aria-label="3.3 排序算法">3.3 排序算法</a><ul>
                        
                <li>
                    <a href="#331-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f" aria-label="3.3.1 冒泡排序">3.3.1 冒泡排序</a></li>
                <li>
                    <a href="#332-%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f" aria-label="3.3.2 选择排序">3.3.2 选择排序</a></li>
                <li>
                    <a href="#333-%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" aria-label="3.3.3 插入排序">3.3.3 插入排序</a></li>
                <li>
                    <a href="#334-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f" aria-label="3.3.4 希尔排序">3.3.4 希尔排序</a></li>
                <li>
                    <a href="#335-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f" aria-label="3.3.5 归并排序">3.3.5 归并排序</a></li>
                <li>
                    <a href="#336-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f" aria-label="3.3.6 快速排序">3.3.6 快速排序</a></li>
                <li>
                    <a href="#337-%e5%a0%86%e6%8e%92%e5%ba%8f" aria-label="3.3.7 堆排序">3.3.7 堆排序</a></li>
                <li>
                    <a href="#338-leetcode%e6%8e%92%e5%ba%8f" aria-label="3.3.8 leetcode排序">3.3.8 leetcode排序</a></li></ul>
                </li>
                <li>
                    <a href="#34-%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95" aria-label="3.4 贪心算法">3.4 贪心算法</a><ul>
                        
                <li>
                    <a href="#341-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="3.4.1 基本概念">3.4.1 基本概念</a></li>
                <li>
                    <a href="#342-%e6%8f%8f%e8%bf%b0" aria-label="3.4.2 描述">3.4.2 描述</a></li>
                <li>
                    <a href="#343-%e5%ba%94%e7%94%a8" aria-label="3.4.3 应用">3.4.3 应用</a></li>
                <li>
                    <a href="#344-leetcode%e9%a2%98%e7%9b%ae" aria-label="3.4.4 leetcode题目">3.4.4 leetcode题目</a></li></ul>
                </li>
                <li>
                    <a href="#35-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" aria-label="3.5 动态规划">3.5 动态规划</a><ul>
                        
                <li>
                    <a href="#351-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="3.5.1 基本概念">3.5.1 基本概念</a></li>
                <li>
                    <a href="#352-%e6%8f%8f%e8%bf%b0%e7%ae%97%e6%b3%95" aria-label="3.5.2 描述算法">3.5.2 描述算法</a></li>
                <li>
                    <a href="#353-%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" aria-label="3.5.3 背包问题">3.5.3 背包问题</a></li>
                <li>
                    <a href="#354-%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97" aria-label="3.5.4 最长公共子序列">3.5.4 最长公共子序列</a></li>
                <li>
                    <a href="#355-leetcode%e9%a2%98%e7%9b%ae" aria-label="3.5.5 leetcode题目">3.5.5 leetcode题目</a></li></ul>
                </li>
                <li>
                    <a href="#36-%e5%9b%9e%e6%ba%af%e6%b3%95" aria-label="3.6 回溯法">3.6 回溯法</a><ul>
                        
                <li>
                    <a href="#361-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="3.6.1 基本概念">3.6.1 基本概念</a></li>
                <li>
                    <a href="#362-%e5%85%ab%e7%9a%87%e5%90%8e%e9%97%ae%e9%a2%98" aria-label="3.6.2 八皇后问题">3.6.2 八皇后问题</a></li>
                <li>
                    <a href="#363-leetcode%e9%a2%98%e7%9b%ae" aria-label="3.6.3 leetcode题目">3.6.3 leetcode题目</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#4-%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="4 参考链接">4 参考链接</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h2 id="1-程序性能">1 程序性能<a hidden class="anchor" aria-hidden="true" href="#1-程序性能">#</a></h2>
<p> 程序性能是指运行程序所需要的<strong>内存大小(空间复杂度)和时间(时间复杂度)</strong>,运行时间和占用空间是算法性能最关键的指标。
 软件程序性能衡量指标:
 响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力</p>
<h3 id="11-空间复杂度">1.1 空间复杂度<a hidden class="anchor" aria-hidden="true" href="#11-空间复杂度">#</a></h3>
<p> 空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。
 算法在计算机存储器上所占用的存储空间，包括<strong>存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间</strong>。</p>
<h3 id="12-时间复杂度">1.2 时间复杂度<a hidden class="anchor" aria-hidden="true" href="#12-时间复杂度">#</a></h3>
<p> 时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。</p>
<p><img loading="lazy" src="https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png" alt="20211027233029"  />
</p>
<h4 id="121-常见算法大o">1.2.1 常见算法大O<a hidden class="anchor" aria-hidden="true" href="#121-常见算法大o">#</a></h4>
<p>  常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)
<img loading="lazy" src="https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png" alt="20211028010721"  />
</p>
<h4 id="122-常见数据结构">1.2.2 常见数据结构<a hidden class="anchor" aria-hidden="true" href="#122-常见数据结构">#</a></h4>
<p>{% pullquote mindmap mindmap-md %}</p>
<ul>
<li>数据结构与算法
<ul>
<li>线性表
<ul>
<li>数组</li>
<li>链表
<ul>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
<li>静态链表</li>
</ul>
</li>
<li>栈
<ul>
<li>顺序栈</li>
<li>链式栈</li>
</ul>
</li>
<li>队列
<ul>
<li>普通队列</li>
<li>双端队列</li>
<li>阻塞队列</li>
<li>并发队列</li>
<li>阻塞并发队列</li>
</ul>
</li>
</ul>
</li>
<li>散列表
<ul>
<li>散列函数</li>
<li>冲突解决
<ul>
<li>链表法</li>
<li>开放地址</li>
<li>其他</li>
</ul>
</li>
<li>动态扩容</li>
<li>位置</li>
</ul>
</li>
<li>树
<ul>
<li>二叉树
<ul>
<li>二叉查找树</li>
<li>平衡二叉树</li>
<li>平衡二叉查找树
<ul>
<li>AVL树</li>
<li>红黑树</li>
</ul>
</li>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
</li>
<li>多路查找树
<ul>
<li>B树</li>
<li>B+树</li>
<li>2-3树</li>
<li>2-3-4树</li>
</ul>
</li>
<li>堆
<ul>
<li>小顶堆</li>
<li>大顶堆</li>
<li>优先级队列</li>
<li>斐波那契堆</li>
<li>二项堆</li>
</ul>
</li>
<li>其他
<ul>
<li>树状数组</li>
<li>线段树</li>
</ul>
</li>
</ul>
</li>
<li>图
<ul>
<li>图的存储
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
</li>
<li>拓扑排序</li>
<li>最短路径</li>
<li>关键路径</li>
<li>最小生成树</li>
<li>二分图</li>
<li>最大流</li>
</ul>
</li>
<li>复杂度分析
<ul>
<li>空间复杂度</li>
<li>时间复杂度</li>
</ul>
</li>
<li>基本算法思想
<ul>
<li>分治法</li>
<li>递归算法</li>
<li>贪心算法</li>
<li>动态规划</li>
<li>回溯法</li>
<li>枚举法</li>
</ul>
</li>
<li>排序
<ul>
<li>O(n^2)
<ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>O(nlogn)
<ul>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
</ul>
</li>
<li>O(n)
<ul>
<li>计数排序</li>
<li>基数排序</li>
<li>桶排序</li>
</ul>
</li>
</ul>
</li>
<li>搜索
<ul>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
<li>A*启发式搜索</li>
</ul>
</li>
<li>查找
<ul>
<li>线性表查找</li>
<li>树结构查找</li>
<li>散列表查找</li>
</ul>
</li>
<li>字符串匹配
<ul>
<li>朴素</li>
<li>KMP</li>
<li>Robin-Karp</li>
<li>Boyer-Moore</li>
<li>AC自动机</li>
<li>Trie</li>
<li>后缀数组</li>
</ul>
</li>
<li>其他
<ul>
<li>数论</li>
<li>计算几何</li>
<li>概率分析</li>
<li>并查集</li>
<li>拓扑网络</li>
<li>矩阵运算
{% endpullquote %}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="本章参考">本章参考：<a hidden class="anchor" aria-hidden="true" href="#本章参考">#</a></h3>
<ul>
<li>复杂度速查表
<a href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>
</ul>
<h2 id="2-基本数据结构">2 基本数据结构<a hidden class="anchor" aria-hidden="true" href="#2-基本数据结构">#</a></h2>
<h3 id="21-线性表">2.1 线性表<a hidden class="anchor" aria-hidden="true" href="#21-线性表">#</a></h3>
<p> 线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。
 数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。
 两种情况下数据的存储问题：
  数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；
  数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”</p>
<h4 id="211-数组">2.1.1 数组<a hidden class="anchor" aria-hidden="true" href="#211-数组">#</a></h4>
<p> 数组是一批相同数据的集合。数组的三部分：<code>地址 大小 和 空间</code>。数组的保存形式为线性表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>]; <span style="color:#75715e">// /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arr1[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> arr6[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcdef&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> NULL;<span style="color:#75715e">//定义一个整型的指针变量，初始化为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> NULL;<span style="color:#75715e">//定义一个字符的指针变量，初始化为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 二维数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C 传递数组给函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myFunction</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>param)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myFunction</span>(<span style="color:#66d9ef">int</span> param[<span style="color:#ae81ff">10</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myFunction</span>(<span style="color:#66d9ef">int</span> param[])
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C 从函数返回数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">myFunction</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>array</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> array {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> used;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">struct</span> array <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; idx <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">-&gt;</span>used; idx<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[%02d]: %08d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, idx, array<span style="color:#f92672">-&gt;</span>arr[idx]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">alloc</span>(<span style="color:#66d9ef">struct</span> array <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    array<span style="color:#f92672">-&gt;</span>arr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(array<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">struct</span> array <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> elem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (array<span style="color:#f92672">-&gt;</span>used <span style="color:#f92672">&gt;=</span> array<span style="color:#f92672">-&gt;</span>size)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; idx <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">-&gt;</span>used; idx<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (array<span style="color:#f92672">-&gt;</span>arr[idx] <span style="color:#f92672">&gt;</span> elem)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">-&gt;</span>used)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memmove</span>(<span style="color:#f92672">&amp;</span>array<span style="color:#f92672">-&gt;</span>arr[idx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], <span style="color:#f92672">&amp;</span>array<span style="color:#f92672">-&gt;</span>arr[idx],
</span></span><span style="display:flex;"><span>            (array<span style="color:#f92672">-&gt;</span>used <span style="color:#f92672">-</span> idx) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    array<span style="color:#f92672">-&gt;</span>arr[idx] <span style="color:#f92672">=</span> elem;
</span></span><span style="display:flex;"><span>    array<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> idx;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">struct</span> array <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> idx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> idx <span style="color:#f92672">&gt;=</span> array<span style="color:#f92672">-&gt;</span>used)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memmove</span>(<span style="color:#f92672">&amp;</span>array<span style="color:#f92672">-&gt;</span>arr[idx], <span style="color:#f92672">&amp;</span>array<span style="color:#f92672">-&gt;</span>arr[idx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>        (array<span style="color:#f92672">-&gt;</span>used <span style="color:#f92672">-</span> idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    array<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">struct</span> array <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> elem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; idx <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">-&gt;</span>used; idx<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (array<span style="color:#f92672">-&gt;</span>arr[idx] <span style="color:#f92672">==</span> elem)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> idx;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (array<span style="color:#f92672">-&gt;</span>arr[idx] <span style="color:#f92672">&gt;</span> elem)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> array ten_int <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>, NULL};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">alloc</span>(<span style="color:#f92672">&amp;</span>ten_int);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ten_int.arr) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== insert 1, 3, 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>ten_int);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">search</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;2 is at position %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, idx);
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">search</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;9 is at position %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, idx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== delete [6] element </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">delete</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>ten_int);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== delete [0] element </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">delete</span>(<span style="color:#f92672">&amp;</span>ten_int, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>ten_int);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<br>
<p><strong>二分搜索</strong>
 基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）
 左闭右闭[left, right]：high = mid - 1;
 左闭右开[left, right)：high = mid;
 二分搜索的时间复杂度为 <em><strong>对数时间O(logn)</strong></em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 左闭 右闭区间  [left, right] 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// low = mid + 1  high = mid - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binary_search</span>(<span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, count1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(low <span style="color:#f92672">&lt;</span> high) {
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> a[mid]) {
</span></span><span style="display:flex;"><span>            high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> a[mid]) {
</span></span><span style="display:flex;"><span>            low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> a[mid]) {
</span></span><span style="display:flex;"><span>            count1<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="212-单链表">2.1.2 单链表<a hidden class="anchor" aria-hidden="true" href="#212-单链表">#</a></h4>
<p>  单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ListElmt_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data;  <span style="color:#75715e">// 数据成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> ListElmt_ <span style="color:#f92672">*</span> next; <span style="color:#75715e">// next指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} ListElmt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> List_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>match)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destroy)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>    ListElmt <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>    ListElmt <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span>} List;
</span></span></code></pre></div><p> 单链表操作：插入、删除、
 如何判断单链表存在回环？
  设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。</p>
<p> 翻转链表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> ListNode <span style="color:#f92672">*</span><span style="color:#a6e22e">reverse</span>(<span style="color:#66d9ef">struct</span> ListNode <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> ListNode <span style="color:#f92672">*</span>res <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (head) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> ListNode <span style="color:#f92672">*</span>pre_node <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        pre_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> res;
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> pre_node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>singleList</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifndef __SINGLELIST_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __SINGLELIST_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> listNode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> listNode <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value;
</span></span><span style="display:flex;"><span>}listNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> linkedList {
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> typesize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>dup)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>match)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>free)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>}linkedList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define listSetDupMethod(l,m) ((l)-&gt;dup = (m))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define listSetFreeMethod(l,m) ((l)-&gt;free = (m))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define listSetMatchMethod(l,m) ((l)-&gt;match = (m))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define listGetDupMethod(l) ((l)-&gt;dup)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define listGetFree(l) ((l)-&gt;free)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define listGetMatchMethod(l) ((l)-&gt;match)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span><span style="color:#a6e22e">listCreate</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listRelease</span>(linkedList <span style="color:#f92672">*</span>list);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listEmpty</span>(linkedList <span style="color:#f92672">*</span>list);
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span><span style="color:#a6e22e">listAddNodeHead</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value);
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span><span style="color:#a6e22e">listAddNodeTail</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value);
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span><span style="color:#a6e22e">listInsertNode</span>(linkedList <span style="color:#f92672">*</span>list, listNode <span style="color:#f92672">*</span>old_node, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value, <span style="color:#66d9ef">bool</span> after);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listDelNode</span>(linkedList <span style="color:#f92672">*</span>list, listNode <span style="color:#f92672">*</span>node);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span><span style="color:#a6e22e">listSearchKey</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span><span style="color:#a6e22e">listIndex</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">long</span> index);
</span></span><span style="display:flex;"><span>linkedList<span style="color:#f92672">*</span> <span style="color:#a6e22e">listRewind</span>(linkedList <span style="color:#f92672">*</span>list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">listLength</span>(linkedList <span style="color:#f92672">*</span>list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// !__SINGLELIST_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;singleList.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span> <span style="color:#a6e22e">listCreate</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    linkedList <span style="color:#f92672">*</span>list <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>list));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>dup <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>match <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listRelease</span>(linkedList <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">listEmpty</span>(list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(list);
</span></span><span style="display:flex;"><span>    list <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listEmpty</span>(linkedList <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (NULL <span style="color:#f92672">!=</span> list<span style="color:#f92672">-&gt;</span>head) {
</span></span><span style="display:flex;"><span>        listNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">!=</span> list<span style="color:#f92672">-&gt;</span>free) {
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">free</span>(pNode<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(pNode<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        pNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(pNode);
</span></span><span style="display:flex;"><span>        pNode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span> <span style="color:#a6e22e">listAddNodeHead</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list <span style="color:#f92672">||</span> NULL <span style="color:#f92672">==</span> value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>node));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>list<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span> <span style="color:#a6e22e">listAddNodeTail</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list <span style="color:#f92672">||</span> NULL <span style="color:#f92672">==</span> value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>node));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">&amp;&amp;</span> list<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        listNode <span style="color:#f92672">*</span>tail <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        listNode <span style="color:#f92672">*</span>pre <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (NULL <span style="color:#f92672">!=</span> tail) {
</span></span><span style="display:flex;"><span>            pre <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>            tail <span style="color:#f92672">=</span> tail<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>list<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>linkedList <span style="color:#f92672">*</span> <span style="color:#a6e22e">listInsertNode</span>(linkedList <span style="color:#f92672">*</span>list, listNode <span style="color:#f92672">*</span>old_node, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value, <span style="color:#66d9ef">bool</span> after)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list <span style="color:#f92672">||</span> NULL <span style="color:#f92672">==</span> old_node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    pNode <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>pNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> pNode) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pNode<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (after) {
</span></span><span style="display:flex;"><span>        pNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> old_node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        old_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pNode;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        listNode <span style="color:#f92672">*</span>pre <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> old_node) {
</span></span><span style="display:flex;"><span>            pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">!=</span> pre) {
</span></span><span style="display:flex;"><span>            pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pNode;
</span></span><span style="display:flex;"><span>            pNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> old_node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>list<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listDelNode</span>(linkedList <span style="color:#f92672">*</span>list, listNode <span style="color:#f92672">*</span>node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list <span style="color:#f92672">||</span> NULL <span style="color:#f92672">==</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>pre <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (NULL <span style="color:#f92672">!=</span> cur <span style="color:#f92672">&amp;&amp;</span> cur <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> pre) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">--</span>list<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">!=</span> list<span style="color:#f92672">-&gt;</span>free) {
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">free</span>(node<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(node);
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span> <span style="color:#a6e22e">listSearchKey</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (NULL <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">!=</span> list<span style="color:#f92672">-&gt;</span>match) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">match</span>(key, node<span style="color:#f92672">-&gt;</span>value) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>value) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span> <span style="color:#a6e22e">listIndex</span>(linkedList <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">long</span> index)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> index <span style="color:#f92672">&gt;</span> list<span style="color:#f92672">-&gt;</span>len) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> index; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        pNode <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pNode;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>linkedList<span style="color:#f92672">*</span> <span style="color:#a6e22e">listRewind</span>(linkedList <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>pre <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (NULL <span style="color:#f92672">!=</span> head) {
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pre;
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> pre;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">listLength</span>(linkedList <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">==</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>single_list</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> single_list {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> single_list_head {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_empty</span>(<span style="color:#66d9ef">struct</span> single_list_head <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">struct</span> single_list_head <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (tmp) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[%02d]: %08d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, idx<span style="color:#f92672">++</span>, tmp<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">**</span>prev, <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>elem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prev)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    elem<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> elem;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_head</span>(<span style="color:#66d9ef">struct</span> single_list_head <span style="color:#f92672">*</span>head, <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>elem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>head<span style="color:#f92672">-&gt;</span>head, elem);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> single_list<span style="color:#f92672">*</span> <span style="color:#a6e22e">del</span>(<span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">**</span>prev)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prev)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>prev <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>prev)<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    tmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> single_list<span style="color:#f92672">*</span> <span style="color:#a6e22e">delete_head</span>(<span style="color:#66d9ef">struct</span> single_list_head<span style="color:#f92672">*</span> head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">del</span>(<span style="color:#f92672">&amp;</span>head<span style="color:#f92672">-&gt;</span>head);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> single_list<span style="color:#f92672">**</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">struct</span> single_list_head<span style="color:#f92672">*</span> head, <span style="color:#66d9ef">int</span> target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">**</span>prev, <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>head<span style="color:#f92672">-&gt;</span>head, tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>prev; tmp <span style="color:#f92672">&amp;&amp;</span> (tmp<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> target);
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>tmp<span style="color:#f92672">-&gt;</span>next, tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>prev);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prev;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse</span>(<span style="color:#66d9ef">struct</span> single_list_head<span style="color:#f92672">*</span> head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list_head tmp <span style="color:#f92672">=</span> {NULL};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>elem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">is_empty</span>(head)) {
</span></span><span style="display:flex;"><span>        elem <span style="color:#f92672">=</span> <span style="color:#a6e22e">delete_head</span>(head);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">insert_head</span>(<span style="color:#f92672">&amp;</span>tmp, elem);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    head<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> tmp.head;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_cyclic</span>(<span style="color:#66d9ef">struct</span> single_list_head<span style="color:#f92672">*</span> head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>s1, <span style="color:#f92672">*</span>s2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    s1 <span style="color:#f92672">=</span> s2 <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(s1 <span style="color:#f92672">&amp;&amp;</span> s2) {
</span></span><span style="display:flex;"><span>        s1 <span style="color:#f92672">=</span> s1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        s2 <span style="color:#f92672">=</span> s2<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">?</span> s2<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next:s2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s1 <span style="color:#f92672">==</span> s2)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> single_list<span style="color:#f92672">*</span> <span style="color:#a6e22e">middle</span>(<span style="color:#66d9ef">struct</span> single_list_head<span style="color:#f92672">*</span> head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">*</span>s1, <span style="color:#f92672">*</span>s2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list pseudo_head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pseudo_head.next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    s1 <span style="color:#f92672">=</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pseudo_head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s2 <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s2<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> s1;
</span></span><span style="display:flex;"><span>        s1 <span style="color:#f92672">=</span> s1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        s2 <span style="color:#f92672">=</span> s2<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list_head head <span style="color:#f92672">=</span> {NULL};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list lists[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> single_list <span style="color:#f92672">**</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; idx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; idx<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        lists[idx].val <span style="color:#f92672">=</span> idx;
</span></span><span style="display:flex;"><span>        lists[idx].next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_head</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">6</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_head</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">5</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_head</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">4</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_head</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_head</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== insert 0, 1, 4, 5, 6</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> <span style="color:#a6e22e">search</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(prev, <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== insert 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;middle elem is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">middle</span>(<span style="color:#f92672">&amp;</span>head)<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> <span style="color:#a6e22e">search</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>prev) <span style="color:#f92672">&amp;&amp;</span> ((<span style="color:#f92672">*</span>prev)<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The list contains 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The list not contains 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">del</span>(prev);
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> <span style="color:#a6e22e">search</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After remove 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>prev) <span style="color:#f92672">&amp;&amp;</span> ((<span style="color:#f92672">*</span>prev)<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The list contains 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The list not contains 2</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After reverse </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">reverse</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;middle elem is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">middle</span>(<span style="color:#f92672">&amp;</span>head)<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lists[<span style="color:#ae81ff">0</span>].next <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>lists[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;list is%s cyclic</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">is_cyclic</span>(<span style="color:#f92672">&amp;</span>head)<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34; not&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>LinkedListAlgo</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 1) 单链表反转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 2) 链表中环的检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 3) 两个有序的链表合并
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 4) 删除链表倒数第 n 个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 5) 求链表的中间结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Author: Smallfly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> SinglyLinkedNode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> SinglyLinkedNode<span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>} SinglyLinkedNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertNode</span>(SinglyLinkedNode<span style="color:#f92672">**</span> head_ref, <span style="color:#66d9ef">int</span> data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printLinkedList</span>(SinglyLinkedNode<span style="color:#f92672">*</span> head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 反转单链表 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse</span>(SinglyLinkedNode<span style="color:#f92672">**</span> head_ref) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>head_ref <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SinglyLinkedNode <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode <span style="color:#f92672">*</span>current <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head_ref;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (current) {
</span></span><span style="display:flex;"><span>        SinglyLinkedNode <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 到达尾结点时，将地址存入 head_ref
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">*</span>head_ref <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>        current <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_reverse</span>() {
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">reverse</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printLinkedList</span>(head);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 检测单链表是否有环 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这里使用一级指针也可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">checkCircle</span>(SinglyLinkedNode<span style="color:#f92672">**</span> head_ref) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>head_ref <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode <span style="color:#f92672">*</span>slow <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head_ref, <span style="color:#f92672">*</span>fast <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head_ref;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (slow <span style="color:#f92672">==</span> fast) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_checkCircle</span>() {
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">checkCircle</span>(<span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;has circle: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result1);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// make circle linklist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SinglyLinkedNode<span style="color:#f92672">*</span> current <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(SinglyLinkedNode));
</span></span><span style="display:flex;"><span>    current<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> h <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        SinglyLinkedNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(SinglyLinkedNode));
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//reset current node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        current <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    current<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> h;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">checkCircle</span>(<span style="color:#f92672">&amp;</span>h);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;has circle: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 有序链表合并 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">moveNode</span>(SinglyLinkedNode<span style="color:#f92672">**</span> dest_ref, SinglyLinkedNode<span style="color:#f92672">**</span> src_ref);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SinglyLinkedNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">mergeSortedLinkedList</span>(SinglyLinkedNode<span style="color:#f92672">*</span> la, SinglyLinkedNode<span style="color:#f92672">*</span> lb) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 辅助结点，next 指针持有合并后的有序链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SinglyLinkedNode dummy;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 有序链表的尾结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SinglyLinkedNode<span style="color:#f92672">*</span> tail <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>dummy;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果有一个链表为空，直接与另一个链表接起来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>la) {
</span></span><span style="display:flex;"><span>            tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> lb;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>lb) {
</span></span><span style="display:flex;"><span>            tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> la;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将头结点较小的优先添加到 tail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (la<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;=</span> lb<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">moveNode</span>(<span style="color:#f92672">&amp;</span>(tail<span style="color:#f92672">-&gt;</span>next), <span style="color:#f92672">&amp;</span>la);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">moveNode</span>(<span style="color:#f92672">&amp;</span>(tail<span style="color:#f92672">-&gt;</span>next), <span style="color:#f92672">&amp;</span>lb);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        tail <span style="color:#f92672">=</span> tail<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dummy.next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将 src_ref 的头结点，添加到 dest_ref 的头部。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">moveNode</span>(SinglyLinkedNode<span style="color:#f92672">**</span> dest_ref, SinglyLinkedNode<span style="color:#f92672">**</span> src_ref) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>src_ref <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> new_node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>src_ref;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>src_ref <span style="color:#f92672">=</span> new_node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    new_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>dest_ref;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>dest_ref <span style="color:#f92672">=</span> new_node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_mergeSortedLinkedList</span>() {
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>a, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>a, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>a, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> b <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>b, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>b, <span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>b, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> result <span style="color:#f92672">=</span> <span style="color:#a6e22e">mergeSortedLinkedList</span>(a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printLinkedList</span>(result);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> result2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">mergeSortedLinkedList</span>(a, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printLinkedList</span>(result2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 删除倒数第 K 个结点 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteLastKth</span>(SinglyLinkedNode<span style="color:#f92672">**</span> head_ref, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>head_ref <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 快指针向前移动 k-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SinglyLinkedNode<span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head_ref;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">&amp;&amp;</span> fast <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果快指针为空，说明结点个数小于 k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (fast <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> slow <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head_ref;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> slow;
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果 prev 为空，头结点刚好是第 k 个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>prev) {
</span></span><span style="display:flex;"><span>        (<span style="color:#f92672">*</span>head_ref) <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>head_ref)<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(slow);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_deleteLastKth</span>() {
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 删除头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">deleteLastKth</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printLinkedList</span>(head);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 删除中间结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">deleteLastKth</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printLinkedList</span>(head);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 求中间结点  */</span>
</span></span><span style="display:flex;"><span>SinglyLinkedNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">findMiddleNode</span>(SinglyLinkedNode<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> slow <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 慢指针走一步，快指针两步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> slow;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_findMiddleNode</span>() {
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertNode</span>(<span style="color:#f92672">&amp;</span>head, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> middleNode <span style="color:#f92672">=</span> <span style="color:#a6e22e">findMiddleNode</span>(head);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, middleNode<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printLinkedList</span>(head);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 工具方法 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 插入新结点到链表头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertNode</span>(SinglyLinkedNode<span style="color:#f92672">**</span> head_ref, <span style="color:#66d9ef">int</span> data) {
</span></span><span style="display:flex;"><span>    SinglyLinkedNode<span style="color:#f92672">*</span> new_node <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(SinglyLinkedNode));
</span></span><span style="display:flex;"><span>    new_node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    new_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head_ref;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>head_ref <span style="color:#f92672">=</span> new_node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printLinkedList</span>(SinglyLinkedNode<span style="color:#f92672">*</span> node) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;--- start ---</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (node) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;data: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, node<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;--- end ---</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 跑测试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_reverse</span>();  
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    test_checkCircle();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    test_mergeSortedLinkedList();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    test_deleteLastKth();  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    test_findMiddleNode();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></details>
<details>
<summary>linklist_jinshaohui</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; File Name: lisklist.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Author:  jinshaohui
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Mail:    jinshaohui789@163.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Time:    18-10-07  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ************************************************************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> stlistNode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> listNode <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}listNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*反转链表*/</span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#a6e22e">reverseList</span>(listNode <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(head <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prev;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*判断链表是否有环*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hasCycle</span>(listNode <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span> low <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(fast <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        low <span style="color:#f92672">=</span> low<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">==</span> fast) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*合并有序链表*/</span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span><span style="color:#a6e22e">mergeTwoLists</span>(listNode <span style="color:#f92672">*</span>l1,listNode <span style="color:#f92672">*</span>l2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode head <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>pRes <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(l1 <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            pRes<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> l2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (l2 <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            pRes<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> l1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(l1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> l2<span style="color:#f92672">-&gt;</span>val) {
</span></span><span style="display:flex;"><span>            pRes<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> l1;
</span></span><span style="display:flex;"><span>            l1 <span style="color:#f92672">=</span> l1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            pRes<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> l2;
</span></span><span style="display:flex;"><span>            l2 <span style="color:#f92672">=</span> l2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pRes <span style="color:#f92672">=</span> pRes<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *删除链表倒数第n个节点，并返回链表头节点 */</span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span> <span style="color:#a6e22e">removeNthFromEnd</span>(listNode<span style="color:#f92672">*</span>headi,<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>fast <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    listNpde <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*快指针往后移动k-1*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>((k <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;&amp;</span> (fast <span style="color:#f92672">!=</span> NULL)) {
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        k<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*说明链表数目不足n个*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fast <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(prev <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*求链表的中间节点*/</span>
</span></span><span style="display:flex;"><span>listNode <span style="color:#f92672">*</span><span style="color:#a6e22e">middleNode</span>(listNode <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span> low <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(fast <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        low <span style="color:#f92672">=</span> low<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> low;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="213-双链表">2.1.3 双链表<a hidden class="anchor" aria-hidden="true" href="#213-双链表">#</a></h4>
<p>  双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> DListElmt_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> DListElmt_ <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> DListElmt_ <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} DListElmt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> DList_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>match)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destroy)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>    DListElmt <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>    DListElmt <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span>} DList;
</span></span></code></pre></div><details>
<summary>Dlist</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Dlist.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> DlistNode {    <span style="color:#75715e">//双向链表中每一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> DlistNode <span style="color:#f92672">*</span>prev;   <span style="color:#75715e">//节点前项指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> DlistNode <span style="color:#f92672">*</span>next;   <span style="color:#75715e">//节点后项指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span>    data;              <span style="color:#75715e">//数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}stDlistNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Dlisthead {    <span style="color:#75715e">//定义链表总体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> size;                 <span style="color:#75715e">//链表长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    stDlistNode <span style="color:#f92672">*</span>head;        <span style="color:#75715e">//头指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    stDlistNode <span style="color:#f92672">*</span>tail;        <span style="color:#75715e">//尾部指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}stDlistHead;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dlist.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;./Dlist.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dlist_init</span>(stDlistHead <span style="color:#f92672">*</span>dlist)    <span style="color:#75715e">//链表初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    dlist<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dlist_destory</span>(stDlistHead <span style="color:#f92672">*</span>dlist)    <span style="color:#75715e">//删除链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    stDlistNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        pNode <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(pNode);
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(dlist,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(stDlistHead));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dlist_insert_head</span>(stDlistHead <span style="color:#f92672">*</span>dlist,stDlistNode <span style="color:#f92672">*</span>pNode,<span style="color:#66d9ef">int</span> data)    <span style="color:#75715e">//插入头结点，操作的链表，操作的节点，数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pNode <span style="color:#f92672">==</span> NULL) {   <span style="color:#75715e">//当只传递一个数据时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pNode <span style="color:#f92672">=</span> (stDlistNode <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(stDlistNode));    <span style="color:#75715e">//新建节点，为节点分配空间（malloc（）可能需要#include&lt;malloc.h&gt;）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pNode <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pNode<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;    
</span></span><span style="display:flex;"><span>    pNode<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    pNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {  <span style="color:#75715e">//如果链表长度为0，即链表当前无节点，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> pNode;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> pNode;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {                 <span style="color:#75715e">//如果链表已有节点，则令新插入节点为头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> pNode;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> pNode;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dlist<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">++</span>;    <span style="color:#75715e">//每成功调用一次，链表长度+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stDlistNode <span style="color:#f92672">*</span> <span style="color:#a6e22e">dlist_remove_tail</span>(stDlistHead <span style="color:#f92672">*</span>dlist)    <span style="color:#75715e">//删除尾部节点,并返回删除节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    stDlistNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pNode <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dlist<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pNode;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dlist_remove_node</span>(stDlistHead <span style="color:#f92672">*</span> dlist,stDlistNode <span style="color:#f92672">*</span>pNode)     <span style="color:#75715e">//删除指定节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((dlist <span style="color:#f92672">==</span> NULL)<span style="color:#f92672">||</span>(pNode <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> pNode) {
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (dlist<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">==</span> pNode) {
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>        dlist<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        pNode<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        pNode<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dlist<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    pNode<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    pNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memset</span>(dlist,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(stDlistHead));     <span style="color:#75715e">//将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>stDlistNode <span style="color:#f92672">*</span> <span style="color:#a6e22e">dlist_search</span>(stDlistHead <span style="color:#f92672">*</span> dlist,<span style="color:#66d9ef">int</span> data)     <span style="color:#75715e">//根据值搜索节点，并返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    stDlistNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(pNode <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pNode<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> data) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> pNode;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pNode <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dlist_dump</span>(stDlistHead <span style="color:#f92672">*</span>dlist)    <span style="color:#75715e">//显示链表中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> no <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    stDlistNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> dlist<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(pNode <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> [%d] = %d&#34;</span>,no<span style="color:#f92672">++</span>,pNode<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        pNode <span style="color:#f92672">=</span> pNode<span style="color:#f92672">-&gt;</span>next;    <span style="color:#75715e">//将pNode的下一个节点赋值给pNode，推进循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Lru_dlist</span>(stDlistHead <span style="color:#f92672">*</span>dlist,<span style="color:#66d9ef">int</span> data)     <span style="color:#75715e">//LRU（最近最少使用）缓存淘汰算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    stDlistNode <span style="color:#f92672">*</span>pNode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pNode <span style="color:#f92672">=</span> <span style="color:#a6e22e">dlist_search</span>(dlist,data);    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pNode <span style="color:#f92672">!=</span> NULL) {    <span style="color:#75715e">//如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">dlist_remove_node</span>(dlist,pNode);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(dlist<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">4</span>)    {    <span style="color:#75715e">//没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pNode <span style="color:#f92672">=</span> <span style="color:#a6e22e">dlist_remove_tail</span>(dlist);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_insert_head</span>(dlist ,pNode,data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    stDlistHead dlist <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    stDlistNode <span style="color:#f92672">*</span> pNode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_init</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> inset 1,2,3&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_insert_head</span>(<span style="color:#f92672">&amp;</span>dlist,NULL,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_insert_head</span>(<span style="color:#f92672">&amp;</span>dlist,NULL,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_insert_head</span>(<span style="color:#f92672">&amp;</span>dlist,NULL,<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_dump</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pNode <span style="color:#f92672">=</span> <span style="color:#a6e22e">dlist_remove_tail</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pNode <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> remove %d&#34;</span>,pNode<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_insert_head</span>(<span style="color:#f92672">&amp;</span>dlist,pNode,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_dump</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Lru_dlist</span>(<span style="color:#f92672">&amp;</span>dlist,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_dump</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Lru_dlist</span>(<span style="color:#f92672">&amp;</span>dlist,<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_dump</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Lru_dlist</span>(<span style="color:#f92672">&amp;</span>dlist,<span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_dump</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Lru_dlist</span>(<span style="color:#f92672">&amp;</span>dlist,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dlist_dump</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(dlist.size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        pNode <span style="color:#f92672">=</span> <span style="color:#a6e22e">dlist_remove_tail</span>(<span style="color:#f92672">&amp;</span>dlist);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pNode <span style="color:#f92672">!=</span> NULL) { 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> remove %d&#34;</span>,pNode<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span> (pNode);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>linux/list</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// linux内核源码双向链表实现include/linux/list.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef _LIST_HEAD_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _LIST_HEAD_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 双向链表节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> list_head {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>next, <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define LIST_HEAD(name) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    struct list_head name = LIST_HEAD_INIT(name)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">INIT_LIST_HEAD</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> list;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加节点：将new插入到prev和next之间。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__list_add</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>new,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>prev,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>next)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>    new<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    new<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>    prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加new节点：将new添加到head之后，是new称为head的后继节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">list_add</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>new, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__list_add</span>(new, head, head<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">list_add_tail</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>new, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__list_add</span>(new, head<span style="color:#f92672">-&gt;</span>prev, head);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从双链表中删除entry节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__list_del</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span> prev, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span> next)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>    prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从双链表中删除entry节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">list_del</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__list_del</span>(entry<span style="color:#f92672">-&gt;</span>prev, entry<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从双链表中删除entry节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__list_del_entry</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__list_del</span>(entry<span style="color:#f92672">-&gt;</span>prev, entry<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">list_del_init</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>entry)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__list_del_entry</span>(entry);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">INIT_LIST_HEAD</span>(entry);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 用new节点取代old节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">list_replace</span>(<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>old,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>new)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    new<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> old<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    new<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>    new<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> old<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>    new<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 双链表是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">list_empty</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> head;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取&#34;MEMBER成员&#34;在&#34;结构体TYPE&#34;中的位置偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 根据&#34;结构体(type)变量&#34;中的&#34;域成员变量(member)的指针(ptr)&#34;来获取指向整个结构体变量的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define container_of(ptr, type, member) ({          \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (type *)( (char *)__mptr - offsetof(type,member) );})
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 遍历双向链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define list_for_each(pos, head) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define list_for_each_safe(pos, n, head) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        pos = n, n = pos-&gt;next)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define list_entry(ptr, type, member) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    container_of(ptr, type, member)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div></details>
<h4 id="214-跳表">2.1.4 跳表<a hidden class="anchor" aria-hidden="true" href="#214-跳表">#</a></h4>
<p> 跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。</p>
<details>
<summary>skiplist</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; File Name: skiplist.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Author:  jinshaohui
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Mail:    jinshaohui789@163.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Time:    18-10-31
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Desc:    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ************************************************************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef __SKIP_LIST_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __SKIP_LIST_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> key;    <span style="color:#75715e">/*key是唯一的*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value;  <span style="color:#75715e">/*存储的内容*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> max_level; <span style="color:#75715e">/*当前节点最大层数*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _node <span style="color:#f92672">*</span>next[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">/*level层链表结构*/</span>
</span></span><span style="display:flex;"><span>}node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _skiplist {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> level;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>}skiplist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*根据当前结构体元素的地址，获取到结构体首地址*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define container(ptr,type,member) ({\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  (type *) ( (char *)__mptr - offsetof(type,member));})
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;./skiplist.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*创建node节点*/</span>
</span></span><span style="display:flex;"><span>node<span style="color:#f92672">*</span> <span style="color:#a6e22e">skip_list_create_node</span>(<span style="color:#66d9ef">int</span> level,<span style="color:#66d9ef">int</span> key,<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span>(node <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(node) <span style="color:#f92672">+</span> level<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(node <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(tmp <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(tmp,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(node) <span style="color:#f92672">+</span> level<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(node<span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>    tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>    tmp<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    tmp<span style="color:#f92672">-&gt;</span>max_level <span style="color:#f92672">=</span> level;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*创建跳表的表头，max_level层数*/</span>
</span></span><span style="display:flex;"><span>skiplist <span style="color:#f92672">*</span> <span style="color:#a6e22e">skip_list_create</span>(<span style="color:#66d9ef">int</span> max_level)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    skiplist <span style="color:#f92672">*</span> list <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list <span style="color:#f92672">=</span> (skiplist <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span> (<span style="color:#66d9ef">sizeof</span>(skiplist));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(list <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_create_node</span>(max_level,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(list);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*skiplist 销毁*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">skip_list_destory</span>(skiplist <span style="color:#f92672">*</span> list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>((list <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>next[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(list<span style="color:#f92672">-&gt;</span>head);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(list);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*插入元素获得层数，是随机产生的*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">skip_list_level</span>(skiplist <span style="color:#f92672">*</span> list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> level <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>max_level; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((<span style="color:#a6e22e">rand</span>()<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            level<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> level;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">skip_list_insert</span>(skiplist <span style="color:#f92672">*</span>list,<span style="color:#66d9ef">int</span> key,<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> level <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">**</span>update <span style="color:#f92672">=</span> NULL;<span style="color:#75715e">/*用来更新每层的指针*/</span>
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (list <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*申请update空间用于保存每层的指针*/</span>
</span></span><span style="display:flex;"><span>    update <span style="color:#f92672">=</span> (node <span style="color:#f92672">**</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(node <span style="color:#f92672">*</span>)<span style="color:#f92672">*</span>list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>max_level);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (update <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*逐层查询节点的*/</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> (list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*初始化每level层的头指针*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(((tmp <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>next[i]) <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> key)) {
</span></span><span style="display:flex;"><span>            prev  <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        update[i] <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*当前key已经存在，返回错误*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((tmp<span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*获取插入元素的随机层数，并更新跳表的最大层数*/</span>
</span></span><span style="display:flex;"><span>    level <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_level</span>(list);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*创建当前数据节点*/</span>
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_create_node</span>(level,key,value);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (tmp <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*更新最大层数*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (level <span style="color:#f92672">&gt;</span> list<span style="color:#f92672">-&gt;</span>level) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>level;i <span style="color:#f92672">&lt;</span> level; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            update[i] <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">=</span> level;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*逐层更新节点的指针*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> level; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        tmp<span style="color:#f92672">-&gt;</span>next[i] <span style="color:#f92672">=</span> update[i]<span style="color:#f92672">-&gt;</span>next[i];
</span></span><span style="display:flex;"><span>        update[i]<span style="color:#f92672">-&gt;</span>next[i] <span style="color:#f92672">=</span> tmp; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">skip_list_delete</span>(skiplist <span style="color:#f92672">*</span> list, <span style="color:#66d9ef">int</span> key ,<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">**</span>update <span style="color:#f92672">=</span> NULL;<span style="color:#75715e">/*用来更新每层的指针*/</span>
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((list <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (value <span style="color:#f92672">==</span> NULL)<span style="color:#f92672">&amp;&amp;</span> (list<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*申请update空间用于保存每层的指针*/</span>
</span></span><span style="display:flex;"><span>    update <span style="color:#f92672">=</span> (node <span style="color:#f92672">**</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(node <span style="color:#f92672">*</span>)<span style="color:#f92672">*</span>list<span style="color:#f92672">-&gt;</span>level);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (update <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*逐层查询节点的*/</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> (list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*初始化每level层的头指针*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(((tmp <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>next[i]) <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> key)) {
</span></span><span style="display:flex;"><span>            prev <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        update[i] <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((tmp <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key)) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>value <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*逐层删除*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> list<span style="color:#f92672">-&gt;</span>level; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(update[i]<span style="color:#f92672">-&gt;</span>next[i] <span style="color:#f92672">==</span> tmp) {
</span></span><span style="display:flex;"><span>                update[i]<span style="color:#f92672">-&gt;</span>next[i] <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>next[i];       
</span></span><span style="display:flex;"><span>            }    
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*更新level的层数*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next[i] <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>                list<span style="color:#f92672">-&gt;</span>level<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>;<span style="color:#75715e">/*未找到节点*/</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">skip_list_search</span>(skiplist <span style="color:#f92672">*</span>list,<span style="color:#66d9ef">int</span> key,<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>((list <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (list<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (value <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(((tmp <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>next[i]) <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;=</span> key)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (tmp<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">*</span>value <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            prev <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">skip_list_dump</span>(skiplist <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">*</span>ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">----------------------------------------------&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> skip list level[%d],count[%d]&#34;</span>,list<span style="color:#f92672">-&gt;</span>level,list<span style="color:#f92672">-&gt;</span>count);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        ptmp <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next[i];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> level[%d]:&#34;</span>,i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(ptmp <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d-%d &#34;</span>,ptmp<span style="color:#f92672">-&gt;</span>key,ptmp<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>            ptmp <span style="color:#f92672">=</span> ptmp<span style="color:#f92672">-&gt;</span>next[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">----------------------------------------------&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    skiplist <span style="color:#f92672">*</span>list <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    list <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_create</span>(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(list <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> 请输入key 和 value，当key = 1000时，退出输入：&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>key,<span style="color:#f92672">&amp;</span>value);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> <span style="color:#ae81ff">1000</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_insert</span>(list,key,value);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> skip list insert %d,failed,res=%d.&#34;</span>,key,res);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">skip_list_dump</span>(list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> 通过key 查询value的数值，当key = 1000时，退出查询&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">==</span> <span style="color:#ae81ff">1000</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_search</span>(list,key,<span style="color:#f92672">&amp;</span>value);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> skip list search %d,failed,res=%d.&#34;</span>,key,res);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> skip list search %d,sucessful,value=%d.&#34;</span>,key,value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">skip_list_dump</span>(list);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> 通过key 删除节点，当key = 1000时，退出删除&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">==</span> <span style="color:#ae81ff">1000</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> <span style="color:#a6e22e">skip_list_delete</span>(list,key,<span style="color:#f92672">&amp;</span>value);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> skip list search %d,failed,res=%d.&#34;</span>,key,res);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> skip list search %d,sucessful,value=%d.&#34;</span>,key,value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">skip_list_dump</span>(list);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">skip_list_destory</span>(list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="215-栈">2.1.5 栈<a hidden class="anchor" aria-hidden="true" href="#215-栈">#</a></h4>
<p> 栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。
 可通过链表来实现栈stack,允许插入和删除的为栈顶(<code>top</code>),另一端为栈底(<code>bottom</code>),栈中每个元素为<code>frame</code>,栈只支持三个操作:<code>pop</code>,<code>top</code>,<code>push</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> List Stack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define stack_init list_init;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">stack_push</span>(Stack <span style="color:#f92672">*</span>stack, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">stack_pop</span>(Stack <span style="color:#f92672">*</span>stack, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>data);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define stack_size list_size;
</span></span></span></code></pre></div><p> c语言顺序栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 元素elem进栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> top, <span style="color:#66d9ef">char</span> elem) {
</span></span><span style="display:flex;"><span>    a[<span style="color:#f92672">++</span>top] <span style="color:#f92672">=</span> elem;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> top;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数据元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> top)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (top <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    top<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> top;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>arrayStack</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; File Name: arrayStack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Author:  jinshaohui
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Mail:    jinshaohui789@163.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Time:    18-10-12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Desc:   数组实现顺序栈 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ************************************************************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef ARRAY_STACJ_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ARRAY_STACJ_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _array_stack {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;<span style="color:#75715e">/*栈的大小*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pos;<span style="color:#75715e">/*当前存储元素的个数，即栈顶元素下表*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;<span style="color:#75715e">/*数据存储区*/</span>
</span></span><span style="display:flex;"><span>}stArrayStack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define arrayStack_size(arrayStack) (arrayStack-&gt;size)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arrayStack_is_empty(arrayStack) (arrayStack-&gt;pos == -1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define arrayStack_is_full(arrayStack)  (arrayStack-&gt;pos == (arrayStack-&gt;size-1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;./arrayStack.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*创建并初始化顺序栈*/</span>
</span></span><span style="display:flex;"><span>stArrayStack <span style="color:#f92672">*</span> <span style="color:#a6e22e">arrayStack_create</span>(<span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    stArrayStack <span style="color:#f92672">*</span>parrStack <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    parrStack <span style="color:#f92672">=</span> (stArrayStack <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(stArrayStack));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (parrStack <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">*</span>size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(parrStack<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(parrStack);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> parrStack;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*销毁顺序栈*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arrayStack_destory</span>(stArrayStack <span style="color:#f92672">*</span> parrStack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(parrStack <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (parrStack<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(parrStack<span style="color:#f92672">-&gt;</span>array);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(parrStack);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*出栈*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">arrayStack_pop</span>(stArrayStack <span style="color:#f92672">*</span>parrStack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">arrayStack_is_empty</span>(parrStack)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> parrStack<span style="color:#f92672">-&gt;</span>array[parrStack<span style="color:#f92672">-&gt;</span>pos];
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>pos<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> data;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*入栈*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">arrayStack_push</span>(stArrayStack <span style="color:#f92672">*</span>parrStack,<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">arrayStack_is_full</span>(parrStack)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>pos<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>array[parrStack<span style="color:#f92672">-&gt;</span>pos] <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">arrayStack_push_new</span>(stArrayStack<span style="color:#f92672">*</span>parrStack,<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*如果栈不满，直接插入*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">arrayStack_is_full</span>(parrStack)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arrayStack_push</span>(parrStack,data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*如果栈已经满，申请内存*/</span>
</span></span><span style="display:flex;"><span>    ptmp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>parrStack<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ptmp <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(ptmp,parrStack<span style="color:#f92672">-&gt;</span>array,parrStack<span style="color:#f92672">-&gt;</span>size<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(parrStack<span style="color:#f92672">-&gt;</span>array);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">=</span> ptmp;
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>parrStack<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>pos<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>array[parrStack<span style="color:#f92672">-&gt;</span>pos] <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">arrayStack_dump</span>(stArrayStack <span style="color:#f92672">*</span>parrStack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">arrayStack_is_empty</span>(parrStack)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> arrayStack is empty.&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">arrayStack size = %d,pos= %d,&#34;</span>,
</span></span><span style="display:flex;"><span>    parrStack<span style="color:#f92672">-&gt;</span>size,parrStack<span style="color:#f92672">-&gt;</span>pos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> parrStack<span style="color:#f92672">-&gt;</span>pos; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">arry[%d] = %d&#34;</span>,i,parrStack<span style="color:#f92672">-&gt;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    stArrayStack <span style="color:#f92672">*</span> parrStack <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> create size = 4 arrayStack.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    parrStack <span style="color:#f92672">=</span> <span style="color:#a6e22e">arrayStack_create</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (parrStack <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> create size = 4 arrayStack faided.&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">arrayStack_push</span>(parrStack,i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> push size = %d arrayStack faided.&#34;</span>,i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">arrayStack_dump</span>(parrStack);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">arrayStack_push_new</span>(parrStack,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> push size = %d arrayStack faided.&#34;</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">arrayStack_dump</span>(parrStack);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">arrayStack_destory</span>(parrStack);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p> 链栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> lineStack {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> lineStack <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}lineStack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lineStack<span style="color:#f92672">*</span> <span style="color:#a6e22e">push</span>(lineStack <span style="color:#f92672">*</span> stack, <span style="color:#66d9ef">char</span> a){
</span></span><span style="display:flex;"><span>    lineStack <span style="color:#f92672">*</span> line<span style="color:#f92672">=</span>(lineStack<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(lineStack));
</span></span><span style="display:flex;"><span>    line<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>a;
</span></span><span style="display:flex;"><span>    line<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>stack;
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">=</span>line;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> stack;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lineStack <span style="color:#f92672">*</span> <span style="color:#a6e22e">pop</span>(lineStack <span style="color:#f92672">*</span> stack){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (stack) {
</span></span><span style="display:flex;"><span>        lineStack <span style="color:#f92672">*</span> p<span style="color:#f92672">=</span>stack;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">=</span>stack<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;弹栈元素：%c &#34;</span>,p<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (stack) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;栈顶元素：%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,stack<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;栈已空</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;栈内没有元素&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stack;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> stack;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>linklist_stack</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; File Name: linklist_stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Author:  jinshaohui
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Mail:    jinshaohui789@163.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Time:    18-10-12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Desc:    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ************************************************************************/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef STACK_LINK_LIST_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_LINK_LIST_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _linkliststack {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _linkliststack <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}linklist_stack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define stack_is_empty(liststack) (liststack-&gt;next == NULL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;./linklist_stack.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>linklist_stack <span style="color:#f92672">*</span> <span style="color:#a6e22e">stack_create</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    linklist_stack <span style="color:#f92672">*</span> stack <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> (linklist_stack <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(linklist_stack));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (stack <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> stack;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stack_destory</span>(linklist_stack<span style="color:#f92672">*</span> stack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    linklist_stack <span style="color:#f92672">*</span> ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">stack_is_empty</span>(stack)) {
</span></span><span style="display:flex;"><span>        ptmp <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(ptmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(stack);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">stack_push</span>(linklist_stack <span style="color:#f92672">*</span>stack,<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    linklist_stack <span style="color:#f92672">*</span> ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ptmp <span style="color:#f92672">=</span> (linklist_stack <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(linklist_stack));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ptmp <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ptmp<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    ptmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> ptmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">stack_pop</span>(linklist_stack<span style="color:#f92672">*</span>stack,<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    linklist_stack <span style="color:#f92672">*</span>ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">stack_is_empty</span>(stack)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    ptmp <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> ptmp<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(ptmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stack_dump</span>(linklist_stack <span style="color:#f92672">*</span>stack)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    linklist_stack <span style="color:#f92672">*</span> ptmp <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(ptmp <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> data = %d&#34;</span>,ptmp<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        ptmp <span style="color:#f92672">=</span> ptmp<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    linklist_stack <span style="color:#f92672">*</span> stack <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> <span style="color:#a6e22e">stack_create</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (stack <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> stack create falied.&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">stack_push</span>(stack,i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> stack push %d falied.&#34;</span>,i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stack_dump</span>(stack);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">stack_pop</span>(stack,<span style="color:#f92672">&amp;</span>data);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> stack pop%d falied.&#34;</span>, i);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> data = %d,&#34;</span>,data);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stack_destory</span>(stack);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="216-队列">2.1.6 队列<a hidden class="anchor" aria-hidden="true" href="#216-队列">#</a></h4>
<p> 队列，在前端(<code>front</code>)进行删除操作，后端(<code>rear</code>)进行插入操作; 按照先进先出(<code>FIFO</code>)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。
 队列也可通过数组和链表实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> List Queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define queue_init list_init;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define queue_destroy list_destroy;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queue_enqueue</span>(Queue <span style="color:#f92672">*</span>queue, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queue_dequeue</span>(Queue <span style="color:#f92672">*</span>queue, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>data);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define queue_size list_size;
</span></span></span></code></pre></div><details>
<summary>array_queue</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; File Name: array_queue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Author:  jinshaohui
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Mail:    jinshaohui789@163.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Time:    18-10-12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Desc:    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ************************************************************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef ARRAY_QUEUE_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ARRAY_QUEUE_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _array_queue {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;<span style="color:#75715e">/*队列的大小*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num; <span style="color:#75715e">/*当前存储数据的大小*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> head;<span style="color:#75715e">/*队列的头*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tail;<span style="color:#75715e">/*队列的尾*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;<span style="color:#75715e">/*数据存储区*/</span>
</span></span><span style="display:flex;"><span>}array_queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define array_queue_is_empty(array_queue) (array_queue-&gt;num == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define array_queue_is_full(array_queue)  ((array_queue-&gt;num) == (array_queue-&gt;size))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;./array_queue.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>array_queue <span style="color:#f92672">*</span> <span style="color:#a6e22e">array_queue_create</span>(<span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    array_queue <span style="color:#f92672">*</span> queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> (array_queue<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(array_queue));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">*</span>size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(queue);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>size  <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>num   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>tail  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> queue;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">array_queue_destory</span>(array_queue <span style="color:#f92672">*</span>queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue<span style="color:#f92672">-&gt;</span>array <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(queue<span style="color:#f92672">-&gt;</span>array);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(queue);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*入队列 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">array_queue_enqueue</span>(array_queue <span style="color:#f92672">*</span>queue,<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*队列为空，或者队列满时，返回-1*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((queue <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (<span style="color:#a6e22e">array_queue_is_full</span>(queue))) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>num<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>array[queue<span style="color:#f92672">-&gt;</span>tail] <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> (queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> queue<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*出队列*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">array_queue_dequeue</span>(array_queue <span style="color:#f92672">*</span> queue,<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*队列为空，数据存储为空，队列为空时返回-1*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((queue <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (data <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (<span style="color:#a6e22e">array_queue_is_empty</span>(queue))) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>array[queue<span style="color:#f92672">-&gt;</span>head];
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>num<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> (queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> queue<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">array_queue_dump</span>(array_queue <span style="color:#f92672">*</span>queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((queue <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (<span style="color:#a6e22e">array_queue_is_empty</span>(queue))) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue is empty&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> size:%d,num:%d,head:%d,tali:%d&#34;</span>,
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>size,queue<span style="color:#f92672">-&gt;</span>num,queue<span style="color:#f92672">-&gt;</span>head,queue<span style="color:#f92672">-&gt;</span>tail);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> queue<span style="color:#f92672">-&gt;</span>num; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        pos <span style="color:#f92672">=</span> (queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">+</span> i) <span style="color:#f92672">%</span>queue<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> array[%d] = %d&#34;</span>,pos,queue<span style="color:#f92672">-&gt;</span>array[pos]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    array_queue <span style="color:#f92672">*</span> queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> <span style="color:#a6e22e">array_queue_create</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue is create failed.&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*队列时空时，出队返回错误*/</span>
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">array_queue_dequeue</span>(queue, <span style="color:#f92672">&amp;</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue %d dequeue failed.&#34;</span>,ret);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*队列大小是4，入队5个，最后一个报错*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">array_queue_enqueue</span>(queue,i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue %d enqueue failed.&#34;</span>,i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array_queue_dump</span>(queue);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">array_queue_dequeue</span>(queue, <span style="color:#f92672">&amp;</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue %d dequeue failed.&#34;</span>,i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue %d dequue.&#34;</span>,data);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array_queue_dump</span>(queue);
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue %d enqueue.&#34;</span>,data);
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">array_queue_enqueue</span>(queue,data);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> queue %d enqueue failed.&#34;</span>,data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array_queue_dump</span>(queue);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array_queue_destory</span>(queue);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>list_queue</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifndef LINK_LIST_QUEUE_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LINK_LIST_QUEUE_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _list_queue_node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _list_queue_node <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}queue_node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _list_queue {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>    queue_node <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>    queue_node <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span>}list_queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define list_queue_is_empty(queue) ((queue-&gt;num) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>list_queue <span style="color:#f92672">*</span><span style="color:#a6e22e">list_queue_create</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">list_queue_enqueue</span>(list_queue <span style="color:#f92672">*</span>queue,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">list_queue_dequeue</span>(list_queue <span style="color:#f92672">*</span>queue,<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;./list_queue.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*创建队列头*/</span>
</span></span><span style="display:flex;"><span>list_queue <span style="color:#f92672">*</span><span style="color:#a6e22e">list_queue_create</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    list_queue <span style="color:#f92672">*</span> queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> (list_queue <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(list_queue));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(queue <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>num  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> queue;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*入队*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">list_queue_enqueue</span>(list_queue <span style="color:#f92672">*</span>queue,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    queue_node <span style="color:#f92672">*</span>ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(queue <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ptmp <span style="color:#f92672">=</span> (queue_node <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(queue_node));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ptmp <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ptmp<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    ptmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> ptmp;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> ptmp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> ptmp;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>num<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*出队*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">list_queue_dequeue</span>(list_queue <span style="color:#f92672">*</span>queue,<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    queue_node <span style="color:#f92672">*</span> ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((queue <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (data <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> <span style="color:#a6e22e">list_queue_is_empty</span>(queue)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    ptmp <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>num<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(ptmp);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>ring_queue</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> ring_queue {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> head, tail;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>_q;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">alloc_queue</span>(<span style="color:#66d9ef">struct</span> ring_queue<span style="color:#f92672">*</span> queue, <span style="color:#66d9ef">int</span> cap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>queue <span style="color:#f92672">||</span> cap <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (queue<span style="color:#f92672">-&gt;</span>_q)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>_q <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(cap <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>queue<span style="color:#f92672">-&gt;</span>_q)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>cap <span style="color:#f92672">=</span> cap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_queue</span>(<span style="color:#66d9ef">struct</span> ring_queue <span style="color:#f92672">*</span>queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>cap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(queue<span style="color:#f92672">-&gt;</span>_q);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_valid_index</span>(<span style="color:#66d9ef">int</span> curr, <span style="color:#66d9ef">int</span> step, <span style="color:#66d9ef">int</span> cap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (curr <span style="color:#f92672">+</span> step) <span style="color:#f92672">%</span> cap;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_next</span>(<span style="color:#66d9ef">int</span> curr, <span style="color:#66d9ef">int</span> cap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_valid_index</span>(curr, <span style="color:#ae81ff">1</span>, cap);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_empty</span>(<span style="color:#66d9ef">struct</span> ring_queue <span style="color:#f92672">*</span>queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> queue<span style="color:#f92672">-&gt;</span>tail);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_full</span>(<span style="color:#66d9ef">struct</span> ring_queue <span style="color:#f92672">*</span>queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next_tail <span style="color:#f92672">=</span> <span style="color:#a6e22e">_next</span>(queue<span style="color:#f92672">-&gt;</span>tail, queue<span style="color:#f92672">-&gt;</span>cap);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (next_tail <span style="color:#f92672">==</span> queue<span style="color:#f92672">-&gt;</span>head);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">enqueue</span>(<span style="color:#66d9ef">struct</span> ring_queue<span style="color:#f92672">*</span> queue, <span style="color:#66d9ef">int</span> elem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_full</span>(queue))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>_q[queue<span style="color:#f92672">-&gt;</span>tail] <span style="color:#f92672">=</span> elem;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> <span style="color:#a6e22e">_next</span>(queue<span style="color:#f92672">-&gt;</span>tail, queue<span style="color:#f92672">-&gt;</span>cap);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dequeue</span>(<span style="color:#66d9ef">struct</span> ring_queue<span style="color:#f92672">*</span> queue, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>elem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_empty</span>(queue))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (elem)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>elem <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>_q[queue<span style="color:#f92672">-&gt;</span>head];
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> <span style="color:#a6e22e">_next</span>(queue<span style="color:#f92672">-&gt;</span>head, queue<span style="color:#f92672">-&gt;</span>cap);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span>(<span style="color:#66d9ef">struct</span> ring_queue<span style="color:#f92672">*</span> queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">-</span> queue<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">+=</span> queue<span style="color:#f92672">-&gt;</span>cap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> size;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">struct</span> ring_queue<span style="color:#f92672">*</span> queue)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, idx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Queue has %d elements with %d capacity</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>(queue), queue<span style="color:#f92672">-&gt;</span>cap);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">size</span>(queue); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">_valid_index</span>(queue<span style="color:#f92672">-&gt;</span>head, i, queue<span style="color:#f92672">-&gt;</span>cap);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[%02d]: %08d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, idx, queue<span style="color:#f92672">-&gt;</span>_q[idx]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> ring_queue queue <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, NULL};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">alloc_queue</span>(<span style="color:#f92672">&amp;</span>queue, <span style="color:#ae81ff">8</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed to allocate a queue</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;A new queue is %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">is_empty</span>(<span style="color:#f92672">&amp;</span>queue)<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;empty&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;not empty&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">enqueue</span>(<span style="color:#f92672">&amp;</span>queue, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After enqueue 1 element, queue is %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">is_empty</span>(<span style="color:#f92672">&amp;</span>queue)<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;empty&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;not empty&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dequeue</span>(<span style="color:#f92672">&amp;</span>queue, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After dequeue 1 element, queue is %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">is_empty</span>(<span style="color:#f92672">&amp;</span>queue)<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;empty&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;not empty&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">7</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">enqueue</span>(<span style="color:#f92672">&amp;</span>queue, i);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After enqueue 7 element, queue is %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">is_full</span>(<span style="color:#f92672">&amp;</span>queue)<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;full&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;not full&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dequeue</span>(<span style="color:#f92672">&amp;</span>queue, NULL);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">enqueue</span>(<span style="color:#f92672">&amp;</span>queue, i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After enqueue/dequeue 4 element, queue is %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">is_full</span>(<span style="color:#f92672">&amp;</span>queue)<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;full&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;not full&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Head is %d, Tail is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, queue.head, queue.tail);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>queue);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free_queue</span>(<span style="color:#f92672">&amp;</span>queue);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p> 队列应用：进程通信
 消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.</p>
<p> linux内核 &lt;sys/msg.h&gt; 头文件中定义了消息队列结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> msqid_ds {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> ipc_perm msg_perm;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> msg<span style="color:#f92672">*</span> msg_first; <span style="color:#75715e">// 指向队列中第一个消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> msg<span style="color:#f92672">*</span> msg_last; <span style="color:#75715e">// 队列中最后一个消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> Linux消息队列函数接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 创建和访问一个消息队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">msgget</span>(<span style="color:#66d9ef">key_t</span> key, <span style="color:#66d9ef">int</span> msgflg);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 把消息添加到消息队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">msgsnd</span>(<span style="color:#66d9ef">int</span> msgid, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>msg_ptr, <span style="color:#66d9ef">size_t</span> msg_sz, <span style="color:#66d9ef">int</span> msgflg);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从一个消息对立获取消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">msgrcv</span>(<span style="color:#66d9ef">int</span> msgid, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>msg_ptr, <span style="color:#66d9ef">size_t</span> msg_st, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> msgtype, <span style="color:#66d9ef">int</span> msgflg);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 控制消息队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">msgctl</span>(<span style="color:#66d9ef">int</span> msgid, <span style="color:#66d9ef">int</span> command, <span style="color:#66d9ef">struct</span> msgid_ds <span style="color:#f92672">*</span>buf);
</span></span></code></pre></div><h4 id="217-leetcode题目">2.1.7 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#217-leetcode题目">#</a></h4>
<ul>
<li>
<p>重复N次的元素&lt;数组&gt;</p>
</li>
<li>
<p>两数相加&lt;链表&gt;</p>
</li>
<li>
<p>基本计算器&lt;栈&gt;</p>
</li>
<li>
<p>设计循环队列&lt;队列&gt;</p>
</li>
</ul>
<h3 id="22-哈希表">2.2 哈希表<a hidden class="anchor" aria-hidden="true" href="#22-哈希表">#</a></h3>
<p> 哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。
 每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.</p>
<h4 id="221-哈希函数设计">2.2.1 哈希函数设计<a hidden class="anchor" aria-hidden="true" href="#221-哈希函数设计">#</a></h4>
<ul>
<li>
<p>直接地址法
关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.
H(k) = aK*i + b</p>
</li>
<li>
<p>数字分析法
取关键字数中分布均匀的若干作为哈希地址</p>
</li>
<li>
<p>平方取中法
取关键字平方中间几位作为散列地址</p>
</li>
<li>
<p>折叠法
把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址</p>
</li>
<li>
<p>除留取余法
关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.
H(K) = K MOD P</p>
</li>
</ul>
<details>
<summary>uthash用法</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************************************
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; File Name: listhash.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Author:  jinshaohui
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Mail:    jinshaohui789@163.com
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Time:    18-11-06
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> &gt; Desc: 根据linux内核模块hashtab编写用户层hashtab接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         linux-4.19.1\security\selinux\ss\hashtab.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     linux-4.19.1\security\selinux\ss\hashtab.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ************************************************************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef __HASHTAB_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __HASHTAB_H__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _hashtab_node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> key;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _hashtab_node <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}hashtab_node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _hashtab {
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">**</span>htables; <span style="color:#75715e">/*哈希桶*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;              <span style="color:#75715e">/*哈希桶的最大数量*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nel;               <span style="color:#75715e">/*哈希桶中元素的个数*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>hash_value)(<span style="color:#66d9ef">struct</span> _hashtab <span style="color:#f92672">*</span>h,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key); <span style="color:#75715e">/*哈希函数*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>keycmp)(<span style="color:#66d9ef">struct</span> _hashtab <span style="color:#f92672">*</span>h,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);<span style="color:#75715e">/*哈希key比较函数，当哈希数值一致时使用*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>hash_node_free)(hashtab_node <span style="color:#f92672">*</span>node);
</span></span><span style="display:flex;"><span>}hashtab;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASHTAB_MAX_NODES  (0xffffffff)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>hash_key_func)(<span style="color:#66d9ef">struct</span> _hashtab <span style="color:#f92672">*</span>h,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key); <span style="color:#75715e">/*哈希函数*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>keycmp_func)(<span style="color:#66d9ef">struct</span> _hashtab <span style="color:#f92672">*</span>h,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);<span style="color:#75715e">/*哈希key比较函数，当哈希数值一致时使用*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>hash_node_free_func)(hashtab_node <span style="color:#f92672">*</span>node);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*根据当前结构体元素的地址，获取到结构体首地址*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define container(ptr,type,member) ({\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  (type *) ( (char *)__mptr - offsetof(type,member));})
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hashtab <span style="color:#f92672">*</span> <span style="color:#a6e22e">hashtab_create</span>(<span style="color:#66d9ef">int</span> size,hash_key_func hash_value,
</span></span><span style="display:flex;"><span>        keycmp_func keycmp,hash_node_free_func hash_node_free);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hashtab_destory</span>(hashtab <span style="color:#f92672">*</span>h);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashtab_insert</span>(hashtab <span style="color:#f92672">*</span> h,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>hashtab_node <span style="color:#f92672">*</span><span style="color:#a6e22e">hashtab_delete</span>(hashtab <span style="color:#f92672">*</span>h, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hashtab_search</span>(hashtab<span style="color:#f92672">*</span>h,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;listhash.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef MEMORY_TEST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;mcheck.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>hashtab <span style="color:#f92672">*</span> <span style="color:#a6e22e">hashtab_create</span>(<span style="color:#66d9ef">int</span> size,hash_key_func hash_value,
</span></span><span style="display:flex;"><span>    keycmp_func keycmp,hash_node_free_func hash_node_free)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    hashtab <span style="color:#f92672">*</span> h <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (hash_value <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (keycmp <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    h <span style="color:#f92672">=</span> (hashtab <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(hashtab));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>htables <span style="color:#f92672">=</span> (hashtab_node <span style="color:#f92672">**</span>)<span style="color:#a6e22e">malloc</span>(size <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(hashtab_node<span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (h<span style="color:#f92672">-&gt;</span>htables <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>nel <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>hash_value <span style="color:#f92672">=</span> hash_value;
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>keycmp <span style="color:#f92672">=</span> keycmp;
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>hash_node_free <span style="color:#f92672">=</span> hash_node_free;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        h<span style="color:#f92672">-&gt;</span>htables[i] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> h;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hashtab_destory</span>(hashtab <span style="color:#f92672">*</span>h)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span>h<span style="color:#f92672">-&gt;</span>size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>htables[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            tmp <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hash_node_free</span>(tmp);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        h<span style="color:#f92672">-&gt;</span>htables[i] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(h<span style="color:#f92672">-&gt;</span>htables);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(h);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashtab_insert</span>(hashtab <span style="color:#f92672">*</span> h,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> hvalue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span>newnode <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((h <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (key <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (data <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*获取hash 数值*/</span>
</span></span><span style="display:flex;"><span>    hvalue <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hash_value</span>(h,key);
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>htables[hvalue];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>((cur <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">keycmp</span>(h,key,cur<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*如果key和当前key比对一致，直接返回，数据已经存在*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((cur <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">keycmp</span>(h,key,cur<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    newnode <span style="color:#f92672">=</span> (hashtab_node <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(hashtab_node));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (newnode <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    newnode<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>    newnode<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (prev <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        newnode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>htables[hvalue];
</span></span><span style="display:flex;"><span>        h<span style="color:#f92672">-&gt;</span>htables[hvalue] <span style="color:#f92672">=</span> newnode;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        newnode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> prev<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> newnode;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    h<span style="color:#f92672">-&gt;</span>nel<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hashtab_node <span style="color:#f92672">*</span><span style="color:#a6e22e">hashtab_delete</span>(hashtab <span style="color:#f92672">*</span>h, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> hvalue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((h <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (key <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*获取hash 数值*/</span>
</span></span><span style="display:flex;"><span>    hvalue <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hash_value</span>(h,key);
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>htables[hvalue];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>((cur <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">keycmp</span>(h,key,cur<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">keycmp</span>(h,key,cur<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (prev <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                        h<span style="color:#f92672">-&gt;</span>htables[hvalue] <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cur;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hashtab_search</span>(hashtab<span style="color:#f92672">*</span>h,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> hvalue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((h <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (key <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*获取hash 数值*/</span>
</span></span><span style="display:flex;"><span>    hvalue <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hash_value</span>(h,key);
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>htables[hvalue];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>((cur <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">keycmp</span>(h,key,cur<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">keycmp</span>(h,key,cur<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cur<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hashtab_dump</span>(hashtab <span style="color:#f92672">*</span>h)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">----开始--size[%d],nel[%d]------------&#34;</span>,h<span style="color:#f92672">-&gt;</span>size,h<span style="color:#f92672">-&gt;</span>nel);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> h<span style="color:#f92672">-&gt;</span>size; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> htables[%d]:&#34;</span>,i);
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>htables[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>((cur <span style="color:#f92672">!=</span> NULL)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;key[%s],data[%s] &#34;</span>,cur<span style="color:#f92672">-&gt;</span>key,cur<span style="color:#f92672">-&gt;</span>data);    
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">----结束--size[%d],nel[%d]------------&#34;</span>,h<span style="color:#f92672">-&gt;</span>size,h<span style="color:#f92672">-&gt;</span>nel);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> test_node
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> key[<span style="color:#ae81ff">80</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">80</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">siample_hash</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> seed <span style="color:#f92672">=</span> <span style="color:#ae81ff">131</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">*</span>str) {
</span></span><span style="display:flex;"><span>        hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">*</span>seed <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>str<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> hash <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">0x7FFFFFFF</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashtab_hvalue</span>(hashtab <span style="color:#f92672">*</span>h,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">siample_hash</span>(key) <span style="color:#f92672">%</span> h<span style="color:#f92672">-&gt;</span>size);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashtab_keycmp</span>(hashtab <span style="color:#f92672">*</span>h,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strcmp</span>(key1,key2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hashtab_node_free</span>(hashtab_node<span style="color:#f92672">*</span>node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> test_node <span style="color:#f92672">*</span> ptmp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    ptmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">container</span>(node<span style="color:#f92672">-&gt;</span>key,<span style="color:#66d9ef">struct</span> test_node,key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(ptmp);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(node);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span> ()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pres <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    hashtab_node <span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> test_node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    hashtab <span style="color:#f92672">*</span>h <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#ifdef MEMORY_TEST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setenv</span>(<span style="color:#e6db74">&#34;MALLOC_TRACE&#34;</span>,<span style="color:#e6db74">&#34;1.txt&#34;</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mtrace</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hashtab_create</span>(<span style="color:#ae81ff">5</span>,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(h<span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> test_node<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> test_node));
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">assert</span>(p <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> 请输入key 和value，当可以等于</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">quit</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">时退出&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>,p<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(p<span style="color:#f92672">-&gt;</span>key,<span style="color:#e6db74">&#34;quit&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> <span style="color:#a6e22e">hashtab_insert</span>(h,p<span style="color:#f92672">-&gt;</span>key,p<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> key[%s],data[%s] insert failed %d&#34;</span>,p<span style="color:#f92672">-&gt;</span>key,p<span style="color:#f92672">-&gt;</span>data,res);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> key[%s],data[%s] insert success %d&#34;</span>,p<span style="color:#f92672">-&gt;</span>key,p<span style="color:#f92672">-&gt;</span>data,res);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hashtab_dump</span>(h);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> test_node<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> test_node));
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">assert</span>(p <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> 请输入key 查询value的数值，当可以等于</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">quit</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">时退出&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(p<span style="color:#f92672">-&gt;</span>key,<span style="color:#e6db74">&#34;quit&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pres <span style="color:#f92672">=</span> <span style="color:#a6e22e">hashtab_search</span>(h,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pres <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> key[%s] search data failed&#34;</span>,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> key[%s],search data[%s] success&#34;</span>,p<span style="color:#f92672">-&gt;</span>key,pres);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hashtab_dump</span>(h);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> test_node<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> test_node));
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">assert</span>(p <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> 请输入key 删除节点的数值，当可以等于</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">quit</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">时退出&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">strcmp</span>(p<span style="color:#f92672">-&gt;</span>key,<span style="color:#e6db74">&#34;quit&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> <span style="color:#a6e22e">hashtab_delete</span>(h,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> key[%s] delete node failed &#34;</span>,p<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> key[%s],delete data[%s] success&#34;</span>,node<span style="color:#f92672">-&gt;</span>key,node<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>            h<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hash_node_free</span>(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hashtab_dump</span>(h);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hashtab_destory</span>(h);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#ifdef MEMORY_TEST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">muntrace</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>hash_table</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* One implementation of hash table with linear probing. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASH_SHIFT 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASH_SIZE (1 &lt;&lt; HASH_SHIFT)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASH_MASK (HASH_SIZE - 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> hash_table {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>  used;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> entry[HASH_SIZE];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_table_reset</span>(<span style="color:#66d9ef">struct</span> hash_table <span style="color:#f92672">*</span>table)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    table<span style="color:#f92672">-&gt;</span>used <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> HASH_SIZE; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    table<span style="color:#f92672">-&gt;</span>entry[i] <span style="color:#f92672">=</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash_function</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> value <span style="color:#f92672">&amp;</span> HASH_MASK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_hash_table</span>(<span style="color:#66d9ef">struct</span> hash_table <span style="color:#f92672">*</span>table)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> HASH_SIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (table<span style="color:#f92672">-&gt;</span>entry[i] <span style="color:#f92672">==</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%2u:       nil </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%2u:%10lu -&gt; %2u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>        i, table<span style="color:#f92672">-&gt;</span>entry[i],
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hash_function</span>(table<span style="color:#f92672">-&gt;</span>entry[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_function_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">srandom</span>(<span style="color:#a6e22e">time</span>(NULL));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> val <span style="color:#f92672">=</span> <span style="color:#a6e22e">random</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%10lu -&gt; %2u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, val, <span style="color:#a6e22e">hash_function</span>(val));;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">next_probe</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> prev_key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (prev_key <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> HASH_MASK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">next_probe_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> key1, key2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    key1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> HASH_SIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        key2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">next_probe</span>(key1);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%2u -&gt; %2u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, key1, key2);
</span></span><span style="display:flex;"><span>        key1 <span style="color:#f92672">=</span> key2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#66d9ef">struct</span> hash_table <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash_function</span>(value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (table<span style="color:#f92672">-&gt;</span>used <span style="color:#f92672">&gt;=</span> HASH_SIZE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (table<span style="color:#f92672">-&gt;</span>entry[key] <span style="color:#f92672">!=</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        key <span style="color:#f92672">=</span> <span style="color:#a6e22e">next_probe</span>(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    table<span style="color:#f92672">-&gt;</span>entry[key] <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    table<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash_table_slot</span>(<span style="color:#66d9ef">struct</span> hash_table <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash_function</span>(value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> HASH_SIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (table<span style="color:#f92672">-&gt;</span>entry[key] <span style="color:#f92672">==</span> value <span style="color:#f92672">||</span> table<span style="color:#f92672">-&gt;</span>entry[key] <span style="color:#f92672">==</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        key <span style="color:#f92672">=</span> <span style="color:#a6e22e">next_probe</span>(key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> key;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">hash_table_find</span>(<span style="color:#66d9ef">struct</span> hash_table <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> table<span style="color:#f92672">-&gt;</span>entry[<span style="color:#a6e22e">hash_table_slot</span>(table, value)] <span style="color:#f92672">==</span> value;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_table_del</span>(<span style="color:#66d9ef">struct</span> hash_table <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i, j, k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">hash_table_find</span>(table, value))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash_table_slot</span>(table, value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        table<span style="color:#f92672">-&gt;</span>entry[i] <span style="color:#f92672">=</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">=</span> <span style="color:#a6e22e">next_probe</span>(j);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (table<span style="color:#f92672">-&gt;</span>entry[j] <span style="color:#f92672">==</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash_function</span>(table<span style="color:#f92672">-&gt;</span>entry[j]);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span> ((i <span style="color:#f92672">&lt;=</span> j) <span style="color:#f92672">?</span> (i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#f92672">&lt;=</span> j) <span style="color:#f92672">:</span> (i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">||</span> k <span style="color:#f92672">&lt;=</span> j));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        table<span style="color:#f92672">-&gt;</span>entry[i] <span style="color:#f92672">=</span> table<span style="color:#f92672">-&gt;</span>entry[j];
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    table<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_table_add_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> hash_table table;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_reset</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">87645</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Table has%s 87645</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_find</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">87645</span>) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;n&#39;t&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Table has%s 87647</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_find</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">87647</span>) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;n&#39;t&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_table_del_test1</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> hash_table table;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_reset</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x1ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x2ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x3ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_hash_table</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== Remove 0x1ff0</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_del</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x1ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_hash_table</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hash_table_del_test2</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> hash_table table;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_reset</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x1ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x1ff1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x1ff2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_add</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x2ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_hash_table</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;=== Remove 0x1ff0</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hash_table_del</span>(<span style="color:#f92672">&amp;</span>table, <span style="color:#ae81ff">0x1ff0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_hash_table</span>(<span style="color:#f92672">&amp;</span>table);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//hash_function_test();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//next_probe_test();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//hash_table_add_test();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">hash_table_del_test2</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="222-哈希冲突">2.2.2 哈希冲突<a hidden class="anchor" aria-hidden="true" href="#222-哈希冲突">#</a></h4>
<p> 理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.</p>
<p> 解决哈希冲突常用方法:</p>
<ul>
<li>链地址法
将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.</li>
<li>线性探测</li>
<li>二次探测</li>
</ul>
<h4 id="223-uthash">2.2.3 uthash<a hidden class="anchor" aria-hidden="true" href="#223-uthash">#</a></h4>
<p> uthash的插入、查找、删除的操作时间都是常量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;uthash.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> my_struct {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id;            <span style="color:#75715e">/* we&#39;ll use this field as the key */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    UT_hash_handle hh; <span style="color:#75715e">/* makes this structure hashable */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>users <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_user</span>(<span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>s) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_ADD_INT</span>(users, id, s);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>uthash用法</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;   /* gets */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;  /* atoi, malloc */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;  /* strcpy */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;uthash.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> my_struct {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id;                    <span style="color:#75715e">/* key */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    UT_hash_handle hh;         <span style="color:#75715e">/* makes this structure hashable */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>users <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_user</span>(<span style="color:#66d9ef">int</span> user_id, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_FIND_INT</span>(users, <span style="color:#f92672">&amp;</span>user_id, s);  <span style="color:#75715e">/* id already in the hash? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s<span style="color:#f92672">==</span>NULL) {
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span> <span style="color:#f92672">*</span>s);
</span></span><span style="display:flex;"><span>        s<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">=</span> user_id;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">HASH_ADD_INT</span>( users, id, s );  <span style="color:#75715e">/* id: name of key field */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strcpy</span>(s<span style="color:#f92672">-&gt;</span>name, name);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">find_user</span>(<span style="color:#66d9ef">int</span> user_id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_FIND_INT</span>(users, <span style="color:#f92672">&amp;</span>user_id, s);  <span style="color:#75715e">/* s: output pointer */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete_user</span>(<span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>user) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_DEL</span>(users, user);  <span style="color:#75715e">/* user: pointer to deletee */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(user);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete_all</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>current_user, <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_ITER</span>(hh, users, current_user, tmp) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">HASH_DEL</span>(users, current_user);  <span style="color:#75715e">/* delete it (users advances to next) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(current_user);             <span style="color:#75715e">/* free it */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_users</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(s<span style="color:#f92672">=</span>users; s <span style="color:#f92672">!=</span> NULL; s<span style="color:#f92672">=</span>(<span style="color:#66d9ef">struct</span> my_struct<span style="color:#f92672">*</span>)(s<span style="color:#f92672">-&gt;</span>hh.next)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;user id %d: name %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, s<span style="color:#f92672">-&gt;</span>id, s<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">name_sort</span>(<span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strcmp</span>(a<span style="color:#f92672">-&gt;</span>name,b<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">id_sort</span>(<span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (a<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">-</span> b<span style="color:#f92672">-&gt;</span>id);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort_by_name</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_SORT</span>(users, name_sort);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort_by_id</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HASH_SORT</span>(users, id_sort);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> in[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, running<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> my_struct <span style="color:#f92672">*</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> num_users;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (running) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 1. add user</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 2. add/rename user by id</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 3. find user</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 4. delete user</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 5. delete all users</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 6. sort items by name</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 7. sort items by id</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 8. print users</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; 9. count users</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;10. quit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">gets</span>(in);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span>(<span style="color:#a6e22e">atoi</span>(in)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;name?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">add_user</span>(id<span style="color:#f92672">++</span>, <span style="color:#a6e22e">gets</span>(in));
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;id?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">gets</span>(in); id <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoi</span>(in);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;name?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">add_user</span>(id, <span style="color:#a6e22e">gets</span>(in));
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;id?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                s <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_user</span>(<span style="color:#a6e22e">atoi</span>(<span style="color:#a6e22e">gets</span>(in)));
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;user: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, s <span style="color:#f92672">?</span> s<span style="color:#f92672">-&gt;</span>name : <span style="color:#e6db74">&#34;unknown&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;id?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                s <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_user</span>(<span style="color:#a6e22e">atoi</span>(<span style="color:#a6e22e">gets</span>(in)));
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (s) <span style="color:#a6e22e">delete_user</span>(s);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;id unknown</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">delete_all</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">sort_by_name</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">7</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">sort_by_id</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">8</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">print_users</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">9</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                num_users<span style="color:#f92672">=</span><span style="color:#a6e22e">HASH_COUNT</span>(users);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;there are %u users</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, num_users);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                running<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">delete_all</span>();  <span style="color:#75715e">/* free any structures */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<ul>
<li>参考链接
官网:https://troydhanson.github.io/uthash/
<a href="https://blog.csdn.net/fan_h_l/article/details/107241520">https://blog.csdn.net/fan_h_l/article/details/107241520</a>
<a href="https://blog.csdn.net/whatday/article/details/95926766">https://blog.csdn.net/whatday/article/details/95926766</a>
<a href="https://www.cnblogs.com/pam-sh/p/12827658.html">https://www.cnblogs.com/pam-sh/p/12827658.html</a></li>
</ul>
<h4 id="224-leetcode题目">2.2.4 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#224-leetcode题目">#</a></h4>
<ul>
<li>
<p>设计哈希集合</p>
</li>
<li>
<p>设计哈希映射</p>
</li>
<li>
<p>根据字符出现频率排序</p>
</li>
</ul>
<h3 id="23-树与二叉树">2.3 树与二叉树<a hidden class="anchor" aria-hidden="true" href="#23-树与二叉树">#</a></h3>
<p> 树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);</p>
<p> 树的特点:</p>
<ul>
<li>没有父节点的节点称为根节点</li>
<li>每个非根节点有且只有一个父节点</li>
<li>除了根结点外,每个子节点可分为多个不相交的子树</li>
<li>树中没有环路</li>
</ul>
<h4 id="231-概述">2.3.1 概述<a hidden class="anchor" aria-hidden="true" href="#231-概述">#</a></h4>
<ul>
<li>节点的度: 一个节点含有子树的个数</li>
<li>树的度: 树中最大的节点度</li>
<li>叶节点: 度为零的节点</li>
<li>父节点</li>
<li>子节点</li>
<li>兄弟节点</li>
<li>节点的层次</li>
<li>深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0</li>
<li>高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.</li>
<li>森林</li>
</ul>
<p> 树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。</p>
<h4 id="232-树的种类">2.3.2 树的种类<a hidden class="anchor" aria-hidden="true" href="#232-树的种类">#</a></h4>
<ul>
<li>无序树</li>
<li>有序树
<ul>
<li>
<p>二叉树: 每个节点最多含有两个子树的树.</p>
<ul>
<li>完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.
<ul>
<li>满二叉树:所有叶节点都最底层的完全二叉树.</li>
</ul>
</li>
<li>平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.</li>
<li>排序二叉树:二叉查找树</li>
</ul>
</li>
<li>
<p>霍夫曼树:带权路径最短的二叉树(又称最优二叉树).</p>
</li>
<li>
<p>B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.</p>
</li>
</ul>
</li>
</ul>
<br>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>二叉树</td>
<td>二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树</td>
</tr>
<tr>
<td>自平衡二叉查找树</td>
<td>AVL树 红黑树 加权平衡树 AA树</td>
</tr>
<tr>
<td>B树</td>
<td>B树 B+树</td>
</tr>
<tr>
<td>堆</td>
<td>二项堆 斐波那契堆</td>
</tr>
<tr>
<td>Trie</td>
<td>后缀树 基数树 三叉查找树</td>
</tr>
</tbody>
</table>
<p> 树有多种结构形式，包括二叉树、。</p>
<h4 id="233-二叉树">2.3.3 二叉树<a hidden class="anchor" aria-hidden="true" href="#233-二叉树">#</a></h4>
<p> 二叉树两个条件:</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个节点的度不能超过2,即只能是0,1或者2</li>
</ul>
<p> 二叉树中结点包含三部分：一个数据成员两个左右指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> BiTreeNode_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> BiTreeNode_ <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> BiTreeNode_ <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>}BiTreeNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> BiTree_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>compare)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destroy)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>    BiTreeNode <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>}BiTree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*树根*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> tree{
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span> root;
</span></span><span style="display:flex;"><span>}Tree;
</span></span></code></pre></div><details>
<summary>二叉树</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&#34;list_queue.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _treenode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _treenode <span style="color:#f92672">*</span>lchild;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _treenode <span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>}Tnode,Tree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_create</span>(Tree <span style="color:#f92672">**</span>Root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">输入节点数值((当输入为100时，当前节点创建完成))):&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>a);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#ae81ff">100</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>Root <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>Root <span style="color:#f92672">=</span> (Tnode <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Tnode));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>Root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        (<span style="color:#f92672">*</span>Root)<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> create %d 的左孩子:&#34;</span>,a);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binarytree_create</span>(<span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>Root)<span style="color:#f92672">-&gt;</span>lchild));
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74"> create %d 的右孩子:&#34;</span>,a);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binarytree_create</span>(<span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>Root)<span style="color:#f92672">-&gt;</span>rchild));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_destory</span>(Tree <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_destory</span>(root<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_destory</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(root);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*先序遍历:根结点--》左子树---》右子树*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_preorder</span>(Tree <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; %d &#34;</span>,root<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_preorder</span>(root<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_preorder</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*中序遍历:左子树--》跟节点---》右子树*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_inorder</span>(Tree <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_inorder</span>(root<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; %d &#34;</span>,root<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_inorder</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*后序遍历:左子树---》右子树-》根节点*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_postorder</span>(Tree <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_postorder</span>(root<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_postorder</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; %d &#34;</span>,root<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_levelorder</span>(Tree <span style="color:#f92672">*</span> root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    list_queue <span style="color:#f92672">*</span>queue <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    Tnode <span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> <span style="color:#a6e22e">list_queue_create</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*根节点先入队*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">list_queue_enqueue</span>(queue,(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">list_queue_is_empty</span>(queue)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">list_queue_dequeue</span>(queue,(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>node);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; %d &#34;</span>,node<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list_queue_enqueue</span>(queue,(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)node<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list_queue_enqueue</span>(queue,(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)node<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(queue);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*打印叶子节点*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binarytree_printfleaf</span>(Tree <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((root<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (root<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; %d &#34;</span>,root<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binarytree_printfleaf</span>(root<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binarytree_printfleaf</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*打印叶子的个数*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarytree_getleafnum</span>(Tree<span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((root<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (root<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">binarytree_getleafnum</span>(root<span style="color:#f92672">-&gt;</span>lchild) <span style="color:#f92672">+</span> <span style="color:#a6e22e">binarytree_getleafnum</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*打印数的高度*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarytree_gethigh</span>(Tree <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lhigh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rhigh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lhigh <span style="color:#f92672">=</span> <span style="color:#a6e22e">binarytree_gethigh</span>(root<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    rhigh <span style="color:#f92672">=</span> <span style="color:#a6e22e">binarytree_gethigh</span>(root<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ((lhigh <span style="color:#f92672">&gt;</span> rhigh)<span style="color:#f92672">?</span>(lhigh <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">:</span>(rhigh <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Tree <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setenv</span>(<span style="color:#e6db74">&#34;MALLOC_TRACE&#34;</span>,<span style="color:#e6db74">&#34;1.txt&#34;</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mtrace</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">创建二叉树:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_create</span>(<span style="color:#f92672">&amp;</span>root);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">先序遍历二叉树:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_preorder</span>(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">中序遍历二叉树:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_inorder</span>(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">后序遍历二叉树:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_postorder</span>(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">层次遍历二叉树:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_levelorder</span>(root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">打印二叉树叶子节点:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_printfleaf</span>(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">打印二叉树叶子节点个数:%d&#34;</span>,<span style="color:#a6e22e">binarytree_getleafnum</span>(root));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">打印二叉树高度:%d&#34;</span>,<span style="color:#a6e22e">binarytree_gethigh</span>(root));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">binarytree_destory</span>(root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">muntrace</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>binarytree</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Implement binary tree in array */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_TREE_NODES (1 &lt;&lt; 8)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> binary_tree {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> nodes;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>n[MAX_TREE_NODES];
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_binary_tree</span>(<span style="color:#66d9ef">struct</span> binary_tree <span style="color:#f92672">*</span>tree)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAX_TREE_NODES; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        tree<span style="color:#f92672">-&gt;</span>n[i] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> <span style="color:#a6e22e">create_node</span>(<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> node));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n)
</span></span><span style="display:flex;"><span>        n<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fake_a_tree</span>(<span style="color:#66d9ef">struct</span> binary_tree<span style="color:#f92672">*</span> tree)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* data is in ordered */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, data[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">init_binary_tree</span>(tree);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* root start at 1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        tree<span style="color:#f92672">-&gt;</span>n[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_node</span>(data[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree<span style="color:#f92672">-&gt;</span>nodes <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_in_order</span>(<span style="color:#66d9ef">struct</span> binary_tree<span style="color:#f92672">*</span> tree, <span style="color:#66d9ef">int</span> index)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tree<span style="color:#f92672">-&gt;</span>n[index])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* left child at (index &lt;&lt; 1) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_in_order</span>(tree, index <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[%2d]: %4d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, index, tree<span style="color:#f92672">-&gt;</span>n[index]<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* right child at (index &lt;&lt; 1) + 1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_in_order</span>(tree, (index <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">in_order</span>(<span style="color:#66d9ef">struct</span> binary_tree<span style="color:#f92672">*</span> tree)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_in_order</span>(tree, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> binary_tree tree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fake_a_tree</span>(<span style="color:#f92672">&amp;</span>tree);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">in_order</span>(<span style="color:#f92672">&amp;</span>tree);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p> 二叉树性质:</p>
<ul>
<li>二叉树中,第i层最多有 2^(i-1)个节点</li>
<li>如果二叉树的深度为K,则二叉树最多有<code>2^K - 1</code>个节点</li>
<li>二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1</li>
</ul>
<p><strong>满二叉树</strong>
 如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。</p>
<p><strong>完全二叉树</strong>
 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>
<p> 树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。</p>
<ul>
<li>先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;cur-&gt;val = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">traversal</span>(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">traversal</span>(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preorderTraversal</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">traversal</span>(root);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 迭戈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MAXSIZE 10000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">preorderTraversal</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode st[MAXSIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> top <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result[MAXSIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    st[top] <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (top <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> st[top];                       <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        top<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        result[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>             <span style="color:#75715e">// 右（空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            st[<span style="color:#f92672">++</span>top] <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right
</span></span><span style="display:flex;"><span>        }       
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 左（空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            st[<span style="color:#f92672">++</span>top] <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left; 
</span></span><span style="display:flex;"><span>        }        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>中序遍历：先访问左子结点，然后根结点，最后右子结点。</li>
<li>后序遍历：先访问左子结点，然后右子结点，最后根结点。</li>
<li>层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;cur-&gt;val = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">traversal</span>(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">traversal</span>(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">preorderTraversal</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">traversal</span>(root, result);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="234-二叉查找树bst">2.3.4 二叉查找树(BST)<a hidden class="anchor" aria-hidden="true" href="#234-二叉查找树bst">#</a></h4>
<p> 二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:</p>
<ul>
<li>若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值</li>
<li>若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值</li>
<li>任意节点的左,右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p> 一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。
 二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。<strong>查找,插入</strong>操作的复杂度是 <code>O(logn)</code>，<strong>搜索,插入,删除</strong>复杂度等于树高,期望<code>O(logn)</code>,最坏为<code>O(n)</code>,(树退化为线性表)n为树中结点数。
 保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。</p>
<p> 二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。</p>
<p> <strong>查找算法</strong>
  1.若b是空树,则搜索失败,否则;
  2.若x等于b的根节点的数据域之值,则查找成功;
  3.若x小于b的根节点的数据域之值,则搜索左子树
  4.查找右子树</p>
<p> <strong>插入算法</strong>
  1.若b是空树,则将s所指节点作为根节点插入;否则
  2.若<code>s-&gt;data</code>等于b的根节点的数据域值,则返回,否则;
  3.若<code>s-&gt;data</code>小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则
  4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)</p>
<p> <strong>删除算法</strong>
  1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.</p>
<details>
<summary>binarysearch</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define OK 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ERROR 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TRUE 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FALSE 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> ElemType;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> node {
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>} BTree, <span style="color:#f92672">*</span>BTreePtr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**************** 插入 **********************/</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Insert</span>(BTreePtr <span style="color:#f92672">*</span>T, ElemType e) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BTreePtr p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>T <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>T <span style="color:#f92672">=</span> (BTreePtr)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(BTree));
</span></span><span style="display:flex;"><span>        (<span style="color:#f92672">*</span>T)<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>T;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> ( p <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (e <span style="color:#f92672">&gt;</span> p<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                    p<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> (BTreePtr) <span style="color:#a6e22e">malloc</span> (<span style="color:#66d9ef">sizeof</span>(BTree));
</span></span><span style="display:flex;"><span>                    p<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                    p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">=</span> (BTreePtr) <span style="color:#a6e22e">malloc</span> (<span style="color:#66d9ef">sizeof</span>(BTree));
</span></span><span style="display:flex;"><span>                    p<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**************** 删除 **********************/</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Delete</span>(BTreePtr T, ElemType e) {
</span></span><span style="display:flex;"><span>    BTreePtr p, pp, minP, minPP, child;
</span></span><span style="display:flex;"><span>    child <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>    pp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( (p <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> e) ) {
</span></span><span style="display:flex;"><span>        pp <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (e <span style="color:#f92672">&gt;</span> p<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//双节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (p<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        minPP <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>        minP <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (minP<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            minPP <span style="color:#f92672">=</span> minP;
</span></span><span style="display:flex;"><span>            minP <span style="color:#f92672">=</span> minP<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> minP<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>        minPP<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">=</span> minP<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(minP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//有一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">||</span> (p<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL)) { <span style="color:#75715e">//应该将原有的pp同child连接在一起
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>lchild) {
</span></span><span style="display:flex;"><span>            child <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>           child <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pp<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">&gt;</span>p<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>            pp<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>child;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            pp<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>child;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//没有节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">==</span> p) {<span style="color:#75715e">//这里面临pp除p以外的节点为null的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        pp<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**************** 查找 **********************/</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Find</span>(BTreePtr T, ElemType e) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((T <span style="color:#f92672">!=</span> NULL) <span style="color:#f92672">&amp;&amp;</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> e)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (e <span style="color:#f92672">&gt;</span> T<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>            T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**************** 最大值 **********************/</span>
</span></span><span style="display:flex;"><span>ElemType <span style="color:#a6e22e">FindMax</span>(BTreePtr T) {
</span></span><span style="display:flex;"><span>    ElemType max;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        max <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>        T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> max;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**************** 最小值 **********************/</span>
</span></span><span style="display:flex;"><span>ElemType <span style="color:#a6e22e">FindMin</span>(BTreePtr T) {
</span></span><span style="display:flex;"><span>    ElemType min;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        min <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>        T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> min;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreOrderTraverse</span>(BTreePtr T)<span style="color:#75715e">//前序遍历二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>,T<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PreOrderTraverse</span>(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PreOrderTraverse</span>(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DestroyTree</span>(BTreePtr T) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>lchild) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">DestroyTree</span>(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(T<span style="color:#f92672">-&gt;</span>rchild) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">DestroyTree</span>(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(T);
</span></span><span style="display:flex;"><span>        T <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/***************** 执行测试 *************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    BTreePtr T;
</span></span><span style="display:flex;"><span>    T <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">66</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">55</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">15</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Insert</span>(<span style="color:#f92672">&amp;</span>T, a[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Max is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">FindMax</span>(T));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Min is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">FindMin</span>(T));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Delete</span>(T, <span style="color:#ae81ff">18</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Delete</span>(T, <span style="color:#ae81ff">13</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">PreOrderTraverse</span>(T);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DestroyTree</span>(T);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>bst</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> child_dir {
</span></span><span style="display:flex;"><span>    left_child,
</span></span><span style="display:flex;"><span>    right_child,
</span></span><span style="display:flex;"><span>    root,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> root {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">int</span> level, <span style="color:#66d9ef">enum</span> child_dir dir)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(node<span style="color:#f92672">-&gt;</span>right, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right_child);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dir <span style="color:#f92672">==</span> left_child)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%*s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, level<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;|&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%*s - %05lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, level<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34; &#34;</span>, node<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dir <span style="color:#f92672">==</span> right_child)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%*s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, level<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;|&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(node<span style="color:#f92672">-&gt;</span>left, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, left_child);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">struct</span> root <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> n <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> data)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> <span style="color:#a6e22e">new_node</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> node));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    n<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">struct</span> root <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>new)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>parent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>r) {
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>r <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    parent <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Don&#39;t support duplicate data */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (new<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> parent<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (new<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> parent<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>parent<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>            parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>parent<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>                parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> new;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">struct</span> root <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>n <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>r, <span style="color:#f92672">**</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>r;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>child;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&amp;&amp;</span> n<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> data) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> n<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>rn <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>right, <span style="color:#f92672">**</span>rp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (rn<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>            rp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rn<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            rn <span style="color:#f92672">=</span> rn<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> rn<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> rn;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> rp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    child <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">?</span> n<span style="color:#f92672">-&gt;</span>left : n<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> root tree;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree.r <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">9</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">8</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">18</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">13</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">21</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">20</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(tree.r, <span style="color:#ae81ff">0</span>, root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#a6e22e">find</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#ae81ff">18</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&amp;&amp;</span> n<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> <span style="color:#ae81ff">18</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Get 18</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> root tree;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node<span style="color:#f92672">*</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree.r <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">9</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">8</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">18</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">13</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">21</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#a6e22e">new_node</span>(<span style="color:#ae81ff">20</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(tree.r, <span style="color:#ae81ff">0</span>, root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">delete</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Delete 20</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(tree.r, <span style="color:#ae81ff">0</span>, root);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">delete</span>(<span style="color:#f92672">&amp;</span>tree, <span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Delete 9</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(tree.r, <span style="color:#ae81ff">0</span>, root);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//insert_test();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">delete_test</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="235-平衡树">2.3.5 平衡树<a hidden class="anchor" aria-hidden="true" href="#235-平衡树">#</a></h4>
<p> 平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.
 <strong>平衡指所有叶子的深度趋于平衡</strong>,更广义指树上所有可能查找的均摊复杂度偏低.<strong>平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡</strong>.
 对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.</p>
<ul>
<li><strong>AVL树</strong></li>
</ul>
<p> 在<strong>AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树</strong>.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.
 <strong>高度为h的AVL树,总节点数最多为2^h-1</strong>; 当前节点数为N时,高度h最多为:</p>
<blockquote>
<p>log(5*0.5 * (N + 1)) - 2</p>
</blockquote>
<br>
<ul>
<li><strong>红黑树</strong></li>
</ul>
<p> 红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)
 红黑树相对于AVL树,牺牲了部分平衡性以换取插入\删除操作时少量的旋转操作,整体性能优于AVL树.</p>
<p> 红黑树与AVL树的相比:
  AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.
  AVL的查找性能通常比红黑树好
  如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.</p>
<p> 红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:
  1.节点是红或黑色
  2.根是黑色
  3.所有叶子都是黑色(叶子是NIL节点)
  4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)
  5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.
 红黑树关键特性:<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.</p>
<ul>
<li><strong>B+树</strong></li>
</ul>
<p> B+树通常用于数据库和操作系统的文件系统中.<strong>B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度</strong>.B+树元素自底向上插入,与二叉树相反.
 B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.</p>
<ul>
<li><strong>字典树</strong></li>
</ul>
<details>
<summary>Trie</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define OK 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ERROR 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define TRUE 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FALSE 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> Node <span style="color:#f92672">*</span>children[<span style="color:#ae81ff">26</span>];
</span></span><span style="display:flex;"><span>    Status end;
</span></span><span style="display:flex;"><span>} Trie, <span style="color:#f92672">*</span>TriePtr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Init</span>(TriePtr <span style="color:#f92672">*</span>T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>T) <span style="color:#f92672">=</span> (TriePtr)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Trie));
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>T)<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;/&#39;</span>;
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>T)<span style="color:#f92672">-&gt;</span>end <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Insert</span>(TriePtr T, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> index;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(c <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>str<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">=</span> c <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>children[index] <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            TriePtr Node;
</span></span><span style="display:flex;"><span>            Node <span style="color:#f92672">=</span> (TriePtr)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(Trie));
</span></span><span style="display:flex;"><span>            Node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>            Node<span style="color:#f92672">-&gt;</span>end <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>            T<span style="color:#f92672">-&gt;</span>children[index] <span style="color:#f92672">=</span> Node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>children[index];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>end <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Search</span>(TriePtr T, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> index;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(c <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>str<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">=</span> c <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>children[index] <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>children[index];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>end) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    TriePtr T;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Init</span>(<span style="color:#f92672">&amp;</span>T);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hi&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Insert</span>(T, str);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;str is search %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">Search</span>(T, str));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;str2 is search %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">Search</span>(T, str2));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="236-堆树和优先队列">2.3.6 堆树和优先队列<a hidden class="anchor" aria-hidden="true" href="#236-堆树和优先队列">#</a></h4>
<p> 堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.
 堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.
 堆的特性:
  必须是完全二叉树
  用数组实现
  任一节点的值是其子树所有节点的最大值或最小值
   最大值时,称为最大堆,也称大顶堆
   最小时,称为最小堆,也称小顶堆.
 <strong>堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)</strong></p>
<p> 堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。
 堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Heap_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>compare)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destroy)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>tree;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>heap</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Implement heap */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_HEAP_SIZE (1 &lt;&lt; 8)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> element {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> heap {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> elements;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> element <span style="color:#f92672">*</span>elem[MAX_HEAP_SIZE];
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_heap</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAX_HEAP_SIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        heap<span style="color:#f92672">-&gt;</span>elem[i] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_heap</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap, <span style="color:#66d9ef">int</span> index)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> element <span style="color:#f92672">*</span>elem;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> level;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;</span> heap<span style="color:#f92672">-&gt;</span>elements)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    elem <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elem[index];
</span></span><span style="display:flex;"><span>    level <span style="color:#f92672">=</span> <span style="color:#a6e22e">fls</span>(index);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_heap</span>(heap, index <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(index <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%*s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, level<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;|&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%*s - %05d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, level<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34; &#34;</span>, elem<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%*s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, level<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;|&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_heap</span>(heap, index <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap, <span style="color:#66d9ef">int</span> elements)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> elements; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[%02d]: %4d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, heap<span style="color:#f92672">-&gt;</span>elem[i]<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> element<span style="color:#f92672">*</span> <span style="color:#a6e22e">create_element</span>(<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> element <span style="color:#f92672">*</span>elem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    elem <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> element));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (elem)
</span></span><span style="display:flex;"><span>        elem<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> elem;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fake_a_heap</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* data is in ordered */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, data[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">init_heap</span>(heap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* root start at 1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        heap<span style="color:#f92672">-&gt;</span>elem[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_element</span>(data[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    heap<span style="color:#f92672">-&gt;</span>elements <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> element <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elem[j];
</span></span><span style="display:flex;"><span>    heap<span style="color:#f92672">-&gt;</span>elem[j] <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elem[i];
</span></span><span style="display:flex;"><span>    heap<span style="color:#f92672">-&gt;</span>elem[i] <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapify</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap, <span style="color:#66d9ef">int</span> parent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> element <span style="color:#f92672">**</span>elem <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elem;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> elements <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elements;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> left, right, max;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        left <span style="color:#f92672">=</span> parent <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        right <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        max <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&lt;=</span> elements <span style="color:#f92672">&amp;&amp;</span> elem[max]<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> elem[left]<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>            max <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">&lt;=</span> elements <span style="color:#f92672">&amp;&amp;</span> elem[max]<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> elem[right]<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>            max <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (max <span style="color:#f92672">==</span> parent)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">swap</span>(heap, max, parent);
</span></span><span style="display:flex;"><span>        parent <span style="color:#f92672">=</span> max;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build_heap</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elements <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">heapify</span>(heap, i);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">heap_sort</span>(<span style="color:#66d9ef">struct</span> heap <span style="color:#f92672">*</span>heap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> elements <span style="color:#f92672">=</span> heap<span style="color:#f92672">-&gt;</span>elements;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (heap<span style="color:#f92672">-&gt;</span>elements) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">swap</span>(heap, <span style="color:#ae81ff">1</span>, heap<span style="color:#f92672">-&gt;</span>elements);
</span></span><span style="display:flex;"><span>        heap<span style="color:#f92672">-&gt;</span>elements<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">heapify</span>(heap, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> elements;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> heap heap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> elements;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fake_a_heap</span>(<span style="color:#f92672">&amp;</span>heap);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_heap</span>(<span style="color:#f92672">&amp;</span>heap, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After Heapify:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">build_heap</span>(<span style="color:#f92672">&amp;</span>heap);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_heap</span>(<span style="color:#f92672">&amp;</span>heap, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;After Heap sort:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    elements <span style="color:#f92672">=</span> <span style="color:#a6e22e">heap_sort</span>(<span style="color:#f92672">&amp;</span>heap);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(<span style="color:#f92672">&amp;</span>heap, elements);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p> 堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。</p>
<p> 优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。</p>
<p> 优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> Heap PQueue;
</span></span></code></pre></div><h4 id="237-leetcode题目">2.3.7 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#237-leetcode题目">#</a></h4>
<ul>
<li>先序遍历构造二叉树</li>
<li>从中序与后序遍历构造二叉树</li>
<li>二叉树的层次遍历</li>
<li>从二叉搜索树到更大和树</li>
<li>二叉搜索树的最近公共祖先</li>
<li>前K个高频单词&lt;堆&gt;</li>
</ul>
<h3 id="24-图">2.4 图<a hidden class="anchor" aria-hidden="true" href="#24-图">#</a></h3>
<p> 图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:<code>G(V,E)</code>.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.</p>
<p> 图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。
 图的访问方式：广度优先和深度优先。</p>
<h4 id="241-基础知识">2.4.1 基础知识<a hidden class="anchor" aria-hidden="true" href="#241-基础知识">#</a></h4>
<p> 图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。</p>
<ul>
<li>一组顶点：用V(vertex)表示顶点集合</li>
<li>一组边：用E(edge)表示边的集合
 图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。</li>
<li>(v, w)表示无向边，即v和w是互通的</li>
<li>&lt; v, w &gt;表示有向边，该边始于v，终于w
 图可分为连通图和非连通图</li>
<li>连通图：所有的点都右路径相连</li>
<li>非连通图：存在某两个点没有路径相连</li>
<li>强连通图：</li>
</ul>
<p> 图中的顶点度</p>
<ul>
<li>度</li>
<li>入度</li>
<li>出度</li>
</ul>
<h4 id="242-图表示">2.4.2 图表示<a hidden class="anchor" aria-hidden="true" href="#242-图表示">#</a></h4>
<p> 图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。
 图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。
邻接矩阵表示</p>
<p>邻接链表表示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> AdjList_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>vertex;
</span></span><span style="display:flex;"><span>    Set adjacent;
</span></span><span style="display:flex;"><span>}AdjList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Graph_ {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> vcount;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ecount;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>match)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);
</span></span><span style="display:flex;"><span>    List adjlists;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>graph</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vertex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vertex_adjs {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex_adjs <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vertex {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex_adjs <span style="color:#f92672">*</span>adj;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_GRAPH_VERTEX (1 &lt;&lt; 8)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> graph {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>vxs[MAX_GRAPH_VERTEX];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_graph</span>(<span style="color:#66d9ef">struct</span> graph <span style="color:#f92672">*</span>graph)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAX_GRAPH_VERTEX; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        graph<span style="color:#f92672">-&gt;</span>vxs[i] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span><span style="color:#a6e22e">create_vertex</span>(<span style="color:#66d9ef">int</span> data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> vertex));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (v) {
</span></span><span style="display:flex;"><span>        v<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>        v<span style="color:#f92672">-&gt;</span>adj <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> v;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vertex_adjs <span style="color:#f92672">*</span><span style="color:#a6e22e">create_vertex_adj</span>(<span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex_adjs <span style="color:#f92672">*</span>v_adj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    v_adj <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> vertex_adjs));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>v_adj)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    v_adj<span style="color:#f92672">-&gt;</span>v <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    v_adj<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> v_adj;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_adj</span>(<span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>v, <span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>adj)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> vertex_adjs <span style="color:#f92672">**</span>v_adj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    v_adj <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v<span style="color:#f92672">-&gt;</span>adj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>v_adj)
</span></span><span style="display:flex;"><span>    v_adj <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>v_adj)<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>v_adj <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_vertex_adj</span>(adj);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_raw</span>(<span style="color:#66d9ef">struct</span> graph <span style="color:#f92672">*</span>graph)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAX_GRAPH_VERTEX; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> vertex <span style="color:#f92672">*</span>v <span style="color:#f92672">=</span> graph<span style="color:#f92672">-&gt;</span>vxs[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> vertex_adjs <span style="color:#f92672">*</span>adj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Vertex[%02d]: %8d -&gt;&#34;</span>, i, v<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        adj <span style="color:#f92672">=</span> v<span style="color:#f92672">-&gt;</span>adj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (adj) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34; %8d,&#34;</span>, adj<span style="color:#f92672">-&gt;</span>v<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>            adj <span style="color:#f92672">=</span> adj<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  1 ----- 2 ----- 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  |     / |     /
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  |    /  |    / 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  |   /   |   /  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  |  /    |  /   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  | /     | /    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  4 ----- 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fake_a_graph</span>(<span style="color:#66d9ef">struct</span> graph <span style="color:#f92672">*</span>graph)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">init_graph</span>(graph);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">-&gt;</span>vxs[i] <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_vertex</span>(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* connect 1 -&gt; 2, 1 -&gt; 4 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">0</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">0</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* connect 2 -&gt; 1, 2 -&gt; 3, 2 -&gt; 5, 2 -&gt; 4 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">4</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* connect 3 -&gt; 2, 3 -&gt; 5 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">2</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">2</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">4</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* connect 4 -&gt; 1, 4 -&gt; 2, 4 -&gt; 5 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">4</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* connect 5 -&gt; 4, 5 -&gt; 2, 5 -&gt; 3 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">4</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">4</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insert_adj</span>(graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">4</span>], graph<span style="color:#f92672">-&gt;</span>vxs[<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> graph g;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fake_a_graph</span>(<span style="color:#f92672">&amp;</span>g);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump_raw</span>(<span style="color:#f92672">&amp;</span>g);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="243-图遍历">2.4.3 图遍历<a hidden class="anchor" aria-hidden="true" href="#243-图遍历">#</a></h4>
<p> 图的搜索方法：深度优先搜索和广度优先搜索。
 深度优先遍历(DFS)
 思路: 从图中某点v出发:
   1.访问顶点v
   2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.
   3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.
 伪代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(Vertex v) {
</span></span><span style="display:flex;"><span>    vistied[v] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (v <span style="color:#960050;background-color:#1e0010">的每个邻接点</span> w) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[w]) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">DFS</span>(w);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><details>
<summary>dfs</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Graph.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_NODES 1000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> visited[MAX_NODES];  <span style="color:#75715e">// array to store visiting order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                         <span style="color:#75715e">// indexed by vertex 0..nV-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfsPathCheck</span>(Graph g, <span style="color:#66d9ef">int</span> nV, Vertex v, Vertex dest)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Vertex w;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> nV; w<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">adjacent</span>(g, v, w) <span style="color:#f92672">&amp;&amp;</span> visited[w] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            visited[w] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (w <span style="color:#f92672">==</span> dest)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dfsPathCheck</span>(g, nV, w, dest))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">findPathDFS</span>(Graph g, <span style="color:#66d9ef">int</span> nV, Vertex src, Vertex dest)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Vertex v;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> nV; v<span style="color:#f92672">++</span>) visited[v] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    visited[src] <span style="color:#f92672">=</span> src;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dfsPathCheck</span>(g, nV, src, dest);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    Graph g <span style="color:#f92672">=</span> <span style="color:#a6e22e">newGraph</span>(V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Edge e;
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> src <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dest <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">findPathDFS</span>(g, V, src, dest)) {
</span></span><span style="display:flex;"><span>        Vertex v <span style="color:#f92672">=</span> dest;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (v <span style="color:#f92672">!=</span> src) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d - &#34;</span>, v);
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">=</span> visited[v];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, src);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p> 广度优先遍历(BFS)
 思路:
   1.顶点v入队列
   2.当队列非空时则继续执行,否则算法结束.
   3.出队列取得队头顶点v&rsquo;,访问顶点v 并标记顶点v已被访问.
   4.查找顶点v的第一个邻接顶点col
   5.若v的邻接顶点col未被访问过的,则col继续.
   6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.</p>
<details>
<summary>bfs_queue</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Graph.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;queue.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_NODES 1000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> visited[MAX_NODES];  <span style="color:#75715e">// array to store visiting order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                         <span style="color:#75715e">// indexed by vertex 0..nV-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">findPathBFS</span>(Graph g, <span style="color:#66d9ef">int</span> nV, Vertex src, Vertex dest)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Vertex v;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> nV; v<span style="color:#f92672">++</span>) visited[v] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    visited[src] <span style="color:#f92672">=</span> src;
</span></span><span style="display:flex;"><span>    queue Q <span style="color:#f92672">=</span> <span style="color:#a6e22e">newQueue</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QueueEnqueue</span>(Q, src);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">QueueIsEmpty</span>(Q)) {
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> <span style="color:#a6e22e">QueueDequeue</span>(Q);
</span></span><span style="display:flex;"><span>        Vertex w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> nV; w<span style="color:#f92672">++</span>) (
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">adjacent</span>(g, v, w) <span style="color:#f92672">&amp;&amp;</span> visited[w] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                visited[w] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (w <span style="color:#f92672">==</span> dest)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">QueueEnqueue</span>(Q, w);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    Graph g <span style="color:#f92672">=</span> <span style="color:#a6e22e">newGraph</span>(V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Edge e;
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>    e.v <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    e.w <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">insertEdge</span>(g, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> src <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dest <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">findPathBFS</span>(g, V, src, dest)) {
</span></span><span style="display:flex;"><span>        Vertex v <span style="color:#f92672">=</span> dest;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (v <span style="color:#f92672">!=</span> src) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d - &#34;</span>, v);
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">=</span> visited[v];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, src);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p> 深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)</p>
<p>深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.
广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.</p>
<h4 id="244-最短路径">2.4.4 最短路径<a hidden class="anchor" aria-hidden="true" href="#244-最短路径">#</a></h4>
<p><strong>迪杰斯特拉Dijkstra算法</strong>
 Dijkstra算法适用于权值为正的图.
 Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.
 在源点可达的情况下,Dijkstra算法的时间复杂度时 <code>O(ElogV)</code>
 算法步骤:
  1.将所有边初始化为无穷大
  2.旋转一个开始的顶点,添加到优先队列中.
  3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.
  4.将该点所有邻接顶点添加到优先队列中.
  5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5
  6.直到所有点都被处理过一次.</p>
<detials>
<summary>迪杰斯特拉</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INF 999
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> mat[MAX][MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> V;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist[MAX];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> q[MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> qp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">enqueue</span>(<span style="color:#66d9ef">int</span> v) { q[qp<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> v; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cf</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dequeue</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">qsort</span>(q, qp, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>), cf);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> q[<span style="color:#f92672">--</span>qp];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queue_has_something</span>() { <span style="color:#66d9ef">return</span> (qp <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> visited[MAX];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> vp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    dist[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> s) {
</span></span><span style="display:flex;"><span>            dist[i] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">enqueue</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">queue_has_something</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> <span style="color:#a6e22e">dequeue</span>();
</span></span><span style="display:flex;"><span>        visited[vp<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mat[u][i]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (dist[i] <span style="color:#f92672">&gt;</span> dist[u] <span style="color:#f92672">+</span> mat[u][i]) {
</span></span><span style="display:flex;"><span>                    dist[i] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> mat[u][i];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the number of vertices: &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34; %d&#34;</span>, <span style="color:#f92672">&amp;</span>V);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the adj matrix: &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34; %d&#34;</span>, <span style="color:#f92672">&amp;</span>mat[i][j]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dijkstra</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Node</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Dist</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, dist[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></detials>
<p><strong>弗洛伊德Floyd算法</strong>
 Floyd算法是一个经典的动态规划算法.首先目标是寻找从点<code>i</code>到<code>j</code>的最短路径.
 <strong>Floyd算法可以求出任意两点的最短距离.时间复杂度:</strong><code>O(你^3)</code>
 从任意节点i到任意节点j的最短路径不外乎2种可能:
  1.是之间从i到j
  2是从i到经过若干个节点k到j
 设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> n; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (A[i][j] <span style="color:#f92672">&gt;</span> (A[i][k] <span style="color:#f92672">+</span> A[k][j])) {
</span></span><span style="display:flex;"><span>                A[i][j] <span style="color:#f92672">=</span> A[i][k] <span style="color:#f92672">+</span> A[k][j];
</span></span><span style="display:flex;"><span>                path[i][j] <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="245-拓扑排序">2.4.5 拓扑排序<a hidden class="anchor" aria-hidden="true" href="#245-拓扑排序">#</a></h4>
<p> 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.
 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。
 拓扑排序步骤：</li>
<li>从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边</li>
<li>重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ul>
<h4 id="246-leetcode题目">2.4.6 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#246-leetcode题目">#</a></h4>
<ul>
<li>判断二分图</li>
<li>克隆图</li>
<li>找到小镇的法官</li>
<li>钥匙和房间</li>
<li>最短路径访问所有节点</li>
</ul>
<br>
<h2 id="3-常见算法">3 常见算法<a hidden class="anchor" aria-hidden="true" href="#3-常见算法">#</a></h2>
<h3 id="31-递归思想">3.1 递归思想<a hidden class="anchor" aria-hidden="true" href="#31-递归思想">#</a></h3>
<h4 id="311-递归思想">3.1.1 递归思想<a hidden class="anchor" aria-hidden="true" href="#311-递归思想">#</a></h4>
<p> 递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.
 如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.</p>
<!--more-->
<p> 斐波那契数列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> N)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (N <span style="color:#f92672">&lt;</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> N;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>(N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">fib</span>(N<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 递归的过程中,符合<strong>后进先出</strong>规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是<strong>递归终止条件</strong>.
 递归思想的两个延申算法:分治算法和动态规划.
 递归的一般结构:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">符合边界条件</span>) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ..;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 某种形式的调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">func</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p> 阶乘函数:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">factorial</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n <span style="color:#f92672">*</span> <span style="color:#a6e22e">factorial</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>参考链接:https://www.jianshu.com/p/b2d2edb4ba5b</li>
</ul>
<h4 id="312-递归基本步骤">3.1.2 递归基本步骤:<a hidden class="anchor" aria-hidden="true" href="#312-递归基本步骤">#</a></h4>
<p>  1.定义一个函数,明确函数功能
  2.寻找问题与子问题之间的关系(递推公式)
  3.将递推公式在定义的函数中实现
  4.推导时间复杂度,判定是否可以接受,无法接受更换算法.</p>
<h4 id="313-代表题目">3.1.3 代表题目<a hidden class="anchor" aria-hidden="true" href="#313-代表题目">#</a></h4>
<ul>
<li>爬楼梯 70</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">climbStairs</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>mem <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mem[n] <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">climb</span>(n, mem);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">climb</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>mem)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (mem[n] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> mem[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mem[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">climb</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, mem) <span style="color:#f92672">+</span> <span style="color:#a6e22e">climb</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, mem);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mem[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>青蛙跳台阶 10-II</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">numWays</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num[n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">jump</span>(n, num);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">jump</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>num)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (num[n] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    num[n] <span style="color:#f92672">=</span> (<span style="color:#a6e22e">jump</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, num) <span style="color:#f92672">+</span> <span style="color:#a6e22e">jump</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, num) <span style="color:#f92672">%</span> <span style="color:#ae81ff">1e9</span><span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> num[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="314-触类旁通">3.1.4 触类旁通<a hidden class="anchor" aria-hidden="true" href="#314-触类旁通">#</a></h4>
<ul>
<li>反转二叉树 226
 1).对于根节点<code>1</code>来说,假设<code>2,3</code>节点下的节点都已经翻转,那么只要翻转<code>2,2</code>节点即满足需求.
 2).对于<code>2,3</code>节点来说,也是翻转其左右节点即可.
 依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即</li>
</ul>
<blockquote>
<p>invert(root) = invert(root-&gt;left) + invert(root-&gt;right)
 加号是追加到root上的意思</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> TreeNode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TreeNode <span style="color:#a6e22e">invertTree</span>(TreeNode <span style="color:#f92672">*</span>root)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>left <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> TreeNode <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(TreeNode));
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>right <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> TreeNode <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(TreeNode));
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">=</span> <span style="color:#a6e22e">invertTree</span>(root.left);
</span></span><span style="display:flex;"><span>    rgith <span style="color:#f92672">=</span> <span style="color:#a6e22e">invertTree</span>(root.right);
</span></span><span style="display:flex;"><span>    root.left <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>    root.right <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>路径总和 112
 给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> TreeNode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">hasPathSum</span>(TreeNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> sum)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root.left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> root.right <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root.data <span style="color:#f92672">==</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> remain <span style="color:#f92672">=</span> sum <span style="color:#f92672">-</span> root.data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hasPathSum</span>(root.left, remain) <span style="color:#f92672">||</span> <span style="color:#a6e22e">hashPashSum</span>(root.right, remain);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>细胞分裂</li>
</ul>
<p><a href="https://www.jianshu.com/p/b2d2edb4ba5b">https://www.jianshu.com/p/b2d2edb4ba5b</a></p>
<h3 id="32-分治法">3.2 分治法<a hidden class="anchor" aria-hidden="true" href="#32-分治法">#</a></h3>
<p> 把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题&hellip;，直到可以直接求解，原问题的解为子问题解的合并。
 分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。</p>
<h4 id="321-概述">3.2.1 概述<a hidden class="anchor" aria-hidden="true" href="#321-概述">#</a></h4>
<p> 分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.</p>
<p> 分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题&hellip;,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的<strong>合并</strong>.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换
 1):数学归纳是使用分治思想.
 2):分治思想不一定使用递归结构.
 递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是<strong>如何分</strong></p>
<h4 id="322-策略">3.2.2 策略<a hidden class="anchor" aria-hidden="true" href="#322-策略">#</a></h4>
<p> 分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.</p>
<h4 id="323-应用场景">3.2.3 应用场景<a hidden class="anchor" aria-hidden="true" href="#323-应用场景">#</a></h4>
<p> 分治法特征:</p>
<ul>
<li>问题缩小到一定程度可容易解决.</li>
<li>问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.</li>
<li>子问题的解可合并为该问题的解.</li>
<li>问题分解的子问题相互独立,子问题之间不包含公告子问题.</li>
</ul>
<h4 id="324-步骤">3.2.4 步骤<a hidden class="anchor" aria-hidden="true" href="#324-步骤">#</a></h4>
<p> 分治法一层递归步骤:</p>
<ul>
<li>
<ol>
<li><strong>分解</strong>:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.</li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>解决</strong>:若子问题可直接求解,则直接求解,否则递归解各个子问题.</li>
</ol>
</li>
<li>
<ol start="3">
<li><strong>合并</strong>:将各个子问题的解合并为原问题的解.</li>
</ol>
</li>
</ul>
<p> </p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"></code></pre></div><br>
<h4 id="325-应用">3.2.5 应用<a hidden class="anchor" aria-hidden="true" href="#325-应用">#</a></h4>
<blockquote>
<p>分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。</p>
</blockquote>
<p> 求x的n次幂
 对数复杂度O(logn)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">power</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> <span style="color:#a6e22e">power</span>(x, n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">power</span>(x, n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> <span style="color:#a6e22e">power</span>(x, (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">power</span>(x, (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="326-leetcode题目">3.2.6 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#326-leetcode题目">#</a></h4>
<ul>
<li>搜索二维矩阵II</li>
<li>求众数</li>
<li>合并k个排序链表</li>
</ul>
<h3 id="33-排序算法">3.3 排序算法<a hidden class="anchor" aria-hidden="true" href="#33-排序算法">#</a></h3>
<p> 各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，</p>
<h4 id="331-冒泡排序">3.3.1 冒泡排序<a hidden class="anchor" aria-hidden="true" href="#331-冒泡排序">#</a></h4>
<p> 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。
 <strong>冒泡排序算法复杂度是O(n^2)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubleSort</span>(<span style="color:#66d9ef">int</span>[] arr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> arr.length;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> out <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; out <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; out<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> in <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; in <span style="color:#f92672">&lt;</span> out; in<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (arr[in] <span style="color:#f92672">&gt;</span> arr[in <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">swap</span>(arr, in, in <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define SWAP(a,b) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">do{\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (a) ^= (b);\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (b) ^= (a);\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (a) ^= (b);\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}while(0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*冒泡排序*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubble_sort</span>(<span style="color:#66d9ef">int</span> a[],<span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> swap_flg <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {<span style="color:#75715e">/*排序的趟数*/</span> 
</span></span><span style="display:flex;"><span>        swap_flg <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">/*每次设置交换标识为0*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; j<span style="color:#f92672">++</span>) {          <span style="color:#75715e">/*本趟排序的遍历元素个数*/</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (a[j] <span style="color:#f92672">&gt;</span> a[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">SWAP</span>(a[j],a[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>                swap_flg <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*本趟数，无数据交换的话，说明已经有序，直接退出*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (swap_flg <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//整数或浮点数皆可使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> bubble_sort(T arr[], <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j; T temp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&gt;</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                temp <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>                arr[j] <span style="color:#f92672">=</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="332-选择排序">3.3.2 选择排序<a hidden class="anchor" aria-hidden="true" href="#332-选择排序">#</a></h4>
<p> 选择排序算法时间复杂度为O(n^2)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectSort</span>(<span style="color:#66d9ef">int</span>[] arr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> arr.lenght;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> out <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; out <span style="color:#f92672">&lt;</span> size; out<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mixIndex <span style="color:#f92672">=</span> out;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> in <span style="color:#f92672">=</span> out <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; in <span style="color:#f92672">&lt;</span> size; in<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (arr[mixIndex] <span style="color:#f92672">&gt;</span> arr[in]) {
</span></span><span style="display:flex;"><span>                mixIndex <span style="color:#f92672">=</span> in;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mixIndex <span style="color:#f92672">!=</span> out) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">swap</span>(arr, mixIndex, out);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*选择排序*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">select_sort</span>(<span style="color:#66d9ef">int</span> a[],<span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)  {
</span></span><span style="display:flex;"><span>        min <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> size; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (a[j] <span style="color:#f92672">&lt;</span> a[min]) {
</span></span><span style="display:flex;"><span>                min <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (min <span style="color:#f92672">!=</span> i) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">SWAP</span>(a[i],a[min]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="333-插入排序">3.3.3 插入排序<a hidden class="anchor" aria-hidden="true" href="#333-插入排序">#</a></h4>
<p> 插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertSort</span>(<span style="color:#66d9ef">int</span>[] arr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> arr.lenght;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> out <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; out <span style="color:#f92672">&lt;</span> size; out<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[out];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> in <span style="color:#f92672">=</span> out;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (in <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> arr[in <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> temp) {
</span></span><span style="display:flex;"><span>            arr[in] <span style="color:#f92672">=</span> arr[in <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            in<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (in <span style="color:#f92672">!=</span> out) {
</span></span><span style="display:flex;"><span>            arr[in] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*插入排序*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_sort</span>(<span style="color:#66d9ef">int</span> a[],<span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> size; i <span style="color:#f92672">++</span>)<span style="color:#75715e">/*需要插入的元素个数*/</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> a[i];<span style="color:#75715e">/*保存插入的元素数据*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* i 之前的元素都是有序的，找到比key小的插入到他后面，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        * 比key大的，需要往后挪一个位置*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>((j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span> (a[j] <span style="color:#f92672">&gt;</span> key)) {
</span></span><span style="display:flex;"><span>            a[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> a[j];
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        a[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">issort</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> size, <span style="color:#66d9ef">int</span> esize, <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>compare)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((key <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(esize)) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> size; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">compare</span>(<span style="color:#f92672">&amp;</span>a[i <span style="color:#f92672">*</span> esize], key) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mamcpy</span>(<span style="color:#f92672">&amp;</span>a[(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> esize], <span style="color:#f92672">&amp;</span>a[i <span style="color:#f92672">*</span> esize], esize);
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memcpy</span>(<span style="color:#f92672">&amp;</span>a[(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> esize], key, esize);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="334-希尔排序">3.3.4 希尔排序<a hidden class="anchor" aria-hidden="true" href="#334-希尔排序">#</a></h4>
<p> 希尔排序时间复杂度O(n*(logn)^2)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shellSort</span>(<span style="color:#66d9ef">int</span>[] arr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> arr.lenght;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&lt;=</span> size <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        h <span style="color:#f92672">=</span> h <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> out <span style="color:#f92672">=</span> h; out <span style="color:#f92672">&lt;</span> size; out<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[out];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> in <span style="color:#f92672">=</span> out;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (in <span style="color:#f92672">-</span> h <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> arr[in <span style="color:#f92672">-</span> h] <span style="color:#f92672">&gt;</span> temp) {
</span></span><span style="display:flex;"><span>                arr[in] <span style="color:#f92672">=</span> arr[in <span style="color:#f92672">-</span> h];
</span></span><span style="display:flex;"><span>                in <span style="color:#f92672">=</span> in <span style="color:#f92672">-</span> h;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (in <span style="color:#f92672">!=</span> out) {
</span></span><span style="display:flex;"><span>                arr[in] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        h <span style="color:#f92672">=</span> (h <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="335-归并排序">3.3.5 归并排序<a hidden class="anchor" aria-hidden="true" href="#335-归并排序">#</a></h4>
<p> 归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">min</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>  x <span style="color:#f92672">&lt;</span> y <span style="color:#f92672">?</span> x : y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> arr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(len <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> seg, start;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (seg <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; seg <span style="color:#f92672">&lt;</span> len; seg <span style="color:#f92672">+=</span> seg) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (start )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; idx <span style="color:#f92672">&lt;</span> size; idx<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%08d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arr[idx]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__merge</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j, k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>((r <span style="color:#f92672">-</span> p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tmp)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">abort</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> p, j <span style="color:#f92672">=</span> q <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> q <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> r;) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (arr[i] <span style="color:#f92672">&lt;=</span> arr[j])
</span></span><span style="display:flex;"><span>            tmp[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[i<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            tmp[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[j<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> q <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (; j <span style="color:#f92672">&lt;=</span> r;)
</span></span><span style="display:flex;"><span>            tmp[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[j<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;=</span> q;)
</span></span><span style="display:flex;"><span>            tmp[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[i<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(arr <span style="color:#f92672">+</span> p, tmp, (r <span style="color:#f92672">-</span> p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(tmp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__merge_sort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> q;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">&gt;=</span> r)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> (p <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__merge_sort</span>(arr, p, q);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__merge_sort</span>(arr, q <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__merge</span>(arr, p, q, r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__merge_sort</span>(arr, <span style="color:#ae81ff">0</span>, size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_verify</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> test[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">56</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__merge</span>(test, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(test, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> test[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">56</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">merge_sort</span>(test, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(test, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//merge_verify();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">merge_sort_test</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="336-快速排序">3.3.6 快速排序<a hidden class="anchor" aria-hidden="true" href="#336-快速排序">#</a></h4>
<p> 快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)</p>
<p> 快速排序三个步骤：</p>
<ul>
<li>分：设定一个分割值并将数据分为两部分。</li>
<li>治：分别在两部分使用递归方式继续使用快速排序方法。</li>
<li>和：对分割部分排序直至完成。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _Range {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> start;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>} Range;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Range <span style="color:#a6e22e">now_Range</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Range r;
</span></span><span style="display:flex;"><span>    r.start <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>    r.end <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>x, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>y;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Range r[len];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    r[p<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">new_Range</span>(<span style="color:#ae81ff">0</span>, len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p) {
</span></span><span style="display:flex;"><span>        Range range <span style="color:#f92672">=</span> r[<span style="color:#f92672">--</span>p];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (range.start <span style="color:#f92672">&gt;=</span> range.end) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> arr[(range.start <span style="color:#f92672">+</span> range.end) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> range.start;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> range.end;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (arr[left] <span style="color:#f92672">&lt;</span> mid) {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">++</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (arr[right] <span style="color:#f92672">&gt;</span> mid) {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">--</span>right;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&lt;=</span> right) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">swap</span>(<span style="color:#f92672">&amp;</span>arr[left], <span style="color:#f92672">&amp;</span>arr[right]);
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (range.start <span style="color:#f92672">&lt;</span> right) {
</span></span><span style="display:flex;"><span>            r[p<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">new_Range</span>(range.start, right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (range.end <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>            r[p<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">new_Range</span>(left, range.end);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> low;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> high;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> arr[low];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从右向左找第一个小于k的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> arr[j] <span style="color:#f92672">&gt;=</span> k) {
</span></span><span style="display:flex;"><span>                j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>                arr[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从左向右找第一个大于等于k的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> arr[i] <span style="color:#f92672">&lt;</span> k) {
</span></span><span style="display:flex;"><span>                i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>                arr[j<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        arr[i] <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">QuickSort</span>(arr, low, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 排序k左边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">QuickSort</span>(arr, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high); <span style="color:#75715e">// 排序k右边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>( <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j, p, tmp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>)  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> a[n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>];   <span style="color:#75715e">// Get the middle element as pivot ..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;; i<span style="color:#f92672">++</span>, j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (a[i] <span style="color:#f92672">&lt;</span> p)
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&lt;</span> a[j])
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( i <span style="color:#f92672">&gt;=</span> j)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> a[i]; a[i] <span style="color:#f92672">=</span> a[j]; a[j] <span style="color:#f92672">=</span> tmp;    <span style="color:#75715e">//swap both ..
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quick_sort</span>( a, i); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quick_sort</span>( a <span style="color:#f92672">+</span> i, n <span style="color:#f92672">-</span> i); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; idx <span style="color:#f92672">&lt;</span> size; idx<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%08d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arr[idx]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//int pivot = arr[r];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (; j <span style="color:#f92672">&lt;</span> r; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&lt;</span> arr[r]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> j) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">swap</span>(arr <span style="color:#f92672">+</span> i, arr <span style="color:#f92672">+</span> j);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">swap</span>(arr <span style="color:#f92672">+</span> i, arr <span style="color:#f92672">+</span> r);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__quick_sort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> q;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">&gt;=</span> r)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> <span style="color:#a6e22e">partition</span>(arr, p, r);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__quick_sort</span>(arr, p, q<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__quick_sort</span>(arr, q<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__quick_sort</span>(arr, <span style="color:#ae81ff">0</span>, size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort_test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> test[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">56</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quick_sort</span>(test, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dump</span>(test, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quick_sort_test</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Qsort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (high <span style="color:#f92672">&lt;=</span> low) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> low;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> high <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> arr[low];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*从左向右找比key大的值*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (arr[<span style="color:#f92672">++</span>i] <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> high) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*从右向左找比key小的值*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (arr[<span style="color:#f92672">--</span>j] <span style="color:#f92672">&gt;</span> key)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> low) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> j) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*交换i,j对应的值*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>        arr[i] <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>        arr[j] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*中枢值与j对应值交换*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[low];
</span></span><span style="display:flex;"><span>    arr[low] <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>    arr[j] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>    Qsort(arr, low, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    Qsort(arr, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>qsort/sort函数</strong>
 在c语言库函数中已经实现了qsort函数,
 qsort函数用法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">qsort</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>base, <span style="color:#66d9ef">int</span> nelem, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fcmp)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// int 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)a <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qsort</span>(arr, n, <span style="color:#66d9ef">sizeof</span>(arr[<span style="color:#ae81ff">0</span>]), cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// char 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">com</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)a <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> word[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qsort</span>(word, <span style="color:#ae81ff">100</span>, <span style="color:#66d9ef">sizeof</span>(word[<span style="color:#ae81ff">0</span>]), cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// double 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>)a <span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">double</span><span style="color:#f92672">*</span>)b <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> in[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qsort</span>(in, <span style="color:#ae81ff">100</span>, <span style="color:#66d9ef">sizeof</span>(in[<span style="color:#ae81ff">00</span>]), cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// struct 结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Sample {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>}st[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>(Sample <span style="color:#f92672">*</span>)a).data <span style="color:#f92672">&gt;</span> (<span style="color:#f92672">*</span>(Sampel <span style="color:#f92672">*</span>)b).data <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qsort</span>(s, <span style="color:#ae81ff">100</span>, <span style="color:#66d9ef">sizeof</span>(s[<span style="color:#ae81ff">0</span>]), cmp);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> Sample <span style="color:#f92672">*</span>c <span style="color:#f92672">=</span> (Sample <span style="color:#f92672">*</span>)a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> Sample <span style="color:#f92672">*</span>d <span style="color:#f92672">=</span> (Sample <span style="color:#f92672">*</span>)b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">!=</span> d<span style="color:#f92672">-&gt;</span>x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> c<span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">-</span> d<span style="color:#f92672">-&gt;</span>x;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d<span style="color:#f92672">-&gt;</span>y <span style="color:#f92672">-</span> c<span style="color:#f92672">-&gt;</span>y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qsort</span>(s,<span style="color:#ae81ff">100</span>,<span style="color:#66d9ef">sizeof</span>(s[<span style="color:#ae81ff">0</span>]),cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>truct Sample
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> str[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>}s[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//按照结构体中字符串str的字典顺序排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strcmp</span>((<span style="color:#f92672">*</span>(Sample <span style="color:#f92672">*</span>)a)<span style="color:#f92672">-&gt;</span>str , (<span style="color:#f92672">*</span>(Sample <span style="color:#f92672">*</span>)b)<span style="color:#f92672">-&gt;</span>str);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qsort</span>(s,<span style="color:#ae81ff">100</span>,<span style="color:#66d9ef">sizeof</span>(s[<span style="color:#ae81ff">0</span>]),cmp);
</span></span></code></pre></div><h4 id="337-堆排序">3.3.7 堆排序<a hidden class="anchor" aria-hidden="true" href="#337-堆排序">#</a></h4>
<p> 桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。
 存在两个问题：
 (1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。
 (2)对每个数据块里的数据怎样排序。
 堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。
 堆排序的过程：
 1.由输入的无序数组构造一个最大堆，作为初始的无序区
 2.把堆顶元素(最大值)和堆尾元素互换
 3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。
 4.重复步骤2，直到堆的尺寸为1
 因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;sdtio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> node {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> key;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> node <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} KeyNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bucket_sort</span>(<span style="color:#66d9ef">int</span> keys[], <span style="color:#66d9ef">int</span> size, <span style="color:#66d9ef">int</span> bucket_size) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>    KeyNode <span style="color:#f92672">**</span>bucket_table <span style="color:#f92672">=</span> (KeyNode <span style="color:#f92672">**</span>)<span style="color:#a6e22e">mallov</span>(bucket_size <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(KeyNode<span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> bucket_size;i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        bucket_table[i] <span style="color:#f92672">=</span> (KeyNode<span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(KeyNode));
</span></span><span style="display:flex;"><span>        bucket_table[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        bucket_table[i]<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;j <span style="color:#f92672">&lt;</span> size;j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        KeyNode <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> (KeyNode <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(KeyNode));
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> keys[j];
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> keys[j]<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        KeyNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> bucket_table[index];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            bucket_table[index]<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            (bucket_table[index]<span style="color:#f92672">-&gt;</span>key)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;=</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            (bucket_table[index]<span style="color:#f92672">-&gt;</span>key)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//print result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    KeyNode <span style="color:#f92672">*</span> k <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> bucket_size;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(k <span style="color:#f92672">=</span> bucket_table[i]<span style="color:#f92672">-&gt;</span>next;k<span style="color:#f92672">!=</span>NULL;k<span style="color:#f92672">=</span>k<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>,k<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> raw[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">38</span>,<span style="color:#ae81ff">65</span>,<span style="color:#ae81ff">97</span>,<span style="color:#ae81ff">76</span>,<span style="color:#ae81ff">13</span>,<span style="color:#ae81ff">27</span>,<span style="color:#ae81ff">49</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(raw)<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bucket_sort</span>(raw,size,<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Heapify</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lef_child <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> right_child <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (lef_child <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">&amp;&amp;</span> A[lef_child] <span style="color:#f92672">&gt;</span> A[max]) {
</span></span><span style="display:flex;"><span>        max <span style="color:#f92672">=</span> lef_child;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (right_child <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">&amp;&amp;</span> A[right_child] <span style="color:#f92672">&gt;</span> A[max]) {
</span></span><span style="display:flex;"><span>        max <span style="color:#f92672">=</span> right_child;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (max <span style="color:#f92672">!=</span> i) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Swap</span>(A, i max);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Heapify</span>(A, max, size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BuildHeap</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> heap_size <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> heap_size <span style="color:#f92672">/</span> w <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Heapify</span>(A, i, heap_size);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> heap_size;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeapSort</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> heap_size <span style="color:#f92672">=</span> <span style="color:#a6e22e">BuildHeap</span>(A, n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (heap_size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Swap</span>(A, <span style="color:#ae81ff">0</span>, heap_size);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Heap</span>(A, <span style="color:#ae81ff">0</span>, heap_size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="338-leetcode排序">3.3.8 leetcode排序<a hidden class="anchor" aria-hidden="true" href="#338-leetcode排序">#</a></h4>
<ul>
<li>按奇偶排序数组</li>
<li>对链表进行插入排序</li>
<li>合并区间</li>
<li>最大数</li>
<li>最接近原点的K个点</li>
</ul>
<h3 id="34-贪心算法">3.4 贪心算法<a hidden class="anchor" aria-hidden="true" href="#34-贪心算法">#</a></h3>
<h4 id="341-基本概念">3.4.1 基本概念<a hidden class="anchor" aria-hidden="true" href="#341-基本概念">#</a></h4>
<p> 贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.
 贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.</p>
<h4 id="342-描述">3.4.2 描述<a hidden class="anchor" aria-hidden="true" href="#342-描述">#</a></h4>
<p> 贪心算法实现步骤:
 1.建立数学模型描述问题
 2.把求解的问题分成若干个子问题
 3.对每个子问题求解,得到子问题的局部最优解
 4.把子问题的解局部最优解合成原来问题的一个解.
 实现算法过程:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#960050;background-color:#1e0010">能朝给定总目标前进一步</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">利用可行的决策</span>,<span style="color:#960050;background-color:#1e0010">求出可行解的一个解元素</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">由所有解元素组合成问题的一个可行解</span>
</span></span></code></pre></div><h4 id="343-应用">3.4.3 应用<a hidden class="anchor" aria-hidden="true" href="#343-应用">#</a></h4>
<p><strong>最小生成树算法</strong>
 贪心算法经典实践:最小生成树算法
 设<code>G=(V, E)</code>是无向连通带权图,即一个网络,E中的每一条边<code>(v,w)</code> 的全为 <code>c[v][w]</code>.如果G的字体 G&rsquo; 是一颗包含 G 的所有顶点的数,则称 G&rsquo; 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.
 最小生成树的性质:
  设<code>G=(V, E)</code>是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.</p>
<p><strong>Prim算法</strong>
  设<code>G=(V, E)</code>是连通带权图, V={1,2,&hellip;,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.</p>
<details>
<summary>Prim</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @author [Timothy Maloney](https://github.com/sl1mb0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @brief [Prim&#39;s algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * implementation in C to find the MST of a weighted, connected graph.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @details Prim&#39;s algorithm uses a greedy approach to generate the MST of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *weighted connected graph. The algorithm begins at an arbitrary vertex v, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *selects a next vertex u, where v and u are connected by a weighted edge whose
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *weight is the minimum of all edges connected to v.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @references Page 319 &#34;Introduction to the Design and Analysis of Algorithms&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *- Anany Levitin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * To test - run &#39;./prim -test&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * prim() will find the MST of the following adj. matrix:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *	  0  1  2  3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *        1  0  4  6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *        2  4  0  5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *        3  6  5  0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The minimum spanning tree for the above weighted connected graph is given by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *the following adj matrix:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *	  0  1  2  3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *	  1  0  0  0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *	  2  0  0  0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *	  3  0  0  0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The following [link](https://visualgo.net/en/mst) provides a visual
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *representation of graphs that can be used to test/verify the algorithm for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *different adj matrices and their weighted, connected graphs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;    /// for assert()</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;inttypes.h&gt;  /// for uint16_t</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;     /// for IO operations</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;    /// for string comparison</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INF 999
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @brief Finds index of minimum element in edge list for an arbitrary vertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr graph row
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param N number of elements in arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @returns index of minimum element in arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint16_t</span> <span style="color:#a6e22e">minimum</span>(<span style="color:#66d9ef">uint16_t</span> arr[], <span style="color:#66d9ef">uint16_t</span> N)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> min <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (arr[i] <span style="color:#f92672">&lt;</span> min) {
</span></span><span style="display:flex;"><span>            min <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>            index <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> index;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @brief Used to find MST of user-generated adj matrix G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @returns void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">prim</span>(<span style="color:#66d9ef">uint16_t</span> G[][MAX], <span style="color:#66d9ef">uint16_t</span> MST[][MAX], <span style="color:#66d9ef">uint16_t</span> V)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> u, v;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> E_t[MAX], path[MAX];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> V_t[MAX], no_of_edges;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    E_t[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// edges for current vertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    V_t[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// list of visited vertices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> V; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        E_t[i] <span style="color:#f92672">=</span> G[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        path[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        V_t[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    no_of_edges <span style="color:#f92672">=</span> V <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (no_of_edges <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">=</span> <span style="color:#a6e22e">minimum</span>(E_t, V);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (V_t[u] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            E_t[u] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>            u <span style="color:#f92672">=</span> <span style="color:#a6e22e">minimum</span>(E_t, V);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> path[u];
</span></span><span style="display:flex;"><span>        MST[v][u] <span style="color:#f92672">=</span> E_t[u];
</span></span><span style="display:flex;"><span>        MST[u][v] <span style="color:#f92672">=</span> E_t[u];
</span></span><span style="display:flex;"><span>        no_of_edges<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        V_t[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> V; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (V_t[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> G[u][i] <span style="color:#f92672">&lt;</span> E_t[i]) {
</span></span><span style="display:flex;"><span>                E_t[i] <span style="color:#f92672">=</span> G[u][i];
</span></span><span style="display:flex;"><span>                path[i] <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @brief Self-test implementations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @returns void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">uint16_t</span> G[][MAX], <span style="color:#66d9ef">uint16_t</span> MST[][MAX], <span style="color:#66d9ef">uint16_t</span> V)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> test[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>}, {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>}};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> solution[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>}, {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>}};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    V <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            G[i][j] <span style="color:#f92672">=</span> test[i][j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prim</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>G), <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>MST), V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">assert</span>(MST[i][j] <span style="color:#f92672">==</span> solution[i][j]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @brief Function user_graph();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * gets user input adj. matrix and finds MST of that graph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @returns void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">user_graph</span>(<span style="color:#66d9ef">uint16_t</span> G[][MAX], <span style="color:#66d9ef">uint16_t</span> MST[][MAX], <span style="color:#66d9ef">uint16_t</span> V)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the number of vertices: &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34; %hd&#34;</span>, <span style="color:#f92672">&amp;</span>V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(V <span style="color:#f92672">&lt;=</span> MAX);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the adj matrix</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> i, j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;G[%d][%d]: &#34;</span>, i, j);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34; %hd&#34;</span>, <span style="color:#f92672">&amp;</span>G[i][j]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (G[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                G[i][j] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prim</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>G), <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>MST), V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;minimum spanning tree:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>, MST[i][j]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @brief Main function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param argc commandline argument count (ignored)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param argv commandline array of arguments (ignored)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @returns 0 on exit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> G[MAX][MAX];    <span style="color:#75715e">///&lt; weighted, connected graph G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span> MST[MAX][MAX];  <span style="color:#75715e">///&lt; adj matrix to hold minimum spanning tree of G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span> V;              <span style="color:#75715e">///&lt; number of vertices in V in G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strcmp</span>(argv[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;-test&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>G), <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>MST), V);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">user_graph</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>G), <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>MST), V);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="344-leetcode题目">3.4.4 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#344-leetcode题目">#</a></h4>
<ul>
<li>柠檬水找零</li>
<li>分发饼干</li>
</ul>
<h3 id="35-动态规划">3.5 动态规划<a hidden class="anchor" aria-hidden="true" href="#35-动态规划">#</a></h3>
<p> 动态规划(<code>DP</code>):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.</p>
<h4 id="351-基本概念">3.5.1 基本概念<a hidden class="anchor" aria-hidden="true" href="#351-基本概念">#</a></h4>
<p> 动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.
 动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.
 动态规划与分治法的区别是子问题通常不是独立的.</p>
<h4 id="352-描述算法">3.5.2 描述算法<a hidden class="anchor" aria-hidden="true" href="#352-描述算法">#</a></h4>
<p> 可采用动态规划的问题3个性质:
 1) <strong>最优化原理</strong>:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.
 2) <strong>无后效性</strong>:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.
 3) <strong>有重叠子问题</strong>:</p>
<br>
&ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.
<p> 动态规划求解三要素:</p>
<blockquote>
<p>(1) 问题的节点
(2) 每个阶段的状态
(3) 从前一个阶段转化到后一个阶段之间的递推关系</p>
</blockquote>
<p> <strong>最优决策表</strong></p>
<blockquote>
<p>f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}</p>
</blockquote>
<h4 id="353-背包问题">3.5.3 背包问题<a hidden class="anchor" aria-hidden="true" href="#353-背包问题">#</a></h4>
<p> 问题描述:
 有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.
 解题思路:
 p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为&quot;前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为&quot;前i-1物品放入剩下的容量为v-volume[i]的背包中&quot;,此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].</p>
<p> <strong>状态转移方程:</strong></p>
<blockquote>
<p>p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}
 伪代码描述:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.</span>..N
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">=</span> V..<span style="color:#ae81ff">.0</span>
</span></span><span style="display:flex;"><span>        p[j] <span style="color:#f92672">=</span> max{p[j<span style="color:#f92672">-</span>volume[i]] <span style="color:#f92672">+</span> value[i], p[j]};
</span></span></code></pre></div><details>
<summary>dp</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> v[]<span style="color:#f92672">=</span>{<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> w[]<span style="color:#f92672">=</span>{<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">100</span>][<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Max</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(a<span style="color:#f92672">&gt;=</span>b){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAns</span>(<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> wi) {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;x<span style="color:#f92672">&lt;=</span>i;x<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		dp[x][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;=</span> wi; x<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		dp[<span style="color:#ae81ff">0</span>][x]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; x <span style="color:#f92672">&lt;=</span> i; x<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> y<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;y<span style="color:#f92672">&lt;=</span>wi;y<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(y<span style="color:#f92672">&gt;=</span>w[x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>				dp[x][y]<span style="color:#f92672">=</span><span style="color:#a6e22e">Max</span>(dp[x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][y],v[x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>dp[x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][y<span style="color:#f92672">-</span>w[x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]);
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				dp[x][y]<span style="color:#f92672">=</span>dp[x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][y];
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%4d&#34;</span>,dp[x][y]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dp[i][wi];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max<span style="color:#f92672">=</span><span style="color:#a6e22e">getAns</span>(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div></details>
<h4 id="354-最长公共子序列">3.5.4 最长公共子序列<a hidden class="anchor" aria-hidden="true" href="#354-最长公共子序列">#</a></h4>
<p> 问题描述:
 一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)
 给定两个序列X,Y,求两个序列的最长公共子序列.
 解题思路:
 最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。
 最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：</p>
<blockquote>
<p>f[1][1] = same(1,1)
f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]}
 其中，<code>same(a,b)</code>当X的第a位与Y的第b位完全相同是&quot;1&quot;，否则位&quot;1&quot;。
 此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。
 该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。</p>
</blockquote>
<p> 伪代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>function <span style="color:#a6e22e">LCSLength</span>(X[<span style="color:#ae81ff">1.</span>.m], Y[<span style="color:#ae81ff">1.</span>.n])
</span></span><span style="display:flex;"><span>    C <span style="color:#f92672">=</span> <span style="color:#a6e22e">array</span>(<span style="color:#ae81ff">0.</span>.m, <span style="color:#ae81ff">0.</span>.n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span>.m
</span></span><span style="display:flex;"><span>        C[i, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span>.n
</span></span><span style="display:flex;"><span>        C[<span style="color:#ae81ff">0</span>, j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1.</span>.m
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1.</span>.n
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> X[i] <span style="color:#f92672">=</span> Y[j]
</span></span><span style="display:flex;"><span>                C[i, j] <span style="color:#f92672">:=</span> C[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                C[i, j] <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(C[i, j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], C[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,j])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C[m, n]
</span></span></code></pre></div><details>
<summary>最长公共序列数</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">100</span>][<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Max</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span> c){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max<span style="color:#f92672">=</span>a;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(b<span style="color:#f92672">&gt;</span>max){
</span></span><span style="display:flex;"><span>		max<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">&gt;</span>max){
</span></span><span style="display:flex;"><span>		max<span style="color:#f92672">=</span>c;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> max;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getMax</span>(<span style="color:#66d9ef">char</span> s1[],<span style="color:#66d9ef">char</span> s2[],<span style="color:#66d9ef">int</span> m,<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i,j;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>){       <span style="color:#75715e">//当 s2取 1个的时候 ,s1为可变长度 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(s1[i]<span style="color:#f92672">==</span>s2[<span style="color:#ae81ff">0</span>]){
</span></span><span style="display:flex;"><span>			dp[i][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(j<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>m;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				dp[j][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		} 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){      <span style="color:#75715e">//当 s1取 1个的时候 ,s2为可变长度 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(s2[i]<span style="color:#f92672">==</span>s1[<span style="color:#ae81ff">0</span>]){
</span></span><span style="display:flex;"><span>			dp[<span style="color:#ae81ff">0</span>][i]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(j<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				dp[<span style="color:#ae81ff">0</span>][j]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		} 
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(s1[i]<span style="color:#f92672">==</span>s2[j]){
</span></span><span style="display:flex;"><span>				dp[i][j]<span style="color:#f92672">=</span><span style="color:#a6e22e">Max</span>(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j],dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>			}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>				dp[i][j]<span style="color:#f92672">=</span>dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">&gt;=</span>dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">?</span>dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">:</span>dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dp[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> m,n;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> s1[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> s2[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gets</span>(s1);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gets</span>(s2);
</span></span><span style="display:flex;"><span>	m<span style="color:#f92672">=</span><span style="color:#a6e22e">strlen</span>(s1);
</span></span><span style="display:flex;"><span>	n<span style="color:#f92672">=</span><span style="color:#a6e22e">strlen</span>(s2);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#a6e22e">getMax</span>(s1,s2,m,n));
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<details>
<summary>Fibonacci_dp</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Fibonacci Series using Dynamic Programming
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Author: Moinak Banerjee(moinak878)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   Date : 1 October ,2019
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Out of Range checking
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">No Such term !</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// declaring array to store fibonacci numbers -- memoization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>((n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));  <span style="color:#75715e">//  one extra to handle edge case, n = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* let 0th and 1st number of the series be 0 and 1*/</span>
</span></span><span style="display:flex;"><span>    f[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    f[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Adding the previous 2 terms to make the 3rd term
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        f[i] <span style="color:#f92672">=</span> f[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> f[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> out <span style="color:#f92672">=</span> f[n];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(f);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> out;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> number;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Asks for the number/position of term in Fibonnacci sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        number <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoi</span>(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Enter the value of n(n starts from 0 ): &#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>number);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The nth term is : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">fib</span>(number));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<h4 id="355-leetcode题目">3.5.5 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#355-leetcode题目">#</a></h4>
<ul>
<li>最大子序和</li>
<li>编辑距离</li>
<li>大礼包</li>
<li>最长上升子序列</li>
</ul>
<h3 id="36-回溯法">3.6 回溯法<a hidden class="anchor" aria-hidden="true" href="#36-回溯法">#</a></h3>
<h4 id="361-基本概念">3.6.1 基本概念<a hidden class="anchor" aria-hidden="true" href="#361-基本概念">#</a></h4>
<p> 回溯算法实际上一个类似枚举的搜索尝试过程,主要是在<strong>搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就&quot;回溯&quot;返回,尝试别的路径</strong>.
 回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为&quot;回溯法&quot;.
 许多复杂度,规模较大的问题都看看而已使用回溯法,有&quot;通用解题方法&quot;的美称.</p>
<p> 在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).
 若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.
 回溯法一般解题步骤:
 1.<strong>针对所给问题,确定问题的解空间</strong>;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.
 2.<strong>确定节点的扩展搜索规则</strong>
 3.<strong>以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索</strong></p>
<p> 伪代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iterativeBacktrack</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (t <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">f</span>(n, t) <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">g</span>(n, t)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(n,t); i <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">g</span>(n,t); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                x[t] <span style="color:#f92672">=</span> <span style="color:#a6e22e">h</span>(i);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">constraint</span>(t) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">bound</span>(t)) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">solution</span>(t)) {
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">output</span>(x);
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        t<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    t<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="362-八皇后问题">3.6.2 八皇后问题<a hidden class="anchor" aria-hidden="true" href="#362-八皇后问题">#</a></h4>
<p> 问题描述
 八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.
 转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n &gt;= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。
（1）因为所有的皇后都不能放在同一列，因为任意两个a[0]&hellip;a[7]的值不能存在相同的两个值
（2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下：
 假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。</p>
<p> 伪代码描述</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">queens</span>(<span style="color:#66d9ef">int</span> Queens) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, k, flag, not_finish <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> a[Queeens<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 为数组的第一个元素赋初值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (not_finish) { <span style="color:#75715e">// not_finish=1 处理尚未结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(not_finish <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&lt;=</span> Queens) { <span style="color:#75715e">// 处理尚未结束且还没处理到第Queeens个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (flag<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; flag <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#f92672">&lt;</span> i; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断是否有多个皇后在同一行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (a[k] <span style="color:#f92672">==</span> a[i]) {
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 判断是否有多个皇后在同一个对角线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; flag <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#f92672">&lt;</span> i; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((a[i] <span style="color:#f92672">==</span> a[k] <span style="color:#f92672">-</span> (k<span style="color:#f92672">-</span>i)) <span style="color:#f92672">||</span> (a]i] <span style="color:#f92672">==</span> a[k] <span style="color:#f92672">+</span> [k<span style="color:#f92672">-</span>i])) {
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="363-leetcode题目">3.6.3 leetcode题目<a hidden class="anchor" aria-hidden="true" href="#363-leetcode题目">#</a></h4>
<ul>
<li>N皇后</li>
<li>括号生成</li>
<li>单词搜索</li>
<li>解数独</li>
</ul>
<h2 id="4-参考链接">4 参考链接<a hidden class="anchor" aria-hidden="true" href="#4-参考链接">#</a></h2>
<ul>
<li>复杂度速查表
<a href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>
<li>线性表
<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8</a>
<ul>
<li>单链表
<a href="https://www.jianshu.com/p/73f0d8f807aa">https://www.jianshu.com/p/73f0d8f807aa</a></li>
</ul>
</li>
</ul>
<p><a href="http://cocofe.cn/">http://cocofe.cn/</a></p>
<ul>
<li>数据结构
<a href="https://github.com/wangzheng0822/algo/">https://github.com/wangzheng0822/algo/</a></li>
</ul>

        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://liuz0123.gitee.io/zain/img/wechat_pay.jpg" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://liuz0123.gitee.io/zain/img/alipay.jpg" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://liuz0123.gitee.io/zain/posts/tech/leetcode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/">
    <span class="title">« 上一页</span>
    <br>
    <span>leetcode基础题目</span>
  </a>
  <a class="next" href="https://liuz0123.gitee.io/zain/posts/tech/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/">
    <span class="title">下一页 »</span>
    <br>
    <span>Linux内核设计与实现原书第3版)</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://twikoo.js.org/quick-start.html#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou', 
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2023 
        <a href="https://liuz0123.gitee.io/zain/" style="color:#939393;">zain&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号申请中</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="填自己的公安图标链接" style="float:left;margin: 0px 5px 0px 0px;"/>
             公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"zain's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
