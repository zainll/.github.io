---
title: "代码随想录"
date: 2023-01-05T00:17:58+08:00
lastmod: 2023-01-05T00:17:58+08:00
author: ["Zain"]
keywords: 
- 
categories: 
- 
tags: 
- leetcode
description: ""
weight: 1
slug: ""
draft: false # 是否为草稿
comments: true
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

- 代码随想录网站 https://programmercarl.com/


# 一.数组

## 1.数组基础

&ensp;数组是存放在连续内存空间上的相同类型数据的集合
- 数组下标都是从0开始的。
- 数组内存空间的地址是连续的
&ensp;数组的在内存空间的地址是连续的，在删除或者增添元素的时候，就要移动其他元素的地址


## 2.二分查找

### 704.[二分查找](https://leetcode.cn/problems/binary-search/)
&ensp;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1  \

### 思路

&ensp;**有序数组**，**数组中无重复元素** -> 使用二分法的前提条件  \
&ensp;二分查找区间的定义就是不变量，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则 \
&ensp;区间的定义一般为两种，**左闭右闭即[left, right]**，或者**左闭右开即[left, right)**

&ensp;**左闭右闭**
- while (left <= right) 要使用 <= ，left == right有意义，使用 <=
- if（nums[middle] > target）right赋值 **middle-1**，当前nums[target]不是target，查找区间结束下标位置是middle-1

```c
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

&ensp;**左闭右开**
- while（left < right）使用 <，left == right 在区间[left, right]没有意义
- if（nums[middle] > target）right更新为 **middle**，即下一个查询区间不会比较nums[middle]

```c
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
  
### 总结

&ensp;区间定义理解，在循环中检查根据查找区间的定义来做边界处理 \
&ensp;区间定义是不变量，在循环中坚持根据查找区间的定义来做边界处理，即循环不变规则  \

### 相关题目

- 35.[搜索插入位置](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html#%E6%80%9D%E8%B7%AF)
- 34.[在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html)
- 69.x 的平方根
- 367.有效的完全平方数

c:
```c
// 左闭右闭[left, right]
int search(int *nums, int numsSize, int target) {
    int left = 0;
    int right = numsSize - 1;
    int middle = 0;
    // left 小于 target，说明区间中元素不为0
    while(left <= right) {
        // 更新查找小毕middle值
        middle = (left + right) / 2;
        // taget 可能在 [left, middle - 1]区间
        if (nums[middle] > target) {
            right = middle - 1;
        } else if (nums[middle] < target) ( // target肯在[middle + 1, right]区间
            left = middle + 1;
        ) else if (nums[middle] == target) {
            return middle;
        }
    }
    // 未找到taget元素 返回-1
    return -1;
}
```

```c
左闭右开区间 [left, right)
int search(int* nums, int numsSize, int target){
    int length = numsSize;
    int left = 0;
    int right = length;	//定义target在左闭右开的区间里，即：[left, right)
    int middle = 0;
    while(left < right){  // left == right时，区间[left, right)属于空集，所以用 < 避免该情况
        int middle = left + (right - left) / 2;
        if(nums[middle] < target){
            //target位于(middle , right) 中为保证集合区间的左闭右开性，可等价为[middle + 1,right)
            left = middle + 1;
        }else if(nums[middle] > target){
            //target位于[left, middle)中
            right = middle ;
        }else{	// nums[middle] == target ，找到目标值target
            return middle;
        }
    }
    //未找到目标值，返回-1
    return -1;
}
```



## 3.移除元素

### 27.[移除元素](https://leetcode.cn/problems/remove-element/)

&ensp;给你一个数组 nums 和一个值 val，你需要 **原地** 移除所有数值等于 val 的元素，并返回移除后数组的新长度  \

### 思路

&ensp;数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能**覆盖**  \

&ensp;**暴力解法**  \
&ensp;两层for循环，一个for循环遍历数组元素，第二个for循环更新数组
```c
int removeElement(int* nums, int numsSize, int val){ 
    int i = 0, j = 0;
    for (; i < numsSize; i++) {
        if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
            for (j = i + 1; j < numsSize; j++) {
                nums[j-1] = nums[j];
            }
        i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
        numsSize--; // 此时数组的大小-1
        }
    }
    return numsSize;
}

```

&ensp;**双指针**  <br>
&ensp;双指针(快慢指针)：一个块指针和慢指针在一个for循环下完成两个for循环工作 \
&ensp;定义快慢指针 
- 快指针：寻找新数组的元素，新数组是不含有目标元素的数组
- 慢指针：指向更新 新数组 下标的位置

&ensp;考察数组、链表、字符串等操作的面试题，都使用双指针法 \
```c
int removeElement(int* nums, int numsSize, int val){
    int fast = 0, slow = 0;
    for (fast = 0; fast < numsSize; fast++) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

### 相关题目
- 26.删除排序数组中的重复项
- 283.移动零
- 844.比较含退格的字符串
- 977.有序数组的平方


## 4.有序数组的平方

### 977.[有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

&ensp;一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序 \

### 思路

&ensp;**暴力排序** <br>
&ensp;先求平方，再排序
```c
int cmp(void* a, void* b) {
    return *(int *)a - *(int *)b;
}

int* sortedSquares(int* nums, int numsSize, int* returnSize){
    *returnSize = numsSize;
    for (int i = 0; i < numsSize; i++) {
        nums[i] = nums[i] * nums[i];
    }
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums;
}
```

&ensp;**双指针法** <br>

&ensp;组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间 \
&ensp;双指针法，i指向起始位置，j指向终止位置 \
&ensp;如果A[i] * A[i] < A[j] * A[j] 那么result[k--] = A[j] * A[j];  \
&ensp;如果A[i] * A[i] >= A[j] * A[j] 那么result[k--] = A[i] * A[i];  \
```c
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    int k = numsSize - 1;
    int* res = (int *)malloc(sizeof(int) * numsSize);
    int i = 0;
    int j = numsSize - 1;
    while (i <= j) {
        if (nums[i] * nums[i] < nums[j] * nums[j]) {
            res[k--] = nums[j] * nums[j];
            j--;
        } else {
            res[k--] = nums[i] * nums[i];
            i++;
        }
    }
    *returnSize = numsSize;
    return res;
    
}
```


