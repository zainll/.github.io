---
title: "代码随想录"
date: 2023-01-05T00:17:58+08:00
lastmod: 2023-01-05T00:17:58+08:00
author: ["Zain"]
keywords: 
- 
categories: 
- 
tags: 
- leetcode
description: ""
weight: 1
slug: ""
draft: false # 是否为草稿
comments: true
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

- 代码随想录网站 https://programmercarl.com/


# 一.数组

## 1.数组基础

&ensp;数组是存放在连续内存空间上的相同类型数据的集合
- 数组下标都是从0开始的。
- 数组内存空间的地址是连续的
&ensp;数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址


## 2.二分查找

### 704.[二分查找](https://leetcode.cn/problems/binary-search/)
&ensp;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1  \

### 思路

&ensp;**有序数组**，**数组中无重复元素** -> 使用二分法的前提条件  \
&ensp;二分查找区间的定义就是不变量，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则 \
&ensp;区间的定义一般为两种，**左闭右闭即[left, right]**，或者**左闭右开即[left, right)**

&ensp;**左闭右闭**
- while (left <= right) 要使用 <= ，left == right有意义，使用 <=
- if（nums[middle] > target）right赋值 **middle-1**，当前nums[target]不是target，查找区间结束下标位置是middle-1

```c
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

&ensp;**左闭右开**
- while（left < right）使用 <，left == right 在区间[left, right]没有意义
- if（nums[middle] > target）right更新为 **middle**，即下一个查询区间不会比较nums[middle]

```c
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
  
### 总结

&ensp;区间定义理解，在循环中检查根据查找区间的定义来做边界处理 \
&ensp;区间定义是不变量，在循环中坚持根据查找区间的定义来做边界处理，即循环不变规则  \

### 相关题目

- 35.[搜索插入位置](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html#%E6%80%9D%E8%B7%AF)
- 34.[在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html)
- 69.x 的平方根
- 367.有效的完全平方数

c:
```c
// 左闭右闭[left, right]
int search(int *nums, int numsSize, int target) {
    int left = 0;
    int right = numsSize - 1;
    int middle = 0;
    // left 小于 target，说明区间中元素不为0
    while(left <= right) {
        // 更新查找小毕middle值
        middle = (left + right) / 2;
        // taget 可能在 [left, middle - 1]区间
        if (nums[middle] > target) {
            right = middle - 1;
        } else if (nums[middle] < target) ( // target肯在[middle + 1, right]区间
            left = middle + 1;
        ) else if (nums[middle] == target) {
            return middle;
        }
    }
    // 未找到taget元素 返回-1
    return -1;
}
```




